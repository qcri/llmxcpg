[
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t\t\tstruct xdp_umem *umem)\n\tbool unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       dev_info,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void ucan_rx_can_msg(struct ucan_priv *up, struct ucan_message_in *m)\n\tstruct net_device_stats *stats = &up->netdev->stats;\n\tlen = le16_to_cpu(m->len);\n\tcanid = le32_to_cpu(m->msg.can_msg.id);\n\tif (canid & CAN_ERR_FLAG) {\n\t\tbool busstate_changed = ucan_handle_error_frame(up, m, canid);\n\t} else {\n\t\tcanid_mask = CAN_RTR_FLAG;\n\t\tif (canid & CAN_EFF_FLAG)\n\t\t\tcanid_mask |= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcanid_mask |= CAN_SFF_MASK;\n\t\tif (canid & ~canid_mask)\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"unexpected bits set (canid %x, mask %x)\",\n\t\t\t\t    canid, canid_mask);\n\t\tcanid &= canid_mask;\n\t}\n\tskb = alloc_can_skb(up->netdev, &cf);\n\tcf->can_id = canid;\n\tcf->len = ucan_can_cc_dlc2len(&m->msg.can_msg, len);\n\tif (!(cf->can_id & CAN_RTR_FLAG) || (cf->can_id & CAN_ERR_FLAG))\n\t\tmemcpy(cf->data, m->msg.can_msg.data, cf->len);\nstatic void ucan_read_bulk_callback(struct urb *urb)\n\tstruct ucan_priv *up = urb->context;\n\tstruct net_device *netdev = up->netdev;\n\tif (WARN_ON(!up->context_array)) {\n\t}\n\tpos = 0;\n\twhile (pos < urb->actual_length) {\n\t\tm = (struct ucan_message_in *)\n\t\t\t((u8 *)urb->transfer_buffer + pos);\n\t\tlen = le16_to_cpu(m->len);\n\t\tif (urb->actual_length - pos < len) {\n\t\t}\n\t\t\tucan_rx_can_msg(up, m);\n\t\t\tucan_tx_complete_msg(up, m);\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (type; t:%d)\\n\",\n\t\t\t\t    m->type);\n\t\tpos += len;\n\t\tpos = round_up(pos, 4);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22003",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static u32 xp_alloc_new_from_fq(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (max > pool->free_heads_cnt)\n\t\tmax = pool->free_heads_cnt;\n\tmax = xskq_cons_nb_entries(pool->fq, max);\n\tcached_cons = pool->fq->cached_cons;\n\twhile (i--) {\n\t\t__xskq_cons_read_addr_unchecked(pool->fq, cached_cons++, &addr);\n\t\tok = pool->unaligned ? xp_check_unaligned(pool, &addr) :\n\t\t\txp_check_aligned(pool, &addr);\n\t\tif (unlikely(!ok)) {\n\t\t\tpool->fq->invalid_descs++;\n\t\t}\n\t\tif (pool->unaligned) {\n\t\t\txskb = pool->free_heads[--pool->free_heads_cnt];\n\t\t\txp_init_xskb_addr(xskb, pool, addr);\n\t\t\tif (pool->dma_pages)\n\t\t\t\txp_init_xskb_dma(xskb, pool, pool->dma_pages, addr);\n\t\t} else {\n\t\t\txskb = &pool->heads[xp_aligned_extract_idx(pool, addr)];\n\t\t}\n\t\t*xdp = &xskb->xdp;\n\t}\nu32 xp_alloc_batch(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (unlikely(pool->dev && dma_dev_need_sync(pool->dev)))\n\t\treturn xp_alloc_slow(pool, xdp, max);\n\tif (unlikely(pool->free_list_cnt)) {\n\t\tnb_entries1 = xp_alloc_reused(pool, xdp, max);\n\t\tif (nb_entries1 == max)\n\t\t\treturn nb_entries1;\n\t\tmax -= nb_entries1;\n\t}\n\tnb_entries2 = xp_alloc_new_from_fq(pool, xdp, max);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static ssize_t sprintf_ipaddr(char *buf, u8 *ip)\n\tchar *str = buf;\n\tif (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0 &&\n\t    ip[4] == 0 && ip[5] == 0 && ip[6] == 0 && ip[7] == 0 &&\n\t    ip[8] == 0 && ip[9] == 0 && ip[10] == 0xff && ip[11] == 0xff) {\n\t} else {\n\t\tstr += sprintf(str, \"%pI6\", ip);\n\t}\nstatic ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_initiator *initiator = entry->initiator;\n\tchar *str = buf;\n\tif (!initiator)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, initiator->isns_server);\n\t\tstr += sprintf_ipaddr(str, initiator->slp_server);\n\t\tstr += sprintf_ipaddr(str, initiator->pri_radius_server);\n\t\tstr += sprintf_ipaddr(str, initiator->sec_radius_server);\nstatic ssize_t ibft_attr_show_nic(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\tchar *str = buf;\n\tif (!nic)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, nic->ip_addr);\n\t\tstr += sprintf_ipaddr(str, nic->gateway);\n\t\tstr += sprintf_ipaddr(str, nic->primary_dns);\n\t\tstr += sprintf_ipaddr(str, nic->secondary_dns);\n\t\tstr += sprintf_ipaddr(str, nic->dhcp);\nstatic ssize_t ibft_attr_show_target(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_tgt *tgt = entry->tgt;\n\tchar *str = buf;\n\tif (!tgt)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, tgt->ip_addr);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tunregister_ieq(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline VALUE build_interned_string(const char *str, const long length)\n    VALUE rstring = rb_utf8_str_new(str, length);\n    return rb_funcall(rb_str_freeze(rstring), i_uminus, 0);\nstatic inline VALUE build_symbol(const char *str, const long length)\n    return rb_str_intern(build_interned_string(str, length));\nstatic VALUE rstring_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, entry);\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rstring = build_interned_string(str, length);\nstatic VALUE rsymbol_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, rb_sym2str(entry));\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rsymbol = build_symbol(str, length);\n    if (cache->length < JSON_RVALUE_CACHE_CAPA) {\n        rvalue_cache_insert_at(cache, mid, rsymbol);\n    }\n    return rsymbol;\nstatic inline VALUE json_string_fastpath(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n    }\nstatic VALUE json_string_unescape(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    const char *p = string, *pe = string, *unescape, *bufferStart;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n        if (RB_LIKELY(cached_key)) {\n            return cached_key;\n        }\n    }\nstatic inline VALUE json_decode_string(JSON_ParserState *state, JSON_ParserConfig *config, const char *start, const char *end, bool escaped, bool is_name)\n    bool intern = is_name || config->freeze;\n    bool symbolize = is_name && config->symbolize_names;\n    if (escaped) {\n        string = json_string_unescape(state, start, end, is_name, intern, symbolize);\n    } else {\n        string = json_string_fastpath(state, start, end, is_name, intern, symbolize);\n    }\n    if (RB_UNLIKELY(config->create_additions && RTEST(config->match_string))) {\n          VALUE memo = rb_ary_new2(2);\n          rb_ary_push(memo, string);\n          rb_hash_foreach(config->match_string, match_i, memo);\n          klass = rb_ary_entry(memo, 1);\n    }\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static u64 accumulate(u64 sum, u64 data)\n\tsum += data;\n\tif (sum < data)\n\t\tsum += 1;\n\treturn sum;\n\t\t\t__u32 len, __u8 proto, __wsum csum)\n\tsrc = *(const __uint128_t *)saddr->s6_addr;\n\tdst = *(const __uint128_t *)daddr->s6_addr;\n\tsum += (u32)proto << 24;\n\tsrc += (src >> 64) | (src << 64);\n\tdst += (dst >> 64) | (dst << 64);\n\tsum = accumulate(sum, src >> 64);\n\tsum = accumulate(sum, dst >> 64);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21789",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_alloc_urbs(struct ipheth_device *iphone)\n\tstruct urb *tx_urb = NULL;\n\tstruct urb *rx_urb = NULL;\n\tu8 *tx_buf = NULL;\n\tu8 *rx_buf = NULL;\n\ttx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (tx_urb == NULL)\n\t\tgoto error_nomem;\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (rx_urb == NULL)\n\t\tgoto free_tx_urb;\n\ttx_buf = usb_alloc_coherent(iphone->udev, IPHETH_TX_BUF_SIZE,\n\t\t\t\t    GFP_KERNEL, &tx_urb->transfer_dma);\n\tif (tx_buf == NULL)\n\t\tgoto free_rx_urb;\n\trx_buf = usb_alloc_coherent(iphone->udev, iphone->rx_buf_len,\n\t\t\t\t    GFP_KERNEL, &rx_urb->transfer_dma);\n\tif (rx_buf == NULL)\n\t\tgoto free_tx_buf;\n\tiphone->tx_urb = tx_urb;\n\tiphone->rx_urb = rx_urb;\n\tiphone->tx_buf = tx_buf;\n\tiphone->rx_buf = rx_buf;\nstatic void ipheth_free_urbs(struct ipheth_device *iphone)\n\tusb_free_coherent(iphone->udev, iphone->rx_buf_len, iphone->rx_buf,\nstatic int ipheth_probe(struct usb_interface *intf,\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tnetdev = alloc_etherdev(sizeof(struct ipheth_device));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tnetdev->netdev_ops = &ipheth_netdev_ops;\n\tnetdev->watchdog_timeo = IPHETH_TX_TIMEOUT;\n\tstrscpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\tdev = netdev_priv(netdev);\n\tdev->udev = udev;\n\tdev->net = netdev;\n\tdev->intf = intf;\n\tdev->confirmed_pairing = false;\n\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_LEGACY;\n\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_legacy;\n\thintf = usb_altnum_to_altsetting(intf, IPHETH_ALT_INTFNUM);\n\tif (hintf == NULL) {\n\t}\n\tfor (i = 0; i < hintf->desc.bNumEndpoints; i++) {\n\t\tendp = &hintf->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endp))\n\t\t\tdev->bulk_in = endp->bEndpointAddress;\n\t\telse if (usb_endpoint_is_bulk_out(endp))\n\t\t\tdev->bulk_out = endp->bEndpointAddress;\n\t}\n\tif (!(dev->bulk_in && dev->bulk_out)) {\n\t}\n\tdev->ctrl_buf = kmalloc(IPHETH_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (dev->ctrl_buf == NULL) {\n\t}\n\tretval = ipheth_get_macaddr(dev);\n\tretval = ipheth_enable_ncm(dev);\n\tif (!retval) {\n\t\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_NCM;\n\t\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_ncm;\n\t}\n\tINIT_DELAYED_WORK(&dev->carrier_work, ipheth_carrier_check_work);\n\tretval = ipheth_alloc_urbs(dev);\n\tusb_set_intfdata(intf, dev);\n\tipheth_free_urbs(dev);\nstatic void ipheth_disconnect(struct usb_interface *intf)\n\tdev = usb_get_intfdata(intf);\n\tif (dev != NULL) {\n\t\tunregister_netdev(dev->net);\n\t\tipheth_kill_urbs(dev);\n\t\tipheth_free_urbs(dev);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t\tif (pte_present(pte))\n\t\t\t\tunmapped++;\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```rio_mport_create_inbound_mapping(struct mport_dev *md, struct file *filp,\n\t\t\t\tu64 raddr, u64 size,\n\tstruct rio_mport *mport = md->mport;\n\tif (size > 0xffffffff)\n\t\treturn -EINVAL;\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL)\n\t\treturn -ENOMEM;\n\tmap->virt_addr = dma_alloc_coherent(mport->dev.parent, size,\n\t\t\t\t\t    &map->phys_addr, GFP_KERNEL);\n\tif (map->virt_addr == NULL) {\n\t}\n\tif (raddr == RIO_MAP_ANY_ADDR)\n\t\traddr = map->phys_addr;\n\tret = rio_map_inb_region(mport, map->phys_addr, raddr, (u32)size, 0);\nrio_mport_get_inbound_mapping(struct mport_dev *md, struct file *filp,\n\t\t\t      u64 raddr, u64 size,\n\tif (raddr == RIO_MAP_ANY_ADDR)\n\t\tgoto get_new;\n\tmutex_lock(&md->buf_mutex);\n\tlist_for_each_entry(map, &md->mappings, node) {\n\t\tif (map->dir != MAP_INBOUND)\n\t\t\tcontinue;\n\t\tif (raddr == map->rio_addr && size == map->size) {\n\t\t} else if (raddr < (map->rio_addr + map->size - 1) &&\n\t\t\t   (raddr + size) > map->rio_addr) {\n\tmutex_unlock(&md->buf_mutex);\n\treturn rio_mport_create_inbound_mapping(md, filp, raddr, size, mapping);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21934",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)\n\tchar name[IFNAMSIZ];\n\tif (vlan_id >= VLAN_VID_MASK)\n\t\treturn -ERANGE;\n\terr = vlan_check_real_dev(real_dev, htons(ETH_P_8021Q), vlan_id,\n\t\tsnprintf(name, IFNAMSIZ, \"vlan%i\", vlan_id);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21920",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       dev_info,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int address_not_null(u8 *ip)\n\treturn (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));\nstatic umode_t ibft_check_nic_for(void *data, int type)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\t\tif (address_not_null(nic->ip_addr))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->gateway))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->primary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->secondary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->dhcp))\n\t\t\trc = S_IRUGO;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21742",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\tu8 *cmd, int size)\n\tr = steam->hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0];\n\tif (!r) {\n\t}\n\tif (hid_report_len(r) < 64)\n\t\treturn -EINVAL;\n\tbuf = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tmemcpy(buf + 1, cmd, size);\nstatic inline int steam_send_report_byte(struct steam_device *steam, u8 cmd)\n\treturn steam_send_report(steam, &cmd, 1);\nstatic int steam_write_settings(struct steam_device *steam,\n\tu8 cmd[64] = {ID_SET_SETTINGS_VALUES, 0x00};\n\tva_start(args, steam);\n\tfor (;;) {\n\t\tif (reg == 0)\n\t\t\tbreak;\n\t\tcmd[cmd[1] + 2] = reg;\n\t\tcmd[cmd[1] + 3] = val & 0xff;\n\t\tcmd[cmd[1] + 4] = val >> 8;\n\t\tcmd[1] += 3;\n\t}\n\tret = steam_send_report(steam, cmd, 2 + cmd[1]);\n\tret = steam_send_report(steam, cmd, sizeof(cmd));\n\tret = steam_send_report_byte(steam, ID_DONGLE_GET_WIRELESS_STATE);\nstatic inline int steam_haptic_pulse(struct steam_device *steam, u8 pad,\n\t\t\t\tu16 duration, u16 interval, u16 count, u8 gain)\n\tif (pad < STEAM_PAD_BOTH)\n\t\tpad ^= 1;\n\treport[2] = pad;\n\treport[3] = duration & 0xFF;\n\treport[4] = duration >> 8;\n\treport[5] = interval & 0xFF;\n\treport[6] = interval >> 8;\n\treport[7] = count & 0xFF;\n\treport[8] = count >> 8;\n\treport[9] = gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\t\t\t\tu16 intensity, u16 left_speed, u16 right_speed,\n\t\t\t\tu8 left_gain, u8 right_gain)\n\treport[3] = intensity & 0xFF;\n\treport[4] = intensity >> 8;\n\treport[5] = left_speed & 0xFF;\n\treport[6] = left_speed >> 8;\n\treport[7] = right_speed & 0xFF;\n\treport[8] = right_speed >> 8;\n\treport[9] = left_gain;\n\treport[10] = right_gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\tsteam_haptic_rumble(steam, 0, steam->rumble_left,\n\t\tsteam->rumble_right, 2, 0);\nstatic void steam_set_lizard_mode(struct steam_device *steam, bool enable)\n\tif (enable) {\n\t\tsteam_send_report_byte(steam, ID_SET_DEFAULT_DIGITAL_MAPPINGS);\n\t\tsteam_send_report_byte(steam, ID_LOAD_DEFAULT_SETTINGS);\n\t} else {\n\t\tmutex_lock(&steam->report_mutex);\n\t\tsteam_send_report_byte(steam, ID_CLEAR_DIGITAL_MAPPINGS);\n\t\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\t\tsteam_write_settings(steam,\n\t\t} else {\n\t\t\tsteam_write_settings(steam,\n\t\t}\n\t}\nstatic int steam_input_open(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, false);\n\t}\nstatic void steam_input_close(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, true);\n\t}\nstatic int steam_register(struct steam_device *steam)\n\tif (!steam->serial_no[0]) {\n\t\tif (steam_get_serial(steam) < 0)\n\t\t\tstrscpy(steam->serial_no, \"XXXXXXXXXX\",\n\t\t\t\t\tsizeof(steam->serial_no));\n\t\thid_info(steam->hdev, \"Steam Controller '%s' connected\",\n\t\t\t\tsteam->serial_no);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS)\n\t\t\tsteam_battery_register(steam);\n\t\tif (list_empty(&steam->list))\n\t\t\tlist_add(&steam->list, &steam_devices);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tclient_opened = steam->client_opened;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (!client_opened) {\n\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tret = steam_register(steam);\n\t} else {\n\tsteam->gamepad_mode = !steam->gamepad_mode;\n\tif (steam->gamepad_mode)\n\t\tsteam_set_lizard_mode(steam, false);\n\telse {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tclient_opened = steam->client_opened;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (!client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tsteam_haptic_pulse(steam, STEAM_PAD_RIGHT, 0x190, 0, 1, 0);\n\tif (steam->gamepad_mode) {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x14D, 0x14D, 0x2D, 0);\n\t} else {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x1F4, 0x1F4, 0x1E, 0);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\topened = steam->client_opened;\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tif (opened) {\n\t\t} else {\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t\t}\n\t}\nstatic int steam_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n\tret = hid_parse(hdev);\n\tif (hdev->group == HID_GROUP_STEAM)\n\t\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (!steam_is_valve_interface(hdev))\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tsteam = devm_kzalloc(&hdev->dev, sizeof(*steam), GFP_KERNEL);\n\tif (!steam)\n\t\treturn -ENOMEM;\n\tsteam->hdev = hdev;\n\thid_set_drvdata(hdev, steam);\n\tspin_lock_init(&steam->lock);\n\tmutex_init(&steam->report_mutex);\n\tsteam->quirks = id->driver_data;\n\tINIT_WORK(&steam->work_connect, steam_work_connect_cb);\n\tINIT_DELAYED_WORK(&steam->mode_switch, steam_mode_switch_cb);\n\tINIT_LIST_HEAD(&steam->list);\n\tINIT_WORK(&steam->rumble_work, steam_haptic_rumble_cb);\n\tsteam->sensor_timestamp_us = 0;\n\tINIT_WORK(&steam->unregister_work, steam_work_unregister_cb);\n\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t} else {\n\t\tsteam->connected = true;\n\t\tret = steam_register(steam);\n\t}\n\tlist_for_each_entry(steam, &steam_devices, list) {\n\t\tif (!steam->client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void corsair_void_process_receiver(struct corsair_void_drvdata *drvdata,\n\t\t\t\t\t  int raw_battery_capacity,\n\tstruct corsair_void_battery_data *battery_data = &drvdata->battery_data;\n\torig_battery_data = *battery_data;\n\tbattery_data->present = true;\n\tbattery_data->capacity_level = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbattery_data->status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tif (raw_battery_status == CORSAIR_VOID_BATTERY_LOW)\n\t\t\tbattery_data->capacity_level = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\telse if (raw_battery_status == CORSAIR_VOID_BATTERY_CRITICAL)\n\t\t\tbattery_data->capacity_level = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\tbattery_data->status = POWER_SUPPLY_STATUS_FULL;\n\t\tbattery_data->status = POWER_SUPPLY_STATUS_CHARGING;\n\tbattery_data->capacity = raw_battery_capacity;\nstatic int corsair_void_raw_event(struct hid_device *hid_dev,\n\t\t\t\t  u8 *data, int size)\n\tstruct corsair_void_drvdata *drvdata = hid_get_drvdata(hid_dev);\n\tif (hid_report->id == CORSAIR_VOID_STATUS_REPORT_ID) {\n\t\tdrvdata->mic_up = FIELD_GET(CORSAIR_VOID_MIC_MASK, data[2]);\n\t\tdrvdata->connected = (data[3] == CORSAIR_VOID_WIRELESS_CONNECTED) ||\n\t\t\t\t     drvdata->is_wired;\n\t\tcorsair_void_process_receiver(drvdata,\n\t\t\t\t\t      FIELD_GET(CORSAIR_VOID_CAPACITY_MASK, data[2]),\n\t} else if (hid_report->id == CORSAIR_VOID_FIRMWARE_REPORT_ID) {\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21797",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static ssize_t sprintf_string(char *str, int len, char *buf)\n\treturn sprintf(str, \"%.*s\\n\", len, buf);\nstatic ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_initiator *initiator = entry->initiator;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\tif (!initiator)\n\t\treturn 0;\n\t\tstr += sprintf_string(str, initiator->initiator_name_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      initiator->initiator_name_off);\nstatic ssize_t ibft_attr_show_nic(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\tif (!nic)\n\t\treturn 0;\n\t\tstr += sprintf_string(str, nic->hostname_len,\n\t\t\t\t      (char *)ibft_loc + nic->hostname_off);\nstatic ssize_t ibft_attr_show_target(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_tgt *tgt = entry->tgt;\n\tvoid *ibft_loc = entry->header;\n\tchar *str = buf;\n\tif (!tgt)\n\t\treturn 0;\n\t\tstr += sprintf_string(str, tgt->tgt_name_len,\n\t\t\t\t      (char *)ibft_loc + tgt->tgt_name_off);\n\t\tstr += sprintf_string(str, tgt->chap_name_len,\n\t\t\t\t      (char *)ibft_loc + tgt->chap_name_off);\n\t\tstr += sprintf_string(str, tgt->chap_secret_len,\n\t\t\t\t      (char *)ibft_loc + tgt->chap_secret_off);\n\t\tstr += sprintf_string(str, tgt->rev_chap_name_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      tgt->rev_chap_name_off);\n\t\tstr += sprintf_string(str, tgt->rev_chap_secret_len,\n\t\t\t\t      (char *)ibft_loc +\n\t\t\t\t      tgt->rev_chap_secret_off);\nstatic ssize_t ibft_attr_show_acpitbl(void *data, int type, char *buf)\n\tchar *str = buf;\n\t\tstr += sprintf_string(str, ACPI_NAMESEG_SIZE,\n\t\t\t\t      entry->header->header.signature);\n\t\tstr += sprintf_string(str, ACPI_OEM_ID_SIZE,\n\t\t\t\t      entry->header->header.oem_id);\n\t\tstr += sprintf_string(str, ACPI_OEM_TABLE_ID_SIZE,\n\t\t\t\t      entry->header->header.oem_table_id);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void geneve_build_header(struct genevehdr *geneveh,\n\t\t\t\tconst struct ip_tunnel_info *info,\n\tgeneveh->ver = GENEVE_VER;\n\tgeneveh->opt_len = info->options_len / 4;\n\tgeneveh->oam = !!(info->key.tun_flags & TUNNEL_OAM);\n\tgeneveh->critical = !!(info->key.tun_flags & TUNNEL_CRIT_OPT);\n\tgeneveh->rsvd1 = 0;\n\ttunnel_id_to_vni(info->key.tun_id, geneveh->vni);\nstatic int geneve_build_skb(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_info *info,\n\t\t\t    bool xnet, int ip_hdr_len,\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tskb_reset_mac_header(skb);\n\tskb_scrub_packet(skb, xnet);\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +\n\t\t       GENEVE_BASE_HLEN + info->options_len + ip_hdr_len;\n\terr = skb_cow_head(skb, min_headroom);\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tgnvh = __skb_push(skb, sizeof(*gnvh) + info->options_len);\n\tinner_proto = inner_proto_inherit ? skb->protocol : htons(ETH_P_TEB);\n\tgeneve_build_header(gnvh, info, inner_proto);\nstatic int geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct geneve_dev *geneve,\n\t\t\t   const struct ip_tunnel_info *info)\n\tbool inner_proto_inherit = geneve->cfg.inner_proto_inherit;\n\tbool xnet = !net_eq(geneve->net, dev_net(geneve->dev));\n\tstruct geneve_sock *gs4 = rcu_dereference(geneve->sock4);\n\tconst struct ip_tunnel_key *key = &info->key;\n\t__be16 df = 0;\n\tif (!skb_vlan_inet_prepare(skb, inner_proto_inherit))\n\t\treturn -EINVAL;\n\tsport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);\n\trt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,\n\t\t\t      geneve->cfg.info.key.tp_dst, sport, &full_tos);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\terr = skb_tunnel_check_pmtu(skb, &rt->dst,\n\t\t\t\t    GENEVE_IPV4_HLEN + info->options_len,\n\t\t\t\t    netif_is_any_bridge_port(dev));\n\tif (geneve->cfg.collect_md) {\n\t\ttos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\t\tttl = key->ttl;\n\t\tdf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\n\t} else {\n\t\ttos = ip_tunnel_ecn_encap(full_tos, ip_hdr(skb), skb);\n\t\tif (geneve->cfg.ttl_inherit)\n\t\t\tttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);\n\t\tttl = ttl ? : ip4_dst_hoplimit(&rt->dst);\n\t\tif (geneve->cfg.df == GENEVE_DF_SET) {\n\t\t\tdf = htons(IP_DF);\n\t\t} else if (geneve->cfg.df == GENEVE_DF_INHERIT) {\n\t\t\tstruct ethhdr *eth = skb_eth_hdr(skb);\n\t\t\tif (ntohs(eth->h_proto) == ETH_P_IPV6) {\n\t\t\t\tdf = htons(IP_DF);\n\t\t\t} else if (ntohs(eth->h_proto) == ETH_P_IP) {\n\t\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t\t\tif (iph->frag_off & htons(IP_DF))\n\t\t\t\t\tdf = htons(IP_DF);\n\t\t\t}\n\t\t}\n\t}\n\terr = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr),\n\t\t\t       inner_proto_inherit);\n\tudp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,\n\t\t\t    tos, ttl, df, sport, geneve->cfg.info.key.tp_dst,\n\t\t\t    !net_eq(geneve->net, dev_net(geneve->dev)),\n\t\t\t    !(info->key.tun_flags & TUNNEL_CSUM));\nstatic netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tif (geneve->cfg.collect_md) {\n\t\tinfo = skb_tunnel_info(skb);\n\t\tif (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {\n\t\t}\n\t} else {\n\t\tinfo = &geneve->cfg.info;\n\t}\n\tif (info->mode & IP_TUNNEL_INFO_IPV6)\n\t\terr = geneve6_xmit_skb(skb, dev, geneve, info);\n\telse\n\t\terr = geneve_xmit_skb(skb, dev, geneve, info);\n\trcu_read_unlock();\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21858",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t\t\tstruct xdp_umem *umem)\n\tbool unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline VALUE build_interned_string(const char *str, const long length)\n    VALUE rstring = rb_utf8_str_new(str, length);\n    return rb_funcall(rb_str_freeze(rstring), i_uminus, 0);\nstatic inline VALUE build_symbol(const char *str, const long length)\n    return rb_str_intern(build_interned_string(str, length));\nstatic VALUE rstring_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, entry);\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rstring = build_interned_string(str, length);\nstatic VALUE rsymbol_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, rb_sym2str(entry));\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rsymbol = build_symbol(str, length);\n    if (cache->length < JSON_RVALUE_CACHE_CAPA) {\n        rvalue_cache_insert_at(cache, mid, rsymbol);\n    }\n    return rsymbol;\nstatic inline VALUE json_string_fastpath(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n    }\nstatic VALUE json_string_unescape(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    const char *p = string, *pe = string, *unescape, *bufferStart;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n        if (RB_LIKELY(cached_key)) {\n            return cached_key;\n        }\n    }\nstatic inline VALUE json_decode_string(JSON_ParserState *state, JSON_ParserConfig *config, const char *start, const char *end, bool escaped, bool is_name)\n    bool intern = is_name || config->freeze;\n    bool symbolize = is_name && config->symbolize_names;\n    if (escaped) {\n        string = json_string_unescape(state, start, end, is_name, intern, symbolize);\n    } else {\n        string = json_string_fastpath(state, start, end, is_name, intern, symbolize);\n    }\n    if (RB_UNLIKELY(config->create_additions && RTEST(config->match_string))) {\n          VALUE memo = rb_ary_new2(2);\n          rb_ary_push(memo, string);\n          rb_hash_foreach(config->match_string, match_i, memo);\n    }\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```void xp_fill_cb(struct xsk_buff_pool *pool, struct xsk_cb_desc *desc)\n\tfor (i = 0; i < pool->heads_cnt; i++) {\n\t\tstruct xdp_buff_xsk *xskb = &pool->heads[i];\n\t\tmemcpy(xskb->cb + desc->off, desc->src, desc->bytes);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ishtp_hid_parse(struct hid_device *hid)\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tstruct ishtp_cl_data *client_data = hid_data->client_data;\n\trv = hid_parse_report(hid, client_data->report_descr[hid_data->index],\n\t\t\t      client_data->report_descr_size[hid_data->index]);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\tstruct folio *folio = page_folio(page);\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\tif (pte_alloc(mm, pmdp))\n\t\tgoto abort;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_charge(folio, vma->vm_mm, GFP_KERNEL))\n\t\tgoto abort;\n\t__folio_mark_uptodate(folio);\n\tif (folio_is_device_private(folio)) {\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tswp_entry = make_writable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\telse\n\t\t\tswp_entry = make_readable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\tentry = swp_entry_to_pte(swp_entry);\n\t} else {\n\t\tif (folio_is_zone_device(folio) &&\n\t\t    !folio_is_device_coherent(folio)) {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto abort;\n\torig_pte = ptep_get(ptep);\n\tif (check_stable_address_space(mm))\n\t\tgoto unlock_abort;\n\tif (pte_present(orig_pte)) {\n\t\tunsigned long pfn = pte_pfn(orig_pte);\n\t} else if (!pte_none(orig_pte))\n\t\tgoto unlock_abort;\n\tif (userfaultfd_missing(vma))\n\t\tgoto unlock_abort;\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tfolio_add_new_anon_rmap(folio, vma, addr, RMAP_EXCLUSIVE);\n\tif (!folio_is_zone_device(folio))\n\t\tfolio_add_lru_vma(folio, vma);\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(orig_pte));\n\t\tptep_clear_flush(vma, addr, ptep);\n\t}\n\tset_pte_at(mm, addr, ptep, entry);\nstatic void __migrate_device_pages(unsigned long *src_pfns,\n\t\t\t\tunsigned long *dst_pfns, unsigned long npages,\n\t\t\t\tstruct migrate_vma *migrate)\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tif (!newpage) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (!page) {\n\t\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\t\t\tVM_BUG_ON(!migrate);\n\t\t\taddr = migrate->start + i*PAGE_SIZE;\n\t\t\tif (!notified) {\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&src_pfns[i]);\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tif (folio_is_device_private(newfolio) ||\n\t\t    folio_is_device_coherent(newfolio)) {\n\t\t\tif (mapping) {\n\t\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t}\n\t\t} else if (folio_is_zone_device(newfolio)) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (migrate && migrate->fault_page == page)\n\t\t\textra_cnt = 1;\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\nvoid migrate_device_pages(unsigned long *src_pfns, unsigned long *dst_pfns,\n\t\t\tunsigned long npages)\n\t__migrate_device_pages(src_pfns, dst_pfns, npages, NULL);\nvoid migrate_vma_pages(struct migrate_vma *migrate)\n\t__migrate_device_pages(migrate->src, migrate->dst, migrate->npages, migrate);\nint migrate_device_coherent_folio(struct folio *folio)\n\tunsigned long src_pfn, dst_pfn = 0;\n\tWARN_ON_ONCE(folio_test_large(folio));\n\tfolio_lock(folio);\n\tsrc_pfn = migrate_pfn(folio_pfn(folio)) | MIGRATE_PFN_MIGRATE;\n\tmigrate_device_unmap(&src_pfn, 1, NULL);\n\tif (!(src_pfn & MIGRATE_PFN_MIGRATE))\n\t\treturn -EBUSY;\n\tdfolio = folio_alloc(GFP_USER | __GFP_NOWARN, 0);\n\tif (dfolio) {\n\t\tfolio_lock(dfolio);\n\t\tdst_pfn = migrate_pfn(folio_pfn(dfolio));\n\t}\n\tmigrate_device_pages(&src_pfn, &dst_pfn, 1);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int xp_alloc_tx_descs(struct xsk_buff_pool *pool, struct xdp_sock *xs)\n\tpool->tx_descs = kvcalloc(xs->tx->nentries, sizeof(*pool->tx_descs),\nstruct xsk_buff_pool *xp_create_and_assign_umem(struct xdp_sock *xs,\n\t\t\t\t\t\tstruct xdp_umem *umem)\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\tif (!pool->heads)\n\t\tgoto out;\n\tif (xs->tx)\n\t\tif (xp_alloc_tx_descs(pool, xs))\n\t\t\tgoto out;\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tdev = urb->context;\n\tif (urb->actual_length < IPHETH_NCM_HEADER_SIZE) {\n\t}\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tif (ncm0->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN) ||\n\t    le16_to_cpu(ncmh->wHeaderLength) + le16_to_cpu(ncm0->wLength) >=\n\t    urb->actual_length) {\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static rvalue_stack *rvalue_stack_grow(rvalue_stack *stack, VALUE *handle, rvalue_stack **stack_ref)\n    long required = stack->capa * 2;\n    if (stack->type == RVALUE_STACK_STACK_ALLOCATED) {\n        stack = rvalue_stack_spill(stack, handle, stack_ref);\n    } else {\nstatic VALUE rvalue_stack_push(rvalue_stack *stack, VALUE value, VALUE *handle, rvalue_stack **stack_ref)\n    if (RB_UNLIKELY(stack->head >= stack->capa)) {\n        stack = rvalue_stack_grow(stack, handle, stack_ref);\n    }\nstatic rvalue_stack *rvalue_stack_spill(rvalue_stack *old_stack, VALUE *handle, rvalue_stack **stack_ref)\n    *handle = TypedData_Make_Struct(0, rvalue_stack, &JSON_Parser_rvalue_stack_type, stack);\n    *stack_ref = stack;\n    MEMCPY(stack, old_stack, rvalue_stack, 1);\njson_eat_whitespace(JSON_ParserState *state)\n    while (state->cursor < state->end && RB_UNLIKELY(whitespace[(unsigned char)*state->cursor])) {\n    }\nstatic inline VALUE json_decode_object(JSON_ParserState *state, JSON_ParserConfig *config, long count)\n    if (RB_UNLIKELY(config->object_class)) {\n        long index = 0;\n        VALUE *items = rvalue_stack_peek(state->stack, count);\n        while (index < count) {\n            VALUE name = items[index++];\n            VALUE value = items[index++];\n        }\n    } else {\n        rb_hash_bulk_insert(count, rvalue_stack_peek(state->stack, count), object);\n    }\n    rvalue_stack_pop(state->stack, count);\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    bool escaped = false;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    return PUSH(string);\n                    state->cursor++;\n                    escaped = true;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"null\", 4) == 0)) {\n                return PUSH(Qnil);\n            }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"true\", 4) == 0)) {\n                return PUSH(Qtrue);\n            }\n            if ((state->end - state->cursor >= 5) && (memcmp(state->cursor + 1, \"alse\", 4) == 0)) {\n                return PUSH(Qfalse);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 3) && (memcmp(state->cursor + 1, \"aN\", 2) == 0)) {\n                return PUSH(CNaN);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 8) && (memcmp(state->cursor, \"Infinity\", 8) == 0)) {\n                return PUSH(CInfinity);\n            }\n            if ((state->end - state->cursor >= 9) && (memcmp(state->cursor + 1, \"Infinity\", 8) == 0)) {\n                if (config->allow_nan) {\n                    return PUSH(CMinusInfinity);\n                } else {\n            }\n            if (integer) {\n                return PUSH(json_decode_integer(start, state->cursor));\n            }\n            return PUSH(json_decode_float(config, start, state->cursor));\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                state->cursor++;\n                return PUSH(json_decode_array(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                        state->cursor++;\n                        long count = state->stack->head - stack_head;\n                        state->current_nesting--;\n                        state->in_array--;\n                        return PUSH(json_decode_array(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                state->cursor++;\n                return PUSH(json_decode_object(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                        state->cursor++;\n                        state->current_nesting--;\n                        long count = state->stack->head - stack_head;\n                        return PUSH(json_decode_object(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic void json_ensure_eof(JSON_ParserState *state)\n    json_eat_whitespace(state);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\n    rvalue_stack_eagerly_release(state->stack_handle);\n    json_ensure_eof(state);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\tstruct folio *folio = page_folio(page);\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\tif (pte_alloc(mm, pmdp))\n\t\tgoto abort;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_charge(folio, vma->vm_mm, GFP_KERNEL))\n\t\tgoto abort;\n\t__folio_mark_uptodate(folio);\n\tif (folio_is_device_private(folio)) {\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\t\t\t\tpage_to_pfn(page));\n\t} else {\n\t\tif (folio_is_zone_device(folio) &&\n\t\t    !folio_is_device_coherent(folio)) {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto abort;\n\torig_pte = ptep_get(ptep);\n\tif (pte_present(orig_pte)) {\n\t\tunsigned long pfn = pte_pfn(orig_pte);\n\t} else if (!pte_none(orig_pte))\n\t\tgoto unlock_abort;\n\tif (userfaultfd_missing(vma))\n\t\tgoto unlock_abort;\n\tfolio_add_new_anon_rmap(folio, vma, addr, RMAP_EXCLUSIVE);\n\tif (!folio_is_zone_device(folio))\n\t\tfolio_add_lru_vma(folio, vma);\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(orig_pte));\n\t}\nstatic void __migrate_device_pages(unsigned long *src_pfns,\n\t\t\t\tunsigned long *dst_pfns, unsigned long npages,\n\t\t\t\tstruct migrate_vma *migrate)\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tif (!newpage) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (!page) {\n\t\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\t\t\tVM_BUG_ON(!migrate);\n\t\t\taddr = migrate->start + i*PAGE_SIZE;\n\t\t\tif (!notified) {\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&src_pfns[i]);\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tif (folio_is_device_private(newfolio) ||\n\t\t    folio_is_device_coherent(newfolio)) {\n\t\t\tif (mapping) {\n\t\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t}\n\t\t} else if (folio_is_zone_device(newfolio)) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (migrate && migrate->fault_page == page)\n\t\t\textra_cnt = 1;\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\nvoid migrate_device_pages(unsigned long *src_pfns, unsigned long *dst_pfns,\n\t\t\tunsigned long npages)\n\t__migrate_device_pages(src_pfns, dst_pfns, npages, NULL);\nvoid migrate_vma_pages(struct migrate_vma *migrate)\n\t__migrate_device_pages(migrate->src, migrate->dst, migrate->npages, migrate);\nint migrate_device_coherent_folio(struct folio *folio)\n\tunsigned long src_pfn, dst_pfn = 0;\n\tWARN_ON_ONCE(folio_test_large(folio));\n\tfolio_lock(folio);\n\tsrc_pfn = migrate_pfn(folio_pfn(folio)) | MIGRATE_PFN_MIGRATE;\n\tmigrate_device_unmap(&src_pfn, 1, NULL);\n\tif (!(src_pfn & MIGRATE_PFN_MIGRATE))\n\t\treturn -EBUSY;\n\tdfolio = folio_alloc(GFP_USER | __GFP_NOWARN, 0);\n\tif (dfolio) {\n\t\tfolio_lock(dfolio);\n\t\tdst_pfn = migrate_pfn(folio_pfn(dfolio));\n\t}\n\tmigrate_device_pages(&src_pfn, &dst_pfn, 1);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline struct genevehdr *geneve_hdr(const struct sk_buff *skb)\n\treturn (struct genevehdr *)(udp_hdr(skb) + 1);\n\t\t\t\t\t    struct sk_buff *skb)\n\tif (geneve_get_sk_family(gs) == AF_INET) {\n\t\tiph = ip_hdr(skb); /* outer IP header... */\n\t\tif (gs->collect_md) {\n\t\t} else {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t}\n\t} else if (geneve_get_sk_family(gs) == AF_INET6) {\n\t\t      struct sk_buff *skb)\n\tstruct genevehdr *gnvh = geneve_hdr(skb);\nstatic int geneve_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\n\tif (unlikely(!pskb_may_pull(skb, GENEVE_BASE_HLEN)))\n\t\tgoto drop;\n\tgeneveh = geneve_hdr(skb);\n\tif (unlikely(geneveh->ver != GENEVE_VER))\n\t\tgoto drop;\n\tgs = rcu_dereference_sk_user_data(sk);\n\tif (!gs)\n\t\tgoto drop;\n\tgeneve = geneve_lookup_skb(gs, skb);\n\tif (!geneve)\n\t\tgoto drop;\n\tinner_proto = geneveh->proto_type;\n\tif (unlikely((!geneve->cfg.inner_proto_inherit &&\n\t\t      inner_proto != htons(ETH_P_TEB)))) {\n\topts_len = geneveh->opt_len * 4;\n\tif (iptunnel_pull_header(skb, GENEVE_BASE_HLEN + opts_len, inner_proto,\n\t\t\t\t !net_eq(geneve->net, dev_net(geneve->dev)))) {\n\tgeneve_rx(geneve, gs, skb);\nstatic int geneve_udp_encap_err_lookup(struct sock *sk, struct sk_buff *skb)\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + GENEVE_BASE_HLEN))\n\t\treturn -EINVAL;\n\tgeneveh = geneve_hdr(skb);\n\tif (geneve_get_sk_family(gs) == AF_INET) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\tif (!gs->collect_md) {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t}\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21858",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_alloc_urbs(struct ipheth_device *iphone)\n\tstruct urb *tx_urb = NULL;\n\tstruct urb *rx_urb = NULL;\n\tu8 *tx_buf = NULL;\n\tu8 *rx_buf = NULL;\n\ttx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (tx_urb == NULL)\n\t\tgoto error_nomem;\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (rx_urb == NULL)\n\t\tgoto free_tx_urb;\n\ttx_buf = usb_alloc_coherent(iphone->udev, IPHETH_TX_BUF_SIZE,\n\t\t\t\t    GFP_KERNEL, &tx_urb->transfer_dma);\n\tif (tx_buf == NULL)\n\t\tgoto free_rx_urb;\n\trx_buf = usb_alloc_coherent(iphone->udev, iphone->rx_buf_len,\n\t\t\t\t    GFP_KERNEL, &rx_urb->transfer_dma);\n\tusb_free_coherent(iphone->udev, IPHETH_TX_BUF_SIZE, tx_buf,\n\t\t\t  tx_urb->transfer_dma);\nstatic int ipheth_probe(struct usb_interface *intf,\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tnetdev = alloc_etherdev(sizeof(struct ipheth_device));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tnetdev->netdev_ops = &ipheth_netdev_ops;\n\tnetdev->watchdog_timeo = IPHETH_TX_TIMEOUT;\n\tstrscpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\tdev = netdev_priv(netdev);\n\tdev->udev = udev;\n\tdev->net = netdev;\n\tdev->intf = intf;\n\tdev->confirmed_pairing = false;\n\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_LEGACY;\n\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_legacy;\n\thintf = usb_altnum_to_altsetting(intf, IPHETH_ALT_INTFNUM);\n\tif (hintf == NULL) {\n\t}\n\tfor (i = 0; i < hintf->desc.bNumEndpoints; i++) {\n\t\tendp = &hintf->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endp))\n\t\t\tdev->bulk_in = endp->bEndpointAddress;\n\t\telse if (usb_endpoint_is_bulk_out(endp))\n\t\t\tdev->bulk_out = endp->bEndpointAddress;\n\t}\n\tif (!(dev->bulk_in && dev->bulk_out)) {\n\t}\n\tdev->ctrl_buf = kmalloc(IPHETH_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (dev->ctrl_buf == NULL) {\n\t}\n\tretval = ipheth_get_macaddr(dev);\n\tretval = ipheth_enable_ncm(dev);\n\tif (!retval) {\n\t\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_NCM;\n\t\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_ncm;\n\t}\n\tINIT_DELAYED_WORK(&dev->carrier_work, ipheth_carrier_check_work);\n\tretval = ipheth_alloc_urbs(dev);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\tstruct folio *folio = page_folio(page);\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\tif (pte_alloc(mm, pmdp))\n\t\tgoto abort;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_charge(folio, vma->vm_mm, GFP_KERNEL))\n\t\tgoto abort;\n\t__folio_mark_uptodate(folio);\n\tif (folio_is_device_private(folio)) {\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tswp_entry = make_writable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\telse\n\t\t\tswp_entry = make_readable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\tentry = swp_entry_to_pte(swp_entry);\n\t} else {\n\t\tif (folio_is_zone_device(folio) &&\n\t\t    !folio_is_device_coherent(folio)) {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto abort;\n\torig_pte = ptep_get(ptep);\n\tif (check_stable_address_space(mm))\n\t\tgoto unlock_abort;\n\tif (pte_present(orig_pte)) {\n\t\tunsigned long pfn = pte_pfn(orig_pte);\n\t} else if (!pte_none(orig_pte))\n\t\tgoto unlock_abort;\n\tif (userfaultfd_missing(vma))\n\t\tgoto unlock_abort;\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tfolio_add_new_anon_rmap(folio, vma, addr, RMAP_EXCLUSIVE);\n\tif (!folio_is_zone_device(folio))\n\t\tfolio_add_lru_vma(folio, vma);\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(orig_pte));\n\t\tptep_clear_flush(vma, addr, ptep);\n\t}\n\tset_pte_at(mm, addr, ptep, entry);\nstatic void __migrate_device_pages(unsigned long *src_pfns,\n\t\t\t\tunsigned long *dst_pfns, unsigned long npages,\n\t\t\t\tstruct migrate_vma *migrate)\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tif (!newpage) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (!page) {\n\t\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\t\t\tVM_BUG_ON(!migrate);\n\t\t\taddr = migrate->start + i*PAGE_SIZE;\n\t\t\tif (!notified) {\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&src_pfns[i]);\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tif (folio_is_device_private(newfolio) ||\n\t\t    folio_is_device_coherent(newfolio)) {\n\t\t\tif (mapping) {\n\t\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t}\n\t\t} else if (folio_is_zone_device(newfolio)) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (migrate && migrate->fault_page == page)\n\t\t\textra_cnt = 1;\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\nvoid migrate_device_pages(unsigned long *src_pfns, unsigned long *dst_pfns,\n\t\t\tunsigned long npages)\n\t__migrate_device_pages(src_pfns, dst_pfns, npages, NULL);\nvoid migrate_vma_pages(struct migrate_vma *migrate)\n\t__migrate_device_pages(migrate->src, migrate->dst, migrate->npages, migrate);\nint migrate_device_coherent_folio(struct folio *folio)\n\tunsigned long src_pfn, dst_pfn = 0;\n\tWARN_ON_ONCE(folio_test_large(folio));\n\tfolio_lock(folio);\n\tsrc_pfn = migrate_pfn(folio_pfn(folio)) | MIGRATE_PFN_MIGRATE;\n\tmigrate_device_unmap(&src_pfn, 1, NULL);\n\tif (!(src_pfn & MIGRATE_PFN_MIGRATE))\n\t\treturn -EBUSY;\n\tdfolio = folio_alloc(GFP_USER | __GFP_NOWARN, 0);\n\tif (dfolio) {\n\t\tfolio_lock(dfolio);\n\t\tdst_pfn = migrate_pfn(folio_pfn(dfolio));\n\t}\n\tmigrate_device_pages(&src_pfn, &dst_pfn, 1);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int qaic_attach_slice_bo_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n\tstruct qaic_attach_slice *args = data;\n\tif (args->data == 0)\n\t\treturn -EINVAL;\n\tusr = file_priv->driver_priv;\n\tuser_data = u64_to_user_ptr(args->data);\n\tobj = drm_gem_object_lookup(file_priv, args->hdr.handle);\n\tif (!obj) {\n\t}\n\tbo = to_qaic_bo(obj);\n\tdrm_gem_object_put(obj);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22001",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void geneve_build_header(struct genevehdr *geneveh,\n\t\t\t\tconst struct ip_tunnel_info *info,\n\tgeneveh->ver = GENEVE_VER;\n\tgeneveh->opt_len = info->options_len / 4;\n\tgeneveh->oam = !!(info->key.tun_flags & TUNNEL_OAM);\n\tgeneveh->critical = !!(info->key.tun_flags & TUNNEL_CRIT_OPT);\n\tgeneveh->rsvd1 = 0;\n\ttunnel_id_to_vni(info->key.tun_id, geneveh->vni);\nstatic int geneve_build_skb(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_info *info,\n\t\t\t    bool xnet, int ip_hdr_len,\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tskb_reset_mac_header(skb);\n\tskb_scrub_packet(skb, xnet);\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +\n\t\t       GENEVE_BASE_HLEN + info->options_len + ip_hdr_len;\n\terr = skb_cow_head(skb, min_headroom);\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tgnvh = __skb_push(skb, sizeof(*gnvh) + info->options_len);\n\tinner_proto = inner_proto_inherit ? skb->protocol : htons(ETH_P_TEB);\n\tgeneve_build_header(gnvh, info, inner_proto);\nstatic int geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct geneve_dev *geneve,\n\t\t\t   const struct ip_tunnel_info *info)\n\tbool inner_proto_inherit = geneve->cfg.inner_proto_inherit;\n\tbool xnet = !net_eq(geneve->net, dev_net(geneve->dev));\n\tstruct geneve_sock *gs4 = rcu_dereference(geneve->sock4);\n\tconst struct ip_tunnel_key *key = &info->key;\n\t__be16 df = 0;\n\tif (!skb_vlan_inet_prepare(skb, inner_proto_inherit))\n\t\treturn -EINVAL;\n\tsport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);\n\trt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,\n\t\t\t      geneve->cfg.info.key.tp_dst, sport, &full_tos);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\terr = skb_tunnel_check_pmtu(skb, &rt->dst,\n\t\t\t\t    GENEVE_IPV4_HLEN + info->options_len,\n\t\t\t\t    netif_is_any_bridge_port(dev));\n\tif (geneve->cfg.collect_md) {\n\t\ttos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\t\tttl = key->ttl;\n\t\tdf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\n\t} else {\n\t\ttos = ip_tunnel_ecn_encap(full_tos, ip_hdr(skb), skb);\n\t\tif (geneve->cfg.ttl_inherit)\n\t\t\tttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);\n\t\tttl = ttl ? : ip4_dst_hoplimit(&rt->dst);\n\t\tif (geneve->cfg.df == GENEVE_DF_SET) {\n\t\t\tdf = htons(IP_DF);\n\t\t} else if (geneve->cfg.df == GENEVE_DF_INHERIT) {\n\t\t\tstruct ethhdr *eth = skb_eth_hdr(skb);\n\t\t\tif (ntohs(eth->h_proto) == ETH_P_IPV6) {\n\t\t\t\tdf = htons(IP_DF);\n\t\t\t} else if (ntohs(eth->h_proto) == ETH_P_IP) {\n\t\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t\t\tif (iph->frag_off & htons(IP_DF))\n\t\t\t\t\tdf = htons(IP_DF);\n\t\t\t}\n\t\t}\n\t}\n\terr = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr),\n\t\t\t       inner_proto_inherit);\n\tudp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,\n\t\t\t    tos, ttl, df, sport, geneve->cfg.info.key.tp_dst,\n\t\t\t    !net_eq(geneve->net, dev_net(geneve->dev)),\n\t\t\t    !(info->key.tun_flags & TUNNEL_CSUM));\nstatic netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tif (geneve->cfg.collect_md) {\n\t\tinfo = skb_tunnel_info(skb);\n\t\tif (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {\n\t\t}\n\t} else {\n\t\tinfo = &geneve->cfg.info;\n\t}\n\tif (info->mode & IP_TUNNEL_INFO_IPV6)\n\t\terr = geneve6_xmit_skb(skb, dev, geneve, info);\n\telse\n\t\terr = geneve_xmit_skb(skb, dev, geneve, info);\n\trcu_read_unlock();\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21858",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t      size_t cur_pos,  size_t payload_len)\n\t\t(unsigned int)cur_pos,\nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       dev_info,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static rvalue_stack *rvalue_stack_grow(rvalue_stack *stack, VALUE *handle, rvalue_stack **stack_ref)\n    long required = stack->capa * 2;\n    if (stack->type == RVALUE_STACK_STACK_ALLOCATED) {\n        stack = rvalue_stack_spill(stack, handle, stack_ref);\n    } else {\nstatic VALUE rvalue_stack_push(rvalue_stack *stack, VALUE value, VALUE *handle, rvalue_stack **stack_ref)\n    if (RB_UNLIKELY(stack->head >= stack->capa)) {\n        stack = rvalue_stack_grow(stack, handle, stack_ref);\n    }\nstatic rvalue_stack *rvalue_stack_spill(rvalue_stack *old_stack, VALUE *handle, rvalue_stack **stack_ref)\n    *handle = TypedData_Make_Struct(0, rvalue_stack, &JSON_Parser_rvalue_stack_type, stack);\n    *stack_ref = stack;\n    MEMCPY(stack, old_stack, rvalue_stack, 1);\njson_eat_whitespace(JSON_ParserState *state)\n    while (state->cursor < state->end && RB_UNLIKELY(whitespace[(unsigned char)*state->cursor])) {\n    }\nstatic inline VALUE json_decode_object(JSON_ParserState *state, JSON_ParserConfig *config, long count)\n    if (RB_UNLIKELY(config->object_class)) {\n        long index = 0;\n        VALUE *items = rvalue_stack_peek(state->stack, count);\n        while (index < count) {\n            VALUE name = items[index++];\n            VALUE value = items[index++];\n        }\n    } else {\n        rb_hash_bulk_insert(count, rvalue_stack_peek(state->stack, count), object);\n    }\n    rvalue_stack_pop(state->stack, count);\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    bool escaped = false;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    return PUSH(string);\n                    state->cursor++;\n                    escaped = true;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"null\", 4) == 0)) {\n                return PUSH(Qnil);\n            }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"true\", 4) == 0)) {\n                return PUSH(Qtrue);\n            }\n            if ((state->end - state->cursor >= 5) && (memcmp(state->cursor + 1, \"alse\", 4) == 0)) {\n                return PUSH(Qfalse);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 3) && (memcmp(state->cursor + 1, \"aN\", 2) == 0)) {\n                return PUSH(CNaN);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 8) && (memcmp(state->cursor, \"Infinity\", 8) == 0)) {\n                return PUSH(CInfinity);\n            }\n            if ((state->end - state->cursor >= 9) && (memcmp(state->cursor + 1, \"Infinity\", 8) == 0)) {\n                if (config->allow_nan) {\n                    return PUSH(CMinusInfinity);\n                } else {\n            }\n            if (integer) {\n                return PUSH(json_decode_integer(start, state->cursor));\n            }\n            return PUSH(json_decode_float(config, start, state->cursor));\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                state->cursor++;\n                return PUSH(json_decode_array(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                        state->cursor++;\n                        long count = state->stack->head - stack_head;\n                        state->current_nesting--;\n                        state->in_array--;\n                        return PUSH(json_decode_array(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                state->cursor++;\n                return PUSH(json_decode_object(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                        state->cursor++;\n                        state->current_nesting--;\n                        long count = state->stack->head - stack_head;\n                        return PUSH(json_decode_object(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic void json_ensure_eof(JSON_ParserState *state)\n    json_eat_whitespace(state);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\n    rvalue_stack_eagerly_release(state->stack_handle);\n    json_ensure_eof(state);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tdev = urb->context;\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline s16 steam_le16(u8 *data)\n\ts16 x = (s16) le16_to_cpup((__le16 *)data);\n\treturn x == -32768 ? -32767 : x;\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tinput_report_abs(input, ABS_HAT2Y, data[11]);\n\tinput_report_abs(input, ABS_HAT2X, data[12]);\n\tx = steam_le16(data + 16);\n\ty = -steam_le16(data + 18);\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0X : ABS_X, x);\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0Y : ABS_Y, y);\n\tif (lpad_touched && !lpad_and_joy) {\n\t\tinput_report_abs(input, ABS_X, 0);\n\t\tinput_report_abs(input, ABS_Y, 0);\n\t}\n\tif (!(lpad_touched || lpad_and_joy)) {\n\t\tinput_report_abs(input, ABS_HAT0X, 0);\n\t\tinput_report_abs(input, ABS_HAT0Y, 0);\n\t}\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 20));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 22));\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tb11 = data[11];\n\tb13 = data[13];\n\tb14 = data[14];\n\tif (lpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT0X, steam_le16(data + 16));\n\t\tinput_report_abs(input, ABS_HAT0Y, steam_le16(data + 18));\n\t} else {\n\tif (rpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT1X, steam_le16(data + 20));\n\t\tinput_report_abs(input, ABS_HAT1Y, steam_le16(data + 22));\n\t} else {\n\tinput_report_abs(input, ABS_X, steam_le16(data + 48));\n\tinput_report_abs(input, ABS_Y, -steam_le16(data + 50));\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 52));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 54));\n\tinput_report_abs(input, ABS_HAT2Y, steam_le16(data + 44));\n\tinput_report_abs(input, ABS_HAT2X, steam_le16(data + 46));\n\t\tstruct input_dev *sensors, u8 *data)\n\tinput_report_abs(sensors, ABS_X, steam_le16(data + 24));\n\tinput_report_abs(sensors, ABS_Z, -steam_le16(data + 26));\n\tinput_report_abs(sensors, ABS_Y, steam_le16(data + 28));\n\tinput_report_abs(sensors, ABS_RX, steam_le16(data + 30));\n\tinput_report_abs(sensors, ABS_RZ, -steam_le16(data + 32));\n\tinput_report_abs(sensors, ABS_RY, steam_le16(data + 34));\n\t\tstruct power_supply *battery, u8 *data)\n\ts16 volts = steam_le16(data + 12);\nstatic int steam_raw_event(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, u8 *data,\n\t\t\tint size)\n\tstruct steam_device *steam = hid_get_drvdata(hdev);\n\tif (!steam)\n\t\treturn 0;\n\tif (steam->client_opened)\n\t\thid_input_report(steam->client_hdev, HID_FEATURE_REPORT,\n\t\t\t\tdata, size, 0);\n\tif (size != 64 || data[0] != 1 || data[1] != 0)\n\t\treturn 0;\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_input_event(steam, input, data);\n\t\tif (likely(input))\n\t\t\tsteam_do_deck_input_event(steam, input, data);\n\t\tif (likely(sensors))\n\t\t\tsteam_do_deck_sensors_event(steam, sensors, data);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\t\tif (likely(battery)) {\n\t\t\t\tsteam_do_battery_event(steam, battery, data);\n\t\t\t} else {\n\t\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,\n\t\t\tchar *newname)\n\tif (strcmp(newname, wiphy_name(&rdev->wiphy)) == 0)\n\t\treturn 0;\n\tresult = cfg80211_dev_check_name(rdev, newname);\n\tresult = device_rename(&rdev->wiphy.dev, newname);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21979",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,\n\t\t\tchar *newname)\n\tif (strcmp(newname, wiphy_name(&rdev->wiphy)) == 0)\n\t\treturn 0;\n\tresult = cfg80211_dev_check_name(rdev, newname);\n\tresult = device_rename(&rdev->wiphy.dev, newname);\n\tif (!IS_ERR_OR_NULL(rdev->wiphy.debugfsdir))\n\t\tdebugfs_rename(rdev->wiphy.debugfsdir->d_parent,\n\t\t\t       rdev->wiphy.debugfsdir,\n\t\t\t       rdev->wiphy.debugfsdir->d_parent, newname);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21979",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t      size_t cur_pos,  size_t payload_len)\n\t\t(unsigned int)cur_pos,\nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline s16 steam_le16(u8 *data)\n\ts16 x = (s16) le16_to_cpup((__le16 *)data);\n\treturn x == -32768 ? -32767 : x;\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tinput_report_abs(input, ABS_HAT2Y, data[11]);\n\tinput_report_abs(input, ABS_HAT2X, data[12]);\n\tx = steam_le16(data + 16);\n\ty = -steam_le16(data + 18);\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 20));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 22));\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tb11 = data[11];\n\tb13 = data[13];\n\tb14 = data[14];\n\tif (lpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT0X, steam_le16(data + 16));\n\t\tinput_report_abs(input, ABS_HAT0Y, steam_le16(data + 18));\n\t} else {\n\tif (rpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT1X, steam_le16(data + 20));\n\t\tinput_report_abs(input, ABS_HAT1Y, steam_le16(data + 22));\n\t} else {\n\tinput_report_abs(input, ABS_X, steam_le16(data + 48));\n\tinput_report_abs(input, ABS_Y, -steam_le16(data + 50));\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 52));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 54));\n\tinput_report_abs(input, ABS_HAT2Y, steam_le16(data + 44));\n\tinput_report_abs(input, ABS_HAT2X, steam_le16(data + 46));\nstatic void steam_do_deck_sensors_event(struct steam_device *steam,\n\t\tstruct input_dev *sensors, u8 *data)\n\tsteam->sensor_timestamp_us += 4000;\n\tinput_event(sensors, EV_MSC, MSC_TIMESTAMP, steam->sensor_timestamp_us);\n\tinput_report_abs(sensors, ABS_X, steam_le16(data + 24));\n\tinput_report_abs(sensors, ABS_Z, -steam_le16(data + 26));\n\tinput_report_abs(sensors, ABS_Y, steam_le16(data + 28));\n\tinput_report_abs(sensors, ABS_RX, steam_le16(data + 30));\n\tinput_report_abs(sensors, ABS_RZ, -steam_le16(data + 32));\n\tinput_report_abs(sensors, ABS_RY, steam_le16(data + 34));\n\t\tstruct power_supply *battery, u8 *data)\n\ts16 volts = steam_le16(data + 12);\nstatic int steam_raw_event(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, u8 *data,\n\t\t\tint size)\n\tstruct steam_device *steam = hid_get_drvdata(hdev);\n\tif (!steam)\n\t\treturn 0;\n\tif (steam->client_opened)\n\t\thid_input_report(steam->client_hdev, HID_FEATURE_REPORT,\n\t\t\t\tdata, size, 0);\n\tif (size != 64 || data[0] != 1 || data[1] != 0)\n\t\treturn 0;\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_input_event(steam, input, data);\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_deck_input_event(steam, input, data);\n\t\tsensors = rcu_dereference(steam->sensors);\n\t\tif (likely(sensors))\n\t\t\tsteam_do_deck_sensors_event(steam, sensors, data);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\t\tif (likely(battery)) {\n\t\t\t\tsteam_do_battery_event(steam, battery, data);\n\t\t\t} else {\n\t\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static bool xp_check_unaligned(struct xsk_buff_pool *pool, u64 *addr)\n\t*addr = xp_unaligned_extract_addr(*addr);\n\tif (*addr >= pool->addrs_cnt ||\n\t    *addr + pool->chunk_size > pool->addrs_cnt ||\nstatic bool xp_check_aligned(struct xsk_buff_pool *pool, u64 *addr)\n\t*addr = xp_aligned_extract_addr(pool, *addr);\n\treturn *addr < pool->addrs_cnt;\nstatic struct xdp_buff_xsk *__xp_alloc(struct xsk_buff_pool *pool)\n\tif (pool->free_heads_cnt == 0)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tif (!xskq_cons_peek_addr_unchecked(pool->fq, &addr)) {\n\t\t}\n\t\tok = pool->unaligned ? xp_check_unaligned(pool, &addr) :\n\t\t     xp_check_aligned(pool, &addr);\n\t\tif (!ok) {\n\t\t\tpool->fq->invalid_descs++;\n\t\t\txskq_cons_release(pool->fq);\n\t\t}\n\t}\nstruct xdp_buff *xp_alloc(struct xsk_buff_pool *pool)\n\tif (!pool->free_list_cnt) {\n\t\txskb = __xp_alloc(pool);\n\t} else {\nstatic u32 xp_alloc_new_from_fq(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (max > pool->free_heads_cnt)\n\t\tmax = pool->free_heads_cnt;\n\tmax = xskq_cons_nb_entries(pool->fq, max);\n\tcached_cons = pool->fq->cached_cons;\n\twhile (i--) {\n\t\t__xskq_cons_read_addr_unchecked(pool->fq, cached_cons++, &addr);\n\t\tok = pool->unaligned ? xp_check_unaligned(pool, &addr) :\n\t\t\txp_check_aligned(pool, &addr);\n\t\tif (unlikely(!ok)) {\n\t\t\tpool->fq->invalid_descs++;\n\t\t}\n\t\tif (pool->unaligned) {\n\t\t\txskb = pool->free_heads[--pool->free_heads_cnt];\n\t\t\txp_init_xskb_addr(xskb, pool, addr);\n\t\t\tif (pool->dma_pages)\n\t\t\t\txp_init_xskb_dma(xskb, pool, pool->dma_pages, addr);\n\t\t} else {\n\t\t\txskb = &pool->heads[xp_aligned_extract_idx(pool, addr)];\n\t\t}\n\t\t*xdp = &xskb->xdp;\n\t}\nstatic u32 xp_alloc_slow(struct xsk_buff_pool *pool, struct xdp_buff **xdp,\n\tfor (i = 0; i < max; i++) {\n\t\tbuff = xp_alloc(pool);\n\t}\nu32 xp_alloc_batch(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (unlikely(pool->dev && dma_dev_need_sync(pool->dev)))\n\t\treturn xp_alloc_slow(pool, xdp, max);\n\tif (unlikely(pool->free_list_cnt)) {\n\t\tnb_entries1 = xp_alloc_reused(pool, xdp, max);\n\t\tif (nb_entries1 == max)\n\t\t\treturn nb_entries1;\n\t\tmax -= nb_entries1;\n\t}\n\tnb_entries2 = xp_alloc_new_from_fq(pool, xdp, max);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline VALUE build_interned_string(const char *str, const long length)\n    VALUE rstring = rb_utf8_str_new(str, length);\n    return rb_funcall(rb_str_freeze(rstring), i_uminus, 0);\nstatic inline VALUE build_symbol(const char *str, const long length)\n    return rb_str_intern(build_interned_string(str, length));\nstatic VALUE rstring_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, entry);\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rstring = build_interned_string(str, length);\nstatic VALUE rsymbol_cache_fetch(rvalue_cache *cache, const char *str, const long length)\n    if (RB_UNLIKELY(length > JSON_RVALUE_CACHE_MAX_ENTRY_LENGTH)) {\n    }\n    if (RB_UNLIKELY(!isalpha((unsigned char)str[0]))) {\n    }\n    while (low <= high) {\n        last_cmp = rstring_cache_cmp(str, length, rb_sym2str(entry));\n    }\n    if (RB_UNLIKELY(memchr(str, '\\\\', length))) {\n    }\n    VALUE rsymbol = build_symbol(str, length);\n    if (cache->length < JSON_RVALUE_CACHE_CAPA) {\n        rvalue_cache_insert_at(cache, mid, rsymbol);\n    }\n    return rsymbol;\nstatic inline VALUE json_string_fastpath(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n    }\nstatic VALUE json_string_unescape(JSON_ParserState *state, const char *string, const char *stringEnd, bool is_name, bool intern, bool symbolize)\n    size_t bufferSize = stringEnd - string;\n    const char *p = string, *pe = string, *unescape, *bufferStart;\n    if (is_name && state->in_array) {\n        if (RB_UNLIKELY(symbolize)) {\n            cached_key = rsymbol_cache_fetch(&state->name_cache, string, bufferSize);\n        } else {\n            cached_key = rstring_cache_fetch(&state->name_cache, string, bufferSize);\n        }\n        if (RB_LIKELY(cached_key)) {\n            return cached_key;\n        }\n    }\nstatic inline VALUE json_decode_string(JSON_ParserState *state, JSON_ParserConfig *config, const char *start, const char *end, bool escaped, bool is_name)\n    bool intern = is_name || config->freeze;\n    bool symbolize = is_name && config->symbolize_names;\n    if (escaped) {\n        string = json_string_unescape(state, start, end, is_name, intern, symbolize);\n    } else {\n        string = json_string_fastpath(state, start, end, is_name, intern, symbolize);\n    }\n    if (RB_UNLIKELY(config->create_additions && RTEST(config->match_string))) {\n          VALUE memo = rb_ary_new2(2);\n          rb_ary_push(memo, string);\n    }\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t      size_t cur_pos,  size_t payload_len)\n\t\t(unsigned int)cur_pos,\nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline int copy_partial_exec_reqs(struct qaic_device *qdev, struct bo_slice *slice,\n\t\t\t\t\t u64 resize, u32 dbc_id, u32 head, u32 *ptail)\n\tstruct dma_bridge_chan *dbc = &qdev->dbc[dbc_id];\n\tstruct dbc_req *reqs = slice->reqs;\n\tu32 tail = *ptail;\n\tavail = head - tail;\n\tif (head <= tail)\n\t\tavail += dbc->nelem;\n\tfor (i = 0; i < slice->nents; i++) {\n\t}\n\tfirst_n = i;\n\tif (avail < (first_n + 1))\n\t\treturn -EAGAIN;\n\tif (first_n) {\n\t\tif (tail + first_n > dbc->nelem) {\n\t\t\tavail = dbc->nelem - tail;\n\t\t\tavail = min_t(u32, avail, first_n);\n\t\t\tmemcpy(dbc->req_q_base + tail * get_dbc_req_elem_size(), reqs,\n\t\t\t       sizeof(*reqs) * avail);\n\t\t\tlast_req = reqs + avail;\n\t\t\tavail = first_n - avail;\n\t\t\tif (avail)\n\t\t\t\tmemcpy(dbc->req_q_base, last_req, sizeof(*reqs) * avail);\n\t\t} else {\n\t}\nstatic int send_bo_list_to_device(struct qaic_device *qdev, struct drm_file *file_priv,\n\t\t\t\t  struct qaic_execute_entry *exec, unsigned int count,\n\t\t\t\t  bool is_partial, struct dma_bridge_chan *dbc, u32 head,\n\t\t\t\t  u32 *tail)\n\tstruct qaic_partial_execute_entry *pexec = (struct qaic_partial_execute_entry *)exec;\n\tfor (i = 0; i < count; i++) {\n\t\tobj = drm_gem_object_lookup(file_priv,\n\t\t\t\t\t    is_partial ? pexec[i].handle : exec[i].handle);\n\t\tif (!obj) {\n\t\t}\n\t\tbo = to_qaic_bo(obj);\n\t\tif (!bo->sliced) {\n\t\t}\n\t\tif (is_partial && pexec[i].resize > bo->size) {\n\t\t}\n\t\tbo->queued = true;\n\t\tbo->req_id = dbc->next_req_id++;\n\t\tlist_for_each_entry(slice, &bo->slices, slice) {\n\t\t\tif (is_partial && pexec[i].resize && pexec[i].resize <= slice->offset)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < slice->nents; j++)\n\t\t\t\tslice->reqs[j].req_id = cpu_to_le16(bo->req_id);\n\t\t\tif (is_partial && pexec[i].resize &&\n\t\t\t    pexec[i].resize < slice->offset + slice->size)\n\t\t\t\tret = copy_partial_exec_reqs(qdev, slice,\n\t\t\t\t\t\t\t     pexec[i].resize - slice->offset,\n\t\t\t\t\t\t\t     dbc->id, head, tail);\n\t\t\telse\n\t\t\t\tret = copy_exec_reqs(qdev, slice, dbc->id, head, tail);\n\t\treinit_completion(&bo->xfer_done);\n\t\tlist_add_tail(&bo->xfer_list, &dbc->xfer_list);\n\t\tdma_sync_sgtable_for_device(&qdev->pdev->dev, bo->sgt, bo->dir);\n\t}\nstatic int __qaic_execute_bo_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv,\n\tstruct qaic_execute *args = data;\n\tsize = is_partial ? sizeof(struct qaic_partial_execute_entry) : sizeof(*exec);\n\tn = (unsigned long)size * args->hdr.count;\n\tif (args->hdr.count == 0 || n / args->hdr.count != size)\n\t\treturn -EINVAL;\n\tuser_data = u64_to_user_ptr(args->data);\n\texec = kcalloc(args->hdr.count, size, GFP_KERNEL);\n\tif (!exec)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(exec, user_data, n)) {\n\t}\n\tusr = file_priv->driver_priv;\n\tqdev = usr->qddev->qdev;\n\tqdev_rcu_id = srcu_read_lock(&qdev->dev_lock);\n\tif (args->hdr.dbc_id >= qdev->num_dbc) {\n\t}\n\tdbc = &qdev->dbc[args->hdr.dbc_id];\n\trcu_id = srcu_read_lock(&dbc->ch_lock);\n\tif (!dbc->usr || dbc->usr->handle != usr->handle) {\n\t}\n\thead = readl(dbc->dbc_base + REQHP_OFF);\n\ttail = readl(dbc->dbc_base + REQTP_OFF);\n\tif (head == U32_MAX || tail == U32_MAX) {\n\t}\n\tqueue_level = head <= tail ? tail - head : dbc->nelem - (head - tail);\n\tret = send_bo_list_to_device(qdev, file_priv, exec, args->hdr.count, is_partial, dbc,\n\t\t\t\t     head, &tail);\nint qaic_execute_bo_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n\treturn __qaic_execute_bo_ioctl(dev, data, file_priv, false);\nint qaic_partial_execute_bo_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n\treturn __qaic_execute_bo_ioctl(dev, data, file_priv, true);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22001",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ism_cmd(struct ism_dev *ism, void *cmd)\n\tstruct ism_req_hdr *req = cmd;\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\n\t__ism_write_cmd(ism, req, 0, sizeof(*req));\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int query_info(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\nstatic int register_sba(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int register_ieq(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\tret = ism_alloc_dmb(ism, dmb);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\tism_v2_capable = true;\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tquery_info(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tism->dev.release = ism_dev_release;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\tu8 *cmd, int size)\n\tr = steam->hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0];\n\tif (!r) {\n\t}\n\tif (hid_report_len(r) < 64)\n\t\treturn -EINVAL;\n\tbuf = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tmemcpy(buf + 1, cmd, size);\nstatic inline int steam_send_report_byte(struct steam_device *steam, u8 cmd)\n\treturn steam_send_report(steam, &cmd, 1);\nstatic int steam_write_settings(struct steam_device *steam,\n\tu8 cmd[64] = {ID_SET_SETTINGS_VALUES, 0x00};\n\tva_start(args, steam);\n\tfor (;;) {\n\t\tif (reg == 0)\n\t\t\tbreak;\n\t\tcmd[cmd[1] + 2] = reg;\n\t\tcmd[cmd[1] + 3] = val & 0xff;\n\t\tcmd[cmd[1] + 4] = val >> 8;\n\t\tcmd[1] += 3;\n\t}\n\tret = steam_send_report(steam, cmd, 2 + cmd[1]);\n\treturn steam_recv_report(steam, cmd, 2 + cmd[1]);\n\tret = steam_send_report(steam, cmd, sizeof(cmd));\n\tret = steam_send_report_byte(steam, ID_DONGLE_GET_WIRELESS_STATE);\nstatic inline int steam_haptic_pulse(struct steam_device *steam, u8 pad,\n\t\t\t\tu16 duration, u16 interval, u16 count, u8 gain)\n\tif (pad < STEAM_PAD_BOTH)\n\t\tpad ^= 1;\n\treport[2] = pad;\n\treport[3] = duration & 0xFF;\n\treport[4] = duration >> 8;\n\treport[5] = interval & 0xFF;\n\treport[6] = interval >> 8;\n\treport[7] = count & 0xFF;\n\treport[8] = count >> 8;\n\treport[9] = gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\t\t\t\tu16 intensity, u16 left_speed, u16 right_speed,\n\t\t\t\tu8 left_gain, u8 right_gain)\n\treport[3] = intensity & 0xFF;\n\treport[4] = intensity >> 8;\n\treport[5] = left_speed & 0xFF;\n\treport[6] = left_speed >> 8;\n\treport[7] = right_speed & 0xFF;\n\treport[8] = right_speed >> 8;\n\treport[9] = left_gain;\n\treport[10] = right_gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\tsteam_haptic_rumble(steam, 0, steam->rumble_left,\n\t\tsteam->rumble_right, 2, 0);\nstatic void steam_set_lizard_mode(struct steam_device *steam, bool enable)\n\tif (enable) {\n\t\tsteam_send_report_byte(steam, ID_SET_DEFAULT_DIGITAL_MAPPINGS);\n\t\tsteam_send_report_byte(steam, ID_LOAD_DEFAULT_SETTINGS);\n\t} else {\n\t\tmutex_lock(&steam->report_mutex);\n\t\tsteam_send_report_byte(steam, ID_CLEAR_DIGITAL_MAPPINGS);\n\t\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\t\tsteam_write_settings(steam,\n\t\t} else {\n\t\t\tsteam_write_settings(steam,\n\t\t}\n\t}\nstatic int steam_input_open(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, false);\n\t}\nstatic void steam_input_close(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, true);\n\t}\nstatic int steam_register(struct steam_device *steam)\n\tif (!steam->serial_no[0]) {\n\t\tif (steam_get_serial(steam) < 0)\n\t\t\tstrscpy(steam->serial_no, \"XXXXXXXXXX\",\n\t\t\t\t\tsizeof(steam->serial_no));\n\t\thid_info(steam->hdev, \"Steam Controller '%s' connected\",\n\t\t\t\tsteam->serial_no);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS)\n\t\t\tsteam_battery_register(steam);\n\t\tif (list_empty(&steam->list))\n\t\t\tlist_add(&steam->list, &steam_devices);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tclient_opened = steam->client_opened;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (!client_opened) {\n\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tret = steam_register(steam);\n\t} else {\n\tsteam->gamepad_mode = !steam->gamepad_mode;\n\tif (steam->gamepad_mode)\n\t\tsteam_set_lizard_mode(steam, false);\n\telse {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tclient_opened = steam->client_opened;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (!client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tsteam_haptic_pulse(steam, STEAM_PAD_RIGHT, 0x190, 0, 1, 0);\n\tif (steam->gamepad_mode) {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x14D, 0x14D, 0x2D, 0);\n\t} else {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x1F4, 0x1F4, 0x1E, 0);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\topened = steam->client_opened;\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tif (opened) {\n\t\t} else {\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t\t}\n\t}\nstatic int steam_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n\tret = hid_parse(hdev);\n\tif (hdev->group == HID_GROUP_STEAM)\n\t\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (!steam_is_valve_interface(hdev))\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tsteam = devm_kzalloc(&hdev->dev, sizeof(*steam), GFP_KERNEL);\n\tif (!steam)\n\t\treturn -ENOMEM;\n\tsteam->hdev = hdev;\n\thid_set_drvdata(hdev, steam);\n\tspin_lock_init(&steam->lock);\n\tmutex_init(&steam->report_mutex);\n\tsteam->quirks = id->driver_data;\n\tINIT_WORK(&steam->work_connect, steam_work_connect_cb);\n\tINIT_DELAYED_WORK(&steam->mode_switch, steam_mode_switch_cb);\n\tINIT_LIST_HEAD(&steam->list);\n\tINIT_WORK(&steam->rumble_work, steam_haptic_rumble_cb);\n\tsteam->sensor_timestamp_us = 0;\n\tINIT_WORK(&steam->unregister_work, steam_work_unregister_cb);\n\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t} else {\n\t\tsteam->connected = true;\n\t\tret = steam_register(steam);\n\t}\n\tlist_for_each_entry(steam, &steam_devices, list) {\n\t\tif (!steam->client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int xp_alloc_tx_descs(struct xsk_buff_pool *pool, struct xdp_sock *xs)\n\tpool->tx_descs = kvcalloc(xs->tx->nentries, sizeof(*pool->tx_descs),\n\t\t\t\t  GFP_KERNEL);\nstruct xsk_buff_pool *xp_create_and_assign_umem(struct xdp_sock *xs,\n\t\t\t\t\t\tstruct xdp_umem *umem)\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\tif (!pool->heads)\n\t\tgoto out;\n\tif (xs->tx)\n\t\tif (xp_alloc_tx_descs(pool, xs))\n\t\t\tgoto out;\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ism_cmd(struct ism_dev *ism, void *cmd)\n\tstruct ism_req_hdr *req = cmd;\n\tstruct ism_resp_hdr *resp = cmd;\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\n\t__ism_write_cmd(ism, req, 0, sizeof(*req));\n\tWRITE_ONCE(resp->ret, ISM_ERROR);\n\t__ism_read_cmd(ism, resp, 0, sizeof(*resp));\n\t__ism_read_cmd(ism, resp + 1, sizeof(*resp), resp->len - sizeof(*resp));\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int query_info(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\nstatic int register_sba(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int register_ieq(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\tret = ism_alloc_dmb(ism, dmb);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\tism_v2_capable = true;\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tquery_info(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tism->dev.release = ism_dev_release;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int address_not_null(u8 *ip)\n\treturn (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));\nstatic umode_t ibft_check_nic_for(void *data, int type)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\t\tif (address_not_null(nic->ip_addr))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->gateway))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->primary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->secondary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->dhcp))\n\t\t\trc = S_IRUGO;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ishtp_hid_parse(struct hid_device *hid)\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tstruct ishtp_cl_data *client_data = hid_data->client_data;\n\trv = hid_parse_report(hid, client_data->report_descr[hid_data->index],\n\t\t\t      client_data->report_descr_size[hid_data->index]);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int address_not_null(u8 *ip)\n\treturn (memcmp(ip, nulls, 16) && memcmp(ip, mapped_nulls, 16));\nstatic umode_t ibft_check_nic_for(void *data, int type)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\t\tif (address_not_null(nic->ip_addr))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->gateway))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->primary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->secondary_dns))\n\t\t\trc = S_IRUGO;\n\t\tif (address_not_null(nic->dhcp))\n\t\t\trc = S_IRUGO;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static ssize_t send_alert_store(struct device *dev,\n\t\t\t\tconst char *buf, size_t count)\n\tstruct corsair_void_drvdata *drvdata = dev_get_drvdata(dev);\n\tstruct hid_device *hid_dev = drvdata->hid_dev;\n\tif (kstrtou8(buf, 10, &alert_id) || alert_id >= 2)\n\t\treturn -EINVAL;\n\tsend_buf = kmalloc(3, GFP_KERNEL);\n\tif (!send_buf)\n\t\treturn -ENOMEM;\n\tsend_buf[0] = CORSAIR_VOID_NOTIF_REQUEST_ID;\n\tsend_buf[1] = 0x02;\n\tsend_buf[2] = alert_id;\n\tret = hid_hw_raw_request(hid_dev, CORSAIR_VOID_NOTIF_REQUEST_ID,\n\t\t\t\t send_buf, 3, HID_OUTPUT_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21797",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\tstruct folio *folio = page_folio(page);\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\tif (pte_alloc(mm, pmdp))\n\t\tgoto abort;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_charge(folio, vma->vm_mm, GFP_KERNEL))\n\t\tgoto abort;\n\t__folio_mark_uptodate(folio);\n\tif (folio_is_device_private(folio)) {\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tswp_entry = make_writable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\telse\n\t\t\tswp_entry = make_readable_device_private_entry(\n\t\t\t\t\t\tpage_to_pfn(page));\n\t\tentry = swp_entry_to_pte(swp_entry);\n\t} else {\n\t\tif (folio_is_zone_device(folio) &&\n\t\t    !folio_is_device_coherent(folio)) {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto abort;\n\torig_pte = ptep_get(ptep);\n\tif (check_stable_address_space(mm))\n\t\tgoto unlock_abort;\n\tif (pte_present(orig_pte)) {\n\t\tunsigned long pfn = pte_pfn(orig_pte);\n\t} else if (!pte_none(orig_pte))\n\t\tgoto unlock_abort;\n\tif (userfaultfd_missing(vma))\n\t\tgoto unlock_abort;\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tfolio_add_new_anon_rmap(folio, vma, addr, RMAP_EXCLUSIVE);\n\tif (!folio_is_zone_device(folio))\n\t\tfolio_add_lru_vma(folio, vma);\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(orig_pte));\n\t\tptep_clear_flush(vma, addr, ptep);\n\t}\n\tset_pte_at(mm, addr, ptep, entry);\nstatic void __migrate_device_pages(unsigned long *src_pfns,\n\t\t\t\tunsigned long *dst_pfns, unsigned long npages,\n\t\t\t\tstruct migrate_vma *migrate)\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(dst_pfns[i]);\n\t\tstruct page *page = migrate_pfn_to_page(src_pfns[i]);\n\t\tif (!newpage) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (!page) {\n\t\t\tif (!(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\t\t\tVM_BUG_ON(!migrate);\n\t\t\taddr = migrate->start + i*PAGE_SIZE;\n\t\t\tif (!notified) {\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&src_pfns[i]);\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tif (folio_is_device_private(newfolio) ||\n\t\t    folio_is_device_coherent(newfolio)) {\n\t\t\tif (mapping) {\n\t\t\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t}\n\t\t} else if (folio_is_zone_device(newfolio)) {\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t}\n\t\tif (migrate && migrate->fault_page == page)\n\t\t\textra_cnt = 1;\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tsrc_pfns[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\nvoid migrate_device_pages(unsigned long *src_pfns, unsigned long *dst_pfns,\n\t\t\tunsigned long npages)\n\t__migrate_device_pages(src_pfns, dst_pfns, npages, NULL);\nvoid migrate_vma_pages(struct migrate_vma *migrate)\n\t__migrate_device_pages(migrate->src, migrate->dst, migrate->npages, migrate);\nint migrate_device_coherent_folio(struct folio *folio)\n\tunsigned long src_pfn, dst_pfn = 0;\n\tWARN_ON_ONCE(folio_test_large(folio));\n\tfolio_lock(folio);\n\tsrc_pfn = migrate_pfn(folio_pfn(folio)) | MIGRATE_PFN_MIGRATE;\n\tmigrate_device_unmap(&src_pfn, 1, NULL);\n\tif (!(src_pfn & MIGRATE_PFN_MIGRATE))\n\t\treturn -EBUSY;\n\tdfolio = folio_alloc(GFP_USER | __GFP_NOWARN, 0);\n\tif (dfolio) {\n\t\tfolio_lock(dfolio);\n\t\tdst_pfn = migrate_pfn(folio_pfn(dfolio));\n\t}\n\tmigrate_device_pages(&src_pfn, &dst_pfn, 1);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void thrustmaster_interrupts(struct hid_device *hdev)\n\tu8 *send_buf = kmalloc(256, GFP_KERNEL);\n\tstruct device *dev = &hdev->dev;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tif (!send_buf) {\n\t}\n\tb_ep = ep->desc.bEndpointAddress;\n\tu8 ep_addr[2] = {b_ep, 0};\n\tfor (i = 0; i < ARRAY_SIZE(setup_arr); ++i) {\n\t\tmemcpy(send_buf, setup_arr[i], setup_arr_sizes[i]);\n\t\tret = usb_interrupt_msg(usbdev,\n\t\t\tusb_sndintpipe(usbdev, b_ep),\n\t\t\tsend_buf,\n\t\t\tsetup_arr_sizes[i],\n\t\t\t&trans,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\nstatic int thrustmaster_probe(struct hid_device *hdev, const struct hid_device_id *id)\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tret = hid_parse(hdev);\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\ttm_wheel = kzalloc(sizeof(struct tm_wheel), GFP_KERNEL);\n\tif (!tm_wheel) {\n\t}\n\ttm_wheel->urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!tm_wheel->urb) {\n\t}\n\ttm_wheel->model_request = kmemdup(&model_request,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!tm_wheel->model_request) {\n\t}\n\ttm_wheel->response = kzalloc(sizeof(struct tm_wheel_response), GFP_KERNEL);\n\tif (!tm_wheel->response) {\n\t}\n\ttm_wheel->change_request = kmemdup(&change_request,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!tm_wheel->change_request) {\n\t}\n\ttm_wheel->usb_dev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\thid_set_drvdata(hdev, tm_wheel);\n\tthrustmaster_interrupts(hdev);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21794",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ism_cmd(struct ism_dev *ism, void *cmd)\n\tstruct ism_req_hdr *req = cmd;\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\n\t__ism_write_cmd(ism, req, 0, sizeof(*req));\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int query_info(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\nstatic int register_sba(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int register_ieq(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\tret = ism_alloc_dmb(ism, dmb);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\tism_v2_capable = true;\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tquery_info(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tism->dev.release = ism_dev_release;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ism_cmd(struct ism_dev *ism, void *cmd)\n\tstruct ism_req_hdr *req = cmd;\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int query_info(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\nstatic int register_sba(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int register_ieq(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\tret = ism_alloc_dmb(ism, dmb);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\tism_v2_capable = true;\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tquery_info(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tism->dev.release = ism_dev_release;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void ucan_rx_can_msg(struct ucan_priv *up, struct ucan_message_in *m)\n\tstruct net_device_stats *stats = &up->netdev->stats;\n\tlen = le16_to_cpu(m->len);\n\tcanid = le32_to_cpu(m->msg.can_msg.id);\n\tif (canid & CAN_ERR_FLAG) {\n\t\tbool busstate_changed = ucan_handle_error_frame(up, m, canid);\n\t} else {\n\t\tcanid_mask = CAN_RTR_FLAG;\n\t\tif (canid & CAN_EFF_FLAG)\n\t\t\tcanid_mask |= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcanid_mask |= CAN_SFF_MASK;\n\t\tif (canid & ~canid_mask)\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"unexpected bits set (canid %x, mask %x)\",\n\t\t\t\t    canid, canid_mask);\n\t\tcanid &= canid_mask;\n\t}\n\tskb = alloc_can_skb(up->netdev, &cf);\n\tcf->can_id = canid;\n\tcf->len = ucan_can_cc_dlc2len(&m->msg.can_msg, len);\n\tif (!(cf->can_id & CAN_RTR_FLAG) || (cf->can_id & CAN_ERR_FLAG))\n\t\tmemcpy(cf->data, m->msg.can_msg.data, cf->len);\nstatic void ucan_read_bulk_callback(struct urb *urb)\n\tstruct ucan_priv *up = urb->context;\n\tstruct net_device *netdev = up->netdev;\n\tif (WARN_ON(!up->context_array)) {\n\t}\n\tpos = 0;\n\twhile (pos < urb->actual_length) {\n\t\tm = (struct ucan_message_in *)\n\t\t\t((u8 *)urb->transfer_buffer + pos);\n\t\tlen = le16_to_cpu(m->len);\n\t\tif (urb->actual_length - pos < len) {\n\t\t}\n\t\t\tucan_rx_can_msg(up, m);\n\t\t\tucan_tx_complete_msg(up, m);\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (type; t:%d)\\n\",\n\t\t\t\t    m->type);\n\t\tpos += len;\n\t\tpos = round_up(pos, 4);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22003",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ism_cmd(struct ism_dev *ism, void *cmd)\n\tstruct ism_req_hdr *req = cmd;\n\tstruct ism_resp_hdr *resp = cmd;\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\n\t__ism_write_cmd(ism, req, 0, sizeof(*req));\n\tWRITE_ONCE(resp->ret, ISM_ERROR);\n\t__ism_read_cmd(ism, resp, 0, sizeof(*resp));\n\t__ism_read_cmd(ism, resp + 1, sizeof(*resp), resp->len - sizeof(*resp));\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int query_info(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\nstatic int register_sba(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int register_ieq(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tif (ism_cmd(ism, &cmd)) {\n\t}\nstatic int unregister_sba(struct ism_dev *ism)\n\tif (!ism->sba)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\nstatic int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\tret = ism_alloc_dmb(ism, dmb);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tret = ism_cmd(ism, &cmd);\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\treturn ism_cmd(ism, &cmd);\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\tism_v2_capable = true;\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tquery_info(ism);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tism->dev.release = ism_dev_release;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void ucan_rx_can_msg(struct ucan_priv *up, struct ucan_message_in *m)\n\tstruct net_device_stats *stats = &up->netdev->stats;\n\tlen = le16_to_cpu(m->len);\n\tcanid = le32_to_cpu(m->msg.can_msg.id);\n\tif (canid & CAN_ERR_FLAG) {\n\t\tbool busstate_changed = ucan_handle_error_frame(up, m, canid);\n\t} else {\n\t\tcanid_mask = CAN_RTR_FLAG;\n\t\tif (canid & CAN_EFF_FLAG)\n\t\t\tcanid_mask |= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcanid_mask |= CAN_SFF_MASK;\n\t\tif (canid & ~canid_mask)\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"unexpected bits set (canid %x, mask %x)\",\n\t\t\t\t    canid, canid_mask);\n\t\tcanid &= canid_mask;\n\t}\n\tskb = alloc_can_skb(up->netdev, &cf);\n\tcf->can_id = canid;\n\tcf->len = ucan_can_cc_dlc2len(&m->msg.can_msg, len);\n\tif (!(cf->can_id & CAN_RTR_FLAG) || (cf->can_id & CAN_ERR_FLAG))\n\t\tmemcpy(cf->data, m->msg.can_msg.data, cf->len);\nstatic void ucan_read_bulk_callback(struct urb *urb)\n\tstruct ucan_priv *up = urb->context;\n\tstruct net_device *netdev = up->netdev;\n\tif (WARN_ON(!up->context_array)) {\n\t}\n\tpos = 0;\n\twhile (pos < urb->actual_length) {\n\t\tm = (struct ucan_message_in *)\n\t\t\t((u8 *)urb->transfer_buffer + pos);\n\t\tlen = le16_to_cpu(m->len);\n\t\tif (urb->actual_length - pos < len) {\n\t\t}\n\t\t\tucan_rx_can_msg(up, m);\n\t\t\tucan_tx_complete_msg(up, m);\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (type; t:%d)\\n\",\n\t\t\t\t    m->type);\n\t\tpos += len;\n\t\tpos = round_up(pos, 4);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22003",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int corsair_void_request_status(struct hid_device *hid_dev, int id)\n\tsend_buf = kmalloc(2, GFP_KERNEL);\n\tif (!send_buf)\n\t\treturn -ENOMEM;\n\tsend_buf[0] = CORSAIR_VOID_STATUS_REQUEST_ID;\n\tsend_buf[1] = id;\n\treturn hid_hw_raw_request(hid_dev, CORSAIR_VOID_STATUS_REQUEST_ID,\n\t\t\t\t  send_buf, 2, HID_OUTPUT_REPORT,\n\t\t\t\t  HID_REQ_SET_REPORT);\n\tbattery_ret = corsair_void_request_status(drvdata->hid_dev,\n\t\t\t\t\t\t  CORSAIR_VOID_STATUS_REPORT_ID);\n\tfirmware_ret = corsair_void_request_status(drvdata->hid_dev,\n\t\t\t\t\t\t   CORSAIR_VOID_FIRMWARE_REPORT_ID);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21797",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,\n\t\t\tchar *newname)\n\tif (strcmp(newname, wiphy_name(&rdev->wiphy)) == 0)\n\t\treturn 0;\n\tresult = cfg80211_dev_check_name(rdev, newname);\n\tresult = device_rename(&rdev->wiphy.dev, newname);\n\tif (!IS_ERR_OR_NULL(rdev->wiphy.debugfsdir))\n\t\tdebugfs_rename(rdev->wiphy.debugfsdir->d_parent,\n\t\t\t       rdev->wiphy.debugfsdir,\n\t\t\t       rdev->wiphy.debugfsdir->d_parent, newname);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21979",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int unregister_ieq(struct ism_dev *ism)\n\tif (!ism->ieq)\n\t\treturn 0;\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\nstatic int ism_read_local_gid(struct ism_dev *ism)\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tret = ism_cmd(ism, &cmd);\n\tism->local_gid = cmd.response.gid;\nstatic int ism_dev_init(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tret = register_sba(ism);\n\tret = register_ieq(ism);\n\tret = ism_read_local_gid(ism);\n\tunregister_ieq(ism);\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tret = ism_dev_init(ism);\nstatic void ism_dev_exit(struct ism_dev *ism)\n\tstruct pci_dev *pdev = ism->pdev;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tif (ism_v2_capable)\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\nstatic void ism_remove(struct pci_dev *pdev)\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\tism_dev_exit(ism);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21856",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static ssize_t sprintf_ipaddr(char *buf, u8 *ip)\n\tchar *str = buf;\n\tif (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0 &&\n\t    ip[4] == 0 && ip[5] == 0 && ip[6] == 0 && ip[7] == 0 &&\n\t    ip[8] == 0 && ip[9] == 0 && ip[10] == 0xff && ip[11] == 0xff) {\n\t} else {\n\t\tstr += sprintf(str, \"%pI6\", ip);\n\t}\nstatic ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_initiator *initiator = entry->initiator;\n\tchar *str = buf;\n\tif (!initiator)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, initiator->isns_server);\n\t\tstr += sprintf_ipaddr(str, initiator->slp_server);\n\t\tstr += sprintf_ipaddr(str, initiator->pri_radius_server);\n\t\tstr += sprintf_ipaddr(str, initiator->sec_radius_server);\nstatic ssize_t ibft_attr_show_nic(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_nic *nic = entry->nic;\n\tchar *str = buf;\n\tif (!nic)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, nic->ip_addr);\n\t\tstr += sprintf_ipaddr(str, nic->gateway);\n\t\tstr += sprintf_ipaddr(str, nic->primary_dns);\n\t\tstr += sprintf_ipaddr(str, nic->secondary_dns);\n\t\tstr += sprintf_ipaddr(str, nic->dhcp);\nstatic ssize_t ibft_attr_show_target(void *data, int type, char *buf)\n\tstruct ibft_kobject *entry = data;\n\tstruct ibft_tgt *tgt = entry->tgt;\n\tchar *str = buf;\n\tif (!tgt)\n\t\treturn 0;\n\t\tstr += sprintf_ipaddr(str, tgt->ip_addr);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21993",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\t\t\tMIGRATE_PFN_MIGRATE;\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tdev = urb->context;\n\tif (urb->actual_length < IPHETH_NCM_HEADER_SIZE) {\n\t}\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tif (ncm0->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN) ||\n\t    le16_to_cpu(ncmh->wHeaderLength) + le16_to_cpu(ncm0->wLength) >=\n\t    urb->actual_length) {\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t\t\tstruct xdp_umem *umem)\n\tbool unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21742",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t\t\tstruct xdp_umem *umem)\n\tbool unaligned = umem->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tentries = unaligned ? umem->chunks : 0;\n\tpool = kvzalloc(struct_size(pool, free_heads, entries),\tGFP_KERNEL);\n\tif (!pool)\n\t\tgoto out;\n\tpool->heads = kvcalloc(umem->chunks, sizeof(*pool->heads), GFP_KERNEL);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, -1, walk);\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t\tfolio = pmd_folio(*pmdp);\n\t\tif (is_huge_zero_folio(folio)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tif (!ptep)\n\t\tgoto again;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tpte = ptep_get(ptep);\n\t\tif (pte_none(pte)) {\n\t\t\tif (vma_is_anonymous(vma)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pte)) {\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\t\t\tpage = pfn_swap_entry_to_page(entry);\n\t\t\tif (!(migrate->flags &\n\t\t\t\tMIGRATE_VMA_SELECT_DEVICE_PRIVATE) ||\n\t\t\t    page->pgmap->owner != migrate->pgmap_owner)\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page)) |\n\t\t\tif (is_writable_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tpfn = pte_pfn(pte);\n\t\t\tif (is_zero_pfn(pfn) &&\n\t\t\t    (migrate->flags & MIGRATE_VMA_SELECT_SYSTEM)) {\n\t\t\t\tmigrate->cpages++;\n\t\t\tpage = vm_normal_page(migrate->vma, addr, pte);\n\t\t\tif (page && !is_zone_device_page(page) &&\n\t\t\t    !(migrate->flags & MIGRATE_VMA_SELECT_SYSTEM))\n\t\t\telse if (page && is_device_coherent_page(page) &&\n\t\t\t    (!(migrate->flags & MIGRATE_VMA_SELECT_DEVICE_COHERENT) ||\n\t\t\t     page->pgmap->owner != migrate->pgmap_owner))\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t}\n\t\tfolio = page_folio(page);\n\t\tfolio_get(folio);\n\t\tif (folio_trylock(folio)) {\n\t\t\tflush_cache_page(vma, addr, pte_pfn(pte));\n\t\t\tanon_exclusive = folio_test_anon(folio) &&\n\t\t\t\t\t  PageAnonExclusive(page);\n\t\t\tif (anon_exclusive) {\n\t\t\t\tpte = ptep_clear_flush(vma, addr, ptep);\n\t\t\t\tif (folio_try_share_anon_rmap_pte(folio, page)) {\n\t\t\t\t\tset_pte_at(mm, addr, ptep, pte);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpte = ptep_get_and_clear(mm, addr, ptep);\n\t\t\t}\n\t\t\tmigrate->cpages++;\n\t\t\tif (pte_dirty(pte))\n\t\t\t\tfolio_mark_dirty(folio);\n\t\t\tif (mpfn & MIGRATE_PFN_WRITE)\n\t\t\t\tentry = make_writable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse if (anon_exclusive)\n\t\t\t\tentry = make_readable_exclusive_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\telse\n\t\t\t\tentry = make_readable_migration_entry(\n\t\t\t\t\t\t\tpage_to_pfn(page));\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_young(pte))\n\t\t\t\t\tentry = make_migration_entry_young(entry);\n\t\t\t\tif (pte_dirty(pte))\n\t\t\t\t\tentry = make_migration_entry_dirty(entry);\n\t\t\t}\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_present(pte)) {\n\t\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t} else {\n\t\t\t\tif (pte_swp_soft_dirty(pte))\n\t\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\t\tif (pte_swp_uffd_wp(pte))\n\t\t\t\t\tswp_pte = pte_swp_mkuffd_wp(swp_pte);\n\t\t\t}\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\t\t\tfolio_remove_rmap_pte(folio, page, vma);\n\t\t} else {\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21861",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline s16 steam_le16(u8 *data)\n\ts16 x = (s16) le16_to_cpup((__le16 *)data);\n\treturn x == -32768 ? -32767 : x;\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tinput_report_abs(input, ABS_HAT2Y, data[11]);\n\tinput_report_abs(input, ABS_HAT2X, data[12]);\n\tx = steam_le16(data + 16);\n\ty = -steam_le16(data + 18);\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0X : ABS_X, x);\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0Y : ABS_Y, y);\n\tif (lpad_touched && !lpad_and_joy) {\n\t\tinput_report_abs(input, ABS_X, 0);\n\t\tinput_report_abs(input, ABS_Y, 0);\n\t}\n\tif (!(lpad_touched || lpad_and_joy)) {\n\t\tinput_report_abs(input, ABS_HAT0X, 0);\n\t\tinput_report_abs(input, ABS_HAT0Y, 0);\n\t}\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 20));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 22));\n\t\tstruct input_dev *input, u8 *data)\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tb11 = data[11];\n\tb13 = data[13];\n\tb14 = data[14];\n\tif (lpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT0X, steam_le16(data + 16));\n\t\tinput_report_abs(input, ABS_HAT0Y, steam_le16(data + 18));\n\t} else {\n\tif (rpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT1X, steam_le16(data + 20));\n\t\tinput_report_abs(input, ABS_HAT1Y, steam_le16(data + 22));\n\t} else {\n\tinput_report_abs(input, ABS_X, steam_le16(data + 48));\n\tinput_report_abs(input, ABS_Y, -steam_le16(data + 50));\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 52));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 54));\n\tinput_report_abs(input, ABS_HAT2Y, steam_le16(data + 44));\n\tinput_report_abs(input, ABS_HAT2X, steam_le16(data + 46));\n\t\tstruct input_dev *sensors, u8 *data)\n\tinput_report_abs(sensors, ABS_X, steam_le16(data + 24));\n\tinput_report_abs(sensors, ABS_Z, -steam_le16(data + 26));\n\tinput_report_abs(sensors, ABS_Y, steam_le16(data + 28));\n\tinput_report_abs(sensors, ABS_RX, steam_le16(data + 30));\n\tinput_report_abs(sensors, ABS_RZ, -steam_le16(data + 32));\n\tinput_report_abs(sensors, ABS_RY, steam_le16(data + 34));\n\t\tstruct power_supply *battery, u8 *data)\n\ts16 volts = steam_le16(data + 12);\nstatic int steam_raw_event(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, u8 *data,\n\t\t\tint size)\n\tstruct steam_device *steam = hid_get_drvdata(hdev);\n\tif (!steam)\n\t\treturn 0;\n\tif (steam->client_opened)\n\t\thid_input_report(steam->client_hdev, HID_FEATURE_REPORT,\n\t\t\t\tdata, size, 0);\n\tif (size != 64 || data[0] != 1 || data[1] != 0)\n\t\treturn 0;\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_input_event(steam, input, data);\n\t\tif (likely(input))\n\t\t\tsteam_do_deck_input_event(steam, input, data);\n\t\tif (likely(sensors))\n\t\t\tsteam_do_deck_sensors_event(steam, sensors, data);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\t\tif (likely(battery)) {\n\t\t\t\tsteam_do_battery_event(steam, battery, data);\n\t\t\t} else {\n\t\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       dev_info,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int qaic_wait_bo_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\n\tstruct qaic_wait *args = data;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tusr = file_priv->driver_priv;\n\tqdev = usr->qddev->qdev;\n\tif (args->dbc_id >= qdev->num_dbc) {\n\t}\n\tobj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!obj) {\n\t}\n\tbo = to_qaic_bo(obj);\n\tdrm_gem_object_put(obj);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22001",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void geneve_build_header(struct genevehdr *geneveh,\n\t\t\t\tconst struct ip_tunnel_info *info,\n\tgeneveh->ver = GENEVE_VER;\n\tgeneveh->opt_len = info->options_len / 4;\n\tgeneveh->oam = !!(info->key.tun_flags & TUNNEL_OAM);\n\tgeneveh->critical = !!(info->key.tun_flags & TUNNEL_CRIT_OPT);\n\tgeneveh->rsvd1 = 0;\n\ttunnel_id_to_vni(info->key.tun_id, geneveh->vni);\nstatic int geneve_build_skb(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_info *info,\n\t\t\t    bool xnet, int ip_hdr_len,\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tskb_reset_mac_header(skb);\n\tskb_scrub_packet(skb, xnet);\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +\n\t\t       GENEVE_BASE_HLEN + info->options_len + ip_hdr_len;\n\terr = skb_cow_head(skb, min_headroom);\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tgnvh = __skb_push(skb, sizeof(*gnvh) + info->options_len);\n\tinner_proto = inner_proto_inherit ? skb->protocol : htons(ETH_P_TEB);\n\tgeneve_build_header(gnvh, info, inner_proto);\nstatic int geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct geneve_dev *geneve,\n\t\t\t   const struct ip_tunnel_info *info)\n\tbool inner_proto_inherit = geneve->cfg.inner_proto_inherit;\n\tbool xnet = !net_eq(geneve->net, dev_net(geneve->dev));\n\tstruct geneve_sock *gs4 = rcu_dereference(geneve->sock4);\n\tconst struct ip_tunnel_key *key = &info->key;\n\t__be16 df = 0;\n\tif (!skb_vlan_inet_prepare(skb, inner_proto_inherit))\n\t\treturn -EINVAL;\n\tsport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);\n\trt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,\n\t\t\t      geneve->cfg.info.key.tp_dst, sport, &full_tos);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\terr = skb_tunnel_check_pmtu(skb, &rt->dst,\n\t\t\t\t    GENEVE_IPV4_HLEN + info->options_len,\n\t\t\t\t    netif_is_any_bridge_port(dev));\n\tif (geneve->cfg.collect_md) {\n\t\ttos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\t\tttl = key->ttl;\n\t\tdf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\n\t} else {\n\t\ttos = ip_tunnel_ecn_encap(full_tos, ip_hdr(skb), skb);\n\t\tif (geneve->cfg.ttl_inherit)\n\t\t\tttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);\n\t\tttl = ttl ? : ip4_dst_hoplimit(&rt->dst);\n\t\tif (geneve->cfg.df == GENEVE_DF_SET) {\n\t\t\tdf = htons(IP_DF);\n\t\t} else if (geneve->cfg.df == GENEVE_DF_INHERIT) {\n\t\t\tstruct ethhdr *eth = skb_eth_hdr(skb);\n\t\t\tif (ntohs(eth->h_proto) == ETH_P_IPV6) {\n\t\t\t\tdf = htons(IP_DF);\n\t\t\t} else if (ntohs(eth->h_proto) == ETH_P_IP) {\n\t\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t\t\tif (iph->frag_off & htons(IP_DF))\n\t\t\t\t\tdf = htons(IP_DF);\n\t\t\t}\n\t\t}\n\t}\n\terr = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr),\n\t\t\t       inner_proto_inherit);\n\tudp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,\n\t\t\t    tos, ttl, df, sport, geneve->cfg.info.key.tp_dst,\n\t\t\t    !net_eq(geneve->net, dev_net(geneve->dev)),\n\t\t\t    !(info->key.tun_flags & TUNNEL_CSUM));\nstatic netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tif (geneve->cfg.collect_md) {\n\t\tinfo = skb_tunnel_info(skb);\n\t\tif (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {\n\t\t}\n\t} else {\n\t\tinfo = &geneve->cfg.info;\n\t}\n\tif (info->mode & IP_TUNNEL_INFO_IPV6)\n\t\terr = geneve6_xmit_skb(skb, dev, geneve, info);\n\telse\n\t\terr = geneve_xmit_skb(skb, dev, geneve, info);\n\trcu_read_unlock();\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21858",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21928",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_alloc_urbs(struct ipheth_device *iphone)\n\tstruct urb *tx_urb = NULL;\n\tstruct urb *rx_urb = NULL;\n\tu8 *tx_buf = NULL;\n\tu8 *rx_buf = NULL;\n\ttx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (tx_urb == NULL)\n\t\tgoto error_nomem;\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (rx_urb == NULL)\n\t\tgoto free_tx_urb;\n\ttx_buf = usb_alloc_coherent(iphone->udev, IPHETH_TX_BUF_SIZE,\n\t\t\t\t    GFP_KERNEL, &tx_urb->transfer_dma);\n\tif (tx_buf == NULL)\n\t\tgoto free_rx_urb;\n\trx_buf = usb_alloc_coherent(iphone->udev, iphone->rx_buf_len,\n\t\t\t\t    GFP_KERNEL, &rx_urb->transfer_dma);\n\tif (rx_buf == NULL)\n\t\tgoto free_tx_buf;\n\tiphone->tx_urb = tx_urb;\n\tiphone->rx_urb = rx_urb;\n\tiphone->tx_buf = tx_buf;\n\tiphone->rx_buf = rx_buf;\nstatic void ipheth_free_urbs(struct ipheth_device *iphone)\n\tusb_free_coherent(iphone->udev, iphone->rx_buf_len, iphone->rx_buf,\n\t\t\t  iphone->rx_urb->transfer_dma);\n\tusb_free_coherent(iphone->udev, IPHETH_TX_BUF_SIZE, iphone->tx_buf,\nstatic int ipheth_probe(struct usb_interface *intf,\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tnetdev = alloc_etherdev(sizeof(struct ipheth_device));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tnetdev->netdev_ops = &ipheth_netdev_ops;\n\tnetdev->watchdog_timeo = IPHETH_TX_TIMEOUT;\n\tstrscpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\tdev = netdev_priv(netdev);\n\tdev->udev = udev;\n\tdev->net = netdev;\n\tdev->intf = intf;\n\tdev->confirmed_pairing = false;\n\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_LEGACY;\n\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_legacy;\n\thintf = usb_altnum_to_altsetting(intf, IPHETH_ALT_INTFNUM);\n\tif (hintf == NULL) {\n\t}\n\tfor (i = 0; i < hintf->desc.bNumEndpoints; i++) {\n\t\tendp = &hintf->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endp))\n\t\t\tdev->bulk_in = endp->bEndpointAddress;\n\t\telse if (usb_endpoint_is_bulk_out(endp))\n\t\t\tdev->bulk_out = endp->bEndpointAddress;\n\t}\n\tif (!(dev->bulk_in && dev->bulk_out)) {\n\t}\n\tdev->ctrl_buf = kmalloc(IPHETH_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (dev->ctrl_buf == NULL) {\n\t}\n\tretval = ipheth_get_macaddr(dev);\n\tretval = ipheth_enable_ncm(dev);\n\tif (!retval) {\n\t\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_NCM;\n\t\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_ncm;\n\t}\n\tINIT_DELAYED_WORK(&dev->carrier_work, ipheth_carrier_check_work);\n\tretval = ipheth_alloc_urbs(dev);\n\tusb_set_intfdata(intf, dev);\n\tipheth_free_urbs(dev);\nstatic void ipheth_disconnect(struct usb_interface *intf)\n\tdev = usb_get_intfdata(intf);\n\tif (dev != NULL) {\n\t\tunregister_netdev(dev->net);\n\t\tipheth_kill_urbs(dev);\n\t\tipheth_free_urbs(dev);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21743",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t      size_t cur_pos,  size_t payload_len)\n\t\t(unsigned int)cur_pos,\nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int corsair_void_request_status(struct hid_device *hid_dev, int id)\n\tsend_buf = kmalloc(2, GFP_KERNEL);\n\tif (!send_buf)\n\t\treturn -ENOMEM;\n\tsend_buf[0] = CORSAIR_VOID_STATUS_REQUEST_ID;\n\tsend_buf[1] = id;\n\treturn hid_hw_raw_request(hid_dev, CORSAIR_VOID_STATUS_REQUEST_ID,\n\t\t\t\t  send_buf, 2, HID_OUTPUT_REPORT,\n\t\t\t\t  HID_REQ_SET_REPORT);\n\tbattery_ret = corsair_void_request_status(drvdata->hid_dev,\n\t\t\t\t\t\t  CORSAIR_VOID_STATUS_REPORT_ID);\n\tfirmware_ret = corsair_void_request_status(drvdata->hid_dev,\n\t\t\t\t\t\t   CORSAIR_VOID_FIRMWARE_REPORT_ID);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21797",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\tu8 *cmd, int size)\n\tr = steam->hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0];\n\tif (!r) {\n\t}\n\tif (hid_report_len(r) < 64)\n\t\treturn -EINVAL;\n\tbuf = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tmemcpy(buf + 1, cmd, size);\nstatic inline int steam_send_report_byte(struct steam_device *steam, u8 cmd)\n\treturn steam_send_report(steam, &cmd, 1);\nstatic int steam_write_settings(struct steam_device *steam,\n\tu8 cmd[64] = {ID_SET_SETTINGS_VALUES, 0x00};\n\tva_start(args, steam);\n\tfor (;;) {\n\t\tif (reg == 0)\n\t\t\tbreak;\n\t\tcmd[cmd[1] + 2] = reg;\n\t\tcmd[cmd[1] + 3] = val & 0xff;\n\t\tcmd[cmd[1] + 4] = val >> 8;\n\t\tcmd[1] += 3;\n\t}\n\tret = steam_send_report(steam, cmd, 2 + cmd[1]);\n\treturn steam_recv_report(steam, cmd, 2 + cmd[1]);\n\tret = steam_send_report(steam, cmd, sizeof(cmd));\n\tret = steam_send_report_byte(steam, ID_DONGLE_GET_WIRELESS_STATE);\nstatic inline int steam_haptic_pulse(struct steam_device *steam, u8 pad,\n\t\t\t\tu16 duration, u16 interval, u16 count, u8 gain)\n\tif (pad < STEAM_PAD_BOTH)\n\t\tpad ^= 1;\n\treport[2] = pad;\n\treport[3] = duration & 0xFF;\n\treport[4] = duration >> 8;\n\treport[5] = interval & 0xFF;\n\treport[6] = interval >> 8;\n\treport[7] = count & 0xFF;\n\treport[8] = count >> 8;\n\treport[9] = gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\t\t\t\tu16 intensity, u16 left_speed, u16 right_speed,\n\t\t\t\tu8 left_gain, u8 right_gain)\n\treport[3] = intensity & 0xFF;\n\treport[4] = intensity >> 8;\n\treport[5] = left_speed & 0xFF;\n\treport[6] = left_speed >> 8;\n\treport[7] = right_speed & 0xFF;\n\treport[8] = right_speed >> 8;\n\treport[9] = left_gain;\n\treport[10] = right_gain;\n\tret = steam_send_report(steam, report, sizeof(report));\n\tsteam_haptic_rumble(steam, 0, steam->rumble_left,\n\t\tsteam->rumble_right, 2, 0);\nstatic void steam_set_lizard_mode(struct steam_device *steam, bool enable)\n\tif (enable) {\n\t\tsteam_send_report_byte(steam, ID_SET_DEFAULT_DIGITAL_MAPPINGS);\n\t\tsteam_send_report_byte(steam, ID_LOAD_DEFAULT_SETTINGS);\n\t} else {\n\t\tmutex_lock(&steam->report_mutex);\n\t\tsteam_send_report_byte(steam, ID_CLEAR_DIGITAL_MAPPINGS);\n\t\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\t\tsteam_write_settings(steam,\n\t\t} else {\n\t\t\tsteam_write_settings(steam,\n\t\t}\n\t}\nstatic int steam_input_open(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, false);\n\t}\nstatic void steam_input_close(struct input_dev *dev)\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\tif (!(steam->quirks & STEAM_QUIRK_DECK)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tset_lizard_mode = !steam->client_opened && lizard_mode;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (set_lizard_mode)\n\t\t\tsteam_set_lizard_mode(steam, true);\n\t}\nstatic int steam_register(struct steam_device *steam)\n\tif (!steam->serial_no[0]) {\n\t\tif (steam_get_serial(steam) < 0)\n\t\t\tstrscpy(steam->serial_no, \"XXXXXXXXXX\",\n\t\t\t\t\tsizeof(steam->serial_no));\n\t\thid_info(steam->hdev, \"Steam Controller '%s' connected\",\n\t\t\t\tsteam->serial_no);\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS)\n\t\t\tsteam_battery_register(steam);\n\t\tif (list_empty(&steam->list))\n\t\t\tlist_add(&steam->list, &steam_devices);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tclient_opened = steam->client_opened;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (!client_opened) {\n\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tret = steam_register(steam);\n\t} else {\n\tsteam->gamepad_mode = !steam->gamepad_mode;\n\tif (steam->gamepad_mode)\n\t\tsteam_set_lizard_mode(steam, false);\n\telse {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tclient_opened = steam->client_opened;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tif (!client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t}\n\tsteam_haptic_pulse(steam, STEAM_PAD_RIGHT, 0x190, 0, 1, 0);\n\tif (steam->gamepad_mode) {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x14D, 0x14D, 0x2D, 0);\n\t} else {\n\t\tsteam_haptic_pulse(steam, STEAM_PAD_LEFT, 0x1F4, 0x1F4, 0x1E, 0);\n\t}\n\tspin_lock_irqsave(&steam->lock, flags);\n\topened = steam->client_opened;\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\tif (connected) {\n\t\tif (opened) {\n\t\t} else {\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t\t}\n\t}\nstatic int steam_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n\tret = hid_parse(hdev);\n\tif (hdev->group == HID_GROUP_STEAM)\n\t\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (!steam_is_valve_interface(hdev))\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tsteam = devm_kzalloc(&hdev->dev, sizeof(*steam), GFP_KERNEL);\n\tif (!steam)\n\t\treturn -ENOMEM;\n\tsteam->hdev = hdev;\n\thid_set_drvdata(hdev, steam);\n\tspin_lock_init(&steam->lock);\n\tmutex_init(&steam->report_mutex);\n\tsteam->quirks = id->driver_data;\n\tINIT_WORK(&steam->work_connect, steam_work_connect_cb);\n\tINIT_DELAYED_WORK(&steam->mode_switch, steam_mode_switch_cb);\n\tINIT_LIST_HEAD(&steam->list);\n\tINIT_WORK(&steam->rumble_work, steam_haptic_rumble_cb);\n\tsteam->sensor_timestamp_us = 0;\n\tINIT_WORK(&steam->unregister_work, steam_work_unregister_cb);\n\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t} else {\n\t\tsteam->connected = true;\n\t\tret = steam_register(steam);\n\t}\n\tlist_for_each_entry(steam, &steam_devices, list) {\n\t\tif (!steam->client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)\n\tstruct net *net = dev_net(real_dev);\n\tchar name[IFNAMSIZ];\n\tif (vlan_id >= VLAN_VID_MASK)\n\t\treturn -ERANGE;\n\terr = vlan_check_real_dev(real_dev, htons(ETH_P_8021Q), vlan_id,\n\t\t\t\t  NULL);\n\t\tsnprintf(name, IFNAMSIZ, \"%s.%i\", real_dev->name, vlan_id);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21920",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)\n\tstruct net *net = dev_net(real_dev);\n\tchar name[IFNAMSIZ];\n\tif (vlan_id >= VLAN_VID_MASK)\n\t\treturn -ERANGE;\n\terr = vlan_check_real_dev(real_dev, htons(ETH_P_8021Q), vlan_id,\n\t\t\t\t  NULL);\n\t\tsnprintf(name, IFNAMSIZ, \"%s.%i\", real_dev->name, vlan_id);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21920",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static struct urb *ucan_prepare_tx_urb(struct ucan_priv *up,\n\t\t\t\t       struct can_frame *cf,\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t}\n\tm = usb_alloc_coherent(up->udev,\n\t\t\t       GFP_ATOMIC,\n\t\t\t       &urb->transfer_dma);\n\tif (!m) {\n\t}\n\tm->type = UCAN_OUT_TX;\n\tm->msg.can_msg.id = cpu_to_le32(cf->can_id);\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t} else {\n\t\t\tsizeof(m->msg.can_msg.id) + cf->len;\n\t\tmemcpy(m->msg.can_msg.data, cf->data, cf->len);\n\t}\nstatic netdev_tx_t ucan_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tcontext = ucan_alloc_context(up);\n\techo_index = context - up->context_array;\n\tif (WARN_ON_ONCE(!context))\n\t\treturn NETDEV_TX_BUSY;\n\turb = ucan_prepare_tx_urb(up, context, cf, echo_index);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-22003",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static u32 xp_alloc_new_from_fq(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (max > pool->free_heads_cnt)\n\t\tmax = pool->free_heads_cnt;\n\tmax = xskq_cons_nb_entries(pool->fq, max);\n\tcached_cons = pool->fq->cached_cons;\n\twhile (i--) {\n\t\t__xskq_cons_read_addr_unchecked(pool->fq, cached_cons++, &addr);\n\t\tok = pool->unaligned ? xp_check_unaligned(pool, &addr) :\n\t\t\txp_check_aligned(pool, &addr);\n\t\tif (unlikely(!ok)) {\n\t\t\tpool->fq->invalid_descs++;\n\t\t}\n\t\tif (pool->unaligned) {\n\t\t\txskb = pool->free_heads[--pool->free_heads_cnt];\n\t\t\txp_init_xskb_addr(xskb, pool, addr);\n\t\t\tif (pool->dma_pages)\n\t\t\t\txp_init_xskb_dma(xskb, pool, pool->dma_pages, addr);\n\t\t} else {\n\t\t\txskb = &pool->heads[xp_aligned_extract_idx(pool, addr)];\n\t\t}\n\t\t*xdp = &xskb->xdp;\n\t}\nu32 xp_alloc_batch(struct xsk_buff_pool *pool, struct xdp_buff **xdp, u32 max)\n\tif (unlikely(pool->dev && dma_dev_need_sync(pool->dev)))\n\t\treturn xp_alloc_slow(pool, xdp, max);\n\tif (unlikely(pool->free_list_cnt)) {\n\t\tnb_entries1 = xp_alloc_reused(pool, xdp, max);\n\t\tif (nb_entries1 == max)\n\t\t\treturn nb_entries1;\n\t\tmax -= nb_entries1;\n\t}\n\tnb_entries2 = xp_alloc_new_from_fq(pool, xdp, max);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21997",
        "cwe": "CWE-190",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t}\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t}\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treport = reports_list->reports;\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\treport_len = report->size;\n\t\t\t\tpayload = recv_msg->payload;\n\t\t\t\tpayload_len = report_len -\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\treport += sizeof(*report) + payload_len;\n\t\t\t}\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t}\n\t\tmsg_len = payload_len + sizeof(struct hostif_msg);\n\t\tif (!cur_pos && cur_pos + msg_len < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\t\tcur_pos += msg_len;\n\t\tpayload += msg_len;\n\t} while (cur_pos < total_len);\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\t\tr_length = rb_in_proc->buf_idx;\n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21929",
        "cwe": "CWE-416",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t}\n\tskb_put_data(skb, buf, len);\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\treturn ipheth_consume_skb(buf, len, dev);\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length -\n\t\t    le16_to_cpu(dpe->wDatagramIndex)) {\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tdpe++;\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21742",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "torvalds/linux"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static rvalue_stack *rvalue_stack_grow(rvalue_stack *stack, VALUE *handle, rvalue_stack **stack_ref)\n    long required = stack->capa * 2;\n    if (stack->type == RVALUE_STACK_STACK_ALLOCATED) {\n        stack = rvalue_stack_spill(stack, handle, stack_ref);\n    } else {\nstatic VALUE rvalue_stack_push(rvalue_stack *stack, VALUE value, VALUE *handle, rvalue_stack **stack_ref)\n    if (RB_UNLIKELY(stack->head >= stack->capa)) {\n        stack = rvalue_stack_grow(stack, handle, stack_ref);\n    }\nstatic rvalue_stack *rvalue_stack_spill(rvalue_stack *old_stack, VALUE *handle, rvalue_stack **stack_ref)\n    *handle = TypedData_Make_Struct(0, rvalue_stack, &JSON_Parser_rvalue_stack_type, stack);\n    *stack_ref = stack;\n    MEMCPY(stack, old_stack, rvalue_stack, 1);\njson_eat_whitespace(JSON_ParserState *state)\n    while (state->cursor < state->end && RB_UNLIKELY(whitespace[(unsigned char)*state->cursor])) {\n    }\nstatic inline VALUE json_decode_object(JSON_ParserState *state, JSON_ParserConfig *config, long count)\n    if (RB_UNLIKELY(config->object_class)) {\n        long index = 0;\n        VALUE *items = rvalue_stack_peek(state->stack, count);\n        while (index < count) {\n            VALUE name = items[index++];\n            VALUE value = items[index++];\n        }\n    } else {\n        rb_hash_bulk_insert(count, rvalue_stack_peek(state->stack, count), object);\n    }\n    rvalue_stack_pop(state->stack, count);\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    bool escaped = false;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n                    state->cursor++;\n                    return PUSH(string);\n                    state->cursor++;\n                    escaped = true;\n                    if ((unsigned char)*state->cursor < 0x20) {\n                        raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n                    }\n                    raise_parse_error(\"invalid ASCII control character in string: %s\", state->cursor);\n        }\n        state->cursor++;\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"null\", 4) == 0)) {\n                return PUSH(Qnil);\n            }\n            if ((state->end - state->cursor >= 4) && (memcmp(state->cursor, \"true\", 4) == 0)) {\n                return PUSH(Qtrue);\n            }\n            if ((state->end - state->cursor >= 5) && (memcmp(state->cursor + 1, \"alse\", 4) == 0)) {\n                return PUSH(Qfalse);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 3) && (memcmp(state->cursor + 1, \"aN\", 2) == 0)) {\n                return PUSH(CNaN);\n            }\n            if (config->allow_nan && (state->end - state->cursor >= 8) && (memcmp(state->cursor, \"Infinity\", 8) == 0)) {\n                return PUSH(CInfinity);\n            }\n            if ((state->end - state->cursor >= 9) && (memcmp(state->cursor + 1, \"Infinity\", 8) == 0)) {\n                if (config->allow_nan) {\n                    return PUSH(CMinusInfinity);\n                } else {\n            }\n            if (integer) {\n                return PUSH(json_decode_integer(start, state->cursor));\n            }\n            return PUSH(json_decode_float(config, start, state->cursor));\n            return json_parse_string(state, config, false);\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                state->cursor++;\n                return PUSH(json_decode_array(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                state->in_array++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ']') {\n                        state->cursor++;\n                        long count = state->stack->head - stack_head;\n                        state->current_nesting--;\n                        state->in_array--;\n                        return PUSH(json_decode_array(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            json_eat_whitespace(state);\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n                raise_parse_error(\"expected ',' or ']' after array value\", state->cursor);\n            }\n            state->cursor++;\n            json_eat_whitespace(state);\n            long stack_head = state->stack->head;\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                state->cursor++;\n                return PUSH(json_decode_object(state, config, 0));\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                if (*state->cursor != '\"') {\n                    raise_parse_error(\"expected object key, got '%s\", state->cursor);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    if (*state->cursor == '}') {\n                        state->cursor++;\n                        state->current_nesting--;\n                        long count = state->stack->head - stack_head;\n                        return PUSH(json_decode_object(state, config, count));\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        json_eat_whitespace(state);\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        if (*state->cursor != '\"') {\n                            raise_parse_error(\"expected object key, got: '%s'\", state->cursor);\n                        }\n                        json_parse_string(state, config, true);\n                        json_eat_whitespace(state);\n                        if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                            raise_parse_error(\"expected ':' after object key, got: '%s\", state->cursor);\n                        }\n                        state->cursor++;\n                        json_parse_any(state, config);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\nstatic void json_ensure_eof(JSON_ParserState *state)\n    json_eat_whitespace(state);\nstatic VALUE cParser_parse(JSON_ParserConfig *config, VALUE Vsource)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    VALUE rvalue_stack_buffer[RVALUE_STACK_INITIAL_CAPA];\n    rvalue_stack stack = {\n        .type = RVALUE_STACK_STACK_ALLOCATED,\n        .ptr = rvalue_stack_buffer,\n        .capa = RVALUE_STACK_INITIAL_CAPA,\n    JSON_ParserState _state = {\n        .cursor = RSTRING_PTR(Vsource),\n        .end = RSTRING_END(Vsource),\n        .stack = &stack,\n    JSON_ParserState *state = &_state;\n    VALUE result = json_parse_any(state, config);\n    rvalue_stack_eagerly_release(state->stack_handle);\n    json_ensure_eof(state);\nstatic VALUE cParserConfig_parse(VALUE self, VALUE Vsource)\n    GET_PARSER_CONFIG;\n    return cParser_parse(config, Vsource);\nstatic VALUE cParser_m_parse(VALUE klass, VALUE Vsource, VALUE opts)\n    Vsource = convert_encoding(StringValue(Vsource));\n    StringValue(Vsource);\n    JSON_ParserConfig _config = {0};\n    JSON_ParserConfig *config = &_config;\n    parser_config_init(config, opts);\n    return cParser_parse(config, Vsource);\n\n```",
        "output": "BENIGN",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "RealWorld",
        "project": "ruby/json"
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int parse_sid(struct smb_sid *psid, char *end_of_acl)\n\tif (!psid->num_subauth)\n\t\treturn 0;\n\tif (psid->num_subauth > SID_MAX_SUB_AUTHORITIES ||\n\t    end_of_acl < (char *)psid + 8 + sizeof(__le32) * psid->num_subauth)\n\tif (pntsd->osidoffset) {\n\t\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22038",
        "cwe": "CWE-125",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tmemset(entity, 0, sizeof(struct drm_sched_entity));\n\tRCU_INIT_POINTER(entity->last_scheduled, NULL);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21995",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tret = spi_nor_write_enable(nor);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21845",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tadapter->pdev = pdev;\n\terr = pcim_enable_device(pdev);\n\terr = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, adapter);\n\tif (!adapter->init_wq) {\n\t}\n\terr = idpf_cfg_hw(adapter);\n\tdestroy_workqueue(adapter->vc_event_wq);\n\tkfree(adapter);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22065",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tstruct appleir *appleir = hid_get_drvdata(hid);\n\tif (!memcmp(data, keyrepeat, sizeof(keyrepeat))) {\n\t\tkey_down(hid, appleir, appleir->current_key);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21948",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tret = steam_send_report(steam, cmd, sizeof(cmd));\n\tret = steam_recv_report(steam, reply, sizeof(reply));\n\tstrscpy(steam->serial_no, reply + 3, sizeof(steam->serial_no));\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21923",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "torvalds/linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int pcie_bwctrl_change_speed(struct pci_dev *port, u16 target_speed, bool use_lt)\n\tret = pcie_retrain_link(port, use_lt);\n\tif (port->subordinate)\n\t\tpcie_update_link_speed(port->subordinate);\n\t\t\t  bool use_lt)\n\t\tret = pcie_bwctrl_change_speed(port, target_speed, use_lt);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22031",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\terr = kfd_queue_buffer_get(vm, properties->write_ptr, &properties->wptr_bo, PAGE_SIZE);\n\terr = kfd_queue_buffer_get(vm, properties->read_ptr, &properties->rptr_bo, PAGE_SIZE);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21940",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tfree_extent_map(split);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21879",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\twritel(intr_enable, cdns_xspi->iobase + CDNS_XSPI_INTR_ENABLE_REG);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22067",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tstruct appleir *appleir = hid_get_drvdata(hid);\n\tif (!memcmp(data, keyrepeat, sizeof(keyrepeat))) {\n\t\tkey_down(hid, appleir, appleir->current_key);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21948",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int veml6075_read_comp(struct veml6075_data *data, int *c1, int *c2)\n\tret = regmap_read(data->regmap, VEML6075_CMD_COMP1, c1);\n\tret = veml6075_read_comp(data, &c1, &c2);\n\t\t*val = veml6075_uva_comp(*val, c1, c2);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-40114",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tfor (i = 0; i < ci->devcount; i++) {\n\t\tif (!dev) {\n\t\t}\n\t\tlp = netdev_priv(dev);\n\t\tarc_printk(D_NORMAL, dev, \"%s Controls\\n\", ci->name);\n\t\tioaddr = pci_resource_start(pdev, cm->bar) + cm->offset;\n\t\tr = devm_request_region(&pdev->dev, ioaddr, cm->size,\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tif (ci->flags & ARC_HAS_ROTARY) {\n\t\t\tdev->dev_id = (inb(priv->misc + ci->rotary) >> 4) & dev_id_mask;\n\t\t\tsnprintf(dev->name, sizeof(dev->name), \"arc%d-%d\", dev->dev_id, i);\n\t\t}\n\t\tif (arcnet_inb(ioaddr, COM20020_REG_R_STATUS) == 0xFF) {\n\t\t}\n\t\tif (com20020_check(dev)) {\n\t\t}\n\t\tret = com20020_found(dev, IRQF_SHARED);\n\t\tcard = devm_kzalloc(&pdev->dev, sizeof(struct com20020_dev),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!card) {\n\t\t}\n\t\tif (ci->flags & ARC_HAS_LED) {\n\t\t\tcard->tx_led.default_trigger = devm_kasprintf(&pdev->dev,\n\t\t\t\t\t\t\tGFP_KERNEL, \"arc%d-%d-tx\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->tx_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->recon_led.default_trigger = devm_kasprintf(&pdev->dev,\n\t\t\t\t\t\t\tGFP_KERNEL, \"arc%d-%d-recon\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->recon_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tret = devm_led_classdev_register(&pdev->dev, &card->tx_led);\n\t\t\tdevm_arcnet_led_init(dev, dev->dev_id, i);\n\t\t}\n\t}\n\tif (ret)\n\t\tcom20020pci_remove(pdev);\nstatic void com20020pci_remove(struct pci_dev *pdev)\n\tpriv = pci_get_drvdata(pdev);\n\tlist_for_each_entry_safe(card, tmpcard, &priv->list_dev, list) {\n\t\tstruct net_device *dev = card->dev;\n\t\tunregister_netdev(dev);\n\t\tfree_irq(dev->irq, dev);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22054",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tfree_extent_map(em);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21879",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline u8 freq_to_perf(struct amd_cpudata *cpudata, unsigned int freq_val)\n\tu8 perf_val = DIV_ROUND_UP_ULL((u64)freq_val * cpudata->nominal_perf,\n\treturn clamp_t(u8, perf_val, cpudata->lowest_perf, cpudata->highest_perf);\nstatic inline u32 perf_to_freq(struct amd_cpudata *cpudata, u8 perf_val)\n\treturn DIV_ROUND_UP_ULL((u64)cpudata->nominal_freq * perf_val,\n\t\t\t      u8 des_perf, u8 max_perf, bool fast_switch, int gov_flags)\n\tdes_perf = clamp_t(u8, des_perf, min_perf, max_perf);\n\tpolicy->cur = perf_to_freq(cpudata, des_perf);\n\tdes_perf = freq_to_perf(cpudata, target_freq);\n\tamd_pstate_update(cpudata, cpudata->min_limit_perf, des_perf,\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-23137",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void nvmet_async_events_free(struct nvmet_ctrl *ctrl)\n\tmutex_lock(&ctrl->lock);\n\tmutex_unlock(&ctrl->lock);\nvoid nvmet_stop_keep_alive_timer(struct nvmet_ctrl *ctrl)\n\tif (unlikely(ctrl->kato == 0))\n\t\treturn;\n\tlist_del(&ctrl->subsys_entry);\n\tnvmet_stop_keep_alive_timer(ctrl);\n\tflush_work(&ctrl->async_event_work);\n\tnvmet_destroy_auth(ctrl);\n\tnvmet_debugfs_ctrl_free(ctrl);\n\tida_free(&cntlid_ida, ctrl->cntlid);\n\tnvmet_async_events_free(ctrl);\n\tkfree(ctrl->sqs);\n\tkfree(ctrl);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21850",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```json_eat_whitespace(JSON_ParserState *state)\n    while (state->cursor < state->end && RB_UNLIKELY(whitespace[(unsigned char)*state->cursor])) {\n    }\nstatic inline VALUE json_decode_string(JSON_ParserState *state, JSON_ParserConfig *config, const char *start, const char *end, bool escaped, bool is_name)\n    if (escaped) {\n        string = json_string_unescape(state, start, end, is_name, intern, symbolize);\n    } else {\nstatic inline VALUE json_parse_string(JSON_ParserState *state, JSON_ParserConfig *config, bool is_name)\n    state->cursor++;\n    const char *start = state->cursor;\n    while (state->cursor < state->end) {\n        if (RB_UNLIKELY(string_scan[(unsigned char)*state->cursor])) {\n                    VALUE string = json_decode_string(state, config, start, state->cursor, escaped, is_name);\n        }\n    }\nstatic VALUE json_parse_any(JSON_ParserState *state, JSON_ParserConfig *config)\n    json_eat_whitespace(state);\n    if (state->cursor >= state->end) {\n        raise_parse_error(\"unexpected end of input\", state->cursor);\n    }\n            state->cursor++;\n            json_eat_whitespace(state);\n            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n            } else {\n                state->current_nesting++;\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                }\n                json_parse_any(state, config);\n            }\n            while (true) {\n                if (state->cursor < state->end) {\n                    if (*state->cursor == ',') {\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == ']')) {\n                            }\n                        }\n                        json_parse_any(state, config);\n                    }\n                }\n            }\n            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n            } else {\n                if (RB_UNLIKELY(config->max_nesting && (config->max_nesting < state->current_nesting))) {\n                    rb_raise(eNestingError, \"nesting of %d is too deep\", state->current_nesting);\n                }\n                json_parse_string(state, config, true);\n                json_eat_whitespace(state);\n                if ((state->cursor >= state->end) || (*state->cursor != ':')) {\n                    raise_parse_error(\"expected ':' after object key\", state->cursor);\n                }\n                state->cursor++;\n                json_parse_any(state, config);\n            }\n            while (true) {\n                json_eat_whitespace(state);\n                if (state->cursor < state->end) {\n                    }\n                    if (*state->cursor == ',') {\n                        state->cursor++;\n                        if (config->allow_trailing_comma) {\n                            if ((state->cursor < state->end) && (*state->cursor == '}')) {\n                            }\n                        }\n                        json_parse_string(state, config, true);\n                    }\n                raise_parse_error(\"expected ',' or '}' after object value, got: '%s'\", state->cursor);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-27788",
        "cwe": "CWE-125",
        "dataset": "CVE2025",
        "project": "ruby/json",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int parse_sid(struct smb_sid *psid, char *end_of_acl)\n\tif (end_of_acl < (char *)psid + 8) {\n\t}\n\tif (psid->num_subauth > SID_MAX_SUB_AUTHORITIES ||\n\t    end_of_acl < (char *)psid + 8 + sizeof(__le32) * psid->num_subauth)\n\tif (pntsd->gsidoffset) {\n\t\trc = parse_sid(group_sid_ptr, end_of_acl);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22038",
        "cwe": "CWE-125",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tinit_completion(&entity->entity_idle);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21995",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tmemset(entity, 0, sizeof(struct drm_sched_entity));\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21995",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static inline struct device *ms_dev(struct rtsx_usb_ms *host)\nstatic int ms_transfer_data(struct rtsx_usb_ms *host, unsigned char data_dir,\n\tstruct rtsx_ucr *ucr = host->ucr;\nstatic int ms_read_bytes(struct rtsx_usb_ms *host, u8 tpc,\n\tstruct rtsx_ucr *ucr = host->ucr;\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\n\tfor (i = 0; i < cnt - 1; i++)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\n\tif (cnt % 2)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + cnt, 0, 0);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (err)\n\t\treturn err;\nstatic int rtsx_usb_ms_issue_cmd(struct rtsx_usb_ms *host)\n\tstruct memstick_request *req = host->req;\n\tdev_dbg(ms_dev(host), \"%s\\n\", __func__);\n\tif (req->need_card_int) {\n\t\tif (host->ifmode != MEMSTICK_SERIAL)\n\t\t\tcfg = WAIT_INT;\n\t}\n\tif (req->long_data) {\n\t\terr = ms_transfer_data(host, req->data_dir,\n\t} else {\n\t\tif (req->data_dir == READ)\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\telse\n\t\t\terr = ms_write_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t}\n\tif (req->need_card_int) {\n\t\tif (host->ifmode == MEMSTICK_SERIAL) {\n\t\t\terr = ms_read_bytes(host, MS_TPC_GET_INT,\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t}\n\tif (!host->req) {\n\t\tdo {\n\t\t\tif (!rc) {\n\t\t\t\telse\n\t\t\t\t\thost->req->error =\n\t\t\t\t\t\trtsx_usb_ms_issue_cmd(host);\n\t\t\t\t\t\thost->req->error);\n\t\t\t}\n\t\t} while (!rc);\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22020",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static __be32 nfsacld_proc_setacl(struct svc_rqst *rqstp)\n\tstruct nfsd3_setaclargs *argp = rqstp->rq_argp;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tinode = d_inode(fh->fh_dentry);\n\terror = fh_want_write(fh);\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_ACCESS,\n\terror = set_posix_acl(&nop_mnt_idmap, fh->fh_dentry, ACL_TYPE_DEFAULT,\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21796",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t\tstruct mlx5hws_cmd_rtc_create_attr *rtc_attr,\nstatic int hws_matcher_create_rtc(struct mlx5hws_matcher *matcher,\n\tstruct mlx5hws_match_template *mt = matcher->mt;\n\t\trtc_attr.is_frst_jumbo = mlx5hws_matcher_mt_is_jumbo(mt);\n\t\tif (attr->insert_mode == MLX5HWS_MATCHER_INSERT_BY_HASH) {\n\t\t\trtc_attr.match_definer_0 = mlx5hws_definer_get_id(mt->definer);\n\t\t} else if (attr->insert_mode == MLX5HWS_MATCHER_INSERT_BY_INDEX) {\n\thws_matcher_set_rtc_attr_sz(matcher, &rtc_attr, rtc_type, false);\n\tret = mlx5hws_cmd_rtc_create(ctx->mdev, &rtc_attr, rtc_0_id);\n\tret = hws_matcher_create_rtc(matcher, HWS_MATCHER_RTC_TYPE_MATCH, 0);\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-21751",
        "cwe": "CWE-416",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tfor (i = 0; i < NUM_NL80211_IFTYPES; i++) {\n\t\the_mcs->rx_mcs_80 = cpu_to_le16(mcs_map);\n\t\the_mcs->tx_mcs_80 = cpu_to_le16(mcs_map);\n\t\tif (is_mt7922(phy->mt76->dev)) {\n\t\t\the_mcs->rx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t\the_mcs->tx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t}\n\t}\n\n```",
        "output": "VULNERABLE",
        "cve": "CVE-2025-22032",
        "cwe": "",
        "dataset": "CVE2025",
        "project": "linux",
        "predicted": ""
    }
]