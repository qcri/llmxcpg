[
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\n                          const void * pvTxData,\n                          size_t xDataLengthBytes,\n                          TickType_t xTicksToWait )\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReturn, xSpace = 0;\n    size_t xRequiredSpace = xDataLengthBytes;\n    const size_t xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;\n    configASSERT( pvTxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\n        configASSERT( xRequiredSpace > xDataLengthBytes );\n        if( xRequiredSpace > xMaxReportedSpace )\n            xTicksToWait = ( TickType_t ) 0;\n    else\n        if( xRequiredSpace > xMaxReportedSpace )\n            xRequiredSpace = xMaxReportedSpace;\n        }\n    if( xTicksToWait != ( TickType_t ) 0 )\n        vTaskSetTimeOutState( &xTimeOut );\n        do\n                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n                if( xSpace < xRequiredSpace )\n                    ( void ) xTaskNotifyStateClear( NULL );\n                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\n            pxStreamBuffer->xTaskWaitingToSend = NULL;\n        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );\n    }\n    if( xSpace == ( size_t ) 0 )\n        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\n                                 const void * pvTxData,\n                                 size_t xDataLengthBytes,\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xRequiredSpace = xDataLengthBytes;\n    configASSERT( pvTxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                       const void * pvTxData,\n                                       size_t xDataLengthBytes,\n                                       size_t xSpace,\n    if( xSpace == ( size_t ) 0 )\n    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )\n        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );\n    else if( xSpace >= xRequiredSpace )\n        ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); \nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                     const uint8_t * pucData,\n                                     size_t xCount )\n    configASSERT( xCount > ( size_t ) 0 );\n    xNextHead = pxStreamBuffer->xHead;\n    xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );\n    configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );\n    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); \n    if( xCount > xFirstLength )\n        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );\n        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); \n    xNextHead += xCount;\n    if( xNextHead >= pxStreamBuffer->xLength )\n        xNextHead -= pxStreamBuffer->xLength;\n    pxStreamBuffer->xHead = xNextHead;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdint.h>\n#include <string.h>\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"stream_buffer.h\"\n#if ( configUSE_TASK_NOTIFICATIONS != 1 )\n    #error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c\n#endif\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE \n#ifndef sbRECEIVE_COMPLETED\n    #define sbRECEIVE_COMPLETED( pxStreamBuffer )                         \\\n    vTaskSuspendAll();                                                    \\\n    {                                                                     \\\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )              \\\n        {                                                                 \\\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, \\\n                                  ( uint32_t ) 0,                         \\\n                                  eNoAction );                            \\\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                \\\n        }                                                                 \\\n    }                                                                     \\\n    ( void ) xTaskResumeAll();\n#endif \n#ifndef sbRECEIVE_COMPLETED_FROM_ISR\n    #define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                            \\\n                                          pxHigherPriorityTaskWoken )                \\\n    {                                                                                \\\n        UBaseType_t uxSavedInterruptStatus;                                          \\\n                                                                                     \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();  \\\n        {                                                                            \\\n            if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )                     \\\n            {                                                                        \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, \\\n                                             ( uint32_t ) 0,                         \\\n                                             eNoAction,                              \\\n                                             pxHigherPriorityTaskWoken );            \\\n                ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                       \\\n            }                                                                        \\\n        }                                                                            \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                 \\\n    }\n#endif \n#ifndef sbSEND_COMPLETED\n    #define sbSEND_COMPLETED( pxStreamBuffer )                               \\\n    vTaskSuspendAll();                                                       \\\n    {                                                                        \\\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )              \\\n        {                                                                    \\\n            ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\n                                  ( uint32_t ) 0,                            \\\n                                  eNoAction );                               \\\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                \\\n        }                                                                    \\\n    }                                                                        \\\n    ( void ) xTaskResumeAll();\n#endif \n#ifndef sbSEND_COMPLETE_FROM_ISR\n    #define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \\\n    {                                                                                   \\\n        UBaseType_t uxSavedInterruptStatus;                                             \\\n                                                                                        \\\n        uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \\\n        {                                                                               \\\n            if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \\\n            {                                                                           \\\n                ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\n                                             ( uint32_t ) 0,                            \\\n                                             eNoAction,                                 \\\n                                             pxHigherPriorityTaskWoken );               \\\n                ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \\\n            }                                                                           \\\n        }                                                                               \\\n        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \\\n    }\n#endif \n#define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )\n#define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) \n#define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) \ntypedef struct StreamBufferDef_t                 \n{\n    volatile size_t xTail;                       \n    volatile size_t xHead;                       \n    size_t xLength;                              \n    size_t xTriggerLevelBytes;                   \n    volatile TaskHandle_t xTaskWaitingToReceive; \n    volatile TaskHandle_t xTaskWaitingToSend;    \n    uint8_t * pucBuffer;                         \n    uint8_t ucFlags;\n    #if ( configUSE_TRACE_FACILITY == 1 )\n        UBaseType_t uxStreamBufferNumber; \n    #endif\n} StreamBuffer_t;\nstatic size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                     const uint8_t * pucData,\n                                     size_t xCount ) PRIVILEGED_FUNCTION;\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\n                                        void * pvRxData,\n                                        size_t xBufferLengthBytes,\n                                        size_t xBytesAvailable,\n                                        size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                       const void * pvTxData,\n                                       size_t xDataLengthBytes,\n                                       size_t xSpace,\n                                       size_t xRequiredSpace ) PRIVILEGED_FUNCTION;\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\n                                      uint8_t * pucData,\n                                      size_t xMaxCount,\n                                      size_t xBytesAvailable ) PRIVILEGED_FUNCTION;\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                          uint8_t * const pucBuffer,\n                                          size_t xBufferSizeBytes,\n                                          size_t xTriggerLevelBytes,\n                                          uint8_t ucFlags ) PRIVILEGED_FUNCTION;\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }\n#endif \n#if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n    StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,\n                                                           size_t xTriggerLevelBytes,\n                                                           BaseType_t xIsMessageBuffer,\n                                                           uint8_t * const pucStreamBufferStorageArea,\n                                                           StaticStreamBuffer_t * const pxStaticStreamBuffer )\n    {\n        StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; \n        StreamBufferHandle_t xReturn;\n        uint8_t ucFlags;\n        configASSERT( pucStreamBufferStorageArea );\n        configASSERT( pxStaticStreamBuffer );\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        if( xIsMessageBuffer != pdFALSE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;\n        }\n        else\n        {\n            ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;\n        }\n        configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        #if ( configASSERT_DEFINED == 1 )\n            {\n                volatile size_t xSize = sizeof( StaticStreamBuffer_t );\n                configASSERT( xSize == sizeof( StreamBuffer_t ) );\n            } \n        #endif \n        if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )\n        {\n            prvInitialiseNewStreamBuffer( pxStreamBuffer,\n                                          pucStreamBufferStorageArea,\n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;\n            traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );\n            xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; \n        }\n        else\n        {\n            xReturn = NULL;\n            traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );\n        }\n        return xReturn;\n    }\n#endif \nvoid vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )\n{\n    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;\n    configASSERT( pxStreamBuffer );\n    traceSTREAM_BUFFER_DELETE( xStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )\n    {\n        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n            {\n                vPortFree( ( void * ) pxStreamBuffer ); \n            }\n        #else\n            {\n                configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );\n            }\n        #endif\n    }\n    else\n    {\n        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );\n    }\n}\nBaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    BaseType_t xReturn = pdFAIL;\n    #if ( configUSE_TRACE_FACILITY == 1 )\n        UBaseType_t uxStreamBufferNumber;\n    #endif\n    configASSERT( pxStreamBuffer );\n    #if ( configUSE_TRACE_FACILITY == 1 )\n        {\n            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;\n        }\n    #endif\n    taskENTER_CRITICAL();\n    {\n        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )\n        {\n            if( pxStreamBuffer->xTaskWaitingToSend == NULL )\n            {\n                prvInitialiseNewStreamBuffer( pxStreamBuffer,\n                                              pxStreamBuffer->pucBuffer,\n                                              pxStreamBuffer->xLength,\n                                              pxStreamBuffer->xTriggerLevelBytes,\n                                              pxStreamBuffer->ucFlags );\n                xReturn = pdPASS;\n                #if ( configUSE_TRACE_FACILITY == 1 )\n                    {\n                        pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\n                    }\n                #endif\n                traceSTREAM_BUFFER_RESET( xStreamBuffer );\n            }\n        }\n    }\n    taskEXIT_CRITICAL();\n    return xReturn;\n}\nsize_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,\n                          const void * pvTxData,\n                          size_t xDataLengthBytes,\n                          TickType_t xTicksToWait )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReturn, xSpace = 0;\n    size_t xRequiredSpace = xDataLengthBytes;\n    TimeOut_t xTimeOut;\n    const size_t xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;\n    configASSERT( pvTxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\n        configASSERT( xRequiredSpace > xDataLengthBytes );\n        if( xRequiredSpace > xMaxReportedSpace )\n        {\n            xTicksToWait = ( TickType_t ) 0;\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        if( xRequiredSpace > xMaxReportedSpace )\n        {\n            xRequiredSpace = xMaxReportedSpace;\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    if( xTicksToWait != ( TickType_t ) 0 )\n    {\n        vTaskSetTimeOutState( &xTimeOut );\n        do\n        {\n            taskENTER_CRITICAL();\n            {\n                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n                if( xSpace < xRequiredSpace )\n                {\n                    ( void ) xTaskNotifyStateClear( NULL );\n                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );\n                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();\n                }\n                else\n                {\n                    taskEXIT_CRITICAL();\n                    break;\n                }\n            }\n            taskEXIT_CRITICAL();\n            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\n            pxStreamBuffer->xTaskWaitingToSend = NULL;\n        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    if( xSpace == ( size_t ) 0 )\n    {\n        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\n    if( xReturn > ( size_t ) 0 )\n    {\n        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\n        {\n            sbSEND_COMPLETED( pxStreamBuffer );\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );\n    }\n    return xReturn;\n}\nsize_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,\n                                 const void * pvTxData,\n                                 size_t xDataLengthBytes,\n                                 BaseType_t * const pxHigherPriorityTaskWoken )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReturn, xSpace;\n    size_t xRequiredSpace = xDataLengthBytes;\n    configASSERT( pvTxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );\n    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );\n    if( xReturn > ( size_t ) 0 )\n    {\n        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )\n        {\n            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );\n    return xReturn;\n}\nstatic size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                       const void * pvTxData,\n                                       size_t xDataLengthBytes,\n                                       size_t xSpace,\n                                       size_t xRequiredSpace )\n{\n    BaseType_t xShouldWrite;\n    size_t xReturn;\n    if( xSpace == ( size_t ) 0 )\n    {\n        xShouldWrite = pdFALSE;\n    }\n    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )\n    {\n        xShouldWrite = pdTRUE;\n        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );\n    }\n    else if( xSpace >= xRequiredSpace )\n    {\n        xShouldWrite = pdTRUE;\n        ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );\n    }\n    else\n    {\n        xShouldWrite = pdFALSE;\n    }\n    if( xShouldWrite != pdFALSE )\n    {\n        xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); \n    }\n    else\n    {\n        xReturn = 0;\n    }\n    return xReturn;\n}\nsize_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,\n                             void * pvRxData,\n                             size_t xBufferLengthBytes,\n                             TickType_t xTicksToWait )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\n    configASSERT( pvRxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n    }\n    else\n    {\n        xBytesToStoreMessageLength = 0;\n    }\n    if( xTicksToWait != ( TickType_t ) 0 )\n    {\n        taskENTER_CRITICAL();\n        {\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n            if( xBytesAvailable <= xBytesToStoreMessageLength )\n            {\n                ( void ) xTaskNotifyStateClear( NULL );\n                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );\n                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n        taskEXIT_CRITICAL();\n        if( xBytesAvailable <= xBytesToStoreMessageLength )\n        {\n            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );\n            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );\n            pxStreamBuffer->xTaskWaitingToReceive = NULL;\n            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n    }\n    if( xBytesAvailable > xBytesToStoreMessageLength )\n    {\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\n        if( xReceivedLength != ( size_t ) 0 )\n        {\n            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );\n            sbRECEIVE_COMPLETED( pxStreamBuffer );\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );\n        mtCOVERAGE_TEST_MARKER();\n    }\n    return xReceivedLength;\n}\nsize_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReturn, xBytesAvailable, xOriginalTail;\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )\n        {\n            xOriginalTail = pxStreamBuffer->xTail;\n            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );\n            xReturn = ( size_t ) xTempReturn;\n            pxStreamBuffer->xTail = xOriginalTail;\n        }\n        else\n        {\n            configASSERT( xBytesAvailable == 0 );\n            xReturn = 0;\n        }\n    }\n    else\n    {\n        xReturn = 0;\n    }\n    return xReturn;\n}\nsize_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,\n                                    void * pvRxData,\n                                    size_t xBufferLengthBytes,\n                                    BaseType_t * const pxHigherPriorityTaskWoken )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;\n    configASSERT( pvRxData );\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n    }\n    else\n    {\n        xBytesToStoreMessageLength = 0;\n    }\n    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );\n    if( xBytesAvailable > xBytesToStoreMessageLength )\n    {\n        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );\n        if( xReceivedLength != ( size_t ) 0 )\n        {\n            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );\n    return xReceivedLength;\n}\nstatic size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,\n                                        void * pvRxData,\n                                        size_t xBufferLengthBytes,\n                                        size_t xBytesAvailable,\n                                        size_t xBytesToStoreMessageLength )\n{\n    size_t xOriginalTail, xReceivedLength, xNextMessageLength;\n    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;\n    if( xBytesToStoreMessageLength != ( size_t ) 0 )\n    {\n        xOriginalTail = pxStreamBuffer->xTail;\n        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );\n        xNextMessageLength = ( size_t ) xTempNextMessageLength;\n        xBytesAvailable -= xBytesToStoreMessageLength;\n        if( xNextMessageLength > xBufferLengthBytes )\n        {\n            pxStreamBuffer->xTail = xOriginalTail;\n            xNextMessageLength = 0;\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n    }\n    else\n    {\n        xNextMessageLength = xBufferLengthBytes;\n    }\n    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); \n    return xReceivedLength;\n}\nBaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )\n{\n    BaseType_t xReturn;\n    size_t xBytesToStoreMessageLength;\n    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    configASSERT( pxStreamBuffer );\n    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )\n    {\n        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;\n    }\n    else\n    {\n        xBytesToStoreMessageLength = 0;\n    }\n    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )\n    {\n        xReturn = pdTRUE;\n    }\n    else\n    {\n        xReturn = pdFALSE;\n    }\n    return xReturn;\n}\nBaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\n                                              BaseType_t * pxHigherPriorityTaskWoken )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    BaseType_t xReturn;\n    UBaseType_t uxSavedInterruptStatus;\n    configASSERT( pxStreamBuffer );\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\n    {\n        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )\n        {\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,\n                                         ( uint32_t ) 0,\n                                         eNoAction,\n                                         pxHigherPriorityTaskWoken );\n            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;\n            xReturn = pdTRUE;\n        }\n        else\n        {\n            xReturn = pdFALSE;\n        }\n    }\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n    return xReturn;\n}\nBaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,\n                                                 BaseType_t * pxHigherPriorityTaskWoken )\n{\n    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;\n    BaseType_t xReturn;\n    UBaseType_t uxSavedInterruptStatus;\n    configASSERT( pxStreamBuffer );\n    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();\n    {\n        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )\n        {\n            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,\n                                         ( uint32_t ) 0,\n                                         eNoAction,\n                                         pxHigherPriorityTaskWoken );\n            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;\n            xReturn = pdTRUE;\n        }\n        else\n        {\n            xReturn = pdFALSE;\n        }\n    }\n    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );\n    return xReturn;\n}\nstatic size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                     const uint8_t * pucData,\n                                     size_t xCount )\n{\n    size_t xNextHead, xFirstLength;\n    configASSERT( xCount > ( size_t ) 0 );\n    xNextHead = pxStreamBuffer->xHead;\n    xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );\n    configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );\n    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); \n    if( xCount > xFirstLength )\n    {\n        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );\n        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); \n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    xNextHead += xCount;\n    if( xNextHead >= pxStreamBuffer->xLength )\n    {\n        xNextHead -= pxStreamBuffer->xLength;\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    pxStreamBuffer->xHead = xNextHead;\n    return xCount;\n}\nstatic size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,\n                                      uint8_t * pucData,\n                                      size_t xMaxCount,\n                                      size_t xBytesAvailable )\n{\n    size_t xCount, xFirstLength, xNextTail;\n    xCount = configMIN( xBytesAvailable, xMaxCount );\n    if( xCount > ( size_t ) 0 )\n    {\n        xNextTail = pxStreamBuffer->xTail;\n        xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );\n        configASSERT( xFirstLength <= xMaxCount );\n        configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );\n        ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); \n        if( xCount > xFirstLength )\n        {\n            configASSERT( xCount <= xMaxCount );\n            ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); \n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n        xNextTail += xCount;\n        if( xNextTail >= pxStreamBuffer->xLength )\n        {\n            xNextTail -= pxStreamBuffer->xLength;\n        }\n        pxStreamBuffer->xTail = xNextTail;\n    }\n    else\n    {\n        mtCOVERAGE_TEST_MARKER();\n    }\n    return xCount;\n}\nstatic void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,\n                                          uint8_t * const pucBuffer,\n                                          size_t xBufferSizeBytes,\n                                          size_t xTriggerLevelBytes,\n                                          uint8_t ucFlags )\n{\n    #if ( configASSERT_DEFINED == 1 )\n        {\n            const BaseType_t xWriteValue = 0x55;\n            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );\n        } \n    #endif\n    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); \n    pxStreamBuffer->pucBuffer = pucBuffer;\n    pxStreamBuffer->xLength = xBufferSizeBytes;\n    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;\n    pxStreamBuffer->ucFlags = ucFlags;\n}\n#if ( configUSE_TRACE_FACILITY == 1 )\n    UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )\n    {\n        return xStreamBuffer->uxStreamBufferNumber;\n    }\n#endif \n#if ( configUSE_TRACE_FACILITY == 1 )\n    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,\n                                             UBaseType_t uxStreamBufferNumber )\n    {\n        xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;\n    }\n#endif \n#if ( configUSE_TRACE_FACILITY == 1 )\n    uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )\n    {\n        return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );\n    }\n#endif \n",
        "cwe": "CWE-190",
        "file_name": "vul_respovul_idx_5707.c",
        "project": "freertos/freertos-kernel",
        "url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```                               OPJ_BYTE *p_src,\n    OPJ_BYTE *l_current_data = p_src;\n    for (pino = 0; pino <= l_tcp->numpocs; ++pino) {\n        while (opj_pi_next(l_current_pi)) {\n            } else {\n            }\n            if (!skip_packet) {\n                l_nb_bytes_read = 0;\n                if (! opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,\n                                           &l_nb_bytes_read, p_max_len, l_pack_info, p_manager)) {\n            } else {\n                l_nb_bytes_read = 0;\n                if (! opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,\n                                         &l_nb_bytes_read, p_max_len, l_pack_info, p_manager)) {\n            }\n            l_current_data += l_nb_bytes_read;\n        }\n    }\n                                     OPJ_BYTE *p_src,\n    OPJ_UINT32 l_nb_bytes_read = 0;\n    if (! opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, &l_read_data, p_src,\n                                    &l_nb_bytes_read, p_max_length, p_pack_info, p_manager)) {\n    p_src += l_nb_bytes_read;\n    if (l_read_data) {\n        if (! opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, &l_nb_bytes_read,\n                                      p_max_length, p_pack_info, p_manager)) {\n    }\n                                        OPJ_BYTE *p_src_data,\n    OPJ_BYTE *l_current_data = p_src_data;\n    for (bandno = 0; bandno < l_res->numbands; ++bandno) {\n        l_cblk = l_prc->cblks.dec;\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n            if (!l_cblk->numnewpasses) {\n                ++l_cblk;\n            }\n            if (!l_cblk->numsegs) {\n                l_seg = l_cblk->segs;\n                ++l_cblk->numsegs;\n            } else {\n                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];\n                if (l_seg->numpasses == l_seg->maxpasses) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            }\n            do {\n                if ((((OPJ_SIZE_T)l_current_data + (OPJ_SIZE_T)l_seg->newlen) <\n                        (OPJ_SIZE_T)l_current_data) ||\n                        (l_current_data + l_seg->newlen > p_src_data + p_max_length)) {\n                if (l_cblk->numchunks == l_cblk->numchunksalloc) {\n                    OPJ_UINT32 l_numchunksalloc = l_cblk->numchunksalloc * 2 + 1;\n                    opj_tcd_seg_data_chunk_t* l_chunks =\n                        (opj_tcd_seg_data_chunk_t*)opj_realloc(l_cblk->chunks,\n                                l_numchunksalloc * sizeof(opj_tcd_seg_data_chunk_t));\n                    if (l_chunks == NULL) {\n                    }\n                    l_cblk->chunks = l_chunks;\n                    l_cblk->numchunksalloc = l_numchunksalloc;\n                }\n                l_cblk->chunks[l_cblk->numchunks].data = l_current_data;\n                l_cblk->chunks[l_cblk->numchunks].len = l_seg->newlen;\n                l_cblk->numchunks ++;\n                l_current_data += l_seg->newlen;\n                l_seg->len += l_seg->newlen;\n                l_seg->numpasses += l_seg->numnewpasses;\n                l_cblk->numnewpasses -= l_seg->numnewpasses;\n                l_seg->real_num_passes = l_seg->numpasses;\n                if (l_cblk->numnewpasses > 0) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            } while (l_cblk->numnewpasses > 0);\n            l_cblk->real_num_segs = l_cblk->numsegs;\n            ++l_cblk;\n        } \n    }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"opj_includes.h\"\n#include \"opj_common.h\"\nstatic void opj_t2_putcommacode(opj_bio_t *bio, OPJ_INT32 n);\nstatic OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio);\nstatic void opj_t2_putnumpasses(opj_bio_t *bio, OPJ_UINT32 n);\nstatic OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio);\nstatic OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,\n                                     opj_tcd_tile_t *tile,\n                                     opj_tcp_t *tcp,\n                                     opj_pi_iterator_t *pi,\n                                     OPJ_BYTE *dest,\n                                     OPJ_UINT32 * p_data_written,\n                                     OPJ_UINT32 len,\n                                     opj_codestream_info_t *cstr_info,\n                                     J2K_T2_MODE p_t2_mode,\n                                     opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_decode_packet(opj_t2_t* t2,\n                                     opj_tcd_tile_t *tile,\n                                     opj_tcp_t *tcp,\n                                     opj_pi_iterator_t *pi,\n                                     OPJ_BYTE *src,\n                                     OPJ_UINT32 * data_read,\n                                     OPJ_UINT32 max_length,\n                                     opj_packet_info_t *pack_info,\n                                     opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_skip_packet(opj_t2_t* p_t2,\n                                   opj_tcd_tile_t *p_tile,\n                                   opj_tcp_t *p_tcp,\n                                   opj_pi_iterator_t *p_pi,\n                                   OPJ_BYTE *p_src,\n                                   OPJ_UINT32 * p_data_read,\n                                   OPJ_UINT32 p_max_length,\n                                   opj_packet_info_t *p_pack_info,\n                                   opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_read_packet_header(opj_t2_t* p_t2,\n        opj_tcd_tile_t *p_tile,\n        opj_tcp_t *p_tcp,\n        opj_pi_iterator_t *p_pi,\n        OPJ_BOOL * p_is_data_present,\n        OPJ_BYTE *p_src_data,\n        OPJ_UINT32 * p_data_read,\n        OPJ_UINT32 p_max_length,\n        opj_packet_info_t *p_pack_info,\n        opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_read_packet_data(opj_t2_t* p_t2,\n                                        opj_tcd_tile_t *p_tile,\n                                        opj_pi_iterator_t *p_pi,\n                                        OPJ_BYTE *p_src_data,\n                                        OPJ_UINT32 * p_data_read,\n                                        OPJ_UINT32 p_max_length,\n                                        opj_packet_info_t *pack_info,\n                                        opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t* p_t2,\n                                        opj_tcd_tile_t *p_tile,\n                                        opj_pi_iterator_t *p_pi,\n                                        OPJ_UINT32 * p_data_read,\n                                        OPJ_UINT32 p_max_length,\n                                        opj_packet_info_t *pack_info,\n                                        opj_event_mgr_t *p_manager);\nstatic OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t* cblk,\n                                OPJ_UINT32 index,\n                                OPJ_UINT32 cblksty,\n                                OPJ_UINT32 first);\nstatic void opj_t2_putcommacode(opj_bio_t *bio, OPJ_INT32 n)\n{\n    while (--n >= 0) {\n        opj_bio_write(bio, 1, 1);\n    }\n    opj_bio_write(bio, 0, 1);\n}\nstatic void opj_t2_putnumpasses(opj_bio_t *bio, OPJ_UINT32 n)\n{\n    if (n == 1) {\n        opj_bio_write(bio, 0, 1);\n    } else if (n == 2) {\n        opj_bio_write(bio, 2, 2);\n    } else if (n <= 5) {\n        opj_bio_write(bio, 0xc | (n - 3), 4);\n    } else if (n <= 36) {\n        opj_bio_write(bio, 0x1e0 | (n - 6), 9);\n    } else if (n <= 164) {\n        opj_bio_write(bio, 0xff80 | (n - 37), 16);\n    }\n}\nOPJ_BOOL opj_t2_encode_packets(opj_t2_t* p_t2,\n                               OPJ_UINT32 p_tile_no,\n                               opj_tcd_tile_t *p_tile,\n                               OPJ_UINT32 p_maxlayers,\n                               OPJ_BYTE *p_dest,\n                               OPJ_UINT32 * p_data_written,\n                               OPJ_UINT32 p_max_len,\n                               opj_codestream_info_t *cstr_info,\n                               opj_tcd_marker_info_t* p_marker_info,\n                               OPJ_UINT32 p_tp_num,\n                               OPJ_INT32 p_tp_pos,\n                               OPJ_UINT32 p_pino,\n                               J2K_T2_MODE p_t2_mode,\n                               opj_event_mgr_t *p_manager)\n{\n    OPJ_BYTE *l_current_data = p_dest;\n    OPJ_UINT32 l_nb_bytes = 0;\n    OPJ_UINT32 compno;\n    OPJ_UINT32 poc;\n    opj_pi_iterator_t *l_pi = 00;\n    opj_pi_iterator_t *l_current_pi = 00;\n    opj_image_t *l_image = p_t2->image;\n    opj_cp_t *l_cp = p_t2->cp;\n    opj_tcp_t *l_tcp = &l_cp->tcps[p_tile_no];\n    OPJ_UINT32 pocno = (l_cp->rsiz == OPJ_PROFILE_CINEMA_4K) ? 2 : 1;\n    OPJ_UINT32 l_max_comp = l_cp->m_specific_param.m_enc.m_max_comp_size > 0 ?\n                            l_image->numcomps : 1;\n    OPJ_UINT32 l_nb_pocs = l_tcp->numpocs + 1;\n    l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);\n    if (!l_pi) {\n        return OPJ_FALSE;\n    }\n    * p_data_written = 0;\n    if (p_t2_mode == THRESH_CALC) { \n        l_current_pi = l_pi;\n        for (compno = 0; compno < l_max_comp; ++compno) {\n            OPJ_UINT32 l_comp_len = 0;\n            l_current_pi = l_pi;\n            for (poc = 0; poc < pocno ; ++poc) {\n                OPJ_UINT32 l_tp_num = compno;\n                opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);\n                if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {\n                    opj_pi_destroy(l_pi, l_nb_pocs);\n                    return OPJ_FALSE;\n                }\n                while (opj_pi_next(l_current_pi)) {\n                    if (l_current_pi->layno < p_maxlayers) {\n                        l_nb_bytes = 0;\n                        if (! opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,\n                                                   l_current_data, &l_nb_bytes,\n                                                   p_max_len, cstr_info,\n                                                   p_t2_mode,\n                                                   p_manager)) {\n                            opj_pi_destroy(l_pi, l_nb_pocs);\n                            return OPJ_FALSE;\n                        }\n                        l_comp_len += l_nb_bytes;\n                        l_current_data += l_nb_bytes;\n                        p_max_len -= l_nb_bytes;\n                        * p_data_written += l_nb_bytes;\n                    }\n                }\n                if (l_cp->m_specific_param.m_enc.m_max_comp_size) {\n                    if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {\n                        opj_pi_destroy(l_pi, l_nb_pocs);\n                        return OPJ_FALSE;\n                    }\n                }\n                ++l_current_pi;\n            }\n        }\n    } else { \n        opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos,\n                             p_t2_mode);\n        l_current_pi = &l_pi[p_pino];\n        if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {\n            opj_pi_destroy(l_pi, l_nb_pocs);\n            return OPJ_FALSE;\n        }\n        if (p_marker_info && p_marker_info->need_PLT) {\n            assert(p_marker_info->packet_count == 0);\n            assert(p_marker_info->p_packet_size == NULL);\n            p_marker_info->p_packet_size = (OPJ_UINT32*) opj_malloc(\n                                               opj_get_encoding_packet_count(l_image, l_cp, p_tile_no) * sizeof(OPJ_UINT32));\n            if (p_marker_info->p_packet_size == NULL) {\n                opj_pi_destroy(l_pi, l_nb_pocs);\n                return OPJ_FALSE;\n            }\n        }\n        while (opj_pi_next(l_current_pi)) {\n            if (l_current_pi->layno < p_maxlayers) {\n                l_nb_bytes = 0;\n                if (! opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,\n                                           l_current_data, &l_nb_bytes, p_max_len,\n                                           cstr_info, p_t2_mode, p_manager)) {\n                    opj_pi_destroy(l_pi, l_nb_pocs);\n                    return OPJ_FALSE;\n                }\n                l_current_data += l_nb_bytes;\n                p_max_len -= l_nb_bytes;\n                * p_data_written += l_nb_bytes;\n                if (p_marker_info && p_marker_info->need_PLT) {\n                    p_marker_info->p_packet_size[p_marker_info->packet_count] = l_nb_bytes;\n                    p_marker_info->packet_count ++;\n                }\n                if (cstr_info) {\n                    if (cstr_info->index_write) {\n                        opj_tile_info_t *info_TL = &cstr_info->tile[p_tile_no];\n                        opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];\n                        if (!cstr_info->packno) {\n                            info_PK->start_pos = info_TL->end_header + 1;\n                        } else {\n                            info_PK->start_pos = ((l_cp->m_specific_param.m_enc.m_tp_on | l_tcp->POC) &&\n                                                  info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno -\n                                                                            1].end_pos + 1;\n                        }\n                        info_PK->end_pos = info_PK->start_pos + l_nb_bytes - 1;\n                        info_PK->end_ph_pos += info_PK->start_pos -\n                                               1;  \n                    }\n                    cstr_info->packno++;\n                }\n                ++p_tile->packno;\n            }\n        }\n    }\n    opj_pi_destroy(l_pi, l_nb_pocs);\n    return OPJ_TRUE;\n}\n#if 0\n#define JAS_FPRINTF fprintf\n#else\n#define JAS_FPRINTF opj_null_jas_fprintf\n#endif\nOPJ_BOOL opj_t2_decode_packets(opj_tcd_t* tcd,\n                               opj_t2_t *p_t2,\n                               OPJ_UINT32 p_tile_no,\n                               opj_tcd_tile_t *p_tile,\n                               OPJ_BYTE *p_src,\n                               OPJ_UINT32 * p_data_read,\n                               OPJ_UINT32 p_max_len,\n                               opj_codestream_index_t *p_cstr_index,\n                               opj_event_mgr_t *p_manager)\n{\n    OPJ_BYTE *l_current_data = p_src;\n    opj_pi_iterator_t *l_pi = 00;\n    OPJ_UINT32 pino;\n    opj_image_t *l_image = p_t2->image;\n    opj_cp_t *l_cp = p_t2->cp;\n    opj_tcp_t *l_tcp = &(p_t2->cp->tcps[p_tile_no]);\n    OPJ_UINT32 l_nb_bytes_read;\n    OPJ_UINT32 l_nb_pocs = l_tcp->numpocs + 1;\n    opj_pi_iterator_t *l_current_pi = 00;\n#ifdef TODO_MSD\n    OPJ_UINT32 curtp = 0;\n    OPJ_UINT32 tp_start_packno;\n#endif\n    opj_packet_info_t *l_pack_info = 00;\n    opj_image_comp_t* l_img_comp = 00;\n    OPJ_ARG_NOT_USED(p_cstr_index);\n#ifdef TODO_MSD\n    if (p_cstr_index) {\n        l_pack_info = p_cstr_index->tile_index[p_tile_no].packet;\n    }\n#endif\n    l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);\n    if (!l_pi) {\n        return OPJ_FALSE;\n    }\n    l_current_pi = l_pi;\n    for (pino = 0; pino <= l_tcp->numpocs; ++pino) {\n        OPJ_BOOL* first_pass_failed = NULL;\n        if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {\n            opj_pi_destroy(l_pi, l_nb_pocs);\n            return OPJ_FALSE;\n        }\n        first_pass_failed = (OPJ_BOOL*)opj_malloc(l_image->numcomps * sizeof(OPJ_BOOL));\n        if (!first_pass_failed) {\n            opj_pi_destroy(l_pi, l_nb_pocs);\n            return OPJ_FALSE;\n        }\n        memset(first_pass_failed, OPJ_TRUE, l_image->numcomps * sizeof(OPJ_BOOL));\n        while (opj_pi_next(l_current_pi)) {\n            OPJ_BOOL skip_packet = OPJ_FALSE;\n            JAS_FPRINTF(stderr,\n                        \"packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\\n\\n\",\n                        l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,\n                        l_current_pi->precno, l_current_pi->layno);\n            if (l_current_pi->layno >= l_tcp->num_layers_to_decode) {\n                skip_packet = OPJ_TRUE;\n            }\n            else if (l_current_pi->resno >=\n                     p_tile->comps[l_current_pi->compno].minimum_num_resolutions) {\n                skip_packet = OPJ_TRUE;\n            } else {\n                OPJ_UINT32 bandno;\n                opj_tcd_tilecomp_t *tilec = &p_tile->comps[l_current_pi->compno];\n                opj_tcd_resolution_t *res = &tilec->resolutions[l_current_pi->resno];\n                skip_packet = OPJ_TRUE;\n                for (bandno = 0; bandno < res->numbands; ++bandno) {\n                    opj_tcd_band_t* band = &res->bands[bandno];\n                    opj_tcd_precinct_t* prec = &band->precincts[l_current_pi->precno];\n                    if (opj_tcd_is_subband_area_of_interest(tcd,\n                                                            l_current_pi->compno,\n                                                            l_current_pi->resno,\n                                                            band->bandno,\n                                                            (OPJ_UINT32)prec->x0,\n                                                            (OPJ_UINT32)prec->y0,\n                                                            (OPJ_UINT32)prec->x1,\n                                                            (OPJ_UINT32)prec->y1)) {\n                        skip_packet = OPJ_FALSE;\n                        break;\n                    }\n                }\n            }\n            if (!skip_packet) {\n                l_nb_bytes_read = 0;\n                first_pass_failed[l_current_pi->compno] = OPJ_FALSE;\n                if (! opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,\n                                           &l_nb_bytes_read, p_max_len, l_pack_info, p_manager)) {\n                    opj_pi_destroy(l_pi, l_nb_pocs);\n                    opj_free(first_pass_failed);\n                    return OPJ_FALSE;\n                }\n                l_img_comp = &(l_image->comps[l_current_pi->compno]);\n                l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno,\n                                            l_img_comp->resno_decoded);\n            } else {\n                l_nb_bytes_read = 0;\n                if (! opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,\n                                         &l_nb_bytes_read, p_max_len, l_pack_info, p_manager)) {\n                    opj_pi_destroy(l_pi, l_nb_pocs);\n                    opj_free(first_pass_failed);\n                    return OPJ_FALSE;\n                }\n            }\n            if (first_pass_failed[l_current_pi->compno]) {\n                l_img_comp = &(l_image->comps[l_current_pi->compno]);\n                if (l_img_comp->resno_decoded == 0) {\n                    l_img_comp->resno_decoded =\n                        p_tile->comps[l_current_pi->compno].minimum_num_resolutions - 1;\n                }\n            }\n            l_current_data += l_nb_bytes_read;\n            p_max_len -= l_nb_bytes_read;\n#ifdef TODO_MSD\n            if (p_cstr_info) {\n                opj_tile_info_v2_t *info_TL = &p_cstr_info->tile[p_tile_no];\n                opj_packet_info_t *info_PK = &info_TL->packet[p_cstr_info->packno];\n                tp_start_packno = 0;\n                if (!p_cstr_info->packno) {\n                    info_PK->start_pos = info_TL->end_header + 1;\n                } else if (info_TL->packet[p_cstr_info->packno - 1].end_pos >=\n                           (OPJ_INT32)\n                           p_cstr_info->tile[p_tile_no].tp[curtp].tp_end_pos) { \n                    info_TL->tp[curtp].tp_numpacks = p_cstr_info->packno -\n                                                     tp_start_packno; \n                    tp_start_packno = p_cstr_info->packno;\n                    curtp++;\n                    info_PK->start_pos = p_cstr_info->tile[p_tile_no].tp[curtp].tp_end_header + 1;\n                } else {\n                    info_PK->start_pos = (l_cp->m_specific_param.m_enc.m_tp_on &&\n                                          info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[p_cstr_info->packno -\n                                                                      1].end_pos + 1;\n                }\n                info_PK->end_pos = info_PK->start_pos + l_nb_bytes_read - 1;\n                info_PK->end_ph_pos += info_PK->start_pos -\n                                       1;  \n                ++p_cstr_info->packno;\n            }\n#endif\n        }\n        ++l_current_pi;\n        opj_free(first_pass_failed);\n    }\n#ifdef TODO_MSD\n    if\n    (p_cstr_info) {\n        p_cstr_info->tile[p_tile_no].tp[curtp].tp_numpacks = p_cstr_info->packno -\n                tp_start_packno; \n    }\n#endif\n    opj_pi_destroy(l_pi, l_nb_pocs);\n    *p_data_read = (OPJ_UINT32)(l_current_data - p_src);\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_decode_packet(opj_t2_t* p_t2,\n                                     opj_tcd_tile_t *p_tile,\n                                     opj_tcp_t *p_tcp,\n                                     opj_pi_iterator_t *p_pi,\n                                     OPJ_BYTE *p_src,\n                                     OPJ_UINT32 * p_data_read,\n                                     OPJ_UINT32 p_max_length,\n                                     opj_packet_info_t *p_pack_info,\n                                     opj_event_mgr_t *p_manager)\n{\n    OPJ_BOOL l_read_data;\n    OPJ_UINT32 l_nb_bytes_read = 0;\n    OPJ_UINT32 l_nb_total_bytes_read = 0;\n    *p_data_read = 0;\n    if (! opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, &l_read_data, p_src,\n                                    &l_nb_bytes_read, p_max_length, p_pack_info, p_manager)) {\n        return OPJ_FALSE;\n    }\n    p_src += l_nb_bytes_read;\n    l_nb_total_bytes_read += l_nb_bytes_read;\n    p_max_length -= l_nb_bytes_read;\n    if (l_read_data) {\n        l_nb_bytes_read = 0;\n        if (! opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, &l_nb_bytes_read,\n                                      p_max_length, p_pack_info, p_manager)) {\n            return OPJ_FALSE;\n        }\n        l_nb_total_bytes_read += l_nb_bytes_read;\n    }\n    *p_data_read = l_nb_total_bytes_read;\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,\n                                     opj_tcd_tile_t * tile,\n                                     opj_tcp_t * tcp,\n                                     opj_pi_iterator_t *pi,\n                                     OPJ_BYTE *dest,\n                                     OPJ_UINT32 * p_data_written,\n                                     OPJ_UINT32 length,\n                                     opj_codestream_info_t *cstr_info,\n                                     J2K_T2_MODE p_t2_mode,\n                                     opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_BYTE* c = dest;\n    OPJ_UINT32 l_nb_bytes;\n    OPJ_UINT32 compno = pi->compno;     \n    OPJ_UINT32 resno  = pi->resno;      \n    OPJ_UINT32 precno = pi->precno;     \n    OPJ_UINT32 layno  = pi->layno;      \n    OPJ_UINT32 l_nb_blocks;\n    opj_tcd_band_t *band = 00;\n    opj_tcd_cblk_enc_t* cblk = 00;\n    opj_tcd_pass_t *pass = 00;\n    opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n    opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n    opj_bio_t *bio = 00;    \n#ifdef ENABLE_EMPTY_PACKET_OPTIMIZATION\n    OPJ_BOOL packet_empty = OPJ_TRUE;\n#else\n    OPJ_BOOL packet_empty = OPJ_FALSE;\n#endif\n#ifdef DEBUG_VERBOSE\n    if (p_t2_mode == FINAL_PASS) {\n        fprintf(stderr,\n                \"encode packet compono=%d, resno=%d, precno=%d, layno=%d\\n\",\n                compno, resno, precno, layno);\n    }\n#endif\n    if (tcp->csty & J2K_CP_CSTY_SOP) {\n        if (length < 6) {\n            if (p_t2_mode == FINAL_PASS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                              \"output buffer. %u needed.\\n\",\n                              length, 6);\n            }\n            return OPJ_FALSE;\n        }\n        c[0] = 255;\n        c[1] = 145;\n        c[2] = 0;\n        c[3] = 4;\n#if 0\n        c[4] = (tile->packno % 65536) / 256;\n        c[5] = (tile->packno % 65536) % 256;\n#else\n        c[4] = (tile->packno >> 8) & 0xff; \n        c[5] = tile->packno & 0xff;\n#endif\n        c += 6;\n        length -= 6;\n    }\n    if (!layno) {\n        band = res->bands;\n        for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n            opj_tcd_precinct_t *prc;\n            if (opj_tcd_is_band_empty(band)) {\n                continue;\n            }\n            if (precno >= res->pw * res->ph) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"opj_t2_encode_packet(): accessing precno=%u >= %u\\n\",\n                              precno, res->pw * res->ph);\n                return OPJ_FALSE;\n            }\n            prc = &band->precincts[precno];\n            opj_tgt_reset(prc->incltree);\n            opj_tgt_reset(prc->imsbtree);\n            l_nb_blocks = prc->cw * prc->ch;\n            for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n                cblk = &prc->cblks.enc[cblkno];\n                cblk->numpasses = 0;\n                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);\n            }\n        }\n    }\n    bio = opj_bio_create();\n    if (!bio) {\n        return OPJ_FALSE;\n    }\n    opj_bio_init_enc(bio, c, length);\n#ifdef ENABLE_EMPTY_PACKET_OPTIMIZATION\n    band = res->bands;\n    for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {\n        opj_tcd_precinct_t *prc;\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            if (!layer->numpasses) {\n                continue;\n            }\n            packet_empty = OPJ_FALSE;\n            break;\n        }\n        if (!packet_empty) {\n            break;\n        }\n    }\n#endif\n    opj_bio_write(bio, packet_empty ? 0 : 1, 1);           \n    band = res->bands;\n    for (bandno = 0; !packet_empty &&\n            bandno < res->numbands; ++bandno, ++band)      {\n        opj_tcd_precinct_t *prc;\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            if (!cblk->numpasses && layer->numpasses) {\n                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);\n            }\n            ++cblk;\n        }\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            OPJ_UINT32 increment = 0;\n            OPJ_UINT32 nump = 0;\n            OPJ_UINT32 len = 0, passno;\n            OPJ_UINT32 l_nb_passes;\n            if (!cblk->numpasses) {\n                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));\n            } else {\n                opj_bio_write(bio, layer->numpasses != 0, 1);\n            }\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n            if (!cblk->numpasses) {\n                cblk->numlenbits = 3;\n                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);\n            }\n            opj_t2_putnumpasses(bio, layer->numpasses);\n            l_nb_passes = cblk->numpasses + layer->numpasses;\n            pass = cblk->passes +  cblk->numpasses;\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                ++nump;\n                len += pass->len;\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment,\n                                                        opj_int_floorlog2((OPJ_INT32)len) + 1\n                                                        - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));\n                    len = 0;\n                    nump = 0;\n                }\n                ++pass;\n            }\n            opj_t2_putcommacode(bio, (OPJ_INT32)increment);\n            cblk->numlenbits += increment;\n            pass = cblk->passes +  cblk->numpasses;\n            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {\n                nump++;\n                len += pass->len;\n                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {\n                    opj_bio_write(bio, (OPJ_UINT32)len,\n                                  cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));\n                    len = 0;\n                    nump = 0;\n                }\n                ++pass;\n            }\n            ++cblk;\n        }\n    }\n    if (!opj_bio_flush(bio)) {\n        opj_bio_destroy(bio);\n        return OPJ_FALSE;               \n    }\n    l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);\n    c += l_nb_bytes;\n    length -= l_nb_bytes;\n    opj_bio_destroy(bio);\n    if (tcp->csty & J2K_CP_CSTY_EPH) {\n        if (length < 2) {\n            if (p_t2_mode == FINAL_PASS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                              \"output buffer. %u needed.\\n\",\n                              length, 2);\n            }\n            return OPJ_FALSE;\n        }\n        c[0] = 255;\n        c[1] = 146;\n        c += 2;\n        length -= 2;\n    }\n    if (cstr_info && cstr_info->index_write) {\n        opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n        info_PK->end_ph_pos = (OPJ_INT32)(c - dest);\n    }\n    band = res->bands;\n    for (bandno = 0; !packet_empty && bandno < res->numbands; bandno++, ++band) {\n        opj_tcd_precinct_t *prc;\n        if (opj_tcd_is_band_empty(band)) {\n            continue;\n        }\n        prc = &band->precincts[precno];\n        l_nb_blocks = prc->cw * prc->ch;\n        cblk = prc->cblks.enc;\n        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {\n            opj_tcd_layer_t *layer = &cblk->layers[layno];\n            if (!layer->numpasses) {\n                ++cblk;\n                continue;\n            }\n            if (layer->len > length) {\n                if (p_t2_mode == FINAL_PASS) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"opj_t2_encode_packet(): only %u bytes remaining in \"\n                                  \"output buffer. %u needed.\\n\",\n                                  length, layer->len);\n                }\n                return OPJ_FALSE;\n            }\n            memcpy(c, layer->data, layer->len);\n            cblk->numpasses += layer->numpasses;\n            c += layer->len;\n            length -= layer->len;\n            if (cstr_info && cstr_info->index_write) {\n                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];\n                info_PK->disto += layer->disto;\n                if (cstr_info->D_max < info_PK->disto) {\n                    cstr_info->D_max = info_PK->disto;\n                }\n            }\n            ++cblk;\n        }\n    }\n    assert(c >= dest);\n    * p_data_written += (OPJ_UINT32)(c - dest);\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_skip_packet(opj_t2_t* p_t2,\n                                   opj_tcd_tile_t *p_tile,\n                                   opj_tcp_t *p_tcp,\n                                   opj_pi_iterator_t *p_pi,\n                                   OPJ_BYTE *p_src,\n                                   OPJ_UINT32 * p_data_read,\n                                   OPJ_UINT32 p_max_length,\n                                   opj_packet_info_t *p_pack_info,\n                                   opj_event_mgr_t *p_manager)\n{\n    OPJ_BOOL l_read_data;\n    OPJ_UINT32 l_nb_bytes_read = 0;\n    OPJ_UINT32 l_nb_total_bytes_read = 0;\n    *p_data_read = 0;\n    if (! opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, &l_read_data, p_src,\n                                    &l_nb_bytes_read, p_max_length, p_pack_info, p_manager)) {\n        return OPJ_FALSE;\n    }\n    p_src += l_nb_bytes_read;\n    l_nb_total_bytes_read += l_nb_bytes_read;\n    p_max_length -= l_nb_bytes_read;\n    if (l_read_data) {\n        l_nb_bytes_read = 0;\n        if (! opj_t2_skip_packet_data(p_t2, p_tile, p_pi, &l_nb_bytes_read,\n                                      p_max_length, p_pack_info, p_manager)) {\n            return OPJ_FALSE;\n        }\n        l_nb_total_bytes_read += l_nb_bytes_read;\n    }\n    *p_data_read = l_nb_total_bytes_read;\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_read_packet_header(opj_t2_t* p_t2,\n        opj_tcd_tile_t *p_tile,\n        opj_tcp_t *p_tcp,\n        opj_pi_iterator_t *p_pi,\n        OPJ_BOOL * p_is_data_present,\n        OPJ_BYTE *p_src_data,\n        OPJ_UINT32 * p_data_read,\n        OPJ_UINT32 p_max_length,\n        opj_packet_info_t *p_pack_info,\n        opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_UINT32 l_nb_code_blocks;\n    OPJ_UINT32 l_remaining_length;\n    OPJ_UINT32 l_header_length;\n    OPJ_UINT32 * l_modified_length_ptr = 00;\n    OPJ_BYTE *l_current_data = p_src_data;\n    opj_cp_t *l_cp = p_t2->cp;\n    opj_bio_t *l_bio = 00;  \n    opj_tcd_band_t *l_band = 00;\n    opj_tcd_cblk_dec_t* l_cblk = 00;\n    opj_tcd_resolution_t* l_res =\n        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];\n    OPJ_BYTE *l_header_data = 00;\n    OPJ_BYTE **l_header_data_start = 00;\n    OPJ_UINT32 l_present;\n    if (p_pi->layno == 0) {\n        l_band = l_res->bands;\n        for (bandno = 0; bandno < l_res->numbands; ++bandno) {\n            if (!opj_tcd_is_band_empty(l_band)) {\n                opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];\n                if (!(p_pi->precno < (l_band->precincts_data_size / sizeof(\n                                          opj_tcd_precinct_t)))) {\n                    opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct\\n\");\n                    return OPJ_FALSE;\n                }\n                opj_tgt_reset(l_prc->incltree);\n                opj_tgt_reset(l_prc->imsbtree);\n                l_cblk = l_prc->cblks.dec;\n                l_nb_code_blocks = l_prc->cw * l_prc->ch;\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n                    l_cblk->numsegs = 0;\n                    l_cblk->real_num_segs = 0;\n                    ++l_cblk;\n                }\n            }\n            ++l_band;\n        }\n    }\n    if (p_tcp->csty & J2K_CP_CSTY_SOP) {\n        if (p_max_length < 6) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Not enough space for expected SOP marker\\n\");\n        } else if ((*l_current_data) != 0xff || (*(l_current_data + 1) != 0x91)) {\n            opj_event_msg(p_manager, EVT_WARNING, \"Expected SOP marker\\n\");\n        } else {\n            l_current_data += 6;\n        }\n    }\n    l_bio = opj_bio_create();\n    if (! l_bio) {\n        return OPJ_FALSE;\n    }\n    if (l_cp->ppm == 1) { \n        l_header_data_start = &l_cp->ppm_data;\n        l_header_data = *l_header_data_start;\n        l_modified_length_ptr = &(l_cp->ppm_len);\n    } else if (p_tcp->ppt == 1) { \n        l_header_data_start = &(p_tcp->ppt_data);\n        l_header_data = *l_header_data_start;\n        l_modified_length_ptr = &(p_tcp->ppt_len);\n    } else { \n        l_header_data_start = &(l_current_data);\n        l_header_data = *l_header_data_start;\n        l_remaining_length = (OPJ_UINT32)(p_src_data + p_max_length - l_header_data);\n        l_modified_length_ptr = &(l_remaining_length);\n    }\n    opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);\n    l_present = opj_bio_read(l_bio, 1);\n    JAS_FPRINTF(stderr, \"present=%d \\n\", l_present);\n    if (!l_present) {\n        opj_bio_inalign(l_bio);\n        l_header_data += opj_bio_numbytes(l_bio);\n        opj_bio_destroy(l_bio);\n        if (p_tcp->csty & J2K_CP_CSTY_EPH) {\n            if ((*l_modified_length_ptr - (OPJ_UINT32)(l_header_data -\n                    *l_header_data_start)) < 2U) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Not enough space for expected EPH marker\\n\");\n            } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Expected EPH marker\\n\");\n            } else {\n                l_header_data += 2;\n            }\n        }\n        l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);\n        *l_modified_length_ptr -= l_header_length;\n        *l_header_data_start += l_header_length;\n        if (p_pack_info) {\n            p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - p_src_data);\n        }\n        * p_is_data_present = OPJ_FALSE;\n        *p_data_read = (OPJ_UINT32)(l_current_data - p_src_data);\n        return OPJ_TRUE;\n    }\n    l_band = l_res->bands;\n    for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band) {\n        opj_tcd_precinct_t *l_prc = &(l_band->precincts[p_pi->precno]);\n        if (opj_tcd_is_band_empty(l_band)) {\n            continue;\n        }\n        l_nb_code_blocks = l_prc->cw * l_prc->ch;\n        l_cblk = l_prc->cblks.dec;\n        for (cblkno = 0; cblkno < l_nb_code_blocks; cblkno++) {\n            OPJ_UINT32 l_included, l_increment, l_segno;\n            OPJ_INT32 n;\n            if (!l_cblk->numsegs) {\n                l_included = opj_tgt_decode(l_bio, l_prc->incltree, cblkno,\n                                            (OPJ_INT32)(p_pi->layno + 1));\n            } else {\n                l_included = opj_bio_read(l_bio, 1);\n            }\n            if (!l_included) {\n                l_cblk->numnewpasses = 0;\n                ++l_cblk;\n                JAS_FPRINTF(stderr, \"included=%d \\n\", l_included);\n                continue;\n            }\n            if (!l_cblk->numsegs) {\n                OPJ_UINT32 i = 0;\n                while (!opj_tgt_decode(l_bio, l_prc->imsbtree, cblkno, (OPJ_INT32)i)) {\n                    ++i;\n                }\n                l_cblk->numbps = (OPJ_UINT32)l_band->numbps + 1 - i;\n                l_cblk->numlenbits = 3;\n            }\n            l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);\n            l_increment = opj_t2_getcommacode(l_bio);\n            l_cblk->numlenbits += l_increment;\n            l_segno = 0;\n            if (!l_cblk->numsegs) {\n                if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 1)) {\n                    opj_bio_destroy(l_bio);\n                    return OPJ_FALSE;\n                }\n            } else {\n                l_segno = l_cblk->numsegs - 1;\n                if (l_cblk->segs[l_segno].numpasses == l_cblk->segs[l_segno].maxpasses) {\n                    ++l_segno;\n                    if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {\n                        opj_bio_destroy(l_bio);\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n            n = (OPJ_INT32)l_cblk->numnewpasses;\n            do {\n                OPJ_UINT32 bit_number;\n                l_cblk->segs[l_segno].numnewpasses = (OPJ_UINT32)opj_int_min((OPJ_INT32)(\n                        l_cblk->segs[l_segno].maxpasses - l_cblk->segs[l_segno].numpasses), n);\n                bit_number = l_cblk->numlenbits + opj_uint_floorlog2(\n                                 l_cblk->segs[l_segno].numnewpasses);\n                if (bit_number > 32) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Invalid bit number %d in opj_t2_read_packet_header()\\n\",\n                                  bit_number);\n                    opj_bio_destroy(l_bio);\n                    return OPJ_FALSE;\n                }\n                l_cblk->segs[l_segno].newlen = opj_bio_read(l_bio, bit_number);\n                JAS_FPRINTF(stderr, \"included=%d numnewpasses=%d increment=%d len=%d \\n\",\n                            l_included, l_cblk->segs[l_segno].numnewpasses, l_increment,\n                            l_cblk->segs[l_segno].newlen);\n                n -= (OPJ_INT32)l_cblk->segs[l_segno].numnewpasses;\n                if (n > 0) {\n                    ++l_segno;\n                    if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {\n                        opj_bio_destroy(l_bio);\n                        return OPJ_FALSE;\n                    }\n                }\n            } while (n > 0);\n            ++l_cblk;\n        }\n    }\n    if (!opj_bio_inalign(l_bio)) {\n        opj_bio_destroy(l_bio);\n        return OPJ_FALSE;\n    }\n    l_header_data += opj_bio_numbytes(l_bio);\n    opj_bio_destroy(l_bio);\n    if (p_tcp->csty & J2K_CP_CSTY_EPH) {\n        if ((*l_modified_length_ptr - (OPJ_UINT32)(l_header_data -\n                *l_header_data_start)) < 2U) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                          \"Not enough space for expected EPH marker\\n\");\n        } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {\n            opj_event_msg(p_manager, EVT_WARNING, \"Expected EPH marker\\n\");\n        } else {\n            l_header_data += 2;\n        }\n    }\n    l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);\n    JAS_FPRINTF(stderr, \"hdrlen=%d \\n\", l_header_length);\n    JAS_FPRINTF(stderr, \"packet body\\n\");\n    *l_modified_length_ptr -= l_header_length;\n    *l_header_data_start += l_header_length;\n    if (p_pack_info) {\n        p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - p_src_data);\n    }\n    *p_is_data_present = OPJ_TRUE;\n    *p_data_read = (OPJ_UINT32)(l_current_data - p_src_data);\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_read_packet_data(opj_t2_t* p_t2,\n                                        opj_tcd_tile_t *p_tile,\n                                        opj_pi_iterator_t *p_pi,\n                                        OPJ_BYTE *p_src_data,\n                                        OPJ_UINT32 * p_data_read,\n                                        OPJ_UINT32 p_max_length,\n                                        opj_packet_info_t *pack_info,\n                                        opj_event_mgr_t* p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_UINT32 l_nb_code_blocks;\n    OPJ_BYTE *l_current_data = p_src_data;\n    opj_tcd_band_t *l_band = 00;\n    opj_tcd_cblk_dec_t* l_cblk = 00;\n    opj_tcd_resolution_t* l_res =\n        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];\n    OPJ_ARG_NOT_USED(p_t2);\n    OPJ_ARG_NOT_USED(pack_info);\n    l_band = l_res->bands;\n    for (bandno = 0; bandno < l_res->numbands; ++bandno) {\n        opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];\n        if ((l_band->x1 - l_band->x0 == 0) || (l_band->y1 - l_band->y0 == 0)) {\n            ++l_band;\n            continue;\n        }\n        l_nb_code_blocks = l_prc->cw * l_prc->ch;\n        l_cblk = l_prc->cblks.dec;\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n            opj_tcd_seg_t *l_seg = 00;\n            if (!l_cblk->numnewpasses) {\n                ++l_cblk;\n                continue;\n            }\n            if (!l_cblk->numsegs) {\n                l_seg = l_cblk->segs;\n                ++l_cblk->numsegs;\n            } else {\n                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];\n                if (l_seg->numpasses == l_seg->maxpasses) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            }\n            do {\n                if ((((OPJ_SIZE_T)l_current_data + (OPJ_SIZE_T)l_seg->newlen) <\n                        (OPJ_SIZE_T)l_current_data) ||\n                        (l_current_data + l_seg->newlen > p_src_data + p_max_length)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\\n\",\n                                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,\n                                  p_pi->compno);\n                    return OPJ_FALSE;\n                }\n#ifdef USE_JPWL\n                if ((l_cblk->len + l_seg->newlen) > 8192) {\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\\n\",\n                                  l_seg->newlen, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);\n                    if (!JPWL_ASSUME) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                        return OPJ_FALSE;\n                    }\n                    l_seg->newlen = 8192 - l_cblk->len;\n                    opj_event_msg(p_manager, EVT_WARNING, \"      - truncating segment to %d\\n\",\n                                  l_seg->newlen);\n                    break;\n                };\n#endif \n                if (l_cblk->numchunks == l_cblk->numchunksalloc) {\n                    OPJ_UINT32 l_numchunksalloc = l_cblk->numchunksalloc * 2 + 1;\n                    opj_tcd_seg_data_chunk_t* l_chunks =\n                        (opj_tcd_seg_data_chunk_t*)opj_realloc(l_cblk->chunks,\n                                l_numchunksalloc * sizeof(opj_tcd_seg_data_chunk_t));\n                    if (l_chunks == NULL) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                      \"cannot allocate opj_tcd_seg_data_chunk_t* array\");\n                        return OPJ_FALSE;\n                    }\n                    l_cblk->chunks = l_chunks;\n                    l_cblk->numchunksalloc = l_numchunksalloc;\n                }\n                l_cblk->chunks[l_cblk->numchunks].data = l_current_data;\n                l_cblk->chunks[l_cblk->numchunks].len = l_seg->newlen;\n                l_cblk->numchunks ++;\n                l_current_data += l_seg->newlen;\n                l_seg->len += l_seg->newlen;\n                l_seg->numpasses += l_seg->numnewpasses;\n                l_cblk->numnewpasses -= l_seg->numnewpasses;\n                l_seg->real_num_passes = l_seg->numpasses;\n                if (l_cblk->numnewpasses > 0) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            } while (l_cblk->numnewpasses > 0);\n            l_cblk->real_num_segs = l_cblk->numsegs;\n            ++l_cblk;\n        } \n        ++l_band;\n    }\n    *(p_data_read) = (OPJ_UINT32)(l_current_data - p_src_data);\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t* p_t2,\n                                        opj_tcd_tile_t *p_tile,\n                                        opj_pi_iterator_t *p_pi,\n                                        OPJ_UINT32 * p_data_read,\n                                        OPJ_UINT32 p_max_length,\n                                        opj_packet_info_t *pack_info,\n                                        opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 bandno, cblkno;\n    OPJ_UINT32 l_nb_code_blocks;\n    opj_tcd_band_t *l_band = 00;\n    opj_tcd_cblk_dec_t* l_cblk = 00;\n    opj_tcd_resolution_t* l_res =\n        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];\n    OPJ_ARG_NOT_USED(p_t2);\n    OPJ_ARG_NOT_USED(pack_info);\n    *p_data_read = 0;\n    l_band = l_res->bands;\n    for (bandno = 0; bandno < l_res->numbands; ++bandno) {\n        opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];\n        if ((l_band->x1 - l_band->x0 == 0) || (l_band->y1 - l_band->y0 == 0)) {\n            ++l_band;\n            continue;\n        }\n        l_nb_code_blocks = l_prc->cw * l_prc->ch;\n        l_cblk = l_prc->cblks.dec;\n        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n            opj_tcd_seg_t *l_seg = 00;\n            if (!l_cblk->numnewpasses) {\n                ++l_cblk;\n                continue;\n            }\n            if (!l_cblk->numsegs) {\n                l_seg = l_cblk->segs;\n                ++l_cblk->numsegs;\n            } else {\n                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];\n                if (l_seg->numpasses == l_seg->maxpasses) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            }\n            do {\n                if (((*p_data_read + l_seg->newlen) < (*p_data_read)) ||\n                        ((*p_data_read + l_seg->newlen) > p_max_length)) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\\n\",\n                                  l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno,\n                                  p_pi->compno);\n                    return OPJ_FALSE;\n                }\n#ifdef USE_JPWL\n                if ((l_cblk->len + l_seg->newlen) > 8192) {\n                    opj_event_msg(p_manager, EVT_WARNING,\n                                  \"JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\\n\",\n                                  l_seg->newlen, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);\n                    if (!JPWL_ASSUME) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                        return -999;\n                    }\n                    l_seg->newlen = 8192 - l_cblk->len;\n                    opj_event_msg(p_manager, EVT_WARNING, \"      - truncating segment to %d\\n\",\n                                  l_seg->newlen);\n                    break;\n                };\n#endif \n                JAS_FPRINTF(stderr, \"p_data_read (%d) newlen (%d) \\n\", *p_data_read,\n                            l_seg->newlen);\n                *(p_data_read) += l_seg->newlen;\n                l_seg->numpasses += l_seg->numnewpasses;\n                l_cblk->numnewpasses -= l_seg->numnewpasses;\n                if (l_cblk->numnewpasses > 0) {\n                    ++l_seg;\n                    ++l_cblk->numsegs;\n                }\n            } while (l_cblk->numnewpasses > 0);\n            ++l_cblk;\n        }\n        ++l_band;\n    }\n    return OPJ_TRUE;\n}\nstatic OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t* cblk,\n                                OPJ_UINT32 index,\n                                OPJ_UINT32 cblksty,\n                                OPJ_UINT32 first)\n{\n    opj_tcd_seg_t* seg = 00;\n    OPJ_UINT32 l_nb_segs = index + 1;\n    if (l_nb_segs > cblk->m_current_max_segs) {\n        opj_tcd_seg_t* new_segs;\n        OPJ_UINT32 l_m_current_max_segs = cblk->m_current_max_segs +\n                                          OPJ_J2K_DEFAULT_NB_SEGS;\n        new_segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs,\n                                                l_m_current_max_segs * sizeof(opj_tcd_seg_t));\n        if (! new_segs) {\n            return OPJ_FALSE;\n        }\n        cblk->segs = new_segs;\n        memset(new_segs + cblk->m_current_max_segs,\n               0, OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));\n        cblk->m_current_max_segs = l_m_current_max_segs;\n    }\n    seg = &cblk->segs[index];\n    opj_tcd_reinit_segment(seg);\n    if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {\n        seg->maxpasses = 1;\n    } else if (cblksty & J2K_CCP_CBLKSTY_LAZY) {\n        if (first) {\n            seg->maxpasses = 10;\n        } else {\n            seg->maxpasses = (((seg - 1)->maxpasses == 1) ||\n                              ((seg - 1)->maxpasses == 10)) ? 2 : 1;\n        }\n    } else {\n        seg->maxpasses = 109;\n    }\n    return OPJ_TRUE;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_5392.c",
        "project": "uclouvain/openjpeg",
        "url": "https://github.com/uclouvain/openjpeg/commit/38d661a3897052c7ff0b39b30c29cb067e130121",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```list_item_verbose(struct bsdtar *bsdtar, FILE *out, struct archive_entry *entry)\n\tchar\t\t\t tmp[100];\n\tif (!bsdtar->u_width) {\n\t\tbsdtar->u_width = 6;\n\t\tbsdtar->gs_width = 13;\n\t}\n\tif (!now)\n\t\ttime(&now);\n\tfprintf(out, \"%s %d \",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry));\n\tp = archive_entry_uname(entry);\n\tif ((p == NULL) || (*p == '\\0')) {\n\t\tsprintf(tmp, \"%lu \",\n\t\t    (unsigned long)archive_entry_uid(entry));\n\t\tp = tmp;\n\t}\n\tw = strlen(p);\n\tif (w > bsdtar->u_width)\n\t\tbsdtar->u_width = w;\n\tfprintf(out, \"%-*s \", (int)bsdtar->u_width, p);\n\tp = archive_entry_gname(entry);\n\tif (p != NULL && p[0] != '\\0') {\n\t\tfprintf(out, \"%s\", p);\n\t\tw = strlen(p);\n\t} else {\n\t\tsprintf(tmp, \"%lu\",\n\t\t    (unsigned long)archive_entry_gid(entry));\n\t\tw = strlen(tmp);\n\t\tfprintf(out, \"%s\", tmp);\n\t}\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsprintf(tmp, \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(tmp, tar_i64toa(archive_entry_size(entry)));\n\t}\n\tif (w + strlen(tmp) >= bsdtar->gs_width)\n\t\tbsdtar->gs_width = w+strlen(tmp)+1;\n\tfprintf(out, \"%*s\", (int)(bsdtar->gs_width - w), tmp);\n\ttim = archive_entry_mtime(entry);\n\tif (tim < now - HALF_YEAR || tim > now + HALF_YEAR)\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b  %Y\" : \"%b \" DAY_FMT \"  %Y\";\n\telse\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b %H:%M\" : \"%b \" DAY_FMT \" %H:%M\";\n\tstrftime(tmp, sizeof(tmp), fmt, localtime(&tim));\n\tfprintf(out, \" %s \", tmp);\n\tsafe_fprintf(out, \"%s\", archive_entry_pathname(entry));\n\tif (archive_entry_hardlink(entry)) \n\t\t    archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) \n\t\tsafe_fprintf(out, \" -> %s\", archive_entry_symlink(entry));\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"bsdtar_platform.h\"\n__FBSDID(\"$FreeBSD: src/usr.bin/tar/util.c,v 1.23 2008/12/15 06:00:25 kientzle Exp $\");\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>  \n#endif\n#include <ctype.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_IO_H\n#include <io.h>\n#endif\n#ifdef HAVE_STDARG_H\n#include <stdarg.h>\n#endif\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_WCTYPE_H\n#include <wctype.h>\n#else\n#define\tiswprint isprint\n#endif\n#include \"bsdtar.h\"\n#include \"err.h\"\n#include \"passphrase.h\"\nstatic size_t\tbsdtar_expand_char(char *, size_t, char);\nstatic const char *strip_components(const char *path, int elements);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tread _read\n#endif\nvoid\nsafe_fprintf(FILE *f, const char *fmt, ...)\n{\n\tchar fmtbuff_stack[256]; \n\tchar outbuff[256]; \n\tchar *fmtbuff_heap; \n\tchar *fmtbuff;  \n\tint fmtbuff_length;\n\tint length, n;\n\tva_list ap;\n\tconst char *p;\n\tunsigned i;\n\twchar_t wc;\n\tchar try_wc;\n\tfmtbuff_heap = NULL;\n\tfmtbuff_length = sizeof(fmtbuff_stack);\n\tfmtbuff = fmtbuff_stack;\n\tva_start(ap, fmt);\n\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\tva_end(ap);\n\twhile (length < 0 || length >= fmtbuff_length) {\n\t\tif (length >= fmtbuff_length)\n\t\t\tfmtbuff_length = length+1;\n\t\telse if (fmtbuff_length < 8192)\n\t\t\tfmtbuff_length *= 2;\n\t\telse if (fmtbuff_length < 1000000)\n\t\t\tfmtbuff_length += fmtbuff_length / 4;\n\t\telse {\n\t\t\tlength = fmtbuff_length;\n\t\t\tfmtbuff_heap[length-1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tfree(fmtbuff_heap);\n\t\tfmtbuff_heap = malloc(fmtbuff_length);\n\t\tif (fmtbuff_heap != NULL) {\n\t\t\tfmtbuff = fmtbuff_heap;\n\t\t\tva_start(ap, fmt);\n\t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);\n\t\t\tva_end(ap);\n\t\t} else {\n\t\t\tlength = sizeof(fmtbuff_stack) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mbtowc(NULL, NULL, 1) == -1) { \n\t\tfree(fmtbuff_heap);\n\t\treturn;\n\t}\n\tp = fmtbuff;\n\ti = 0;\n\ttry_wc = 1;\n\twhile (*p != '\\0') {\n\t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {\n\t\t\tlength -= n;\n\t\t\tif (iswprint(wc) && wc != L'\\\\') {\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\toutbuff[i++] = *p++;\n\t\t\t} else {\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\ti += (unsigned)bsdtar_expand_char(\n\t\t\t\t\t    outbuff, i, *p++);\n\t\t\t}\n\t\t} else {\n\t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);\n\t\t\ttry_wc = 0;\n\t\t}\n\t\tif (i > (sizeof(outbuff) - 128)) {\n\t\t\toutbuff[i] = '\\0';\n\t\t\tfprintf(f, \"%s\", outbuff);\n\t\t\ti = 0;\n\t\t}\n\t}\n\toutbuff[i] = '\\0';\n\tfprintf(f, \"%s\", outbuff);\n\tfree(fmtbuff_heap);\n}\nstatic size_t\nbsdtar_expand_char(char *buff, size_t offset, char c)\n{\n\tsize_t i = offset;\n\tif (isprint((unsigned char)c) && c != '\\\\')\n\t\tbuff[i++] = c;\n\telse {\n\t\tbuff[i++] = '\\\\';\n\t\tswitch (c) {\n\t\tcase '\\a': buff[i++] = 'a'; break;\n\t\tcase '\\b': buff[i++] = 'b'; break;\n\t\tcase '\\f': buff[i++] = 'f'; break;\n\t\tcase '\\n': buff[i++] = 'n'; break;\n#if '\\r' != '\\n'\n\t\tcase '\\r': buff[i++] = 'r'; break;\n#endif\n\t\tcase '\\t': buff[i++] = 't'; break;\n\t\tcase '\\v': buff[i++] = 'v'; break;\n\t\tcase '\\\\': buff[i++] = '\\\\'; break;\n\t\tdefault:\n\t\t\tsprintf(buff + i, \"%03o\", 0xFF & (int)c);\n\t\t\ti += 3;\n\t\t}\n\t}\n\treturn (i - offset);\n}\nvoid\nset_chdir(struct bsdtar *bsdtar, const char *newdir)\n{\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\tif (newdir[0] == '/' || newdir[0] == '\\\\' ||\n\t    (((newdir[0] >= 'a' && newdir[0] <= 'z') ||\n\t      (newdir[0] >= 'A' && newdir[0] <= 'Z')) &&\n\t    newdir[1] == ':' && (newdir[2] == '/' || newdir[2] == '\\\\'))) {\n#else\n\tif (newdir[0] == '/') {\n#endif\n\t\tfree(bsdtar->pending_chdir);\n\t\tbsdtar->pending_chdir = NULL;\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\tbsdtar->pending_chdir = strdup(newdir);\n\telse {\n\t\tchar *old_pending = bsdtar->pending_chdir;\n\t\tsize_t old_len = strlen(old_pending);\n\t\tbsdtar->pending_chdir = malloc(old_len + strlen(newdir) + 2);\n\t\tif (old_pending[old_len - 1] == '/')\n\t\t\told_pending[old_len - 1] = '\\0';\n\t\tif (bsdtar->pending_chdir != NULL)\n\t\t\tsprintf(bsdtar->pending_chdir, \"%s/%s\",\n\t\t\t    old_pending, newdir);\n\t\tfree(old_pending);\n\t}\n\tif (bsdtar->pending_chdir == NULL)\n\t\tlafe_errc(1, errno, \"No memory\");\n}\nstatic const char*\nstrip_absolute_path(struct bsdtar *bsdtar, const char *p)\n{\n\tconst char *rp;\n\tif ((p[0] == '/' || p[0] == '\\\\') &&\n\t    (p[1] == '/' || p[1] == '\\\\') &&\n\t    (p[2] == '.' || p[2] == '?') &&\n\t    (p[3] == '/' || p[3] == '\\\\'))\n\t{\n\t\tif (p[2] == '?' &&\n\t\t    (p[4] == 'U' || p[4] == 'u') &&\n\t\t    (p[5] == 'N' || p[5] == 'n') &&\n\t\t    (p[6] == 'C' || p[6] == 'c') &&\n\t\t    (p[7] == '/' || p[7] == '\\\\'))\n\t\t\tp += 8;\n\t\telse\n\t\t\tp += 4;\n\t\twarn_strip_drive_letter(bsdtar);\n\t}\n\tdo {\n\t\trp = p;\n\t\tif (((p[0] >= 'a' && p[0] <= 'z') ||\n\t\t     (p[0] >= 'A' && p[0] <= 'Z')) &&\n\t\t    p[1] == ':') {\n\t\t\tp += 2;\n\t\t\twarn_strip_drive_letter(bsdtar);\n\t\t}\n\t\twhile (p[0] == '/' || p[0] == '\\\\') {\n\t\t\tif (p[1] == '.' &&\n\t\t\t    p[2] == '.' &&\n\t\t\t    (p[3] == '/' || p[3] == '\\\\')) {\n\t\t\t\tp += 3; \n\t\t\t} else if (p[1] == '.' &&\n\t\t\t\t   (p[2] == '/' || p[2] == '\\\\')) {\n\t\t\t\tp += 2; \n\t\t\t} else\n\t\t\t\tp += 1; \n\t\t\twarn_strip_leading_char(bsdtar, rp);\n\t\t}\n\t} while (rp != p);\n\treturn (p);\n}\nint\nedit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n{\n\tconst char *name = archive_entry_pathname(entry);\n\tconst char *original_name = name;\n\tconst char *hardlinkname = archive_entry_hardlink(entry);\n\tconst char *original_hardlinkname = hardlinkname;\n#if defined(HAVE_REGEX_H) || defined(HAVE_PCREPOSIX_H)\n\tchar *subst_name;\n\tint r;\n\tr = apply_substitution(bsdtar, name, &subst_name, 0, 0);\n\tif (r == -1) {\n\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\treturn 1;\n\t}\n\tif (r == 1) {\n\t\tarchive_entry_copy_pathname(entry, subst_name);\n\t\tif (*subst_name == '\\0') {\n\t\t\tfree(subst_name);\n\t\t\treturn -1;\n\t\t} else\n\t\t\tfree(subst_name);\n\t\tname = archive_entry_pathname(entry);\n\t\toriginal_name = name;\n\t}\n\tif (hardlinkname != NULL) {\n\t\tr = apply_substitution(bsdtar, hardlinkname, &subst_name, 0, 1);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_hardlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t\thardlinkname = archive_entry_hardlink(entry);\n\t\toriginal_hardlinkname = hardlinkname;\n\t}\n\tif (archive_entry_symlink(entry) != NULL) {\n\t\tr = apply_substitution(bsdtar, archive_entry_symlink(entry), &subst_name, 1, 0);\n\t\tif (r == -1) {\n\t\t\tlafe_warnc(0, \"Invalid substitution, skipping entry\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (r == 1) {\n\t\t\tarchive_entry_copy_symlink(entry, subst_name);\n\t\t\tfree(subst_name);\n\t\t}\n\t}\n#endif\n\tif (bsdtar->strip_components > 0) {\n\t\tname = strip_components(name, bsdtar->strip_components);\n\t\tif (name == NULL)\n\t\t\treturn (1);\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_components(hardlinkname,\n\t\t\t    bsdtar->strip_components);\n\t\t\tif (hardlinkname == NULL)\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\tif (!bsdtar->option_absolute_paths) {\n\t\tname = strip_absolute_path(bsdtar, name);\n\t\tif (*name == '\\0')\n\t\t\tname = \".\";\n\t\tif (hardlinkname != NULL) {\n\t\t\thardlinkname = strip_absolute_path(bsdtar, hardlinkname);\n\t\t\tif (*hardlinkname == '\\0')\n\t\t\t\treturn (1);\n\t\t}\n\t} else {\n\t\twhile (name[0] == '/' && name[1] == '/')\n\t\t\tname++;\n\t}\n\tif (name != original_name) {\n\t\tarchive_entry_copy_pathname(entry, name);\n\t}\n\tif (hardlinkname != original_hardlinkname) {\n\t\tarchive_entry_copy_hardlink(entry, hardlinkname);\n\t}\n\treturn (0);\n}\n#define PPBUFF_SIZE 1024\nvoid\nlist_item_verbose(struct bsdtar *bsdtar, FILE *out, struct archive_entry *entry)\n{\n\tchar\t\t\t tmp[100];\n\tsize_t\t\t\t w;\n\tconst char\t\t*p;\n\tconst char\t\t*fmt;\n\ttime_t\t\t\t tim;\n\tstatic time_t\t\t now;\n\tif (!bsdtar->u_width) {\n\t\tbsdtar->u_width = 6;\n\t\tbsdtar->gs_width = 13;\n\t}\n\tif (!now)\n\t\ttime(&now);\n\tfprintf(out, \"%s %d \",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry));\n\tp = archive_entry_uname(entry);\n\tif ((p == NULL) || (*p == '\\0')) {\n\t\tsprintf(tmp, \"%lu \",\n\t\t    (unsigned long)archive_entry_uid(entry));\n\t\tp = tmp;\n\t}\n\tw = strlen(p);\n\tif (w > bsdtar->u_width)\n\t\tbsdtar->u_width = w;\n\tfprintf(out, \"%-*s \", (int)bsdtar->u_width, p);\n\tp = archive_entry_gname(entry);\n\tif (p != NULL && p[0] != '\\0') {\n\t\tfprintf(out, \"%s\", p);\n\t\tw = strlen(p);\n\t} else {\n\t\tsprintf(tmp, \"%lu\",\n\t\t    (unsigned long)archive_entry_gid(entry));\n\t\tw = strlen(tmp);\n\t\tfprintf(out, \"%s\", tmp);\n\t}\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsprintf(tmp, \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(tmp, tar_i64toa(archive_entry_size(entry)));\n\t}\n\tif (w + strlen(tmp) >= bsdtar->gs_width)\n\t\tbsdtar->gs_width = w+strlen(tmp)+1;\n\tfprintf(out, \"%*s\", (int)(bsdtar->gs_width - w), tmp);\n\ttim = archive_entry_mtime(entry);\n#define\tHALF_YEAR (time_t)365 * 86400 / 2\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#define\tDAY_FMT  \"%d\"  \n#else\n#define\tDAY_FMT  \"%e\"  \n#endif\n\tif (tim < now - HALF_YEAR || tim > now + HALF_YEAR)\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b  %Y\" : \"%b \" DAY_FMT \"  %Y\";\n\telse\n\t\tfmt = bsdtar->day_first ? DAY_FMT \" %b %H:%M\" : \"%b \" DAY_FMT \" %H:%M\";\n\tstrftime(tmp, sizeof(tmp), fmt, localtime(&tim));\n\tfprintf(out, \" %s \", tmp);\n\tsafe_fprintf(out, \"%s\", archive_entry_pathname(entry));\n\tif (archive_entry_hardlink(entry)) \n\t\tsafe_fprintf(out, \" link to %s\",\n\t\t    archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) \n\t\tsafe_fprintf(out, \" -> %s\", archive_entry_symlink(entry));\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1570.c",
        "project": "libarchive/libarchive",
        "url": "https://github.com/libarchive/libarchive/commit/e37b620fe8f14535d737e89a4dcabaed4517bf1a",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\t\t enum copy_direction dir, u32 *crcp)\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\tif (length == 0)\n\t\treturn 0;\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\t\tmemcpy(dest, src, length);\n\t}\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum copy_direction\tdir,\n\tu32\t\t\t*crcp)\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tif (length == 0)\n\t\treturn 0;\n\tif (length > resid) {\n\t}\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t}\n\t}\n\twhile (length > 0) {\n\t\tbytes = length;\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t}\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t}\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\nint mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\n#define IB_ACCESS_REMOTE\t(IB_ACCESS_REMOTE_READ\t\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_WRITE\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_ATOMIC)\nint rxe_mem_init_user(struct rxe_dev *rxe, struct rxe_pd *pd, u64 start,\n\t\t      u64 length, u64 iova, int access, struct ib_udata *udata,\n\t\t      struct rxe_mem *mem)\n{\n\tint\t\t\tentry;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf = NULL;\n\tstruct ib_umem\t\t*umem;\n\tstruct scatterlist\t*sg;\n\tint\t\t\tnum_buf;\n\tvoid\t\t\t*vaddr;\n\tint err;\n\tumem = ib_umem_get(pd->ibpd.uobject->context, start, length, access, 0);\n\tif (IS_ERR(umem)) {\n\t\tpr_warn(\"err %d from rxe_umem_get\\n\",\n\t\t\t(int)PTR_ERR(umem));\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\tmem->umem = umem;\n\tnum_buf = umem->nmap;\n\trxe_mem_init(access, mem);\n\terr = rxe_mem_alloc(rxe, mem, num_buf);\n\tif (err) {\n\t\tpr_warn(\"err %d from rxe_mem_alloc\\n\", err);\n\t\tib_umem_release(umem);\n\t\tgoto err1;\n\t}\n\tWARN_ON(!is_power_of_2(umem->page_size));\n\tmem->page_shift\t\t= ilog2(umem->page_size);\n\tmem->page_mask\t\t= umem->page_size - 1;\n\tnum_buf\t\t\t= 0;\n\tmap\t\t\t= mem->map;\n\tif (length > 0) {\n\t\tbuf = map[0]->buf;\n\t\tfor_each_sg(umem->sg_head.sgl, sg, umem->nmap, entry) {\n\t\t\tvaddr = page_address(sg_page(sg));\n\t\t\tif (!vaddr) {\n\t\t\t\tpr_warn(\"null vaddr\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err1;\n\t\t\t}\n\t\t\tbuf->addr = (uintptr_t)vaddr;\n\t\t\tbuf->size = umem->page_size;\n\t\t\tnum_buf++;\n\t\t\tbuf++;\n\t\t\tif (num_buf >= RXE_BUF_PER_MAP) {\n\t\t\t\tmap++;\n\t\t\t\tbuf = map[0]->buf;\n\t\t\t\tnum_buf = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmem->pd\t\t\t= pd;\n\tmem->umem\t\t= umem;\n\tmem->access\t\t= access;\n\tmem->length\t\t= length;\n\tmem->iova\t\t= iova;\n\tmem->va\t\t\t= start;\n\tmem->offset\t\t= ib_umem_offset(umem);\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\treturn 0;\nerr1:\n\treturn err;\n}\nint rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\t\t enum copy_direction dir, u32 *crcp)\n{\n\tint\t\t\terr;\n\tint\t\t\tbytes;\n\tu8\t\t\t*va;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf;\n\tint\t\t\tm;\n\tint\t\t\ti;\n\tsize_t\t\t\toffset;\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\tif (length == 0)\n\t\treturn 0;\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tu8 *src, *dest;\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\t\tmemcpy(dest, src, length);\n\t\treturn 0;\n\t}\n\tWARN_ON(!mem->map);\n\terr = mem_check_range(mem, iova, length);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto err1;\n\t}\n\tlookup_iova(mem, iova, &m, &i, &offset);\n\tmap\t= mem->map + m;\n\tbuf\t= map[0]->buf + i;\n\twhile (length > 0) {\n\t\tu8 *src, *dest;\n\t\tva\t= (u8 *)(uintptr_t)buf->addr + offset;\n\t\tsrc  = (dir == to_mem_obj) ? addr : va;\n\t\tdest = (dir == to_mem_obj) ? va : addr;\n\t\tbytes\t= buf->size - offset;\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\t\tif (crcp)\n\t\t\tcrc = crc32_le(crc, src, bytes);\n\t\tmemcpy(dest, src, bytes);\n\t\tlength\t-= bytes;\n\t\taddr\t+= bytes;\n\t\toffset\t= 0;\n\t\tbuf++;\n\t\ti++;\n\t\tif (i == RXE_BUF_PER_MAP) {\n\t\t\ti = 0;\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t}\n\t}\n\tif (crcp)\n\t\t*crcp = crc;\n\treturn 0;\nerr1:\n\treturn err;\n}\nint copy_data(\n\tstruct rxe_dev\t\t*rxe,\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum copy_direction\tdir,\n\tu32\t\t\t*crcp)\n{\n\tint\t\t\tbytes;\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tu64\t\t\tiova;\n\tint\t\t\terr;\n\tif (length == 0)\n\t\treturn 0;\n\tif (length > resid) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\twhile (length > 0) {\n\t\tbytes = length;\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\trxe_drop_ref(mem);\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\tif (err)\n\t\t\t\tgoto err2;\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\tif (mem)\n\t\trxe_drop_ref(mem);\n\treturn 0;\nerr2:\n\tif (mem)\n\t\trxe_drop_ref(mem);\nerr1:\n\treturn err;\n}\n",
        "cwe": "CWE-190",
        "file_name": "vul_respovul_idx_1554.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```new_address(const char *hostname_or_ip) {\n    if (hostname_or_ip == NULL)\n        return NULL;\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n                hostname_or_ip + 5,\n    }\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n            struct Address *addr = new_address(ip_buf);\n        }\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n2018-12-05  Dustin Lundquist <dustin@null-ptr.net>\n\t0.6.0 Release\n\n\t* PROXY v1 protocol support\n\t* SO_REUSEPORT support on Linux 3.9 and later\n\t* Listener ipv6_only directive to accept only IPv6 connections\n\t* TCP keepalive\n\n2017-04-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.5.0 Release\n\n\t* Transparent proxy support\n\t* Use accept4() on Linix\n\t* Run as group specified in config\n\n2015-04-07  Dustin Lundquist <dustin@null-ptr.net>\n\t0.4.0 release\n\n\t* Improve DNS resolver:\n\t  Support for AAAA records\n\t  Configuration options\n\t* Global access log\n\t* Man page for sniproxy.conf\n\t* Reject IP literals as hostnames for wildcard backends\n\n2014-09-26  Dustin Lundquist <dustin@null-ptr.net>\n\t0.3.6 release\n\n\t* Improve logging:\n\t  Fix negative connection duration in access log\n\t  Include log rotate script\n\t  Reopen log files on SIGHUP\n\t  Share file handle to same log file between listeners\n\t  Avoid unnecessary reconnection to syslog socket\n\t  Cache timestamp string for current second\n\t* Man page\n\t* Packaging improvements:\n\t  passes lintian and rpm-lint\n\n2014-08-13\tDustin Lundquist <dustin@null-ptr.net>\n\t0.3.5 release\n\n\t* Configuration reloading on SIGHUP\n\t* SSL 2.0 connection handling: do not treat as an error, use fallback\n\taddress if configured.\n\t* Fix buffer_coalesce error\n\t* Spawn privileged child to bind sockets to privileged ports on reload\n\t* Add -V flag to return sniproxy version\n\t* Use libev for timestamps to improve portability\n\t* Include several for BSD compatibility\n\t* Large file support (for log files)\n\n\nFile number 2:\n#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.60])\nAC_INIT([sniproxy], [0.6.0])\nAC_CONFIG_SRCDIR([src/sniproxy.c])\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE([subdir-objects])\nAM_SILENT_RULES([yes])\nAC_GNU_SOURCE\n\n# Checks for programs.\nAC_PROG_CC_C99\n# Required by automake < 1.14\nAM_PROG_CC_C_O\n\n\n# Checks for libraries.\nPKG_CHECK_MODULES([LIBEV], [libev], HAVE_LIBEV=yes; AC_DEFINE(HAVE_LIBEV, 1),\n[AC_LIB_HAVE_LINKFLAGS(ev,, [#include <ev.h>], [ev_run(0,0);])\n if test x$ac_cv_libev = xyes; then\n  AC_SUBST([LIBEV_LIBS], [$LIBEV])\n else\n  AC_MSG_ERROR([[***\n*** libev4 was not found.\n***]])\n fi\n])\n\nPKG_CHECK_MODULES([LIBPCRE], [libpcre], HAVE_LIBPCRE=yes; AC_DEFINE(HAVE_LIBPCRE, 1),\n[AC_LIB_HAVE_LINKFLAGS(pcre,, [#include <pcre.h>], [pcre_exec(0,0,0,0,0,0,0,0);])\n if test x$ac_cv_libpcre = xyes; then\n  AC_SUBST([LIBPCRE_LIBS], [$LIBPCRE])\n else\n  AC_MSG_ERROR([[***\n*** libpcre was not found.\n***]])\n fi\n])\n\nAC_ARG_ENABLE([dns],\n  [AS_HELP_STRING([--disable-dns], [Disable DNS resolution])],\n  [dns=\"$withval\"], [dns=yes])\n\nAM_CONDITIONAL([DNS_ENABLED], [test \"x$dns\" = \"xyes\"])\n\nAS_IF([test \"x$dns\" = \"xyes\"],\n [PKG_CHECK_MODULES([LIBUDNS], [libudns], HAVE_LIBUDNS=yes; AC_DEFINE(HAVE_LIBUDNS, 1),\n  [AC_LIB_HAVE_LINKFLAGS(udns,, [#include <udns.h>], [dns_init(0, 0);])\n   AS_IF([test x$ac_cv_libudns = xyes], [AC_SUBST([LIBUDNS_LIBS], [$LIBUDNS])])\n  ])\n])\n\nAC_ARG_ENABLE([rfc3339-timestamps],\n  [AS_HELP_STRING([--enable-rfc3339-timestamps], [Enable RFC3339 timestamps])],\n  [rfc3339_timestamps=${enableval}], [rfc3339_timestamps=no])\n\nAS_IF([test \"x$rfc3339_timestamps\" = \"xyes\"],\n    [AC_DEFINE([RFC3339_TIMESTAMP], 1, [RFC3339 timestamps enabled])])\n\n# Checks for header files.\nAC_CHECK_HEADERS([arpa/inet.h fcntl.h inttypes.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h strings.h sys/socket.h sys/time.h syslog.h unistd.h],,\n    AC_MSG_ERROR([required header(s) not found]))\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_INLINE\nAC_TYPE_PID_T\nAC_TYPE_UID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT8_T\n\n# Checks for library functions.\nAC_FUNC_FORK\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\nAC_FUNC_STRTOD\nAC_CHECK_FUNCS([atexit daemon memset socket strcasecmp strchr strdup strerror strncasecmp strrchr strspn strtoul],,\n    AC_MSG_ERROR([required functions(s) not found]))\n\nAC_CHECK_FUNCS([accept4])\n\n# Enable large file support (so we can log more than 2GB)\nAC_SYS_LARGEFILE\n\nAC_CONFIG_FILES([Makefile\n                 src/Makefile\n                 man/Makefile\n                 tests/Makefile])\n\nAC_OUTPUT\n\nFile number 3:\nsniproxy (0.6.0) unstable; urgency=medium\n  * PROXY v1 protocol support\n  * SO_REUSEPORT support on Linux 3.9 and later\n  * Listener ipv6_only directive to accept only IPv6 connections\n  * TCP keepalive\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 05 Dec 2018 20:12:24 -0800\nsniproxy (0.5.0) unstable; urgency=medium\n  * Transparent proxy support\n  * Use accept4() on Linix\n  * Run as group specified in config\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 26 Apr 2017 07:17:13 -0700\nsniproxy (0.4.0) unstable; urgency=medium\n  * Improve DNS resolver:\n    Support for AAAA records\n    Configuration options\n  * Global access log\n  * Man page for sniproxy.conf\n  * Reject IP literals as hostnames for wildcard backends\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 07 Apr 2015 09:14:41 -0700\nsniproxy (0.3.6) unstable; urgency=medium\n  * Improve logging:\n    Fix negative connection duration in access log\n    Include log rotate script\n    Reopen log files on SIGHUP\n    Share file handle to same log file between listeners\n    Avoid unnecessary reconnection to syslog socket\n    Cache timestamp string for current second\n  * Man page\n  * Packaging improvements:\n    passes lintian and rpm-lint\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 26 Sep 2014 19:52:38 -0700\nsniproxy (0.3.5) unstable; urgency=medium\n  * Configuration reloading on SIGHUP\n  * SSL 2.0 connection handling: do not treat as an error, use fallback\n    address if configured.\n  * Fix buffer_coalesce error\n  * Spawn privileged child to bind sockets to privileged ports on reload\n  * Add -V flag to return sniproxy version\n  * Use libev for timestamps to improve portability\n  * Include several for BSD compatibility\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 13 Aug 2014 18:25:53 -0700\nsniproxy (0.3.4) unstable; urgency=medium\n  * Add source address specification configuration option.\n  * Line buffer log files.\n  * Fix segfault when no hostname included in TLS extensions.\n  * Fix erroneously report of invalid TLS client handshake.\n -- Dustin Lundquist <dustin@null-ptr.net>  Sun, 18 May 2014 14:38:33 -0700\nsniproxy (0.3.3) unstable; urgency=medium\n  * Fix format argument segfault in buffer full warning.\n  * Add sniproxy-dbg package.\n  * File descriptor limit: raise limit and improve handling when limit is\n    reached.\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 22 Apr 2014 17:35:59 -0700\nsniproxy (0.3.2-1) unstable; urgency=high\n  * Fix use after free when client closes connection before DNS response is\n    received.\n  * Fix two DNS query memory leaks.\n -- Dustin Lundquist <dustin@null-ptr.net>  Fri, 11 Apr 2014 16:32:06 -0700\nsniproxy (0.3.1-1) unstable; urgency=high\n  * Fix bug when client completely fills the buffer before the DNS query is\n    answered.\n  * Fix handling of invalid hostnames in client requests.\n -- Dustin Lundquist <dustin@null-ptr.net>  Wed, 09 Apr 2014 21:08:55 -0700\nsniproxy (0.3-1) unstable; urgency=medium\n  * Nonblocking connect and DNS resolution\n -- Dustin Lundquist <dustin@null-ptr.net>  Tue, 08 Apr 2014 17:03:37 -0700\nsniproxy (0.2) unstable; urgency=low\n  * Moving pidfile\n -- Dustin Lundquist <dustin@null-ptr.net>  Thu, 30 Jan 2014 13:51:02 -0800\nsniproxy (0.1-1) unstable; urgency=low\n  * Initial release\n -- Andreas Loibl <andreas@andreas-loibl.de>  Tue, 18 Jun 2013 17:55:43 +0200\nFile number 4:\n8\n\nFile number 5:\nName: sniproxy\nVersion: 0.6.0\nRelease: 1%{?dist}\nSummary: Transparent TLS and HTTP layer 4 proxy with SNI support\n\nGroup: System Environment/Daemons\nLicense: BSD\nURL: https://github.com/dlundquist/sniproxy\nSource0: %{name}-%{version}.tar.gz\nBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)\n\nBuildRequires: autoconf, automake, curl, libev-devel, pcre-devel, perl, gettext-devel, udns-devel\n\n%description\nProxies incoming HTTP and TLS connections based on the hostname contained in\nthe initial request of the TCP session. This enables HTTPS name-based virtual\nhosting to separate backend servers without installing the private key on the\nproxy machine.\n\n\n%prep\n%setup -q\n\n\n%build\n%configure CFLAGS=\"-I/usr/include/libev\"\nmake %{?_smp_mflags}\n\n\n%install\nrm -rf $RPM_BUILD_ROOT\nmake install DESTDIR=$RPM_BUILD_ROOT\n\n\n%clean\nrm -rf $RPM_BUILD_ROOT\n\n\n%files\n%defattr(-,root,root,-)\n%{_sbindir}/sniproxy\n%doc\n%{_mandir}/man8/sniproxy.8.gz\n%{_mandir}/man5/sniproxy.conf.5.gz\n\n\n\n%changelog\n* Wed Dec 5 2018 Dustin Lundquist <dustin@null-ptr.net> 0.6.0-1\n- PROXY v1 protocol support\n- SO_REUSEPORT support on Linux 3.9 and later\n- Listener ipv6_only directive to accept only IPv6 connections\n- TCP keepalive\n\n* Wed Apr 26 2017 Dustin Lundquist <dustin@null-ptr.net> 0.5.0-1\n- Transparent proxy support\n- Use accept4() on Linix\n- Run as group specified in config\n\n* Tue Apr 7 2015 Dustin Lundquist <dustin@null-ptr.net> 0.4.0-1\n- Improve DNS resolver:\n  Support for AAAA records\n  Configuration options\n- Global access log\n- Man page for sniproxy.conf\n- Reject IP literals as hostnames for wildcard backends\n\n* Fri Sep 26 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.6-1\n- Improve logging:\n  Fix negative connection duration in access log\n  Include log rotate script\n  Reopen log files on SIGHUP\n  Share file handle to same log file between listeners\n  Avoid unnecessary reconnection to syslog socket\n  Cache timestamp string for current second\n- Man page\n- Packaging improvements:\n  passes lintian and rpm-lint\n\n* Wed Aug 13 2014 Dustin Lundquist <dustin@null-ptr.net> 0.3.5-1\n- Configuration reloading on SIGHUP\n- SSL 2.0 connection handling: do not treat as an error, use fallback\n  address if configured.\n- Fix buffer_coalesce error\n- Spawn privileged child to bind sockets to privileged ports on reload\n- Add -V flag to return sniproxy version\n- Use libev for timestamps to improve portability\n- Include several for BSD compatibility\n- Large file support (for log files)\n\nFile number 6:\n#!/bin/sh\n\nVERSION=0.6.0\n\nSOURCE_DIR=$(dirname $0)\nGIT_DIR=${SOURCE_DIR}/.git\n\ncd ${SOURCE_DIR}\n\nif [ -d ${GIT_DIR} ]; then\n    GIT_VERSION=$(git describe --tags)\n    if [ \"x\" != \"x${GIT_VERSION}\" ]; then\n        if echo ${GIT_VERSION} | grep -q '-'; then\n            VER=$(echo ${GIT_VERSION} | cut -d- -f1)\n            REV=$(echo ${GIT_VERSION} | cut -d- -f2)\n            REF=$(echo ${GIT_VERSION} | cut -d- -f3)\n\n            VERSION=${VER}+git.${REV}.${REF}\n        else\n            # Release version (e.g. 0.3.5)\n            VERSION=${GIT_VERSION}\n            DEBIAN_VERSION=${VERSION}\n            SPEC_VERSION=${VERSION}\n        fi\n    fi\nfi\n\n# Update Autoconf with new version\nsed -i \"s/^\\(AC_INIT(\\[sniproxy\\], \\[\\)[^]]*\\(.\\+\\)$/\\1${VERSION}\\2/\" ${SOURCE_DIR}/configure.ac\n\n# Update redhat/sniproxy.spec with new version\nsed -i \"s/^Version:\\s\\+[^ ]\\+/Version: ${VERSION}/\" ${SOURCE_DIR}/redhat/sniproxy.spec\n\n# Update debian/changelog with new version\ndebchange --newversion ${VERSION} \"New git revision\"\n\nFile number 7:\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h> \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h> \n#include <sys/un.h>\n#include <assert.h>\n#include \"address.h\"\nstruct Address {\n    enum {\n        HOSTNAME,\n        SOCKADDR,\n        WILDCARD,\n    } type;\n    size_t len;     \n    uint16_t port;  \n    char data[];\n};\nstatic const char valid_label_bytes[] =\n\"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\nstatic int valid_hostname(const char *);\nstruct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n    if (hostname_or_ip == NULL)\n        return NULL;\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n            return addr;\n        }\n    }\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n        return addr;\n    }\n    return NULL;\n}\nstruct Address *\nnew_address_sa(const struct sockaddr *sa, socklen_t sa_len) {\n    struct Address *addr = malloc(offsetof(struct Address, data) + sa_len);\n    if (addr != NULL) {\n        addr->type = SOCKADDR;\n        addr->len = sa_len;\n        memcpy(addr->data, sa, sa_len);\n        addr->port = address_port(addr);\n    }\n    return addr;\n}\nconst struct sockaddr *\naddress_sa(const struct Address *addr) {\n    if (addr->type != SOCKADDR)\n        return NULL;\n    return (struct sockaddr *)addr->data;\n}\nuint16_t\naddress_port(const struct Address *addr) {\n    switch (addr->type) {\n        case HOSTNAME:\n            return addr->port;\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    return ntohs(((struct sockaddr_in *)addr->data)\n                            ->sin_port);\n                case AF_INET6:\n                    return ntohs(((struct sockaddr_in6 *)addr->data)\n                            ->sin6_port);\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    return 0;\n                default:\n                    assert(0);\n                    return 0;\n            }\n        case WILDCARD:\n            return addr->port;\n        default:\n            assert(0);\n            return 0;\n    }\n}\nvoid\naddress_set_port(struct Address *addr, uint16_t port) {\n    switch (addr->type) {\n        case SOCKADDR:\n            switch (address_sa(addr)->sa_family) {\n                case AF_INET:\n                    (((struct sockaddr_in *)addr->data) ->sin_port) =\n                        htons(port);\n                    break;\n                case AF_INET6:\n                    (((struct sockaddr_in6 *)addr->data) ->sin6_port) =\n                        htons(port);\n                    break;\n                case AF_UNIX:\n                case AF_UNSPEC:\n                    break;\n                default:\n                    assert(0);\n            }\n        case HOSTNAME:\n        case WILDCARD:\n            addr->port = port;\n            break;\n        default:\n            assert(0);\n    }\n}\nconst char *\ndisplay_sockaddr(const void *sa, char *buffer, size_t buffer_len) {\n    char ip[INET6_ADDRSTRLEN];\n    if (sa == NULL || buffer == NULL)\n        return NULL;\n    switch (((const struct sockaddr *)sa)->sa_family) {\n        case AF_INET:\n            inet_ntop(AF_INET,\n                      &((const struct sockaddr_in *)sa)->sin_addr,\n                      ip, sizeof(ip));\n            if (((struct sockaddr_in *)sa)->sin_port != 0)\n                snprintf(buffer, buffer_len, \"%s:%\" PRIu16, ip,\n                        ntohs(((struct sockaddr_in *)sa)->sin_port));\n            else\n                snprintf(buffer, buffer_len, \"%s\", ip);\n            break;\n        case AF_INET6:\n            inet_ntop(AF_INET6,\n                      &((const struct sockaddr_in6 *)sa)->sin6_addr,\n                      ip, sizeof(ip));\n            if (((struct sockaddr_in6 *)sa)->sin6_port != 0)\n                snprintf(buffer, buffer_len, \"[%s]:%\" PRIu16, ip,\n                         ntohs(((struct sockaddr_in6 *)sa)->sin6_port));\n            else\n                snprintf(buffer, buffer_len, \"[%s]\", ip);\n            break;\n        case AF_UNIX:\n            snprintf(buffer, buffer_len, \"unix:%s\",\n                     ((struct sockaddr_un *)sa)->sun_path);\n            break;\n        case AF_UNSPEC:\n            snprintf(buffer, buffer_len, \"NONE\");\n            break;\n        default:\n            assert(0);\n    }\n    return buffer;\n}\nint\nis_numeric(const char *s) {\n    char *p;\n    if (s == NULL || *s == '\\0')\n        return 0;\n    int n = strtod(s, &p);\n    (void)n; \n    return *p == '\\0'; \n}\nstatic int\nvalid_hostname(const char *hostname) {\n    if (hostname == NULL)\n        return 0;\n    size_t hostname_len = strlen(hostname);\n    if (hostname_len < 1 || hostname_len > 255)\n        return 0;\n    if (hostname[0] == '.')\n        return 0;\n    const char *hostname_end = hostname + hostname_len;\n    for (const char *label = hostname; label < hostname_end;) {\n        size_t label_len = (size_t)(hostname_end - label);\n        char *next_dot = strchr(label, '.');\n        if (next_dot != NULL)\n            label_len = (size_t)(next_dot - label);\n        assert(label + label_len <= hostname_end);\n        if (label_len > 63 || label_len < 1)\n            return 0;\n        if (label[0] == '-' || label[label_len - 1] == '-')\n            return 0;\n        if (strspn(label, valid_label_bytes) < label_len)\n            return 0;\n        label += label_len + 1;\n    }\n    return 1;\n}\nFile number 8:\nAM_CPPFLAGS = -I$(top_srcdir)/src -g $(LIBEV_CFLAGS) $(LIBPCRE_CFLAGS) $(LIBUDNS_CFLAGS)\nAM_CFLAGS = -fno-strict-aliasing -Wall -Wextra -Wpedantic -Wwrite-strings\n\nTESTS = address_test \\\n        buffer_test \\\n        cfg_tokenizer_test \\\n        table_test \\\n        http_test \\\n        tls_test \\\n        binder_test\n\nTESTS += functional_test \\\n         bad_request_test \\\n         bind_source_test \\\n         connection_reset_test \\\n         fallback_test \\\n         fd_limit_test \\\n         ipv6_v6only_test \\\n         proxy_header_test \\\n         reload_test \\\n         reuseport_test \\\n         slow_client_test \\\n         transparent_proxy_test\nif DNS_ENABLED\n  TESTS += config_test \\\n           resolv_test \\\n           bad_dns_request_test\nendif\n\ncheck_PROGRAMS = http_test \\\n                 tls_test \\\n                 table_test \\\n                 binder_test \\\n                 buffer_test \\\n                 cfg_tokenizer_test \\\n                 address_test \\\n                 resolv_test \\\n                 config_test\n\nhttp_test_SOURCES = http_test.c \\\n                    ../src/http.c\n\ntls_test_SOURCES = tls_test.c \\\n                   ../src/tls.c \\\n                   ../src/logger.c\n\nbinder_test_SOURCES = binder_test.c \\\n                      ../src/binder.c \\\n                      ../src/logger.c\n\nbuffer_test_SOURCES = buffer_test.c \\\n                      ../src/buffer.c\n\nbuffer_test_LDADD = $(LIBEV_LIBS)\n\naddress_test_SOURCES = address_test.c \\\n                      ../src/address.c\n\ncfg_tokenizer_test_SOURCES = cfg_tokenizer_test.c \\\n                             ../src/cfg_tokenizer.c\n\nconfig_test_SOURCES = config_test.c \\\n                      ../src/binder.c \\\n                      ../src/config.c \\\n                      ../src/cfg_parser.c \\\n                      ../src/cfg_tokenizer.c \\\n                      ../src/address.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/listener.c \\\n                      ../src/connection.c \\\n                      ../src/buffer.c \\\n                      ../src/logger.c \\\n                      ../src/resolv.c \\\n                      ../src/resolv.h \\\n                      ../src/tls.c \\\n                      ../src/http.c\n\nconfig_test_LDADD = $(LIBEV_LIBS) $(LIBPCRE_LIBS) $(LIBUDNS_LIBS)\n\nresolv_test_SOURCES = resolv_test.c \\\n                      ../src/resolv.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\nresolv_test_LDADD = $(LIBEV_LIBS) $(LIBUDNS_LIBS)\n\ntable_test_SOURCES = table_test.c \\\n                      ../src/backend.c \\\n                      ../src/table.c \\\n                      ../src/address.c \\\n                      ../src/logger.c\n\ntable_test_LDADD = $(LIBPCRE_LIBS)\n\nFile number 9:\n#!/usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\n\nmy $bad_requests = [\n    {\n        # Test bad name server\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: ...........\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size\n        request => \"PUT / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 65536\\r\\n\\r\\n\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Exceed buffer size before host header\n        request => \"GET /\" . 'x' x 65536,\n        client => \\&http_client,\n    },\n    {\n        # Invalid hostname\n        request => \"GET / HTTP/1.1\\r\\nHost: \\0example.com\\r\\n\\r\\n\",\n        client => \\&http_client,\n    },\n    {\n        # Test client aborting connection before DNS response received\n        request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\",\n        client => \\&http_client_abort,\n    },\n];\n\nsub http_client($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n\n    my $buffer;\n    $socket->recv($buffer, 4096);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub http_client_abort($$) {\n    my $port = shift;\n    my $request = shift;\n\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n                                       PeerPort => $port,\n                                       Proto => \"tcp\",\n                                       Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n\n    $socket->send($request);\n    sleep(1);\n\n    $socket->close();\n\n    return undef;\n}\n\nsub proxy {\n    my $config = shift;\n\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\n\n\nsub worker($$$) {\n    my ($port, $requests, $offset) = @_;\n\n    for (my $i = 0; $i < $requests; $i++) {\n        my $test = $bad_requests->[($i + $offset) % int(@$bad_requests)];\n        my $error = $test->{client}($port, $test->{request});\n\n        die($error) if defined $error;\n    }\n    # Success\n    exit 0;\n}\n\nsub make_wildcard_config($) {\n    my $proxy_port = shift;\n\n    my ($fh, $filename) = File::Temp::tempfile();\n\n    # Write out a test config file\n    print $fh <<END;\n# Minimal test configuration\n\nresolver {\n    # Use an RFC1166 documentation prefix IP address as the nameserver\n    # this should be not respond to DNS queries in any environment\n    nameserver 192.0.2.99\n}\n\nlisten 127.0.0.1 $proxy_port {\n    proto http\n}\n\ntable {\n    .* *:80\n}\nEND\n\n    close ($fh);\n\n    return $filename;\n}\n\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || int(@$bad_requests);\n\n    my $config = make_wildcard_config($proxy_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $proxy_port);\n\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&worker, $proxy_port, $iterations, $i);\n    }\n\n    # Wait for all our children to finish\n    wait_for_type('worker');\n\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    sleep 1;\n\n    # Delete our test configuration\n    unlink($config);\n\n    # Kill off any remaining children\n    reap_children();\n}\n\nmain();\n\nFile number 10:\n#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse File::Basename;\nuse lib dirname (__FILE__);\nuse TestUtils;\nuse TestHTTPD;\nuse File::Temp;\nuse IO::Socket::INET;\nuse Time::HiRes;\nsub proxy {\n    my $config = shift;\n    exec(@_, '../src/sniproxy', '-f', '-c', $config);\n}\nsub slow_client($$) {\n    my $port = shift;\n    my $requests = shift;\n    my $request = \"GET / HTTP/1.1\\r\\n\" .\n        \"UserAgent: slow_client/0.1\\r\\n\" .\n        \"Host: localhost:$port\\r\\n\" .\n        \"Accept: */*\\r\\n\" .\n        \"\\r\\n\";\n    local $SIG{ALRM} = sub { die \"alarm\\n\" };\n    alarm 10;\n    my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n            PeerPort => $port,\n            Proto => \"tcp\",\n            Type => SOCK_STREAM)\n        or die \"couldn't connect $!\";\n    $socket->send($request);\n    foreach (split(\"\\r\\n\", $request)) {\n        $socket->send(\"$_\\r\\n\");\n        sleep(1);\n    }\n    my $buffer;\n    $socket->recv($buffer, 4096);\n    $socket->close();\n    die(\"Unexpected response: $buffer\") unless ($buffer =~ /\\AHTTP\\/1\\.1 200 OK/);\n    exit(0);\n}\nsub main {\n    my $proxy_port = $ENV{SNI_PROXY_PORT} || 8080;\n    my $httpd_port = $ENV{TEST_HTTPD_PORT} || 8081;\n    my $workers = $ENV{WORKERS} || 3;\n    my $iterations = $ENV{ITERATIONS} || 3;\n    my $local_httpd = $ENV{LOCAL_HTTPD_PORT};\n    my $config = make_config($proxy_port, $local_httpd || $httpd_port);\n    my $proxy_pid = start_child('server', \\&proxy, $config, @ARGV);\n    my $httpd_pid = start_child('server', \\&TestHTTPD::httpd, port => $httpd_port) unless $local_httpd;\n    # Wait for proxy to load and parse config\n    wait_for_port(port => $httpd_port);\n    wait_for_port(port => $proxy_port);\n    for (my $i = 0; $i < $workers; $i++) {\n        start_child('worker', \\&slow_client, $proxy_port, $iterations);\n    }\n    # Wait for all our children to finish\n    wait_for_type('worker');\n    # Give the proxy a second to flush buffers and close server connections\n    sleep 1;\n    # For troubleshooting connections stuck in CLOSE_WAIT state\n    #kill 10, $proxy_pid;\n    #system(\"netstat -ptn | grep $proxy_pid\\/sniproxy\");\n    # For troubleshooting 100% CPU usage\n    #system(\"top -n 1 -p $proxy_pid -b\");\n    # Orderly shutdown of the server\n    kill 15, $proxy_pid;\n    kill 15, $httpd_pid unless $local_httpd;\n    sleep 1;\n    # Delete our test configuration\n    unlink($config);\n    # Kill off any remaining children\n    reap_children();\n}\n",
        "cwe": "CWE-120",
        "file_name": "vul_respovul_idx_10824.c",
        "project": "dlundquist/sniproxy",
        "url": "https://github.com/dlundquist/sniproxy/commit/f8d9a433fe22ab2fa15c00179048ab02ae23d583",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```                                         double scale, double shift,\n  int64_t tmp_signed = 0;\n    tmp_unsigned = (uint32_t)*vl->val.integer;\n    tmp_signed = (int32_t)*vl->val.integer;\n  } else if (vl->type == ASN_COUNTER64) {\n    tmp_unsigned = (uint32_t)vl->val.counter64->high;\n    tmp_unsigned = tmp_unsigned << 32;\n    tmp_unsigned += (uint32_t)vl->val.counter64->low;\n    tmp_signed = (int64_t)tmp_unsigned;\n  } else if (vl->type == ASN_OCTET_STR) {\n  } else {\n    if (vl->type == ASN_NULL)\n      INFO(\"snmp plugin: OID \\\"%s\\\" is undefined (type ASN_NULL)\", oid_buffer);\n    else\n  }\n  if (vl->type == ASN_OCTET_STR) {\n  } \n  else if (type == DS_TYPE_COUNTER) {\n  } else if (type == DS_TYPE_GAUGE) {\n    if (!defined)\n      ret.gauge = NAN;\n    else if (prefer_signed)\n      ret.gauge = (scale * tmp_signed) + shift;\n    else\n      ret.gauge = (scale * tmp_unsigned) + shift;\n  } else if (type == DS_TYPE_DERIVE) {\n  return (ret);\n                                   const host_definition_t *hd,\n                                   const data_definition_t *dd) {\n  } else {\n         1.0,  0.0, hd->name, dd->name);\n  }\nstatic int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *res = NULL;\n  size_t oid_list_len = data->values_len + 1;\n  oid_t oid_list[oid_list_len];\n  _Bool oid_list_todo[oid_list_len];\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n  if (host->sess_handle == NULL) {\n  }\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n  }\n  if (ds->ds_num != data->values_len) {\n  }\n  assert(data->values_len > 0);\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else \n    oid_list_len--;\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n  }\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n  while (status == 0) {\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n    }\n    for (i = 0; i < oid_list_len; i++) {\n      if (!oid_list_todo[i])\n        continue;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n    res = NULL;\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n    }\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n    vb = res->variables;\n    if (vb == NULL) {\n    }\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n      } else \n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n        }\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n        }\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } \n} \nstatic int csnmp_read_value(host_definition_t *host, data_definition_t *data) {\n  if ((status != STAT_SUCCESS) || (res == NULL)) {\n  }\n  for (vb = res->variables; vb != NULL; vb = vb->next_variable) {\n    for (i = 0; i < data->values_len; i++)\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n  } \n} \n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"collectd.h\"\n#include \"common.h\"\n#include \"plugin.h\"\n#include \"utils_complain.h\"\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-includes.h>\n#include <fnmatch.h>\nstruct oid_s {\n  oid oid[MAX_OID_LEN];\n  size_t oid_len;\n};\ntypedef struct oid_s oid_t;\nunion instance_u {\n  char string[DATA_MAX_NAME_LEN];\n  oid_t oid;\n};\ntypedef union instance_u instance_t;\nstruct data_definition_s {\n  char *name; \n  char *type; \n  _Bool is_table;\n  instance_t instance;\n  char *instance_prefix;\n  oid_t *values;\n  size_t values_len;\n  double scale;\n  double shift;\n  struct data_definition_s *next;\n  char **ignores;\n  size_t ignores_len;\n  int invert_match;\n};\ntypedef struct data_definition_s data_definition_t;\nstruct host_definition_s {\n  char *name;\n  char *address;\n  int version;\n  char *community;\n  char *username;\n  oid *auth_protocol;\n  size_t auth_protocol_len;\n  char *auth_passphrase;\n  oid *priv_protocol;\n  size_t priv_protocol_len;\n  char *priv_passphrase;\n  int security_level;\n  char *context;\n  void *sess_handle;\n  c_complain_t complaint;\n  cdtime_t interval;\n  data_definition_t **data_list;\n  int data_list_len;\n};\ntypedef struct host_definition_s host_definition_t;\nstruct csnmp_list_instances_s {\n  oid_t suffix;\n  char instance[DATA_MAX_NAME_LEN];\n  struct csnmp_list_instances_s *next;\n};\ntypedef struct csnmp_list_instances_s csnmp_list_instances_t;\nstruct csnmp_table_values_s {\n  oid_t suffix;\n  value_t value;\n  struct csnmp_table_values_s *next;\n};\ntypedef struct csnmp_table_values_s csnmp_table_values_t;\nstatic data_definition_t *data_head = NULL;\nstatic int csnmp_read_host(user_data_t *ud);\nstatic void csnmp_oid_init(oid_t *dst, oid const *src, size_t n) {\n  assert(n <= STATIC_ARRAY_SIZE(dst->oid));\n  memcpy(dst->oid, src, sizeof(*src) * n);\n  dst->oid_len = n;\n}\nstatic int csnmp_oid_compare(oid_t const *left, oid_t const *right) {\n  return (\n      snmp_oid_compare(left->oid, left->oid_len, right->oid, right->oid_len));\n}\nstatic int csnmp_oid_suffix(oid_t *dst, oid_t const *src, oid_t const *root) {\n  if (src->oid_len <= root->oid_len)\n    return (EINVAL);\n  if (snmp_oid_ncompare(root->oid, root->oid_len, src->oid, src->oid_len,\n                         root->oid_len) != 0)\n    return (EINVAL);\n  memset(dst, 0, sizeof(*dst));\n  dst->oid_len = src->oid_len - root->oid_len;\n  memcpy(dst->oid, &src->oid[root->oid_len],\n         dst->oid_len * sizeof(dst->oid[0]));\n  return (0);\n}\nstatic int csnmp_oid_to_string(char *buffer, size_t buffer_size,\n                               oid_t const *o) {\n  char oid_str[MAX_OID_LEN][16];\n  char *oid_str_ptr[MAX_OID_LEN];\n  for (size_t i = 0; i < o->oid_len; i++) {\n    ssnprintf(oid_str[i], sizeof(oid_str[i]), \"%lu\", (unsigned long)o->oid[i]);\n    oid_str_ptr[i] = oid_str[i];\n  }\n  return (strjoin(buffer, buffer_size, oid_str_ptr, o->oid_len,\n                   \".\"));\n}\nstatic void csnmp_host_close_session(host_definition_t *host) \n{\n  if (host->sess_handle == NULL)\n    return;\n  snmp_sess_close(host->sess_handle);\n  host->sess_handle = NULL;\n} \nstatic int csnmp_config_add_data_values(data_definition_t *dd,\n                                        oconfig_item_t *ci) {\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Values' needs at least one argument.\");\n    return (-1);\n  }\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: `Values' needs only string argument.\");\n      return (-1);\n    }\n  sfree(dd->values);\n  dd->values_len = 0;\n  dd->values = malloc(sizeof(*dd->values) * ci->values_num);\n  if (dd->values == NULL)\n    return (-1);\n  dd->values_len = (size_t)ci->values_num;\n  for (int i = 0; i < ci->values_num; i++) {\n    dd->values[i].oid_len = MAX_OID_LEN;\n    if (NULL == snmp_parse_oid(ci->values[i].value.string, dd->values[i].oid,\n                               &dd->values[i].oid_len)) {\n      ERROR(\"snmp plugin: snmp_parse_oid (%s) failed.\",\n            ci->values[i].value.string);\n      free(dd->values);\n      dd->values = NULL;\n      dd->values_len = 0;\n      return (-1);\n    }\n  }\n  return (0);\n} \nstatic int csnmp_config_add_data(oconfig_item_t *ci) {\n  data_definition_t *dd;\n  int status = 0;\n  dd = calloc(1, sizeof(*dd));\n  if (dd == NULL)\n    return (-1);\n  status = cf_util_get_string(ci, &dd->name);\n  if (status != 0) {\n    free(dd);\n    return (-1);\n  }\n  dd->scale = 1.0;\n  dd->shift = 0.0;\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n    if (strcasecmp(\"Type\", option->key) == 0)\n      status = cf_util_get_string(option, &dd->type);\n    else if (strcasecmp(\"Table\", option->key) == 0)\n      status = cf_util_get_boolean(option, &dd->is_table);\n    else if (strcasecmp(\"Instance\", option->key) == 0)\n      status = csnmp_config_add_data_instance(dd, option);\n    else if (strcasecmp(\"InstancePrefix\", option->key) == 0)\n      status = csnmp_config_add_data_instance_prefix(dd, option);\n    else if (strcasecmp(\"Values\", option->key) == 0)\n      status = csnmp_config_add_data_values(dd, option);\n    else if (strcasecmp(\"Shift\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->shift);\n    else if (strcasecmp(\"Scale\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->scale);\n    else if (strcasecmp(\"Ignore\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist(dd, option);\n    else if (strcasecmp(\"InvertMatch\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist_match_inverted(dd, option);\n    else {\n      WARNING(\"snmp plugin: Option `%s' not allowed here.\", option->key);\n      status = -1;\n    }\n    if (status != 0)\n      break;\n  } \n  while (status == 0) {\n    if (dd->type == NULL) {\n      WARNING(\"snmp plugin: `Type' not given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n    if (dd->values == NULL) {\n      WARNING(\"snmp plugin: No `Value' given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n    break;\n  } \n  if (status != 0) {\n    sfree(dd->name);\n    sfree(dd->instance_prefix);\n    sfree(dd->values);\n    sfree(dd->ignores);\n    sfree(dd);\n    return (-1);\n  }\n  DEBUG(\"snmp plugin: dd = { name = %s, type = %s, is_table = %s, values_len = \"\n        \"%zu }\",\n        dd->name, dd->type, (dd->is_table != 0) ? \"true\" : \"false\",\n        dd->values_len);\n  if (data_head == NULL)\n    data_head = dd;\n  else {\n    data_definition_t *last;\n    last = data_head;\n    while (last->next != NULL)\n      last = last->next;\n    last->next = dd;\n  }\n  return (0);\n} \nstatic int csnmp_config_add_host_collect(host_definition_t *host,\n                                         oconfig_item_t *ci) {\n  data_definition_t *data;\n  data_definition_t **data_list;\n  int data_list_len;\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Collect' needs at least one argument.\");\n    return (-1);\n  }\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: All arguments to `Collect' must be strings.\");\n      return (-1);\n    }\n  data_list_len = host->data_list_len + ci->values_num;\n  data_list =\n      realloc(host->data_list, sizeof(data_definition_t *) * data_list_len);\n  if (data_list == NULL)\n    return (-1);\n  host->data_list = data_list;\n  for (int i = 0; i < ci->values_num; i++) {\n    for (data = data_head; data != NULL; data = data->next)\n      if (strcasecmp(ci->values[i].value.string, data->name) == 0)\n        break;\n    if (data == NULL) {\n      WARNING(\"snmp plugin: No such data configured: `%s'\",\n              ci->values[i].value.string);\n      continue;\n    }\n    DEBUG(\"snmp plugin: Collect: host = %s, data[%i] = %s;\", host->name,\n          host->data_list_len, data->name);\n    host->data_list[host->data_list_len] = data;\n    host->data_list_len++;\n  } \n  return (0);\n} \nstatic int csnmp_config_add_host(oconfig_item_t *ci) {\n  host_definition_t *hd;\n  int status = 0;\n  char cb_name[DATA_MAX_NAME_LEN];\n  hd = calloc(1, sizeof(*hd));\n  if (hd == NULL)\n    return (-1);\n  hd->version = 2;\n  C_COMPLAIN_INIT(&hd->complaint);\n  status = cf_util_get_string(ci, &hd->name);\n  if (status != 0) {\n    sfree(hd);\n    return status;\n  }\n  hd->sess_handle = NULL;\n  hd->interval = 0;\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n    status = 0;\n    if (strcasecmp(\"Address\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->address);\n    else if (strcasecmp(\"Community\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->community);\n    else if (strcasecmp(\"Version\", option->key) == 0)\n      status = csnmp_config_add_host_version(hd, option);\n    else if (strcasecmp(\"Collect\", option->key) == 0)\n      csnmp_config_add_host_collect(hd, option);\n    else if (strcasecmp(\"Interval\", option->key) == 0)\n      cf_util_get_cdtime(option, &hd->interval);\n    else if (strcasecmp(\"Username\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->username);\n    else if (strcasecmp(\"AuthProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_auth_protocol(hd, option);\n    else if (strcasecmp(\"PrivacyProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_priv_protocol(hd, option);\n    else if (strcasecmp(\"AuthPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->auth_passphrase);\n    else if (strcasecmp(\"PrivacyPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->priv_passphrase);\n    else if (strcasecmp(\"SecurityLevel\", option->key) == 0)\n      status = csnmp_config_add_host_security_level(hd, option);\n    else if (strcasecmp(\"Context\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->context);\n    else {\n      WARNING(\n          \"snmp plugin: csnmp_config_add_host: Option `%s' not allowed here.\",\n          option->key);\n      status = -1;\n    }\n    if (status != 0)\n      break;\n  } \n  while (status == 0) {\n    if (hd->address == NULL) {\n      WARNING(\"snmp plugin: `Address' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->community == NULL && hd->version < 3) {\n      WARNING(\"snmp plugin: `Community' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->version == 3) {\n      if (hd->username == NULL) {\n        WARNING(\"snmp plugin: `Username' not given for host `%s'\", hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == 0) {\n        WARNING(\"snmp plugin: `SecurityLevel' not given for host `%s'\",\n                hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n          hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->auth_protocol == NULL) {\n          WARNING(\"snmp plugin: `AuthProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->auth_passphrase == NULL) {\n          WARNING(\"snmp plugin: `AuthPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->priv_protocol == NULL) {\n          WARNING(\"snmp plugin: `PrivacyProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->priv_passphrase == NULL) {\n          WARNING(\"snmp plugin: `PrivacyPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n    }\n    break;\n  } \n  if (status != 0) {\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n  DEBUG(\"snmp plugin: hd = { name = %s, address = %s, community = %s, version \"\n        \"= %i }\",\n        hd->name, hd->address, hd->community, hd->version);\n  ssnprintf(cb_name, sizeof(cb_name), \"snmp-%s\", hd->name);\n  user_data_t ud = {.data = hd, .free_func = csnmp_host_definition_destroy};\n  status =\n      plugin_register_complex_read( NULL, cb_name, csnmp_read_host,\n                                   hd->interval,  &ud);\n  if (status != 0) {\n    ERROR(\"snmp plugin: Registering complex read function failed.\");\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n  return (0);\n} \nstatic void csnmp_host_open_session(host_definition_t *host) {\n  struct snmp_session sess;\n  int error;\n  if (host->sess_handle != NULL)\n    csnmp_host_close_session(host);\n  snmp_sess_init(&sess);\n  sess.peername = host->address;\n  switch (host->version) {\n  case 1:\n    sess.version = SNMP_VERSION_1;\n    break;\n  case 3:\n    sess.version = SNMP_VERSION_3;\n    break;\n  default:\n    sess.version = SNMP_VERSION_2c;\n    break;\n  }\n  if (host->version == 3) {\n    sess.securityName = host->username;\n    sess.securityNameLen = strlen(host->username);\n    sess.securityLevel = host->security_level;\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n        sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityAuthProto = host->auth_protocol;\n      sess.securityAuthProtoLen = host->auth_protocol_len;\n      sess.securityAuthKeyLen = USM_AUTH_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->auth_passphrase,\n                          strlen(host->auth_passphrase), sess.securityAuthKey,\n                          &sess.securityAuthKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from auth_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityPrivProto = host->priv_protocol;\n      sess.securityPrivProtoLen = host->priv_protocol_len;\n      sess.securityPrivKeyLen = USM_PRIV_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->priv_passphrase,\n                          strlen(host->priv_passphrase), sess.securityPrivKey,\n                          &sess.securityPrivKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from priv_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n    if (host->context != NULL) {\n      sess.contextName = host->context;\n      sess.contextNameLen = strlen(host->context);\n    }\n  } else \n  {\n    sess.community = (u_char *)host->community;\n    sess.community_len = strlen(host->community);\n  }\n  host->sess_handle = snmp_sess_open(&sess);\n  if (host->sess_handle == NULL) {\n    char *errstr = NULL;\n    snmp_error(&sess, NULL, NULL, &errstr);\n    ERROR(\"snmp plugin: host %s: snmp_sess_open failed: %s\", host->name,\n          (errstr == NULL) ? \"Unknown problem\" : errstr);\n    sfree(errstr);\n  }\n} \nstatic value_t csnmp_value_list_to_value(struct variable_list *vl, int type,\n                                         double scale, double shift,\n                                         const char *host_name,\n                                         const char *data_name) {\n  value_t ret;\n  uint64_t tmp_unsigned = 0;\n  int64_t tmp_signed = 0;\n  _Bool defined = 1;\n  _Bool prefer_signed = 0;\n  if ((vl->type == ASN_INTEGER) || (vl->type == ASN_UINTEGER) ||\n      (vl->type == ASN_COUNTER)\n#ifdef ASN_TIMETICKS\n      || (vl->type == ASN_TIMETICKS)\n#endif\n      || (vl->type == ASN_GAUGE)) {\n    tmp_unsigned = (uint32_t)*vl->val.integer;\n    tmp_signed = (int32_t)*vl->val.integer;\n    if (vl->type == ASN_INTEGER)\n      prefer_signed = 1;\n    DEBUG(\"snmp plugin: Parsed int32 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_COUNTER64) {\n    tmp_unsigned = (uint32_t)vl->val.counter64->high;\n    tmp_unsigned = tmp_unsigned << 32;\n    tmp_unsigned += (uint32_t)vl->val.counter64->low;\n    tmp_signed = (int64_t)tmp_unsigned;\n    DEBUG(\"snmp plugin: Parsed int64 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_OCTET_STR) {\n  } else {\n    char oid_buffer[1024] = {0};\n    snprint_objid(oid_buffer, sizeof(oid_buffer) - 1, vl->name,\n                  vl->name_length);\n#ifdef ASN_NULL\n    if (vl->type == ASN_NULL)\n      INFO(\"snmp plugin: OID \\\"%s\\\" is undefined (type ASN_NULL)\", oid_buffer);\n    else\n#endif\n      WARNING(\"snmp plugin: I don't know the ASN type #%i \"\n              \"(OID: \\\"%s\\\", data block \\\"%s\\\", host block \\\"%s\\\")\",\n              (int)vl->type, oid_buffer,\n              (data_name != NULL) ? data_name : \"UNKNOWN\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\");\n    defined = 0;\n  }\n  if (vl->type == ASN_OCTET_STR) {\n    int status = -1;\n    if (vl->val.string != NULL) {\n      char string[64];\n      size_t string_length;\n      string_length = sizeof(string) - 1;\n      if (vl->val_len < string_length)\n        string_length = vl->val_len;\n      memcpy(string, vl->val.string, string_length);\n      string[string_length] = 0;\n      status = parse_value(string, &ret, type);\n      if (status != 0) {\n        ERROR(\"snmp plugin: host %s: csnmp_value_list_to_value: Parsing string \"\n              \"as %s failed: %s\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\",\n              DS_TYPE_TO_STRING(type), string);\n      }\n    }\n    if (status != 0) {\n      switch (type) {\n      case DS_TYPE_COUNTER:\n      case DS_TYPE_DERIVE:\n      case DS_TYPE_ABSOLUTE:\n        memset(&ret, 0, sizeof(ret));\n        break;\n      case DS_TYPE_GAUGE:\n        ret.gauge = NAN;\n        break;\n      default:\n        ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown \"\n              \"data source type: %i.\",\n              type);\n        ret.gauge = NAN;\n      }\n    }\n  } \n  else if (type == DS_TYPE_COUNTER) {\n    ret.counter = tmp_unsigned;\n  } else if (type == DS_TYPE_GAUGE) {\n    if (!defined)\n      ret.gauge = NAN;\n    else if (prefer_signed)\n      ret.gauge = (scale * tmp_signed) + shift;\n    else\n      ret.gauge = (scale * tmp_unsigned) + shift;\n  } else if (type == DS_TYPE_DERIVE) {\n    if (prefer_signed)\n      ret.derive = (derive_t)tmp_signed;\n    else\n      ret.derive = (derive_t)tmp_unsigned;\n  } else if (type == DS_TYPE_ABSOLUTE) {\n    ret.absolute = (absolute_t)tmp_unsigned;\n  } else {\n    ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown data source \"\n          \"type: %i.\",\n          type);\n    ret.gauge = NAN;\n  }\n  return (ret);\n} \nstatic int csnmp_strvbcopy_hexstring(char *dst, \n                                     const struct variable_list *vb,\n                                     size_t dst_size) {\n  char *buffer_ptr;\n  size_t buffer_free;\n  dst[0] = 0;\n  buffer_ptr = dst;\n  buffer_free = dst_size;\n  for (size_t i = 0; i < vb->val_len; i++) {\n    int status;\n    status = snprintf(buffer_ptr, buffer_free, (i == 0) ? \"%02x\" : \":%02x\",\n                      (unsigned int)vb->val.bitstring[i]);\n    assert(status >= 0);\n    if (((size_t)status) >= buffer_free) \n    {\n      dst[dst_size - 1] = 0;\n      return ENOMEM;\n    } else \n    {\n      buffer_ptr += (size_t)status;\n      buffer_free -= (size_t)status;\n    }\n  }\n  return 0;\n} \nstatic int csnmp_strvbcopy(char *dst, \n                           const struct variable_list *vb, size_t dst_size) {\n  char *src;\n  size_t num_chars;\n  if (vb->type == ASN_OCTET_STR)\n    src = (char *)vb->val.string;\n  else if (vb->type == ASN_BIT_STR)\n    src = (char *)vb->val.bitstring;\n  else if (vb->type == ASN_IPADDRESS) {\n    return ssnprintf(dst, dst_size,\n                     \"%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \"\",\n                     (uint8_t)vb->val.string[0], (uint8_t)vb->val.string[1],\n                     (uint8_t)vb->val.string[2], (uint8_t)vb->val.string[3]);\n  } else {\n    dst[0] = 0;\n    return (EINVAL);\n  }\n  num_chars = dst_size - 1;\n  if (num_chars > vb->val_len)\n    num_chars = vb->val_len;\n  for (size_t i = 0; i < num_chars; i++) {\n    if ((unsigned char)src[i] < 32)\n      return (csnmp_strvbcopy_hexstring(dst, vb, dst_size));\n    dst[i] = src[i];\n  }\n  dst[num_chars] = 0;\n  dst[dst_size - 1] = 0;\n  if (dst_size <= vb->val_len)\n    return ENOMEM;\n  return 0;\n} \nstatic int csnmp_instance_list_add(csnmp_list_instances_t **head,\n                                   csnmp_list_instances_t **tail,\n                                   const struct snmp_pdu *res,\n                                   const host_definition_t *hd,\n                                   const data_definition_t *dd) {\n  csnmp_list_instances_t *il;\n  struct variable_list *vb;\n  oid_t vb_name;\n  int status;\n  uint32_t is_matched;\n  for (vb = res->variables; (vb != NULL) && (vb->next_variable != NULL);\n       vb = vb->next_variable)\n    ;\n  if (vb == NULL)\n    return (-1);\n  csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n  il = calloc(1, sizeof(*il));\n  if (il == NULL) {\n    ERROR(\"snmp plugin: calloc failed.\");\n    return (-1);\n  }\n  il->next = NULL;\n  status = csnmp_oid_suffix(&il->suffix, &vb_name, &dd->instance.oid);\n  if (status != 0) {\n    sfree(il);\n    return (status);\n  }\n  if ((vb->type == ASN_OCTET_STR) || (vb->type == ASN_BIT_STR) ||\n      (vb->type == ASN_IPADDRESS)) {\n    char *ptr;\n    csnmp_strvbcopy(il->instance, vb, sizeof(il->instance));\n    is_matched = 0;\n    for (uint32_t i = 0; i < dd->ignores_len; i++) {\n      status = fnmatch(dd->ignores[i], il->instance, 0);\n      if (status == 0) {\n        if (dd->invert_match == 0) {\n          sfree(il);\n          return 0;\n        } else {\n          is_matched = 1;\n          break;\n        }\n      }\n    }\n    if (dd->invert_match != 0 && is_matched == 0) {\n      sfree(il);\n      return 0;\n    }\n    for (ptr = il->instance; *ptr != '\\0'; ptr++) {\n      if ((*ptr > 0) && (*ptr < 32))\n        *ptr = ' ';\n      else if (*ptr == '/')\n        *ptr = '_';\n    }\n    DEBUG(\"snmp plugin: il->instance = `%s';\", il->instance);\n  } else {\n    value_t val = csnmp_value_list_to_value(\n        vb, DS_TYPE_COUNTER,\n         1.0,  0.0, hd->name, dd->name);\n    ssnprintf(il->instance, sizeof(il->instance), \"%llu\", val.counter);\n  }\n  if (*head == NULL)\n    *head = il;\n  else\n    (*tail)->next = il;\n  *tail = il;\n  return (0);\n} \nstatic int csnmp_dispatch_table(host_definition_t *host,\n                                data_definition_t *data,\n                                csnmp_list_instances_t *instance_list,\n                                csnmp_table_values_t **value_table) {\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n  csnmp_list_instances_t *instance_list_ptr;\n  csnmp_table_values_t **value_table_ptr;\n  size_t i;\n  _Bool have_more;\n  oid_t current_suffix;\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n  assert(ds->ds_num == data->values_len);\n  assert(data->values_len > 0);\n  instance_list_ptr = instance_list;\n  value_table_ptr = calloc(data->values_len, sizeof(*value_table_ptr));\n  if (value_table_ptr == NULL)\n    return (-1);\n  for (i = 0; i < data->values_len; i++)\n    value_table_ptr[i] = value_table[i];\n  vl.values_len = data->values_len;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL) {\n    ERROR(\"snmp plugin: malloc failed.\");\n    sfree(value_table_ptr);\n    return (-1);\n  }\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n  vl.interval = host->interval;\n  have_more = 1;\n  while (have_more) {\n    _Bool suffix_skipped = 0;\n    if (instance_list != NULL) {\n      if (instance_list_ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n      memcpy(&current_suffix, &instance_list_ptr->suffix,\n             sizeof(current_suffix));\n    } else \n    {\n      csnmp_table_values_t *ptr = value_table_ptr[0];\n      if (ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n      memcpy(&current_suffix, &ptr->suffix, sizeof(current_suffix));\n    }\n    for (i = 0; i < data->values_len; i++) {\n      while (\n          (value_table_ptr[i] != NULL) &&\n          (csnmp_oid_compare(&value_table_ptr[i]->suffix, &current_suffix) < 0))\n        value_table_ptr[i] = value_table_ptr[i]->next;\n      if (value_table_ptr[i] == NULL) {\n        have_more = 0;\n        break;\n      } else if (csnmp_oid_compare(&value_table_ptr[i]->suffix,\n                                   &current_suffix) > 0) {\n        suffix_skipped = 1;\n        break;\n      }\n    } \n    if (!have_more)\n      break;\n    if (suffix_skipped) {\n      if (instance_list != NULL)\n        instance_list_ptr = instance_list_ptr->next;\n      else\n        value_table_ptr[0] = value_table_ptr[0]->next;\n      continue;\n    }\n#if COLLECT_DEBUG\n    for (i = 1; i < data->values_len; i++) {\n      assert(value_table_ptr[i] != NULL);\n      assert(csnmp_oid_compare(&value_table_ptr[i - 1]->suffix,\n                               &value_table_ptr[i]->suffix) == 0);\n    }\n    assert((instance_list_ptr == NULL) ||\n           (csnmp_oid_compare(&instance_list_ptr->suffix,\n                              &value_table_ptr[0]->suffix) == 0));\n#endif\n    sstrncpy(vl.type, data->type, sizeof(vl.type));\n    {\n      char temp[DATA_MAX_NAME_LEN];\n      if (instance_list_ptr == NULL)\n        csnmp_oid_to_string(temp, sizeof(temp), &current_suffix);\n      else\n        sstrncpy(temp, instance_list_ptr->instance, sizeof(temp));\n      if (data->instance_prefix == NULL)\n        sstrncpy(vl.type_instance, temp, sizeof(vl.type_instance));\n      else\n        ssnprintf(vl.type_instance, sizeof(vl.type_instance), \"%s%s\",\n                  data->instance_prefix, temp);\n    }\n    for (i = 0; i < data->values_len; i++)\n      vl.values[i] = value_table_ptr[i]->value;\n    if (vl.type_instance[0] != '\\0')\n      plugin_dispatch_values(&vl);\n    if (instance_list != NULL)\n      instance_list_ptr = instance_list_ptr->next;\n    else\n      value_table_ptr[0] = value_table_ptr[0]->next;\n  } \n  sfree(vl.values);\n  sfree(value_table_ptr);\n  return (0);\n} \nstatic int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n  const data_set_t *ds;\n  size_t oid_list_len = data->values_len + 1;\n  oid_t oid_list[oid_list_len];\n  _Bool oid_list_todo[oid_list_len];\n  int status;\n  size_t i;\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else \n    oid_list_len--;\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n    if (oid_list_todo_num == 0) {\n      DEBUG(\"snmp plugin: all variables have left their subtree\");\n      snmp_free_pdu(req);\n      status = 0;\n      break;\n    }\n    res = NULL;\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n      char *errstr = NULL;\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n      if (res != NULL)\n        snmp_free_pdu(res);\n      res = NULL;\n      sfree(errstr);\n      csnmp_host_close_session(host);\n      status = -1;\n      break;\n    }\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else \n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n    } \n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } \n  if (res != NULL)\n    snmp_free_pdu(res);\n  res = NULL;\n  if (status == 0)\n    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n  sfree(value_list_head);\n  sfree(value_list_tail);\n  return (0);\n} \nstatic int csnmp_read_value(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n  int status;\n  size_t i;\n  DEBUG(\"snmp plugin: csnmp_read_value (host = %s, data = %s)\", host->name,\n        data->name);\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_value: host->sess_handle == NULL\");\n    return (-1);\n  }\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  vl.values_len = ds->ds_num;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL)\n    return (-1);\n  for (i = 0; i < vl.values_len; i++) {\n    if (ds->ds[i].type == DS_TYPE_COUNTER)\n      vl.values[i].counter = 0;\n    else\n      vl.values[i].gauge = NAN;\n  }\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n  sstrncpy(vl.type, data->type, sizeof(vl.type));\n  sstrncpy(vl.type_instance, data->instance.string, sizeof(vl.type_instance));\n  vl.interval = host->interval;\n  req = snmp_pdu_create(SNMP_MSG_GET);\n  if (req == NULL) {\n    ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n    sfree(vl.values);\n    return (-1);\n  }\n  for (i = 0; i < data->values_len; i++)\n    snmp_add_null_var(req, data->values[i].oid, data->values[i].oid_len);\n  status = snmp_sess_synch_response(host->sess_handle, req, &res);\n  if ((status != STAT_SUCCESS) || (res == NULL)) {\n    char *errstr = NULL;\n    snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n    ERROR(\"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n          host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n    if (res != NULL)\n      snmp_free_pdu(res);\n    sfree(errstr);\n    sfree(vl.values);\n    csnmp_host_close_session(host);\n    return (-1);\n  }\n  for (vb = res->variables; vb != NULL; vb = vb->next_variable) {\n#if COLLECT_DEBUG\n    char buffer[1024];\n    snprint_variable(buffer, sizeof(buffer), vb->name, vb->name_length, vb);\n    DEBUG(\"snmp plugin: Got this variable: %s\", buffer);\n#endif \n    for (i = 0; i < data->values_len; i++)\n      if (snmp_oid_compare(data->values[i].oid, data->values[i].oid_len,\n                           vb->name, vb->name_length) == 0)\n        vl.values[i] =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n  } \n  snmp_free_pdu(res);\n  DEBUG(\"snmp plugin: -> plugin_dispatch_values (&vl);\");\n  plugin_dispatch_values(&vl);\n  sfree(vl.values);\n  return (0);\n} \n",
        "cwe": "CWE-415",
        "file_name": "safe_respovul_idx_2536.c",
        "project": "collectd/collectd",
        "url": "https://github.com/collectd/collectd/commit/d16c24542b2f96a194d43a73c2e5778822b9cb47",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```keyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)\n  if (!kv)\n    return -1;\n  val = keyval_get(kv, name);\n  okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));\n  if (!okv)\n      return -1;\n  okv->name = strdup(name);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#ifndef CLOCK_REALTIME\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UUID\n#include <uuid/uuid.h>\n#endif\n#ifdef HAVE_PTHREAD_NP_H\n# include <pthread_np.h>\n#endif\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <unistr.h>\n#include <uniconv.h>\n#include <libavutil/base64.h>\n#include \"logger.h\"\n#include \"conffile.h\"\n#include \"misc.h\"\nstatic char *buildopts[] =\n  {\n#ifdef HAVE_FFMPEG\n    \"ffmpeg\",\n#else\n    \"libav\",\n#endif\n#ifdef SPOTIFY\n    \"Spotify\",\n#else\n    \"Without Spotify\",\n#endif\n#ifdef SPOTIFY_LIBRESPOTC\n    \"librespot-c\",\n#endif\n#ifdef SPOTIFY_LIBSPOTIFY\n    \"libspotify\",\n#endif\n#ifdef LASTFM\n    \"LastFM\",\n#else\n    \"Without LastFM\",\n#endif\n#ifdef CHROMECAST\n    \"Chromecast\",\n#else\n    \"Without Chromecast\",\n#endif\n#ifdef MPD\n    \"MPD\",\n#else\n    \"Without MPD\",\n#endif\n#ifdef HAVE_LIBWEBSOCKETS\n    \"Websockets\",\n#else\n    \"Without websockets\",\n#endif\n#ifdef HAVE_ALSA\n    \"ALSA\",\n#else\n    \"Without ALSA\",\n#endif\n#ifdef HAVE_LIBPULSE\n    \"Pulseaudio\",\n#endif\n#ifdef WEBINTERFACE\n    \"Webinterface\",\n#else\n    \"Without webinterface\",\n#endif\n#ifdef HAVE_REGEX_H\n    \"Regex\",\n#else\n    \"Without regex\",\n#endif\n    NULL\n  };\nint\nnet_address_get(char *addr, size_t addr_len, union net_sockaddr *naddr)\n{\n  const char *s;\n  memset(addr, 0, addr_len); // Just in case caller doesn't check for errors\n  if (naddr->sa.sa_family == AF_INET6)\n     s = inet_ntop(AF_INET6, &naddr->sin6.sin6_addr, addr, addr_len);\n  else\n     s = inet_ntop(AF_INET, &naddr->sin.sin_addr, addr, addr_len);\n  if (!s)\n    return -1;\n  return 0;\n}\nint\nnet_port_get(short unsigned *port, union net_sockaddr *naddr)\n{\n  if (naddr->sa.sa_family == AF_INET6)\n     *port = ntohs(naddr->sin6.sin6_port);\n  else\n     *port = ntohs(naddr->sin.sin_port);\n  return 0;\n}\nint\nnet_connect(const char *addr, unsigned short port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  char strport[8];\n  int fd;\n  int ret;\n  DPRINTF(E_DBG, L_MISC, \"Connecting to '%s' at %s (port %u)\\n\", log_service_name, addr, port);\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_UNSPEC : AF_INET;\n  snprintf(strport, sizeof(strport), \"%hu\", port);\n  ret = getaddrinfo(addr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, gai_strerror(ret));\n      return -1;\n    }\n  for (ptr = servinfo; ptr; ptr = ptr->ai_next)\n    {\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\t{\n\t  continue;\n\t}\n      ret = connect(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0 && errno != EINPROGRESS) // EINPROGRESS in case of SOCK_NONBLOCK\n\t{\n\t  close(fd);\n\t  continue;\n\t}\n      break;\n    }\n  freeaddrinfo(servinfo);\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, strerror(errno));\n      return -1;\n    }\n  // net_address_get(ipaddr, sizeof(ipaddr), (union net_sockaddr *)ptr->ai-addr);\n  return fd;\n}\nint\nnet_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n      // TODO libevent sets this, we do the same?\n      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t  // We want to be sure the service is dual stack\n\t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n      break;\n    }\n  freeaddrinfo(servinfo);\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n  // Get the port that was assigned\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n  return fd;\n error:\n  close(fd);\n  return -1;\n}\nint\nnet_evhttp_bind(struct evhttp *evhttp, short unsigned port, const char *log_service_name)\n{\n  const char *bind_address;\n  bool v6_enabled;\n  int ret;\n  bind_address = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n  if (bind_address)\n    evhttp_bind_socket(evhttp, bind_address, port);\n  // For Linux, we could just do evhttp_bind_socket() for \"::\", and both the\n  // ipv4 and v6 port would be bound. However, for bsd it seems it is necessary\n  // to do like below.\n  v6_enabled = cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\");\n  if (v6_enabled)\n    {\n      ret = evhttp_bind_socket(evhttp, \"::\", port);\n      if (ret < 0)\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv6, falling back to IPv4\\n\", log_service_name, port);\n\t  v6_enabled = 0;\n\t}\n    }\n  ret = evhttp_bind_socket(evhttp, \"0.0.0.0\", port);\n  if (ret < 0)\n    {\n      if (!v6_enabled)\n\treturn -1;\n#ifndef __linux__\n      DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv4, listening on IPv6 only\\n\", log_service_name, port);\n#endif\n    }\n  return 0;\n}\n#if SIZEOF_VOID_P == 8 \nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 47;\n  const uint64_t m = 0xc6a4a7935bd1e995;\n  const uint64_t *data;\n  const uint64_t *end;\n  const unsigned char *data_tail;\n  uint64_t h;\n  uint64_t k;\n  h = seed ^ (len * m);\n  data = (const uint64_t *)key;\n  end = data + (len / 8);\n  while (data != end)\n    {\n      k = *data++;\n      k *= m;\n      k ^= k >> r;\n      k *= m;\n      h ^= k;\n      h *= m;\n    }\n  data_tail = (const unsigned char *)data;\n  switch (len & 7)\n    {\n      case 7:\n\th ^= (uint64_t)(data_tail[6]) << 48; \n      case 6:\n\th ^= (uint64_t)(data_tail[5]) << 40; \n      case 5:\n\th ^= (uint64_t)(data_tail[4]) << 32; \n      case 4:\n\th ^= (uint64_t)(data_tail[3]) << 24; \n      case 3:\n\th ^= (uint64_t)(data_tail[2]) << 16; \n      case 2:\n\th ^= (uint64_t)(data_tail[1]) << 8; \n      case 1:\n\th ^= (uint64_t)(data_tail[0]);\n\th *= m;\n    }\n  h ^= h >> r;\n  h *= m;\n  h ^= h >> r;\n  return h;\n}\n#elif SIZEOF_VOID_P == 4 \nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 24;\n  const uint32_t m = 0x5bd1e995;\n  const uint32_t *data;\n  const unsigned char *data_tail;\n  uint32_t k1;\n  uint32_t h1;\n  uint32_t k2;\n  uint32_t h2;\n  uint64_t h;\n  h1 = seed ^ len;\n  h2 = 0;\n  data = (const uint32_t *)key;\n  while (len >= 8)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n      k2 = *data++;\n      k2 *= m; k2 ^= k2 >> r; k2 *= m;\n      h2 *= m; h2 ^= k2;\n      len -= 8;\n    }\n  if (len >= 4)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n      len -= 4;\n    }\n  data_tail = (const unsigned char *)data;\n  switch(len)\n    {\n      case 3:\n\th2 ^= (uint32_t)(data_tail[2]) << 16;\n      case 2:\n\th2 ^= (uint32_t)(data_tail[1]) << 8;\n      case 1:\n\th2 ^= (uint32_t)(data_tail[0]);\n\th2 *= m;\n    };\n  h1 ^= h2 >> 18; h1 *= m;\n  h2 ^= h1 >> 22; h2 *= m;\n  h1 ^= h2 >> 17; h1 *= m;\n  h2 ^= h1 >> 19; h2 *= m;\n  h = h1;\n  h = (h << 32) | h2;\n  return h;\n}\n#else\n# error Platform not supported\n#endif\nint\nkeyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)\n{\n  struct onekeyval *okv;\n  const char *val;\n  if (!kv)\n    return -1;\n  val = keyval_get(kv, name);\n  if (val)\n    {\n      if (strcmp(val, value) == 0)\n        return 0;\n      else \n        return -1;\n    }\n  okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));\n  if (!okv)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval\\n\");\n      return -1;\n    }\n  okv->name = strdup(name);\n  if (!okv->name)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval name\\n\");\n      free(okv);\n      return -1;\n    }\n  okv->value = (char *)malloc(size + 1);\n  if (!okv->value)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval value\\n\");\n      free(okv->name);\n      free(okv);\n      return -1;\n    }\n  memcpy(okv->value, value, size);\n  okv->value[size] = '\\0';\n  okv->next = NULL;\n  if (!kv->head)\n    kv->head = okv;\n  if (kv->tail)\n    kv->tail->next = okv;\n  kv->tail = okv;\n  return 0;\n}\n#if defined(HAVE_MACH_CLOCK) || defined(HAVE_MACH_TIMER)\n#include <mach/mach_time.h> \n#include <mach/mach.h>      \n#include <mach/clock.h>     \nextern mach_port_t clock_port;\n#ifndef HAVE_CLOCK_GETTIME\nint\nclock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n  static int clock_init = 0;\n  static clock_serv_t clock;\n  mach_timespec_t mts;\n  int ret;\n  if (! clock_init) {\n    clock_init = 1;\n    if (host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clock))\n      abort(); \n  }\n  if(! tp)\n    return -1;\n  switch (clock_id) {\n  case CLOCK_REALTIME:\n    ret = clock_get_time(clock, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n  case CLOCK_MONOTONIC:\n    ret = clock_get_time(clock_port, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n  default:\n    ret = -1;\n    break;\n  }\n  return ret;\n}\nint\nclock_getres(clockid_t clock_id, struct timespec *res)\n{\n  if (! res)\n    return -1;\n  res->tv_sec = 0;\n  res->tv_nsec = 1000;\n  return 0;\n}\n#endif \n#ifndef HAVE_TIMER_SETTIME\n#include <sys/time.h> \nint\ntimer_create(clockid_t clock_id, void *sevp, timer_t *timer_id)\n{\n  if (clock_id != CLOCK_MONOTONIC)\n    return -1;\n  if (sevp)\n    return -1;\n  *timer_id = 0;\n  return 0;\n}\nint\ntimer_delete(timer_t timer_id)\n{\n  struct itimerval timerval;\n  if (timer_id != 0)\n    return -1;\n  memset(&timerval, 0, sizeof(struct itimerval));\n  return setitimer(ITIMER_REAL, &timerval, NULL);\n}\nint\ntimer_settime(timer_t timer_id, int flags, const struct itimerspec *tp, struct itimerspec *old)\n{\n  struct itimerval tv;\n  if (timer_id != 0 || ! tp || old)\n    return -1;\n  TIMESPEC_TO_TIMEVAL(&(tv.it_value), &(tp->it_value));\n  TIMESPEC_TO_TIMEVAL(&(tv.it_interval), &(tp->it_interval));\n  return setitimer(ITIMER_REAL, &tv, NULL);\n}\nint\ntimer_getoverrun(timer_t timer_id)\n{\n  return 0;\n}\n#endif \n#endif \n#ifdef HAVE_UUID\nvoid\nuuid_make(char *str)\n{\n  uuid_t uu;\n  uuid_generate_random(uu);\n  uuid_unparse_upper(uu, str);\n}\n#else\n#endif\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_6382.c",
        "project": "owntone/owntone-server",
        "url": "https://github.com/owntone/owntone-server/commit/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n      iter->in_range = 0;\n    }\n  if (!iter->in_range)\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    iter->in_range = 1;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"config.h\"\n#include <ctype.h>\n#include <errno.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"private.h\"\n#include \"mutt/lib.h\"\n#include \"config/lib.h\"\n#include \"email/lib.h\"\n#include \"core/lib.h\"\n#include \"conn/lib.h\"\n#include \"gui/lib.h\"\n#include \"lib.h\"\n#include \"bcache/lib.h\"\n#include \"adata.h\"\n#include \"edata.h\"\n#include \"mdata.h\"\n#include \"msn.h\"\n#include \"mutt_account.h\"\n#include \"mutt_globals.h\"\n#include \"options.h\"\n#ifdef USE_HCACHE\n#include \"hcache/lib.h\"\n#endif\n#ifdef USE_HCACHE\nstatic void imap_msn_index_to_uid_seqset(struct Buffer *buf, struct ImapMboxData *mdata)\n{\n  int first = 1, state = 0;\n  unsigned int cur_uid = 0, last_uid = 0;\n  unsigned int range_begin = 0, range_end = 0;\n  const size_t max_msn = imap_msn_highest(&mdata->msn);\n  for (unsigned int msn = 1; msn <= max_msn + 1; msn++)\n  {\n    bool match = false;\n    if (msn <= max_msn)\n    {\n      struct Email *e_cur = imap_msn_get(&mdata->msn, msn - 1);\n      cur_uid = e_cur ? imap_edata_get(e_cur)->uid : 0;\n      if (!state || (cur_uid && ((cur_uid - 1) == last_uid)))\n        match = true;\n      last_uid = cur_uid;\n    }\n    if (match)\n    {\n      switch (state)\n      {\n        case 1: \n          state = 2;\n        case 2: \n          range_end = cur_uid;\n          break;\n        default:\n          state = 1;\n          range_begin = cur_uid;\n          break;\n      }\n    }\n    else if (state)\n    {\n      if (first)\n        first = 0;\n      else\n        mutt_buffer_addch(buf, ',');\n      if (state == 1)\n        mutt_buffer_add_printf(buf, \"%u\", range_begin);\n      else if (state == 2)\n        mutt_buffer_add_printf(buf, \"%u:%u\", range_begin, range_end);\n      state = 1;\n      range_begin = cur_uid;\n    }\n  }\n}\nstatic void imap_hcache_namer(const char *path, struct Buffer *dest)\n{\n  mutt_buffer_printf(dest, \"%s.hcache\", path);\n}\nvoid imap_hcache_open(struct ImapAccountData *adata, struct ImapMboxData *mdata)\n{\n  if (!adata || !mdata)\n    return;\n  if (mdata->hcache)\n    return;\n  struct HeaderCache *hc = NULL;\n  struct Buffer *mbox = mutt_buffer_pool_get();\n  struct Buffer *cachepath = mutt_buffer_pool_get();\n  imap_cachepath(adata->delim, mdata->name, mbox);\n  if (strstr(mutt_buffer_string(mbox), \"/../\") ||\n      mutt_str_equal(mutt_buffer_string(mbox), \"..\") ||\n      mutt_strn_equal(mutt_buffer_string(mbox), \"../\", 3))\n  {\n    goto cleanup;\n  }\n  size_t len = mutt_buffer_len(mbox);\n  if ((len > 3) && (strcmp(mutt_buffer_string(mbox) + len - 3, \"/..\") == 0))\n    goto cleanup;\n  struct Url url = { 0 };\n  mutt_account_tourl(&adata->conn->account, &url);\n  url.path = mbox->data;\n  url_tobuffer(&url, cachepath, U_PATH);\n  const char *const c_header_cache =\n      cs_subset_path(NeoMutt->sub, \"header_cache\");\n  hc = mutt_hcache_open(c_header_cache, mutt_buffer_string(cachepath), imap_hcache_namer);\ncleanup:\n  mutt_buffer_pool_release(&mbox);\n  mutt_buffer_pool_release(&cachepath);\n  mdata->hcache = hc;\n}\nvoid imap_hcache_close(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return;\n  mutt_hcache_close(mdata->hcache);\n  mdata->hcache = NULL;\n}\nstruct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return NULL;\n  char key[16];\n  sprintf(key, \"/%u\", uid);\n  struct HCacheEntry hce =\n      mutt_hcache_fetch(mdata->hcache, key, mutt_str_len(key), mdata->uidvalidity);\n  if (!hce.email && hce.uidvalidity)\n  {\n    mutt_debug(LL_DEBUG3, \"hcache uidvalidity mismatch: %u\\n\", hce.uidvalidity);\n  }\n  return hce.email;\n}\nint imap_hcache_put(struct ImapMboxData *mdata, struct Email *e)\n{\n  if (!mdata->hcache)\n    return -1;\n  char key[16];\n  sprintf(key, \"/%u\", imap_edata_get(e)->uid);\n  return mutt_hcache_store(mdata->hcache, key, mutt_str_len(key), e, mdata->uidvalidity);\n}\nint imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid)\n{\n  if (!mdata->hcache)\n    return -1;\n  char key[16];\n  sprintf(key, \"/%u\", uid);\n  return mutt_hcache_delete_record(mdata->hcache, key, mutt_str_len(key));\n}\nint imap_hcache_store_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n  struct Buffer buf = mutt_buffer_make(8192);\n  imap_msn_index_to_uid_seqset(&buf, mdata);\n  int rc = mutt_hcache_store_raw(mdata->hcache, \"/UIDSEQSET\", 10, buf.data,\n                                 mutt_buffer_len(&buf) + 1);\n  mutt_debug(LL_DEBUG3, \"Stored /UIDSEQSET %s\\n\", buf.data);\n  mutt_buffer_dealloc(&buf);\n  return rc;\n}\nint imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return -1;\n  return mutt_hcache_delete_record(mdata->hcache, \"/UIDSEQSET\", 10);\n}\nchar *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata)\n{\n  if (!mdata->hcache)\n    return NULL;\n  char *seqset = NULL;\n  size_t dlen = 0;\n  char *hc_seqset = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDSEQSET\", 10, &dlen);\n  if (hc_seqset)\n  {\n    seqset = mutt_strn_dup(hc_seqset, dlen);\n    mutt_hcache_free_raw(mdata->hcache, (void **) &hc_seqset);\n  }\n  mutt_debug(LL_DEBUG3, \"Retrieved /UIDSEQSET %s\\n\", NONULL(seqset));\n  return seqset;\n}\n#endif\nint imap_parse_path(const char *path, struct ConnAccount *cac, char *mailbox, size_t mailboxlen)\n{\n  static unsigned short ImapPort = 0;\n  static unsigned short ImapsPort = 0;\n  if (ImapPort == 0)\n  {\n    struct servent *service = getservbyname(\"imap\", \"tcp\");\n    if (service)\n      ImapPort = ntohs(service->s_port);\n    else\n      ImapPort = IMAP_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAP port %d\\n\", ImapPort);\n  }\n  if (ImapsPort == 0)\n  {\n    struct servent *service = getservbyname(\"imaps\", \"tcp\");\n    if (service)\n      ImapsPort = ntohs(service->s_port);\n    else\n      ImapsPort = IMAP_SSL_PORT;\n    mutt_debug(LL_DEBUG3, \"Using default IMAPS port %d\\n\", ImapsPort);\n  }\n  cac->port = ImapPort;\n  cac->type = MUTT_ACCT_TYPE_IMAP;\n  cac->service = \"imap\";\n  cac->get_field = imap_get_field;\n  struct Url *url = url_parse(path);\n  if (!url)\n    return -1;\n  if ((url->scheme != U_IMAP) && (url->scheme != U_IMAPS))\n  {\n    url_free(&url);\n    return -1;\n  }\n  if ((mutt_account_fromurl(cac, url) < 0) || (cac->host[0] == '\\0'))\n  {\n    url_free(&url);\n    return -1;\n  }\n  if (url->scheme == U_IMAPS)\n    cac->flags |= MUTT_ACCT_SSL;\n  mutt_str_copy(mailbox, url->path, mailboxlen);\n  url_free(&url);\n  if ((cac->flags & MUTT_ACCT_SSL) && !(cac->flags & MUTT_ACCT_PORT))\n    cac->port = ImapsPort;\n  return 0;\n}\nvoid imap_pretty_mailbox(char *path, size_t pathlen, const char *folder)\n{\n  struct ConnAccount cac_target = { { 0 } };\n  struct ConnAccount cac_home = { { 0 } };\n  struct Url url = { 0 };\n  const char *delim = NULL;\n  int tlen;\n  int hlen = 0;\n  bool home_match = false;\n  char target_mailbox[1024];\n  char home_mailbox[1024];\n  if (imap_parse_path(path, &cac_target, target_mailbox, sizeof(target_mailbox)) < 0)\n    return;\n  if (imap_path_probe(folder, NULL) != MUTT_IMAP)\n    goto fallback;\n  if (imap_parse_path(folder, &cac_home, home_mailbox, sizeof(home_mailbox)) < 0)\n    goto fallback;\n  tlen = mutt_str_len(target_mailbox);\n  hlen = mutt_str_len(home_mailbox);\n  if (tlen && imap_account_match(&cac_home, &cac_target) &&\n      mutt_strn_equal(home_mailbox, target_mailbox, hlen))\n  {\n    const char *const c_imap_delim_chars =\n        cs_subset_string(NeoMutt->sub, \"imap_delim_chars\");\n    if (hlen == 0)\n      home_match = true;\n    else if (c_imap_delim_chars)\n    {\n      for (delim = c_imap_delim_chars; *delim != '\\0'; delim++)\n        if (target_mailbox[hlen] == *delim)\n          home_match = true;\n    }\n  }\n  if (home_match)\n  {\n    *path++ = '+';\n    if (hlen == 0)\n      hlen = -1;\n    memcpy(path, target_mailbox + hlen + 1, tlen - hlen - 1);\n    path[tlen - hlen - 1] = '\\0';\n    return;\n  }\nfallback:\n  mutt_account_tourl(&cac_target, &url);\n  url.path = target_mailbox;\n  url_tostring(&url, path, pathlen, U_NO_FLAGS);\n}\nint imap_wait_keepalive(pid_t pid)\n{\n  struct sigaction oldalrm;\n  struct sigaction act;\n  sigset_t oldmask;\n  int rc;\n  const bool c_imap_passive = cs_subset_bool(NeoMutt->sub, \"imap_passive\");\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", true, NULL);\n  OptKeepQuiet = true;\n  sigprocmask(SIG_SETMASK, NULL, &oldmask);\n  sigemptyset(&act.sa_mask);\n  act.sa_handler = mutt_sig_empty_handler;\n#ifdef SA_INTERRUPT\n  act.sa_flags = SA_INTERRUPT;\n#else\n  act.sa_flags = 0;\n#endif\n  sigaction(SIGALRM, &act, &oldalrm);\n  const short c_imap_keepalive =\n      cs_subset_number(NeoMutt->sub, \"imap_keepalive\");\n  alarm(c_imap_keepalive);\n  while ((waitpid(pid, &rc, 0) < 0) && (errno == EINTR))\n  {\n    alarm(0); \n    imap_keepalive();\n    alarm(c_imap_keepalive);\n  }\n  alarm(0); \n  sigaction(SIGALRM, &oldalrm, NULL);\n  sigprocmask(SIG_SETMASK, &oldmask, NULL);\n  OptKeepQuiet = false;\n  cs_subset_str_native_set(NeoMutt->sub, \"imap_passive\", c_imap_passive, NULL);\n  return rc;\n}\nint mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_6048.c",
        "project": "neomutt/neomutt",
        "url": "https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```njs_function_native_frame(njs_vm_t *vm, njs_function_t *function,\n    const njs_value_t *this, const njs_value_t *args, njs_uint_t nargs,\n    njs_bool_t ctor)\n    size = NJS_NATIVE_FRAME_SIZE\n           + (function->args_offset + nargs) * sizeof(njs_value_t);\n    frame = njs_function_frame_alloc(vm, size);\n    if (njs_slow_path(frame == NULL)) {\n    }\n    frame->function = function;\n    frame->nargs = function->args_offset + nargs;\n    frame->ctor = ctor;\n    frame->native = 1;\n    frame->pc = NULL;\n    value = (njs_value_t *) ((u_char *) frame + NJS_NATIVE_FRAME_SIZE);\n    frame->arguments = value;\n    frame->arguments_offset = value + function->args_offset;\n    bound = function->bound;\n    if (bound == NULL) {\n        *value++ = *this;\n    } else {\n        do {\n            *value++ = *bound++;\n        } while (n != 0);\n    }\n    if (args != NULL) {\n        memcpy(value, args, nargs * sizeof(njs_value_t));\n    }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <njs_main.h>\nnjs_function_t *\nnjs_function_alloc(njs_vm_t *vm, njs_function_lambda_t *lambda,\n    njs_bool_t async)\n{\n    size_t          size;\n    njs_object_t    *proto;\n    njs_function_t  *function;\n    size = sizeof(njs_function_t) + lambda->nclosures * sizeof(njs_value_t *);\n    function = njs_mp_zalloc(vm->mem_pool, size);\n    if (njs_slow_path(function == NULL)) {\n        goto fail;\n    }\n    function->ctor = lambda->ctor;\n    function->args_offset = 1;\n    function->u.lambda = lambda;\n    if (function->ctor) {\n        function->object.shared_hash = vm->shared->function_instance_hash;\n    } else if (async) {\n        function->object.shared_hash = vm->shared->async_function_instance_hash;\n    } else {\n        function->object.shared_hash = vm->shared->arrow_instance_hash;\n    }\n    if (async) {\n        proto = &vm->prototypes[NJS_OBJ_TYPE_ASYNC_FUNCTION].object;\n    } else {\n        proto = &vm->prototypes[NJS_OBJ_TYPE_FUNCTION].object;\n    }\n    function->object.__proto__ = proto;\n    function->object.type = NJS_FUNCTION;\n    function->object.extensible = 1;\n    return function;\nfail:\n    njs_memory_error(vm);\n    return NULL;\n}\nnjs_int_t\nnjs_function_name_set(njs_vm_t *vm, njs_function_t *function,\n    njs_value_t *name, const char *prefix)\n{\n    u_char              *p;\n    size_t              len, symbol;\n    njs_int_t           ret;\n    njs_value_t         value;\n    njs_string_prop_t   string;\n    njs_object_prop_t   *prop;\n    njs_lvlhsh_query_t  lhq;\n    prop = njs_object_prop_alloc(vm, &njs_string_name, name, 0);\n    if (njs_slow_path(prop == NULL)) {\n        return NJS_ERROR;\n    }\n    symbol = 0;\n    if (njs_is_symbol(&prop->value)) {\n        symbol = 2;\n        prop->value = *njs_symbol_description(&prop->value);\n    }\n    if (prefix != NULL || symbol != 0) {\n        value = prop->value;\n        (void) njs_string_prop(&string, &value);\n        len = (prefix != NULL) ? njs_strlen(prefix) + 1: 0;\n        p = njs_string_alloc(vm, &prop->value, string.size + len + symbol,\n                             string.length + len + symbol);\n        if (njs_slow_path(p == NULL)) {\n            return NJS_ERROR;\n        }\n        if (len != 0) {\n            p = njs_cpymem(p, prefix, len - 1);\n            *p++ = ' ';\n        }\n        if (symbol != 0) {\n            *p++ = '[';\n        }\n        p = njs_cpymem(p, string.start, string.size);\n        if (symbol != 0) {\n            *p++ = ']';\n        }\n    }\n    prop->configurable = 1;\n    lhq.key_hash = NJS_NAME_HASH;\n    lhq.key = njs_str_value(\"name\");\n    lhq.replace = 0;\n    lhq.value = prop;\n    lhq.proto = &njs_object_hash_proto;\n    lhq.pool = vm->mem_pool;\n    ret = njs_lvlhsh_insert(&function->object.hash, &lhq);\n    if (njs_slow_path(ret != NJS_OK)) {\n        njs_internal_error(vm, \"lvlhsh insert failed\");\n        return NJS_ERROR;\n    }\n    return NJS_OK;\n}\nnjs_int_t\nnjs_function_arguments_object_init(njs_vm_t *vm, njs_native_frame_t *frame)\n{\n    njs_int_t           ret;\n    njs_uint_t          nargs, n;\n    njs_value_t         value;\n    njs_object_t        *arguments;\n    njs_object_prop_t   *prop;\n    njs_lvlhsh_query_t  lhq;\n    static const njs_value_t  njs_string_length = njs_string(\"length\");\n    arguments = njs_object_alloc(vm);\n    if (njs_slow_path(arguments == NULL)) {\n        return NJS_ERROR;\n    }\n    arguments->shared_hash = vm->shared->arguments_object_instance_hash;\n    nargs = frame->nargs;\n    njs_set_number(&value, nargs);\n    prop = njs_object_prop_alloc(vm, &njs_string_length, &value, 1);\n    if (njs_slow_path(prop == NULL)) {\n        return NJS_ERROR;\n    }\n    prop->enumerable = 0;\n    lhq.value = prop;\n    lhq.key_hash = NJS_LENGTH_HASH;\n    njs_string_get(&prop->name, &lhq.key);\n    lhq.replace = 0;\n    lhq.pool = vm->mem_pool;\n    lhq.proto = &njs_object_hash_proto;\n    ret = njs_lvlhsh_insert(&arguments->hash, &lhq);\n    if (njs_slow_path(ret != NJS_OK)) {\n        njs_internal_error(vm, \"lvlhsh insert failed\");\n        return NJS_ERROR;\n    }\n    for (n = 0; n < nargs; n++) {\n        njs_uint32_to_string(&value, n);\n        prop = njs_object_prop_alloc(vm, &value, &frame->arguments[n], 1);\n        if (njs_slow_path(prop == NULL)) {\n            return NJS_ERROR;\n        }\n        lhq.value = prop;\n        njs_string_get(&prop->name, &lhq.key);\n        lhq.key_hash = njs_djb_hash(lhq.key.start, lhq.key.length);\n        ret = njs_lvlhsh_insert(&arguments->hash, &lhq);\n        if (njs_slow_path(ret != NJS_OK)) {\n            njs_internal_error(vm, \"lvlhsh insert failed\");\n            return NJS_ERROR;\n        }\n    }\n    frame->arguments_object = arguments;\n    return NJS_OK;\n}\nconst njs_object_prop_t  njs_arguments_object_instance_properties[] =\n{\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"callee\"),\n        .value = njs_value(NJS_INVALID, 1, NAN),\n        .getter = njs_native_function(njs_function_prototype_thrower, 0),\n        .setter = njs_native_function(njs_function_prototype_thrower, 0),\n        .writable = NJS_ATTRIBUTE_UNSET,\n    },\n};\nconst njs_object_init_t  njs_arguments_object_instance_init = {\n    njs_arguments_object_instance_properties,\n    njs_nitems(njs_arguments_object_instance_properties),\n};\nnjs_int_t\nnjs_function_native_frame(njs_vm_t *vm, njs_function_t *function,\n    const njs_value_t *this, const njs_value_t *args, njs_uint_t nargs,\n    njs_bool_t ctor)\n{\n    size_t              size;\n    njs_uint_t          n;\n    njs_value_t         *value, *bound;\n    njs_native_frame_t  *frame;\n    size = NJS_NATIVE_FRAME_SIZE\n           + (function->args_offset + nargs) * sizeof(njs_value_t);\n    frame = njs_function_frame_alloc(vm, size);\n    if (njs_slow_path(frame == NULL)) {\n        return NJS_ERROR;\n    }\n    frame->function = function;\n    frame->nargs = function->args_offset + nargs;\n    frame->ctor = ctor;\n    frame->native = 1;\n    frame->pc = NULL;\n    value = (njs_value_t *) ((u_char *) frame + NJS_NATIVE_FRAME_SIZE);\n    frame->arguments = value;\n    frame->arguments_offset = value + function->args_offset;\n    bound = function->bound;\n    if (bound == NULL) {\n        *value++ = *this;\n    } else {\n        n = function->args_offset;\n        do {\n            *value++ = *bound++;\n            n--;\n        } while (n != 0);\n    }\n    if (args != NULL) {\n        memcpy(value, args, nargs * sizeof(njs_value_t));\n    }\n    return NJS_OK;\n}\nnjs_int_t\nnjs_function_lambda_frame(njs_vm_t *vm, njs_function_t *function,\n    const njs_value_t *this, const njs_value_t *args, njs_uint_t nargs,\n    njs_bool_t ctor)\n{\n    size_t                 n, frame_size;\n    uint32_t               args_count, value_count, value_size, temp_size;\n    njs_value_t            *value, *bound, **new, **temp;\n    njs_frame_t            *frame;\n    njs_function_t         *target;\n    njs_native_frame_t     *native_frame;\n    njs_function_lambda_t  *lambda;\n    bound = function->bound;\n    if (njs_fast_path(bound == NULL)) {\n        lambda = function->u.lambda;\n        target = function;\n    } else {\n        target = function->u.bound_target;\n        if (njs_slow_path(target->bound != NULL)) {\n            njs_internal_error(vm, \"chain of bound function are not supported\");\n            return NJS_ERROR;\n        }\n        lambda = target->u.lambda;\n    }\n    args_count = function->args_offset + njs_max(nargs, lambda->nargs);\n    value_count = args_count + njs_max(args_count, lambda->nlocal);\n    value_size = value_count * sizeof(njs_value_t *);\n    temp_size = lambda->temp * sizeof(njs_value_t *);\n    frame_size = value_size + temp_size\n                        + ((value_count + lambda->temp) * sizeof(njs_value_t));\n    native_frame = njs_function_frame_alloc(vm, NJS_FRAME_SIZE + frame_size);\n    if (njs_slow_path(native_frame == NULL)) {\n        return NJS_ERROR;\n    }\n    new = (njs_value_t **) ((u_char *) native_frame + NJS_FRAME_SIZE);\n    value = (njs_value_t *) ((u_char *) new + value_size + temp_size);\n    n = value_count + lambda->temp;\n    while (n != 0) {\n        n--;\n        new[n] = &value[n];\n        njs_set_invalid(new[n]);\n    }\n    temp = (njs_value_t **) ((u_char *) native_frame + NJS_FRAME_SIZE\n                                                     + value_size);\n    native_frame->arguments = value;\n    native_frame->arguments_offset = value + (function->args_offset - 1);\n    native_frame->local = new + args_count;\n    native_frame->temp = temp;\n    native_frame->function = target;\n    native_frame->nargs = nargs;\n    native_frame->ctor = ctor;\n    native_frame->native = 0;\n    native_frame->pc = NULL;\n    *native_frame->local[0] = *this;\n    if (njs_slow_path(function->global_this\n                      && njs_is_null_or_undefined(this)))\n    {\n        njs_set_object(native_frame->local[0], &vm->global_object);\n    }\n    if (bound != NULL) {\n        n = function->args_offset;\n        native_frame->nargs += n - 1;\n        if (!ctor) {\n            *native_frame->local[0] = *bound;\n        }\n        bound++;\n        n--;\n        while (n != 0) {\n            *value++ = *bound++;\n            n--;\n        };\n    }\n    if (args != NULL) {\n        while (nargs != 0) {\n            *value++ = *args++;\n            nargs--;\n        }\n    }\n    frame = (njs_frame_t *) native_frame;\n    frame->exception.catch = NULL;\n    frame->exception.next = NULL;\n    frame->previous_active_frame = vm->active_frame;\n    return NJS_OK;\n}\nnjs_native_frame_t *\nnjs_function_frame_alloc(njs_vm_t *vm, size_t size)\n{\n    size_t              spare_size, chunk_size;\n    njs_native_frame_t  *frame;\n    spare_size = vm->top_frame ? vm->top_frame->free_size : 0;\n    if (njs_fast_path(size <= spare_size)) {\n        frame = (njs_native_frame_t *) vm->top_frame->free;\n        chunk_size = 0;\n    } else {\n        spare_size = size + NJS_FRAME_SPARE_SIZE;\n        spare_size = njs_align_size(spare_size, NJS_FRAME_SPARE_SIZE);\n        if (vm->stack_size + spare_size > NJS_MAX_STACK_SIZE) {\n            njs_range_error(vm, \"Maximum call stack size exceeded\");\n            return NULL;\n        }\n        frame = njs_mp_align(vm->mem_pool, sizeof(njs_value_t), spare_size);\n        if (njs_slow_path(frame == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n        chunk_size = spare_size;\n        vm->stack_size += spare_size;\n    }\n    njs_memzero(frame, sizeof(njs_native_frame_t));\n    frame->size = chunk_size;\n    frame->free_size = spare_size - size;\n    frame->free = (u_char *) frame + size;\n    frame->previous = vm->top_frame;\n    vm->top_frame = frame;\n    return frame;\n}\nnjs_int_t\nnjs_function_lambda_call(njs_vm_t *vm, void *promise_cap, void *async_ctx)\n{\n    uint32_t               n;\n    njs_int_t              ret;\n    njs_frame_t            *frame;\n    njs_value_t            *args, **local, *value;\n    njs_value_t            **cur_local, **cur_closures, **cur_temp;\n    njs_function_t         *function;\n    njs_declaration_t      *declr;\n    njs_function_lambda_t  *lambda;\n    frame = (njs_frame_t *) vm->top_frame;\n    function = frame->native.function;\n    njs_assert(function->context == NULL);\n    if (function->global && !function->closure_copied) {\n        ret = njs_function_capture_global_closures(vm, function);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    lambda = function->u.lambda;\n    args = vm->top_frame->arguments;\n    local = vm->top_frame->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(args)) {\n            njs_set_undefined(args);\n        }\n        *local++ = args++;\n    }\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    vm->levels[NJS_LEVEL_LOCAL] = vm->top_frame->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(function);\n    vm->levels[NJS_LEVEL_TEMP] = frame->native.temp;\n    if (lambda->rest_parameters) {\n        ret = njs_function_rest_parameters_init(vm, &frame->native);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (lambda->self != NJS_INDEX_NONE) {\n        value = njs_scope_value(vm, lambda->self);\n        if (!njs_is_valid(value)) {\n            njs_set_function(value, function);\n        }\n    }\n    vm->active_frame = frame;\n    n = lambda->ndeclarations;\n    while (n != 0) {\n        n--;\n        declr = &lambda->declarations[n];\n        value = njs_scope_value(vm, declr->index);\n        *value = *declr->value;\n        function = njs_function_value_copy(vm, value);\n        if (njs_slow_path(function == NULL)) {\n            return NJS_ERROR;\n        }\n        ret = njs_function_capture_closure(vm, function, function->u.lambda);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    ret = njs_vmcode_interpreter(vm, lambda->start, promise_cap, async_ctx);\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    return ret;\n}\nnjs_int_t\nnjs_function_native_call(njs_vm_t *vm)\n{\n    njs_int_t              ret;\n    njs_function_t         *function, *target;\n    njs_native_frame_t     *native, *previous;\n    njs_function_native_t  call;\n    native = vm->top_frame;\n    function = native->function;\n    if (njs_fast_path(function->bound == NULL)) {\n        call = function->u.native;\n    } else {\n        target = function->u.bound_target;\n        if (njs_slow_path(target->bound != NULL)) {\n            njs_internal_error(vm, \"chain of bound function are not supported\");\n            return NJS_ERROR;\n        }\n        call = target->u.native;\n    }\n    ret = call(vm, native->arguments, native->nargs, function->magic8);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    if (ret == NJS_DECLINED) {\n        return NJS_OK;\n    }\n    previous = njs_function_previous_frame(native);\n    njs_vm_scopes_restore(vm, native, previous);\n    if (!native->skip) {\n        *native->retval = vm->retval;\n    }\n    njs_function_frame_free(vm, native);\n    return NJS_OK;\n}\nnjs_int_t\nnjs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}\nnjs_inline \nnjs_int_t\nnjs_function_capture_global_closures(njs_vm_t *vm, njs_function_t *function)\n{\n    void                   *start, *end;\n    uint32_t               n;\n    njs_value_t            *value, **refs, **global;\n    njs_index_t            *indexes, index;\n    njs_native_frame_t     *native;\n    njs_function_lambda_t  *lambda;\n    lambda = function->u.lambda;\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n    native = vm->top_frame;\n    while (native->previous->function != NULL) {\n        native = native->previous;\n    }\n    start = native;\n    end = native->free;\n    indexes = lambda->closures;\n    refs = njs_function_closures(function);\n    global = vm->levels[NJS_LEVEL_GLOBAL];\n    n = lambda->nclosures;\n    while (n > 0) {\n        n--;\n        index = indexes[n];\n        switch (njs_scope_index_type(index)) {\n        case NJS_LEVEL_LOCAL:\n            value = njs_function_closure_value(vm, native->local, index,\n                                               start, end);\n            break;\n        case NJS_LEVEL_GLOBAL:\n            value = njs_function_closure_value(vm, global, index, start, end);\n            break;\n        default:\n            njs_type_error(vm, \"unexpected value type for closure \\\"%uD\\\"\",\n                           njs_scope_index_type(index));\n            return NJS_ERROR;\n        }\n        if (njs_slow_path(value == NULL)) {\n            return NJS_ERROR;\n        }\n        refs[n] = value;\n    }\n    function->closure_copied = 1;\n    return NJS_OK;\n}\nnjs_int_t\nnjs_function_prototype_create(njs_vm_t *vm, njs_object_prop_t *prop,\n    njs_value_t *value, njs_value_t *setval, njs_value_t *retval)\n{\n    njs_value_t     *proto, proto_value, *cons;\n    njs_object_t    *prototype;\n    njs_function_t  *function;\n    if (setval == NULL) {\n        prototype = njs_object_alloc(vm);\n        if (njs_slow_path(prototype == NULL)) {\n            return NJS_ERROR;\n        }\n        njs_set_object(&proto_value, prototype);\n        setval = &proto_value;\n    }\n    function = njs_function_value_copy(vm, value);\n    if (njs_slow_path(function == NULL)) {\n        return NJS_ERROR;\n    }\n    proto = njs_function_property_prototype_set(vm, njs_object_hash(value),\n                                                setval);\n    if (njs_slow_path(proto == NULL)) {\n        return NJS_ERROR;\n    }\n    if (setval == &proto_value && njs_is_object(proto)) {\n        cons = njs_property_constructor_set(vm, njs_object_hash(proto), value);\n        if (njs_slow_path(cons == NULL)) {\n            return NJS_ERROR;\n        }\n    }\n    *retval = *proto;\n    return NJS_OK;\n}\nnjs_int_t\nnjs_function_constructor(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t async)\n{\n    njs_chb_t               chain;\n    njs_int_t               ret;\n    njs_str_t               str, file;\n    njs_uint_t              i;\n    njs_parser_t            parser;\n    njs_vm_code_t           *code;\n    njs_function_t          *function;\n    njs_generator_t         generator;\n    njs_parser_node_t       *node;\n    njs_function_lambda_t   *lambda;\n    const njs_token_type_t  *type;\n    static const njs_token_type_t  safe_ast[] = {\n        NJS_TOKEN_END,\n        NJS_TOKEN_FUNCTION_EXPRESSION,\n        NJS_TOKEN_STATEMENT,\n        NJS_TOKEN_RETURN,\n        NJS_TOKEN_THIS,\n        NJS_TOKEN_ILLEGAL\n    };\n    static const njs_token_type_t  safe_ast_async[] = {\n        NJS_TOKEN_END,\n        NJS_TOKEN_ASYNC_FUNCTION_EXPRESSION,\n        NJS_TOKEN_STATEMENT,\n        NJS_TOKEN_RETURN,\n        NJS_TOKEN_THIS,\n        NJS_TOKEN_ILLEGAL\n    };\n    if (!vm->options.unsafe && nargs != 2) {\n        goto fail;\n    }\n    njs_chb_init(&chain, vm->mem_pool);\n    if (async) {\n        njs_chb_append_literal(&chain, \"(async function(\");\n    } else {\n        njs_chb_append_literal(&chain, \"(function(\");\n    }\n    for (i = 1; i < nargs - 1; i++) {\n        ret = njs_value_to_chain(vm, &chain, njs_argument(args, i));\n        if (njs_slow_path(ret < NJS_OK)) {\n            return ret;\n        }\n        if (i != (nargs - 2)) {\n            njs_chb_append_literal(&chain, \",\");\n        }\n    }\n    njs_chb_append_literal(&chain, \"){\");\n    ret = njs_value_to_chain(vm, &chain, njs_argument(args, nargs - 1));\n    if (njs_slow_path(ret < NJS_OK)) {\n        return ret;\n    }\n    njs_chb_append_literal(&chain, \"})\");\n    ret = njs_chb_join(&chain, &str);\n    if (njs_slow_path(ret != NJS_OK)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n    file = njs_str_value(\"runtime\");\n    ret = njs_parser_init(vm, &parser, NULL, &file, str.start,\n                          str.start + str.length, 1);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_parser(vm, &parser);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    if (!vm->options.unsafe) {\n        node = parser.node;\n        type = (async) ? &safe_ast_async[0] : &safe_ast[0];\n        for (; *type != NJS_TOKEN_ILLEGAL; type++, node = node->right) {\n            if (node == NULL) {\n                goto fail;\n            }\n            if (node->left != NULL\n                && node->token_type != NJS_TOKEN_FUNCTION_EXPRESSION\n                && node->left->token_type != NJS_TOKEN_NAME)\n            {\n                goto fail;\n            }\n            if (node->token_type != *type) {\n                goto fail;\n            }\n        }\n    }\n    ret = njs_generator_init(&generator, &file, 0, 1);\n    if (njs_slow_path(ret != NJS_OK)) {\n        njs_internal_error(vm, \"njs_generator_init() failed\");\n        return NJS_ERROR;\n    }\n    code = njs_generate_scope(vm, &generator, parser.scope,\n                              &njs_entry_anonymous);\n    if (njs_slow_path(code == NULL)) {\n        if (!njs_is_error(&vm->retval)) {\n            njs_internal_error(vm, \"njs_generate_scope() failed\");\n        }\n        return NJS_ERROR;\n    }\n    njs_chb_destroy(&chain);\n    lambda = ((njs_vmcode_function_t *) generator.code_start)->lambda;\n    function = njs_function_alloc(vm, lambda, (njs_bool_t) async);\n    if (njs_slow_path(function == NULL)) {\n        return NJS_ERROR;\n    }\n    function->global = 1;\n    function->global_this = 1;\n    function->args_count = lambda->nargs - lambda->rest_parameters;\n    njs_set_function(&vm->retval, function);\n    return NJS_OK;\nfail:\n    njs_type_error(vm, \"function constructor is disabled in \\\"safe\\\" mode\");\n    return NJS_ERROR;\n}\nstatic const njs_object_prop_t  njs_function_constructor_properties[] =\n{\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"name\"),\n        .value = njs_string(\"Function\"),\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"length\"),\n        .value = njs_value(NJS_NUMBER, 1, 1.0),\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY_HANDLER,\n        .name = njs_string(\"prototype\"),\n        .value = njs_prop_handler(njs_object_prototype_create),\n    },\n};\nconst njs_object_init_t  njs_function_constructor_init = {\n    njs_function_constructor_properties,\n    njs_nitems(njs_function_constructor_properties),\n};\nstatic njs_int_t\nnjs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    }\n    if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    if (njs_slow_path(length > 1024)) {\n        njs_internal_error(vm, \"argument list is too long\");\n        return NJS_ERROR;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}\nstatic njs_int_t\nnjs_function_prototype_bind(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    size_t              size;\n    njs_int_t           ret;\n    njs_value_t         *values, name;\n    njs_function_t      *function;\n    njs_lvlhsh_query_t  lhq;\n    if (!njs_is_function(&args[0])) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    function = njs_mp_alloc(vm->mem_pool, sizeof(njs_function_t));\n    if (njs_slow_path(function == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n    *function = *njs_function(&args[0]);\n    njs_lvlhsh_init(&function->object.hash);\n    function->object.shared_hash = vm->shared->arrow_instance_hash;\n    function->object.__proto__ = &vm->prototypes[NJS_OBJ_TYPE_FUNCTION].object;\n    function->object.shared = 0;\n    function->u.bound_target = njs_function(&args[0]);\n    njs_object_property_init(&lhq, &njs_string_name, NJS_NAME_HASH);\n    ret = njs_object_property(vm, &args[0], &lhq, &name);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    if (!njs_is_string(&name)) {\n        name = njs_string_empty;\n    }\n    ret = njs_function_name_set(vm, function, &name, \"bound\");\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    if (nargs == 1) {\n        args = njs_value_arg(&njs_value_undefined);\n    } else {\n        nargs--;\n        args++;\n    }\n    if (nargs > function->args_count) {\n        function->args_count = 0;\n    } else {\n        function->args_count -= nargs - 1;\n    }\n    function->args_offset = nargs;\n    size = nargs * sizeof(njs_value_t);\n    values = njs_mp_alloc(vm->mem_pool, size);\n    if (njs_slow_path(values == NULL)) {\n        njs_memory_error(vm);\n        njs_mp_free(vm->mem_pool, function);\n        return NJS_ERROR;\n    }\n    function->bound = values;\n    memcpy(values, args, size);\n    njs_set_function(&vm->retval, function);\n    return NJS_OK;\n}\nstatic const njs_object_prop_t  njs_function_prototype_properties[] =\n{\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"name\"),\n        .value = njs_string(\"\"),\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"length\"),\n        .value = njs_value(NJS_NUMBER, 0, 0.0),\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY_HANDLER,\n        .name = njs_string(\"constructor\"),\n        .value = njs_prop_handler(njs_object_prototype_create_constructor),\n        .writable = 1,\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"call\"),\n        .value = njs_native_function(njs_function_prototype_call, 1),\n        .writable = 1,\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"apply\"),\n        .value = njs_native_function(njs_function_prototype_apply, 2),\n        .writable = 1,\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"bind\"),\n        .value = njs_native_function(njs_function_prototype_bind, 1),\n        .writable = 1,\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"caller\"),\n        .value = njs_value(NJS_INVALID, 1, NAN),\n        .getter = njs_native_function(njs_function_prototype_thrower, 0),\n        .setter = njs_native_function(njs_function_prototype_thrower, 0),\n        .writable = NJS_ATTRIBUTE_UNSET,\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY,\n        .name = njs_string(\"arguments\"),\n        .value = njs_value(NJS_INVALID, 1, NAN),\n        .getter = njs_native_function(njs_function_prototype_thrower, 0),\n        .setter = njs_native_function(njs_function_prototype_thrower, 0),\n        .writable = NJS_ATTRIBUTE_UNSET,\n        .configurable = 1,\n    },\n};\nconst njs_object_init_t  njs_function_prototype_init = {\n    njs_function_prototype_properties,\n    njs_nitems(njs_function_prototype_properties),\n};\nconst njs_object_prop_t  njs_function_instance_properties[] =\n{\n    {\n        .type = NJS_PROPERTY_HANDLER,\n        .name = njs_string(\"length\"),\n        .value = njs_prop_handler(njs_function_instance_length),\n        .configurable = 1,\n    },\n    {\n        .type = NJS_PROPERTY_HANDLER,\n        .name = njs_string(\"prototype\"),\n        .value = njs_prop_handler(njs_function_prototype_create),\n        .writable = 1\n    },\n};\nconst njs_object_init_t  njs_function_instance_init = {\n    njs_function_instance_properties,\n    njs_nitems(njs_function_instance_properties),\n};\nconst njs_object_prop_t  njs_arrow_instance_properties[] =\n{\n    {\n        .type = NJS_PROPERTY_HANDLER,\n        .name = njs_string(\"length\"),\n        .value = njs_prop_handler(njs_function_instance_length),\n        .configurable = 1,\n    },\n};\nconst njs_object_init_t  njs_arrow_instance_init = {\n    njs_arrow_instance_properties,\n    njs_nitems(njs_arrow_instance_properties),\n};\nconst njs_object_type_init_t  njs_function_type_init = {\n   .constructor = njs_native_ctor(njs_function_constructor, 1, 0),\n   .constructor_props = &njs_function_constructor_init,\n   .prototype_props = &njs_function_prototype_init,\n   .prototype_value = { .function = { .native = 1,\n                                      .args_offset = 1,\n                                      .u.native = njs_prototype_function,\n                                      .object = { .type = NJS_FUNCTION } } },\n};\nFile number 2:\n/*---\nincludes: [compareArray.js]\nflags: [async]\n---*/\n\nlet stages = [];\n\nasync function f(v) {\n    if (v == 3) {\n        return;\n    }\n\n    stages.push(`f>${v}`);\n\n    await \"X\";\n\n    f(v + 1);\n\n    stages.push(`f<${v}`);\n}\n\nf(0)\n.then(v => {\n    assert.compareArray(stages, ['f>0','f>1','f<0','f>2','f<1']);\n})\n.then($DONE, $DONE);\n\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_7946.c",
        "project": "nginx/njs",
        "url": "https://github.com/nginx/njs/commit/ad48705bf1f04b4221a5f5b07715ac48b3160d53",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int read_image_tga( gdIOCtx *ctx, oTga *tga )\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint bitmap_caret = 0;\n\tif(overflow2(tga->width, tga->height)) {\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\tif(overflow2(image_block_size, sizeof(int))) {\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t}\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t}\n\t\tbuffer_caret = 0;\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\tbuffer_caret = 0;\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif \n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"gd_tga.h\"\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\tfree_tga(tga);\n\treturn image;\n}\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\tunsigned char header[18];\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\ttga->ident = NULL;\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\treturn 1;\n}\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\tcase TGA_TYPE_RGB_RLE:\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\t\tbuffer_caret = 0;\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\t\tbuffer_caret = 0;\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\treturn 1;\n}\nFile number 2:\nlibgd_test_programs += \\\n\ttga/bug00084 \\\n\ttga/bug00247 \\\n\ttga/bug00247a \\\n\ttga/bug00248 \\\n\ttga/bug00248a \\\n\ttga/heap_overflow \\\n\ttga/tga_null \\\n\ttga/tga_read\n\nEXTRA_DIST += \\\n\ttga/CMakeLists.txt \\\n\ttga/bug00084.tga \\\n\ttga/bug00247.tga \\\n\ttga/bug00247a.tga \\\n\ttga/bug00248.tga \\\n\ttga/bug00248a.tga \\\n\ttga/heap_overflow.tga \\\n\ttga/tga_read_rgb.png \\\n\ttga/tga_read_rgb.tga \\\n\ttga/tga_read_rgb_rle.tga\n\nFile number 3:\n/**\n * Test that the crafted TGA file doesn't trigger OOB reads.\n */\n\n\n#include \"gd.h\"\n#include \"gdtest.h\"\n\n\nstatic size_t read_test_file(char **buffer, char *basename);\n\n\nint main()\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n\n    size = read_test_file(&buffer, \"heap_overflow.tga\");\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n\n    return gdNumFailures();\n}\n\n\nstatic size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n\n    filename = gdTestFilePath2(\"tga\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n\n    fclose(fp);\n    free(filename);\n\n    return act_size;\n}\n\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_1785.c",
        "project": "libgd/libgd",
        "url": "https://github.com/libgd/libgd/commit/58b6dde319c301b0eae27d12e2a659e067d80558",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\n    a = fgetc(infile);\n    if (a != 0xff || fgetc(infile) != M_SOI){\n    }\n        for (a=0;;a++){\n            marker = fgetc(infile);\n            if (marker != 0xff && prev == 0xff) break;\n            if (marker == EOF){\n                ErrFatal(\"Unexpected end of file\");\n            }\n        }\n        lh = fgetc(infile);\n        ll = fgetc(infile);\n        if (lh == EOF || ll == EOF){\n        }\n        itemlen = (lh << 8) | ll;\n        if (itemlen < 2){\n        }\n        Sections[SectionsRead].Size = itemlen;\n        Data = (uchar *)malloc(itemlen);\n        if (Data == NULL){\n        }\n        Sections[SectionsRead].Data = Data;\n        Data[0] = (uchar)lh;\n        Data[1] = (uchar)ll;\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\n                if (ReadMode & READ_IMAGE){\n                    cp = ftell(infile);\n                    fseek(infile, 0, SEEK_END);\n                    ep = ftell(infile);\n                    fseek(infile, cp, SEEK_SET);\n                    size = ep-cp;\n                    Data = (uchar *)malloc(size);\n                    if (Data == NULL){\n                    }\n                    got = fread(Data, 1, size, infile);\n                }\n                if (itemlen < 16){\n                }\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\n                }\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\n                if (ShowTags){\n                    if (Data[14] || Data[15]){\n                    }\n                }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"jhead.h\"\nImageInfo_t ImageInfo;\nstatic Section_t * Sections = NULL;\nstatic int SectionsAllocated;\nstatic int SectionsRead;\nstatic int HaveAll;\n#define PSEUDO_IMAGE_MARKER 0x123; // Extra value.\nstatic void process_COM (const uchar * Data, int length)\n{\n    int ch;\n    char Comment[MAX_COMMENT_SIZE+1];\n    int nch;\n    int a;\n    nch = 0;\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; // Truncate if it won't fit in our structure.\n    for (a=2;a<length;a++){\n        ch = Data[a];\n        if (ch == '\\r' && Data[a+1] == '\\n') continue; // Remove cr followed by lf.\n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\n            Comment[nch++] = (char)ch;\n        }else{\n            Comment[nch++] = '?';\n        }\n    }\n    Comment[nch] = '\\0'; // Null terminate\n    if (ShowTags){\n        printf(\"COM marker comment: %s\\n\",Comment);\n    }\n    strcpy(ImageInfo.Comments,Comment);\n}\nint ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\n{\n    int a;\n    int HaveCom = FALSE;\n    a = fgetc(infile);\n    if (a != 0xff || fgetc(infile) != M_SOI){\n        return FALSE;\n    }\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\n    for(;;){\n        int itemlen;\n        int prev;\n        int marker = 0;\n        int ll,lh, got;\n        uchar * Data;\n        CheckSectionsAllocated();\n        prev = 0;\n        for (a=0;;a++){\n            marker = fgetc(infile);\n            if (marker != 0xff && prev == 0xff) break;\n            if (marker == EOF){\n                ErrFatal(\"Unexpected end of file\");\n            }\n            prev = marker;\n        }\n        if (a > 10){\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\n        }\n        Sections[SectionsRead].Type = marker;\n        // Read the length of the section.\n        lh = fgetc(infile);\n        ll = fgetc(infile);\n        if (lh == EOF || ll == EOF){\n            ErrFatal(\"Unexpected end of file\");\n        }\n        itemlen = (lh << 8) | ll;\n        if (itemlen < 2){\n            ErrFatal(\"invalid marker\");\n        }\n        Sections[SectionsRead].Size = itemlen;\n        Data = (uchar *)malloc(itemlen);\n        if (Data == NULL){\n            ErrFatal(\"Could not allocate memory\");\n        }\n        Sections[SectionsRead].Data = Data;\n        // Store first two pre-read bytes.\n        Data[0] = (uchar)lh;\n        Data[1] = (uchar)ll;\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\n        if (got != itemlen-2){\n            ErrFatal(\"Premature end of file?\");\n        }\n        SectionsRead += 1;\n        switch(marker){\n            case M_SOS:   // stop before hitting compressed data \n                // If reading entire image is requested, read the rest of the data.\n                if (ReadMode & READ_IMAGE){\n                    int cp, ep, size;\n                    // Determine how much file is left.\n                    cp = ftell(infile);\n                    fseek(infile, 0, SEEK_END);\n                    ep = ftell(infile);\n                    fseek(infile, cp, SEEK_SET);\n                    size = ep-cp;\n                    Data = (uchar *)malloc(size);\n                    if (Data == NULL){\n                        ErrFatal(\"could not allocate data for entire image\");\n                    }\n                    got = fread(Data, 1, size, infile);\n                    if (got != size){\n                        ErrFatal(\"could not read the rest of the image\");\n                    }\n                    CheckSectionsAllocated();\n                    Sections[SectionsRead].Data = Data;\n                    Sections[SectionsRead].Size = size;\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\n                    SectionsRead ++;\n                    HaveAll = 1;\n                }\n                return TRUE;\n            case M_DQT:\n                // Use for jpeg quality guessing\n                process_DQT(Data, itemlen);\n                break;\n            case M_DHT:   \n                // Use for jpeg quality guessing\n                process_DHT(Data, itemlen);\n                break;\n            case M_EOI:   // in case it's a tables-only JPEG stream\n                fprintf(stderr,\"No image in jpeg!\\n\");\n                return FALSE;\n            case M_COM: // Comment section\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\n                    // Discard this section.\n                    free(Sections[--SectionsRead].Data);\n                }else{\n                    process_COM(Data, itemlen);\n                    HaveCom = TRUE;\n                }\n                break;\n            case M_JFIF:\n                // Regular jpegs always have this tag, exif images have the exif\n                // marker instead, althogh ACDsee will write images with both markers.\n                // this program will re-create this marker on absence of exif marker.\n                // hence no need to keep the copy from the file.\n                if (itemlen < 16){\n                    fprintf(stderr,\"Jfif header too short\\n\");\n                    goto ignore;\n                }\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\n                }\n                ImageInfo.JfifHeader.Present = TRUE;\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\n                if (ShowTags){\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\n                        case 0: printf(\"(aspect ratio)\"); break;\n                        case 1: printf(\"(dots per inch)\"); break;\n                        case 2: printf(\"(dots per cm)\"); break;\n                        default: printf(\"(unknown)\"); break;\n                    }\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\n                    if (Data[14] || Data[15]){\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\n                    }\n                }\n                ignore:\n                free(Sections[--SectionsRead].Data);\n                break;\n            case M_EXIF:\n                // There can be different section using the same marker.\n                if (ReadMode & READ_METADATA){\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\n                        process_EXIF(Data, itemlen);\n                        break;\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\n                        if (ShowTags){\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\n                            if (ShowTags){\n                                ShowXmp(Sections[SectionsRead-1]);\n                            }\n                        }\n                        break;\n                    }\n                }\n                // Oterwise, discard this section.\n                free(Sections[--SectionsRead].Data);\n                break;\n            case M_IPTC:\n                if (ReadMode & READ_METADATA){\n                    if (ShowTags){\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\n                    }\n                    // Note: We just store the IPTC section.  Its relatively straightforward\n                    // and we don't act on any part of it, so just display it at parse time.\n                }else{\n                    free(Sections[--SectionsRead].Data);\n                }\n                break;\n            case M_SOF0: \n            case M_SOF1: \n            case M_SOF2: \n            case M_SOF3: \n            case M_SOF5: \n            case M_SOF6: \n            case M_SOF7: \n            case M_SOF9: \n            case M_SOF10:\n            case M_SOF11:\n            case M_SOF13:\n            case M_SOF14:\n            case M_SOF15:\n                if (itemlen < 8){\n                    fprintf(stderr,\"Section too short\\n\");\n                    break;\n                }\n                process_SOFn(Data, marker);\n                break;\n            default:\n                // Skip any other sections.\n                if (ShowTags){\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\n                }\n                break;\n        }\n    }\n    return TRUE;\n}\nint ReplaceThumbnail(const char * ThumbFileName)\n{\n    FILE * ThumbnailFile;\n    int ThumbLen, NewExifSize;\n    Section_t * ExifSection;\n    uchar * ThumbnailPointer;\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        if (ThumbFileName == NULL){\n            // Delete of nonexistent thumbnail (not even pointers present)\n            // No action, no error.\n            return FALSE;\n        }\n        // Adding or removing of thumbnail is not possible - that would require rearranging\n        // of the exif header, which is risky, and jhad doesn't know how to do.\n        fprintf(stderr,\"Image contains no thumbnail to replace - add is not possible\\n\");\n        return FALSE;\n    }\n    if (ThumbFileName){\n        ThumbnailFile = fopen(ThumbFileName,\"rb\");\n        if (ThumbnailFile == NULL){\n            noread:\n            ErrFatal(\"Could not read thumbnail file\");\n            return FALSE;\n        }\n        // get length\n        fseek(ThumbnailFile, 0, SEEK_END);\n        ThumbLen = ftell(ThumbnailFile);\n        fseek(ThumbnailFile, 0, SEEK_SET);\n        if (ThumbLen + ImageInfo.ThumbnailOffset > 0x10000-20){\n            ErrFatal(\"Thumbnail is too large to insert into exif header\");\n        }\n    }else{\n        if (ImageInfo.ThumbnailSize == 0){\n             return FALSE;\n        }\n        ThumbLen = 0;\n        ThumbnailFile = NULL;\n    }\n    ExifSection = FindSection(M_EXIF);\n    NewExifSize = ImageInfo.ThumbnailOffset+8+ThumbLen;\n    ExifSection->Data = (uchar *)realloc(ExifSection->Data, NewExifSize);\n    ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8;\n    if (ThumbnailFile){\n        if (fread(ThumbnailPointer, 1, ThumbLen, ThumbnailFile) != ThumbLen){\n            goto noread;\n        }\n        fclose(ThumbnailFile);\n    }\n    ImageInfo.ThumbnailSize = ThumbLen;\n    Put32u(ExifSection->Data+ImageInfo.ThumbnailSizeOffset+8, ThumbLen);\n    ExifSection->Data[0] = (uchar)(NewExifSize >> 8);\n    ExifSection->Data[1] = (uchar)NewExifSize;\n    ExifSection->Size = NewExifSize;\n    return TRUE;\n}\nvoid DiscardAllButExif(void)\n{\n    Section_t ExifKeeper;\n    Section_t CommentKeeper;\n    Section_t IptcKeeper;\n    Section_t XmpKeeper;\n    int a;\n    memset(&ExifKeeper, 0, sizeof(ExifKeeper));\n    memset(&CommentKeeper, 0, sizeof(CommentKeeper));\n    memset(&IptcKeeper, 0, sizeof(IptcKeeper));\n    memset(&XmpKeeper, 0, sizeof(IptcKeeper));\n    for (a=0;a<SectionsRead;a++){\n        if (Sections[a].Type == M_EXIF && ExifKeeper.Type == 0){\n           ExifKeeper = Sections[a];\n        }else if (Sections[a].Type == M_XMP && XmpKeeper.Type == 0){\n           XmpKeeper = Sections[a];\n        }else if (Sections[a].Type == M_COM && CommentKeeper.Type == 0){\n            CommentKeeper = Sections[a];\n        }else if (Sections[a].Type == M_IPTC && IptcKeeper.Type == 0){\n            IptcKeeper = Sections[a];\n        }else{\n            free(Sections[a].Data);\n        }\n    }\n    SectionsRead = 0;\n    if (ExifKeeper.Type){\n        CheckSectionsAllocated();\n        Sections[SectionsRead++] = ExifKeeper;\n    }\n    if (CommentKeeper.Type){\n        CheckSectionsAllocated();\n        Sections[SectionsRead++] = CommentKeeper;\n    }\n    if (IptcKeeper.Type){\n        CheckSectionsAllocated();\n        Sections[SectionsRead++] = IptcKeeper;\n    }\n    if (XmpKeeper.Type){\n        CheckSectionsAllocated();\n        Sections[SectionsRead++] = XmpKeeper;\n    }\n}    \nvoid WriteJpegFile(const char * FileName)\n{\n    FILE * outfile;\n    int a;\n    if (!HaveAll){\n        ErrFatal(\"Can't write back - didn't read all\");\n    }\n    outfile = fopen(FileName,\"wb\");\n    if (outfile == NULL){\n        ErrFatal(\"Could not open file for write\");\n    }\n    // Initial static jpeg marker.\n    fputc(0xff,outfile);\n    fputc(0xd8,outfile);\n    if (Sections[0].Type != M_EXIF && Sections[0].Type != M_JFIF){\n        // The image must start with an exif or jfif marker.  If we threw those away, create one.\n        static uchar JfifHead[18] = {\n            0xff, M_JFIF,\n            0x00, 0x10, 'J' , 'F' , 'I' , 'F' , 0x00, 0x01, \n            0x01, 0x01, 0x01, 0x2C, 0x01, 0x2C, 0x00, 0x00 \n        };\n        if (ImageInfo.ResolutionUnit == 2 || ImageInfo.ResolutionUnit == 3){\n            // Use the exif resolution info to fill out the jfif header.\n            // Usually, for exif images, there's no jfif header, so if wediscard\n            // the exif header, use info from the exif header for the jfif header.\n            ImageInfo.JfifHeader.ResolutionUnits = (char)(ImageInfo.ResolutionUnit-1);\n            // Jfif is 1 and 2, Exif is 2 and 3 for In and cm respecively\n            ImageInfo.JfifHeader.XDensity = (int)ImageInfo.xResolution;\n            ImageInfo.JfifHeader.YDensity = (int)ImageInfo.yResolution;\n        }\n        JfifHead[11] = ImageInfo.JfifHeader.ResolutionUnits;\n        JfifHead[12] = (uchar)(ImageInfo.JfifHeader.XDensity >> 8);\n        JfifHead[13] = (uchar)ImageInfo.JfifHeader.XDensity;\n        JfifHead[14] = (uchar)(ImageInfo.JfifHeader.YDensity >> 8);\n        JfifHead[15] = (uchar)ImageInfo.JfifHeader.YDensity;\n        fwrite(JfifHead, 18, 1, outfile);\n        // use the values from the exif data for the jfif header, if we have found values\n        if (ImageInfo.ResolutionUnit != 0) { \n            // JFIF.ResolutionUnit is {1,2}, EXIF.ResolutionUnit is {2,3}\n            JfifHead[11] = (uchar)ImageInfo.ResolutionUnit - 1; \n        }\n        if (ImageInfo.xResolution > 0.0 && ImageInfo.yResolution > 0.0) { \n            JfifHead[12] = (uchar)((int)ImageInfo.xResolution>>8);\n            JfifHead[13] = (uchar)((int)ImageInfo.xResolution);\n            JfifHead[14] = (uchar)((int)ImageInfo.yResolution>>8);\n            JfifHead[15] = (uchar)((int)ImageInfo.yResolution);\n        }\n    }\n    // Write all the misc sections\n    for (a=0;a<SectionsRead-1;a++){\n        fputc(0xff,outfile);\n        fputc((unsigned char)Sections[a].Type, outfile);\n        fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\n    }\n    // Write the remaining image data.\n    fwrite(Sections[a].Data, Sections[a].Size, 1, outfile);\n    fclose(outfile);\n}\nint RemoveUnknownSections(void)\n{\n    int a;\n    int Modified = FALSE;\n    for (a=0;a<SectionsRead-1;){\n        switch(Sections[a].Type){\n            case  M_SOF0:\n            case  M_SOF1:\n            case  M_SOF2:\n            case  M_SOF3:\n            case  M_SOF5:\n            case  M_SOF6:\n            case  M_SOF7:\n            case  M_SOF9:\n            case  M_SOF10:\n            case  M_SOF11:\n            case  M_SOF13:\n            case  M_SOF14:\n            case  M_SOF15:\n            case  M_SOI:\n            case  M_EOI:\n            case  M_SOS:\n            case  M_JFIF:\n            case  M_EXIF:\n            case  M_XMP:\n            case  M_COM:\n            case  M_DQT:\n            case  M_DHT:\n            case  M_DRI:\n            case  M_IPTC:\n                // keep.\n                a++;\n                break;\n            default:\n                // Unknown.  Delete.\n                free (Sections[a].Data);\n                // Move succeding sections back by one to close space in array.\n                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\n                SectionsRead -= 1;\n                Modified = TRUE;\n        }\n    }\n    return Modified;\n}\n",
        "cwe": "CWE-120",
        "file_name": "vul_respovul_idx_12152.c",
        "project": "matthias-wandel/jhead",
        "url": "https://github.com/Matthias-Wandel/jhead/commit/4827ed31c226dc5ed93603bd649e0e387a1778da",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```   memset(params, '\\0', PARAMS_LEN+1);\n      memset(params, '\\0', PARAMS_LEN+1);\n      snprintf(params, 5, \"arp:\");\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <ec.h>\n#include <ec_gtk.h>\nvoid gtkui_conf_set(char *name, short value);\nshort gtkui_conf_get(char *name);\nvoid gtkui_conf_read(void);\nvoid gtkui_conf_save(void);\nstatic char *filename = NULL;\nstatic struct gtk_conf_entry settings[] = {\n   { \"window_top\", 0 },\n   { \"window_left\", 0 },\n   { \"window_height\", 440 },\n   { \"window_width\", 600 },\n   { NULL, 0 },\n};\nvoid gtkui_conf_set(char *name, short value) {\n   short c = 0;\n   DEBUG_MSG(\"gtkui_conf_set: name=%s value=%hu\", name, value);\n   for(c = 0; settings[c].name != NULL; c++) {\n      if(!strcmp(name, settings[c].name)) {\n          settings[c].value = value;\n          break;\n      }\n   }\n}\nvoid gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_home_dir();\n#endif\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}\nFile number 2:\n#include <ec.h>\n#include <ec_gtk.h>\n#include <ec_mitm.h>\nvoid gtkui_arp_poisoning(void);\nvoid gtkui_icmp_redir(void);\nvoid gtkui_port_stealing(void);\nvoid gtkui_dhcp_spoofing(void);\nvoid gtkui_mitm_stop(void);\nstatic void gtkui_start_mitm(void);\n#define PARAMS_LEN   512\nstatic char params[PARAMS_LEN+1];\nvoid gtkui_arp_poisoning(void)\n{\n   GtkWidget *dialog, *vbox, *hbox, *image, *button1, *button2, *frame;\n   gint response = 0;\n   gboolean remote = FALSE;\n   gboolean oneway = FALSE;\n   DEBUG_MSG(\"gtk_arp_poisoning\");\n   memset(params, '\\0', PARAMS_LEN+1);\n   dialog = gtk_dialog_new_with_buttons(\"MITM Attack: ARP Poisoning\", GTK_WINDOW (window),\n                                        GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK, \n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);\n   gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);\n   gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);\n   hbox = gtk_hbox_new (FALSE, 5);\n   gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);\n   gtk_widget_show(hbox);\n   image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);\n   gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);\n   gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);\n   gtk_widget_show(image);\n   frame = gtk_frame_new(\"Optional parameters\");\n   gtk_container_set_border_width(GTK_CONTAINER (frame), 5);\n   gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);\n   gtk_widget_show(frame);\n   vbox = gtk_vbox_new (FALSE, 2);\n   gtk_container_set_border_width(GTK_CONTAINER (vbox), 5);\n   gtk_container_add(GTK_CONTAINER (frame), vbox);\n   gtk_widget_show(vbox);\n   button1 = gtk_check_button_new_with_label(\"Sniff remote connections.\");\n   gtk_box_pack_start(GTK_BOX (vbox), button1, FALSE, FALSE, 0);\n   gtk_widget_show(button1);\n   button2 = gtk_check_button_new_with_label(\"Only poison one-way.\");\n   gtk_box_pack_start(GTK_BOX (vbox), button2, FALSE, FALSE, 0);\n   gtk_widget_show(button2);\n   response = gtk_dialog_run(GTK_DIALOG(dialog));\n   if(response == GTK_RESPONSE_OK) {\n      gtk_widget_hide(dialog);\n      memset(params, '\\0', PARAMS_LEN+1);\n      snprintf(params, 5, \"arp:\");\n      if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (button1))) {\n        strcat(params, \"remote\");\n        remote = TRUE;\n      }\n      if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (button2))) {\n         if(remote)\n            strcat(params, \",\");\n         strcat(params, \"oneway\");\n         oneway = TRUE;\n      } \n      if(!remote && !oneway) {\n         ui_error(\"You must select at least one ARP mode\");\n         return;\n      }\n      gtkui_start_mitm();\n   }\n   gtk_widget_destroy(dialog);\n}\nvoid gtkui_icmp_redir(void)\n{\n   GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame;\n   gint response = 0;\n   DEBUG_MSG(\"gtk_icmp_redir\");\n   dialog = gtk_dialog_new_with_buttons(\"MITM Attack: ICMP Redirect\", GTK_WINDOW (window),\n                                        GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);\n   gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);\n   gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);\n   hbox = gtk_hbox_new (FALSE, 5);\n   gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);\n   gtk_widget_show(hbox);\n   image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);\n   gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);\n   gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);\n   gtk_widget_show(image);\n   frame = gtk_frame_new(\"Gateway Information\");\n   gtk_container_set_border_width(GTK_CONTAINER (frame), 5);\n   gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);\n   gtk_widget_show(frame);\n   table = gtk_table_new(2, 2, FALSE);\n   gtk_table_set_row_spacings(GTK_TABLE (table), 5);\n   gtk_table_set_col_spacings(GTK_TABLE (table), 5);\n   gtk_container_set_border_width(GTK_CONTAINER (table), 8);\n   gtk_container_add(GTK_CONTAINER (frame), table);\n   gtk_widget_show(table);\n   label = gtk_label_new(\"MAC Address\");\n   gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);\n   gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0);\n   gtk_widget_show(label);\n   entry1 = gtk_entry_new();\n   gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN);\n   gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1); \n   gtk_widget_show(entry1);\n   label = gtk_label_new(\"IP Address\");\n   gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);\n   gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);\n   gtk_widget_show(label);\n   entry2 = gtk_entry_new();\n   gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN);\n   gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2);\n   gtk_widget_show(entry2);\n   response = gtk_dialog_run(GTK_DIALOG(dialog));\n   if(response == GTK_RESPONSE_OK) {\n      gtk_widget_hide(dialog);\n      snprintf(params, 6, \"icmp:\");\n      strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), ETH_ASCII_ADDR_LEN);\n      strncat(params, \"/\", 1);\n      strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), IP6_ASCII_ADDR_LEN);\n      gtkui_start_mitm();\n   }\n   gtk_widget_destroy(dialog);\n}\nvoid gtkui_port_stealing(void)\n{\n   GtkWidget *dialog, *vbox, *hbox, *image, *button1, *button2, *frame;\n   gint response = 0;\n   gboolean remote = FALSE;\n   DEBUG_MSG(\"gtk_port_stealing\"); \n   dialog = gtk_dialog_new_with_buttons(\"MITM Attack: Port Stealing\", GTK_WINDOW (window),\n                                        GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);\n   gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);\n   gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);\n   hbox = gtk_hbox_new (FALSE, 5);\n   gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);\n   gtk_widget_show(hbox);\n   image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);\n   gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);\n   gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);\n   gtk_widget_show(image);\n   frame = gtk_frame_new(\"Optional parameters\");\n   gtk_container_set_border_width(GTK_CONTAINER (frame), 5);\n   gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);\n   gtk_widget_show(frame);\n   vbox = gtk_vbox_new (FALSE, 2);\n   gtk_container_set_border_width(GTK_CONTAINER (vbox), 5);\n   gtk_container_add(GTK_CONTAINER (frame), vbox);\n   gtk_widget_show(vbox);\n   button1 = gtk_check_button_new_with_label(\"Sniff remote connections.\");\n   gtk_box_pack_start(GTK_BOX (vbox), button1, FALSE, FALSE, 0);\n   gtk_widget_show(button1);\n   button2 = gtk_check_button_new_with_label(\"Propagate to other switches.\");\n   gtk_box_pack_start(GTK_BOX (vbox), button2, FALSE, FALSE, 0);\n   gtk_widget_show(button2);\n   response = gtk_dialog_run(GTK_DIALOG(dialog));\n   if(response == GTK_RESPONSE_OK) {    \n      gtk_widget_hide(dialog);          \n      snprintf(params, 6, \"port:\");\n      if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (button1))) {\n         strcat(params, \"remote\");\n         remote = TRUE;\n      }\n      if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON (button2))) {\n         if(remote)\n            strcat(params, \",\");\n         strcat(params, \"tree\");\n      }\n      gtkui_start_mitm();\n   }\n   gtk_widget_destroy(dialog);\n}\nvoid gtkui_dhcp_spoofing(void)\n{\n   GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *entry3, *frame;\n   gint response = 0;\n   DEBUG_MSG(\"gtk_dhcp_spoofing\");\n   memset(params, '\\0', PARAMS_LEN+1);\n   dialog = gtk_dialog_new_with_buttons(\"MITM Attack: DHCP Spoofing\", GTK_WINDOW (window),\n                                        GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);\n   gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);\n   gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);\n   hbox = gtk_hbox_new (FALSE, 5);\n   gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);\n   gtk_widget_show(hbox);\n   image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);\n   gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);\n   gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);\n   gtk_widget_show(image);\n   frame = gtk_frame_new(\"Server Information\");\n   gtk_container_set_border_width(GTK_CONTAINER (frame), 5);\n   gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);\n   gtk_widget_show(frame);\n   table = gtk_table_new(3, 2, FALSE);\n   gtk_table_set_row_spacings(GTK_TABLE (table), 5);\n   gtk_table_set_col_spacings(GTK_TABLE (table), 5);\n   gtk_container_set_border_width(GTK_CONTAINER (table), 8);\n   gtk_container_add(GTK_CONTAINER (frame), table);\n   gtk_widget_show(table);\n   label = gtk_label_new(\"IP Pool (optional)\");\n   gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);\n   gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0);\n   gtk_widget_show(label);\n   entry1 = gtk_entry_new(); \n   gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1);\n   gtk_widget_show(entry1);\n   label = gtk_label_new(\"Netmask\"); \n   gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);\n   gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);\n   gtk_widget_show(label);\n   entry2 = gtk_entry_new();\n   gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN);\n   gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2);\n   gtk_widget_show(entry2);\n   label = gtk_label_new(\"DNS Server IP\");   \n   gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);\n   gtk_table_attach(GTK_TABLE (table), label, 0, 1, 2, 3, GTK_FILL, GTK_FILL, 0, 0);\n   gtk_widget_show(label);\n   entry3 = gtk_entry_new();\n   gtk_entry_set_max_length(GTK_ENTRY (entry3), IP6_ASCII_ADDR_LEN);\n   gtk_table_attach_defaults(GTK_TABLE (table), entry3, 1, 2, 2, 3);\n   gtk_widget_show(entry3);\n   response = gtk_dialog_run(GTK_DIALOG(dialog));\n   if(response == GTK_RESPONSE_OK) {\n      gtk_widget_hide(dialog);\n      snprintf(params, 6, \"dhcp:\");\n      strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN);\n      strncat(params, \"/\", PARAMS_LEN);\n      strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN);\n      strncat(params, \"/\", PARAMS_LEN);\n      strncat(params, gtk_entry_get_text(GTK_ENTRY(entry3)), PARAMS_LEN);\n      gtkui_start_mitm();\n   }\n   gtk_widget_destroy(dialog);\n}\nstatic void gtkui_start_mitm(void)\n{\n   DEBUG_MSG(\"gtk_start_mitm\");\n   mitm_set(params);\n   mitm_start();\n}\n",
        "cwe": "CWE-120",
        "file_name": "safe_respovul_idx_4143.c",
        "project": "ettercap/ettercap",
        "url": "https://github.com/Ettercap/ettercap/commit/4ef3ede30181eca9add74305ad26dbcb0c3686a0",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int ttm_tt_swapout(struct ttm_tt *ttm, struct file *persistent_swap_storage)\n\tif (!persistent_swap_storage) {\n\t\tswap_storage = shmem_file_setup(\"ttm swap\",\n\t\t\t\t\t\tttm->num_pages << PAGE_SHIFT,\n\t\t\t\t\t\t0);\n\t\tif (IS_ERR(swap_storage)) {\n\t\t}\n\t} else {\n\t\tswap_storage = persistent_swap_storage;\n\t}\n\tswap_space = swap_storage->f_mapping;\n\tfor (i = 0; i < ttm->num_pages; ++i) {\n\t\tgfp_t gfp_mask = mapping_gfp_mask(swap_space);\n\t\tgfp_mask |= (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY ? __GFP_RETRY_MAYFAIL : 0);\n\t\tfrom_page = ttm->pages[i];\n\t\tif (unlikely(from_page == NULL))\n\t\t\tcontinue;\n\t\tto_page = shmem_read_mapping_page_gfp(swap_space, i, gfp_mask);\n\t\tif (IS_ERR(to_page)) {\n\t\t}\n\t\tcopy_highpage(to_page, from_page);\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include \"nouveau_drv.h\"\n#include \"nouveau_mem.h\"\n#include \"nouveau_ttm.h\"\nstruct nouveau_sgdma_be {\n\tstruct ttm_dma_tt ttm;\n\tstruct nouveau_mem *mem;\n};\nstatic struct ttm_backend_func nv04_sgdma_backend = {\n\t.bind\t\t\t= nv04_sgdma_bind,\n\t.unbind\t\t\t= nv04_sgdma_unbind,\n\t.destroy\t\t= nouveau_sgdma_destroy\n};\nstatic struct ttm_backend_func nv50_sgdma_backend = {\n\t.bind\t\t\t= nv50_sgdma_bind,\n\t.unbind\t\t\t= nv04_sgdma_unbind,\n\t.destroy\t\t= nouveau_sgdma_destroy\n};\nstruct ttm_tt *\nnouveau_sgdma_create_ttm(struct ttm_buffer_object *bo, uint32_t page_flags)\n{\n\tstruct nouveau_drm *drm = nouveau_bdev(bo->bdev);\n\tstruct nouveau_sgdma_be *nvbe;\n\tnvbe = kzalloc(sizeof(*nvbe), GFP_KERNEL);\n\tif (!nvbe)\n\t\treturn NULL;\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA)\n\t\tnvbe->ttm.ttm.func = &nv04_sgdma_backend;\n\telse\n\t\tnvbe->ttm.ttm.func = &nv50_sgdma_backend;\n\tif (ttm_dma_tt_init(&nvbe->ttm, bo, page_flags)) {\n\t\tkfree(nvbe);\n\t\treturn NULL;\n\t}\n\treturn &nvbe->ttm.ttm;\n}\nFile number 2:\n#define pr_fmt(fmt) \"[TTM] \" fmt\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <drm/drm_cache.h>\n#include <drm/ttm/ttm_bo_driver.h>\n#include <drm/ttm/ttm_page_alloc.h>\n#include <drm/ttm/ttm_set_memory.h>\nstatic int ttm_tt_alloc_page_directory(struct ttm_tt *ttm)\n{\n\tttm->pages = kvmalloc_array(ttm->num_pages, sizeof(void*),\n\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!ttm->pages)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nstatic int ttm_dma_tt_alloc_page_directory(struct ttm_dma_tt *ttm)\n{\n\tttm->ttm.pages = kvmalloc_array(ttm->ttm.num_pages,\n\t\t\t\t\t  sizeof(*ttm->ttm.pages) +\n\t\t\t\t\t  sizeof(*ttm->dma_address),\n\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!ttm->ttm.pages)\n\t\treturn -ENOMEM;\n\tttm->dma_address = (void *) (ttm->ttm.pages + ttm->ttm.num_pages);\n\treturn 0;\n}\nstatic int ttm_sg_tt_alloc_page_directory(struct ttm_dma_tt *ttm)\n{\n\tttm->dma_address = kvmalloc_array(ttm->ttm.num_pages,\n\t\t\t\t\t  sizeof(*ttm->dma_address),\n\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!ttm->dma_address)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nstatic void ttm_tt_init_fields(struct ttm_tt *ttm,\n\t\t\t       struct ttm_buffer_object *bo,\n\t\t\t       uint32_t page_flags)\n{\n\tttm->bdev = bo->bdev;\n\tttm->num_pages = bo->num_pages;\n\tttm->caching_state = tt_cached;\n\tttm->page_flags = page_flags;\n\tttm->state = tt_unpopulated;\n\tttm->swap_storage = NULL;\n\tttm->sg = bo->sg;\n}\nint ttm_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,\n\t\tuint32_t page_flags)\n{\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\tif (ttm_tt_alloc_page_directory(ttm)) {\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_tt_init);\nEXPORT_SYMBOL(ttm_tt_fini);\nint ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,\n\t\t    uint32_t page_flags)\n{\n\tstruct ttm_tt *ttm = &ttm_dma->ttm;\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\tINIT_LIST_HEAD(&ttm_dma->pages_list);\n\tif (ttm_dma_tt_alloc_page_directory(ttm_dma)) {\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_dma_tt_init);\nint ttm_sg_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,\n\t\t   uint32_t page_flags)\n{\n\tstruct ttm_tt *ttm = &ttm_dma->ttm;\n\tint ret;\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\tINIT_LIST_HEAD(&ttm_dma->pages_list);\n\tif (page_flags & TTM_PAGE_FLAG_SG)\n\t\tret = ttm_sg_tt_alloc_page_directory(ttm_dma);\n\telse\n\t\tret = ttm_dma_tt_alloc_page_directory(ttm_dma);\n\tif (ret) {\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ttm_sg_tt_init);\nEXPORT_SYMBOL(ttm_dma_tt_fini);\nEXPORT_SYMBOL(ttm_tt_bind);\nint ttm_tt_swapout(struct ttm_tt *ttm, struct file *persistent_swap_storage)\n{\n\tstruct address_space *swap_space;\n\tstruct file *swap_storage;\n\tstruct page *from_page;\n\tstruct page *to_page;\n\tint i;\n\tint ret = -ENOMEM;\n\tBUG_ON(ttm->state != tt_unbound && ttm->state != tt_unpopulated);\n\tBUG_ON(ttm->caching_state != tt_cached);\n\tif (!persistent_swap_storage) {\n\t\tswap_storage = shmem_file_setup(\"ttm swap\",\n\t\t\t\t\t\tttm->num_pages << PAGE_SHIFT,\n\t\t\t\t\t\t0);\n\t\tif (IS_ERR(swap_storage)) {\n\t\t\tpr_err(\"Failed allocating swap storage\\n\");\n\t\t\treturn PTR_ERR(swap_storage);\n\t\t}\n\t} else {\n\t\tswap_storage = persistent_swap_storage;\n\t}\n\tswap_space = swap_storage->f_mapping;\n\tfor (i = 0; i < ttm->num_pages; ++i) {\n\t\tgfp_t gfp_mask = mapping_gfp_mask(swap_space);\n\t\tgfp_mask |= (ttm->page_flags & TTM_PAGE_FLAG_NO_RETRY ? __GFP_RETRY_MAYFAIL : 0);\n\t\tfrom_page = ttm->pages[i];\n\t\tif (unlikely(from_page == NULL))\n\t\t\tcontinue;\n\t\tto_page = shmem_read_mapping_page_gfp(swap_space, i, gfp_mask);\n\t\tif (IS_ERR(to_page)) {\n\t\t\tret = PTR_ERR(to_page);\n\t\t\tgoto out_err;\n\t\t}\n\t\tcopy_highpage(to_page, from_page);\n\t\tset_page_dirty(to_page);\n\t\tmark_page_accessed(to_page);\n\t\tput_page(to_page);\n\t}\n\tttm_tt_unpopulate(ttm);\n\tttm->swap_storage = swap_storage;\n\tttm->page_flags |= TTM_PAGE_FLAG_SWAPPED;\n\tif (persistent_swap_storage)\n\t\tttm->page_flags |= TTM_PAGE_FLAG_PERSISTENT_SWAP;\n\treturn 0;\nout_err:\n\tif (!persistent_swap_storage)\n\t\tfput(swap_storage);\n\treturn ret;\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_5806.c",
        "project": "gregkh/linux",
        "url": "https://github.com/gregkh/linux/commit/5de5b6ecf97a021f29403aa272cb4e03318ef586",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int nfs_mount_reply(uchar *pkt, unsigned len)\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\nstatic void nfs_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n\t\t\tunsigned src, unsigned len)\n\tif (len > sizeof(struct rpc_t))\n\t\treturn;\n\t\treply = nfs_mount_reply(pkt, len);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <common.h>\n#include <command.h>\n#include <net.h>\n#include <malloc.h>\n#include <mapmem.h>\n#include \"nfs.h\"\n#include \"bootp.h\"\n#define HASHES_PER_LINE 65\t\n#define NFS_RETRY_COUNT 30\n#ifndef CONFIG_NFS_TIMEOUT\n# define NFS_TIMEOUT 2000UL\n#else\n# define NFS_TIMEOUT CONFIG_NFS_TIMEOUT\n#endif\n#define NFS_RPC_ERR\t1\n#define NFS_RPC_DROP\t124\nstatic int fs_mounted;\nstatic unsigned long rpc_id;\nstatic int nfs_offset = -1;\nstatic int nfs_len;\nstatic ulong nfs_timeout = NFS_TIMEOUT;\nstatic char dirfh[NFS_FHSIZE];\t\nstatic char filefh[NFS3_FHSIZE]; \nstatic int filefh3_length;\t\nstatic enum net_loop_state nfs_download_state;\nstatic struct in_addr nfs_server_ip;\nstatic int nfs_server_mount_port;\nstatic int nfs_server_port;\nstatic int nfs_our_port;\nstatic int nfs_timeout_count;\nstatic int nfs_state;\n#define STATE_PRCLOOKUP_PROG_MOUNT_REQ\t1\n#define STATE_PRCLOOKUP_PROG_NFS_REQ\t2\n#define STATE_MOUNT_REQ\t\t\t3\n#define STATE_UMOUNT_REQ\t\t4\n#define STATE_LOOKUP_REQ\t\t5\n#define STATE_READ_REQ\t\t\t6\n#define STATE_READLINK_REQ\t\t7\nstatic char *nfs_filename;\nstatic char *nfs_path;\nstatic char nfs_path_buff[2048];\n#define NFSV2_FLAG 1\n#define NFSV3_FLAG 1 << 1\nstatic char supported_nfs_versions = NFSV2_FLAG | NFSV3_FLAG;\nstatic inline int store_block(uchar *src, unsigned offset, unsigned len)\n{\n\tulong newsize = offset + len;\n#ifdef CONFIG_SYS_DIRECT_FLASH_NFS\n\tint i, rc = 0;\n\tfor (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {\n\t\tif (load_addr + offset >= flash_info[i].start[0]) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc) { \n\t\trc = flash_write((uchar *)src, (ulong)(load_addr+offset), len);\n\t\tif (rc) {\n\t\t\tflash_perror(rc);\n\t\t\treturn -1;\n\t\t}\n\t} else\n#endif \n\t{\n\t\tvoid *ptr = map_sysmem(load_addr + offset, len);\n\t\tmemcpy(ptr, src, len);\n\t\tunmap_sysmem(ptr);\n\t}\n\tif (net_boot_file_size < (offset + len))\n\t\tnet_boot_file_size = newsize;\n\treturn 0;\n}\nstatic char *basename(char *path)\n{\n\tchar *fname;\n\tfname = path + strlen(path) - 1;\n\twhile (fname >= path) {\n\t\tif (*fname == '/') {\n\t\t\tfname++;\n\t\t\tbreak;\n\t\t}\n\t\tfname--;\n\t}\n\treturn fname;\n}\nstatic char *dirname(char *path)\n{\n\tchar *fname;\n\tfname = basename(path);\n\t--fname;\n\t*fname = '\\0';\n\treturn path;\n}\nstatic uint32_t *rpc_add_credentials(uint32_t *p)\n{\n\t*p++ = htonl(1);\t\t\n\t*p++ = htonl(20);\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\t*p++ = 0;\t\t\t\n\treturn p;\n}\nstatic void rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)\n{\n\tstruct rpc_t rpc_pkt;\n\tunsigned long id;\n\tuint32_t *p;\n\tint pktlen;\n\tint sport;\n\tid = ++rpc_id;\n\trpc_pkt.u.call.id = htonl(id);\n\trpc_pkt.u.call.type = htonl(MSG_CALL);\n\trpc_pkt.u.call.rpcvers = htonl(2);\t\n\trpc_pkt.u.call.prog = htonl(rpc_prog);\n\tswitch (rpc_prog) {\n\tcase PROG_NFS:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_pkt.u.call.vers = htonl(2);\t\n\t\telse \n\t\t\trpc_pkt.u.call.vers = htonl(3);\t\n\t\tbreak;\n\tcase PROG_PORTMAP:\n\tcase PROG_MOUNT:\n\tdefault:\n\t\trpc_pkt.u.call.vers = htonl(2);\t\n\t}\n\trpc_pkt.u.call.proc = htonl(rpc_proc);\n\tp = (uint32_t *)&(rpc_pkt.u.call.data);\n\tif (datalen)\n\t\tmemcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));\n\tpktlen = (char *)p + datalen * sizeof(uint32_t) - (char *)&rpc_pkt;\n\tmemcpy((char *)net_tx_packet + net_eth_hdr_size() + IP_UDP_HDR_SIZE,\n\t       &rpc_pkt.u.data[0], pktlen);\n\tif (rpc_prog == PROG_PORTMAP)\n\t\tsport = SUNRPC_PORT;\n\telse if (rpc_prog == PROG_MOUNT)\n\t\tsport = nfs_server_mount_port;\n\telse\n\t\tsport = nfs_server_port;\n\tnet_send_udp_packet(net_server_ethaddr, nfs_server_ip, sport,\n\t\t\t    nfs_our_port, pktlen);\n}\nstatic void rpc_lookup_req(int prog, int ver)\n{\n\tuint32_t data[16];\n\tdata[0] = 0; data[1] = 0;\t\n\tdata[2] = 0; data[3] = 0;\t\n\tdata[4] = htonl(prog);\n\tdata[5] = htonl(ver);\n\tdata[6] = htonl(17);\t\n\tdata[7] = 0;\n\trpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);\n}\nstatic void nfs_mount_req(char *path)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint pathlen;\n\tpathlen = strlen(path);\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\t*p++ = htonl(pathlen);\n\tif (pathlen & 3)\n\t\t*(p + pathlen / 4) = 0;\n\tmemcpy(p, path, pathlen);\n\tp += (pathlen + 3) / 4;\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\trpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);\n}\nstatic void nfs_umountall_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tif ((nfs_server_mount_port == -1) || (!fs_mounted))\n\t\treturn;\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\trpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);\n}\nstatic void nfs_readlink_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t} else { \n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t}\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\trpc_req(PROG_NFS, NFS_READLINK, data, len);\n}\nstatic void nfs_lookup_req(char *fname)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint fnamelen;\n\tfnamelen = strlen(fname);\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\t\trpc_req(PROG_NFS, NFS_LOOKUP, data, len);\n\t} else {  \n\t\t*p++ = htonl(NFS_FHSIZE);\t\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\t\trpc_req(PROG_NFS, NFS3PROC_LOOKUP, data, len);\n\t}\n}\nstatic void nfs_read_req(int offset, int readlen)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t} else { \n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t\t*p++ = htonl(0); \n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t}\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\trpc_req(PROG_NFS, NFS_READ, data, len);\n}\nstatic void nfs_send(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_MOUNT, 1);\n\t\telse  \n\t\t\trpc_lookup_req(PROG_MOUNT, 3);\n\t\tbreak;\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_NFS, 2);\n\t\telse  \n\t\t\trpc_lookup_req(PROG_NFS, 3);\n\t\tbreak;\n\tcase STATE_MOUNT_REQ:\n\t\tnfs_mount_req(nfs_path);\n\t\tbreak;\n\tcase STATE_UMOUNT_REQ:\n\t\tnfs_umountall_req();\n\t\tbreak;\n\tcase STATE_LOOKUP_REQ:\n\t\tnfs_lookup_req(nfs_filename);\n\t\tbreak;\n\tcase STATE_READ_REQ:\n\t\tnfs_read_req(nfs_offset, nfs_len);\n\t\tbreak;\n\tcase STATE_READLINK_REQ:\n\t\tnfs_readlink_req();\n\t\tbreak;\n\t}\n}\nstatic int rpc_lookup_reply(int prog, uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\tdebug(\"%s\\n\", __func__);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\tswitch (prog) {\n\tcase PROG_MOUNT:\n\t\tnfs_server_mount_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\tcase PROG_NFS:\n\t\tnfs_server_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\t}\n\treturn 0;\n}\nstatic int nfs_mount_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\tfs_mounted = 1;\n\tmemcpy(dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\treturn 0;\n}\nstatic int nfs_umountall_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\tfs_mounted = 0;\n\tmemset(dirfh, 0, sizeof(dirfh));\n\treturn 0;\n}\nstatic int nfs_lookup_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tswitch (ntohl(rpc_pkt.u.reply.astatus)) {\n\t\tcase NFS_RPC_SUCCESS: \n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_MISMATCH:\n\t\t\tswitch (ntohl(rpc_pkt.u.reply.data[0])) {\n\t\t\tcase 3:\n\t\t\t\tdebug(\"*** Warning: NFS version not supported: Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tdebug(\"Will retry with NFSv3\\n\");\n\t\t\t\tsupported_nfs_versions &= ~NFSV2_FLAG;\n\t\t\t\treturn -NFS_RPC_PROG_MISMATCH;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tputs(\"*** ERROR: NFS version not supported\");\n\t\t\t\tdebug(\": Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tputs(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_UNAVAIL:\n\t\tcase NFS_RPC_PROC_UNAVAIL:\n\t\tcase NFS_RPC_GARBAGE_ARGS:\n\t\tcase NFS_RPC_SYSTEM_ERR:\n\t\tdefault: \n\t\t\tdebug(\"*** ERROR: accept state error (%d)\\n\",\n\t\t\t      ntohl(rpc_pkt.u.reply.astatus));\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\t} else {  \n\t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\t\tif (filefh3_length > NFS3_FHSIZE)\n\t\t\tfilefh3_length  = NFS3_FHSIZE;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);\n\t}\n\treturn 0;\n}\nstatic int nfs3_get_attributes_offset(uint32_t *data)\n{\n\tif (ntohl(data[1]) != 0) {\n\t\treturn 22;\n\t} else {\n\t\treturn 1;\n\t}\n}\nstatic int nfs_readlink_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tint nfsv3_data_offset = 0;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy((unsigned char *)&rpc_pkt, pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\tif (!(supported_nfs_versions & NFSV2_FLAG)) { \n\t\tnfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t}\n\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\tif (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {\n\t\tint pathlen;\n\t\tstrcat(nfs_path, \"/\");\n\t\tpathlen = strlen(nfs_path);\n\t\tmemcpy(nfs_path + pathlen,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[pathlen + rlen] = 0;\n\t} else {\n\t\tmemcpy(nfs_path,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n\treturn 0;\n}\nstatic int nfs_read_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tuchar *data_ptr;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, sizeof(rpc_pkt.u.reply));\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tif (rpc_pkt.u.reply.rstatus)\n\t\t\treturn -9999;\n\t\tif (rpc_pkt.u.reply.astatus)\n\t\t\treturn -9999;\n\t\treturn -ntohl(rpc_pkt.u.reply.data[0]);\n\t}\n\tif ((nfs_offset != 0) && !((nfs_offset) %\n\t\t\t(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))\n\t\tputs(\"\\n\\t \");\n\tif (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))\n\t\tputc('#');\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\trlen = ntohl(rpc_pkt.u.reply.data[18]);\n\t\tdata_ptr = (uchar *)&(rpc_pkt.u.reply.data[19]);\n\t} else {  \n\t\tint nfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\t\tdata_ptr = (uchar *)\n\t\t\t&(rpc_pkt.u.reply.data[4 + nfsv3_data_offset]);\n\t}\n\tif (store_block(data_ptr, nfs_offset, rlen))\n\t\t\treturn -9999;\n\treturn rlen;\n}\nstatic void nfs_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n\t\t\tunsigned src, unsigned len)\n{\n\tint rlen;\n\tint reply;\n\tdebug(\"%s\\n\", __func__);\n\tif (len > sizeof(struct rpc_t))\n\t\treturn;\n\tif (dest != nfs_our_port)\n\t\treturn;\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (rpc_lookup_reply(PROG_MOUNT, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_PRCLOOKUP_PROG_NFS_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (rpc_lookup_reply(PROG_NFS, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_MOUNT_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\tcase STATE_MOUNT_REQ:\n\t\treply = nfs_mount_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Cannot mount\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_LOOKUP_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_UMOUNT_REQ:\n\t\treply = nfs_umountall_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tdebug(\"*** ERROR: Cannot umount\\n\");\n\t\t\tnet_set_state(NETLOOP_FAIL);\n\t\t} else {\n\t\t\tputs(\"\\ndone\\n\");\n\t\t\tnet_set_state(nfs_download_state);\n\t\t}\n\t\tbreak;\n\tcase STATE_LOOKUP_REQ:\n\t\treply = nfs_lookup_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: File lookup fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else if (reply == -NFS_RPC_PROG_MISMATCH &&\n\t\t\t   supported_nfs_versions != 0) {\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_READ_REQ;\n\t\t\tnfs_offset = 0;\n\t\t\tnfs_len = NFS_READ_SIZE;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_READLINK_REQ:\n\t\treply = nfs_readlink_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Symlink fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tdebug(\"Symlink --> %s\\n\", nfs_path);\n\t\t\tnfs_filename = basename(nfs_path);\n\t\t\tnfs_path     = dirname(nfs_path);\n\t\t\tnfs_state = STATE_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_READ_REQ:\n\t\trlen = nfs_read_reply(pkt, len);\n\t\tif (rlen == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\t\tif (rlen > 0) {\n\t\t\tnfs_offset += rlen;\n\t\t\tnfs_send();\n\t\t} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {\n\t\t\tnfs_state = STATE_READLINK_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tif (!rlen)\n\t\t\t\tnfs_download_state = NETLOOP_SUCCESS;\n\t\t\tif (rlen < 0)\n\t\t\t\tdebug(\"NFS READ error (%d)\\n\", rlen);\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\t}\n}\nvoid nfs_start(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\tnfs_download_state = NETLOOP_FAIL;\n\tnfs_server_ip = net_server_ip;\n\tnfs_path = (char *)nfs_path_buff;\n\tif (nfs_path == NULL) {\n\t\tnet_set_state(NETLOOP_FAIL);\n\t\tprintf(\"*** ERROR: Fail allocate memory\\n\");\n\t\treturn;\n\t}\n\tif (!net_parse_bootfile(&nfs_server_ip, nfs_path,\n\t\t\t\tsizeof(nfs_path_buff))) {\n\t\tsprintf(nfs_path, \"/nfsroot/%02X%02X%02X%02X.img\",\n\t\t\tnet_ip.s_addr & 0xFF,\n\t\t\t(net_ip.s_addr >>  8) & 0xFF,\n\t\t\t(net_ip.s_addr >> 16) & 0xFF,\n\t\t\t(net_ip.s_addr >> 24) & 0xFF);\n\t\tprintf(\"*** Warning: no boot file name; using '%s'\\n\",\n\t\t       nfs_path);\n\t}\n\tnfs_filename = basename(nfs_path);\n\tnfs_path     = dirname(nfs_path);\n\tprintf(\"Using %s device\\n\", eth_get_name());\n\tprintf(\"File transfer via NFS from server %pI4; our IP address is %pI4\",\n\t       &nfs_server_ip, &net_ip);\n\tif (net_gateway.s_addr && net_netmask.s_addr) {\n\t\tstruct in_addr our_net;\n\t\tstruct in_addr server_net;\n\t\tour_net.s_addr = net_ip.s_addr & net_netmask.s_addr;\n\t\tserver_net.s_addr = nfs_server_ip.s_addr & net_netmask.s_addr;\n\t\tif (our_net.s_addr != server_net.s_addr)\n\t\t\tprintf(\"; sending through gateway %pI4\",\n\t\t\t       &net_gateway);\n\t}\n\tprintf(\"\\nFilename '%s/%s'.\", nfs_path, nfs_filename);\n\tif (net_boot_file_expected_size_in_blocks) {\n\t\tprintf(\" Size is 0x%x Bytes = \",\n\t\t       net_boot_file_expected_size_in_blocks << 9);\n\t\tprint_size(net_boot_file_expected_size_in_blocks << 9, \"\");\n\t}\n\tprintf(\"\\nLoad address: 0x%lx\\nLoading: *\\b\", load_addr);\n\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\tnet_set_udp_handler(nfs_handler);\n\tnfs_timeout_count = 0;\n\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\tnfs_our_port = 1000;\n\tmemset(net_server_ethaddr, 0, 6);\n\tnfs_send();\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_3617.c",
        "project": "u-boot/u-boot",
        "url": "https://github.com/u-boot/u-boot/commit/741a8a08ebe5bc3ccfe3cde6c2b44ee53891af21",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```BZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\nBZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {\n}\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n    }\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n    }\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n    }\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n    }\n}\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n}\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    u32 n_blocks = read_neutral_s32(in + 9);\n    in += 13;\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n    }\n    *out_size = 0;\n    for (u32 i = 0; i < n_blocks; i++) {\n        s32 size = read_neutral_s32(in);\n        if (size < 0 || size > block_size) goto malformed_header;\n        if (in_size < size + 8) {\n            return BZ3_ERR_TRUNCATED_DATA;\n        }\n        s32 orig_size = read_neutral_s32(in + 4);\n        if (orig_size < 0) goto malformed_header;\n        if (buf_max < *out_size + orig_size) {\n            return BZ3_ERR_DATA_TOO_BIG;\n        }\n        memcpy(compression_buf, in + 8, size);\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n        }\n        memcpy(out + *out_size, compression_buf, orig_size);\n        *out_size += orig_size;\n        in += size + 8;\n    }\n}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"libbz3.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"libsais.h\"\nstatic const u32 crc32Table[256] = {\n    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,\n    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,\n    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,\n    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,\n    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,\n    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,\n    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,\n    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,\n    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,\n    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,\n    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,\n    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,\n    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,\n    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,\n    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,\n    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,\n    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,\n    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,\n    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,\n    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,\n    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,\n    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,\n    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,\n    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,\n    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,\n    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,\n    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,\n    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,\n    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L\n};\nstatic u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n    return crc;\n}\n#define LZP_DICTIONARY 18\n#define LZP_MIN_MATCH 40\n#define MATCH 0xf2\nstatic s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,\n                            s32 * RESTRICT lut) {\n    const u8 * ins = in;\n    const u8 * outs = out;\n    const u8 * out_eob = out_end - 8;\n    const u8 * heur = in;\n    u32 ctx;\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = in - ins;\n        if (val > 0) {\n            const u8 * RESTRICT ref = ins + val;\n            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&\n                memcmp(in, ref, sizeof(u32)) == 0) {\n                if (heur > in && *(u32 *)heur != *(u32 *)(ref + (heur - in))) goto not_found;\n                s32 len = 4;\n                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {\n                    if (*(u32 *)(in + len) != *(u32 *)(ref + len)) break;\n                }\n                if (len < LZP_MIN_MATCH) {\n                    if (heur < in + len) heur = in + len;\n                    goto not_found;\n                }\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n                in += len;\n                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n                *out++ = MATCH;\n                len -= LZP_MIN_MATCH;\n                while (len >= 254) {\n                    len -= 254;\n                    *out++ = 254;\n                    if (out >= out_eob) break;\n                }\n                *out++ = len;\n            } else {\n            not_found:;\n                u8 next = *out++ = *in++;\n                ctx = ctx << 8 | next;\n                if (next == MATCH) *out++ = 255;\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n    while (in < in_end && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(in - ins);\n        u8 next = *out++ = *in++;\n        ctx = ctx << 8 | next;\n        if (next == MATCH && val > 0) *out++ = 255;\n    }\n    return out >= out_eob ? -1 : (s32)(out - outs);\n}\nstatic s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,\n                            const u8 * out_end) {\n    const u8 * outs = out;\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n    while (in < in_end && out < out_end) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(out - outs);\n        if (*in == MATCH && val > 0) {\n            in++;\n            if (*in != 255) {\n                s32 len = LZP_MIN_MATCH;\n                while (1) {\n                    if (in == in_end) return -1;\n                    len += *in;\n                    if (*in++ != 254) break;\n                }\n                const u8 * ref = outs + val;\n                u8 * oe = out + len;\n                if (oe > out_end) oe = out_end;\n                while (out < oe) *out++ = *ref++;\n                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n            } else {\n                in++;\n                ctx = (ctx << 8) | (*out++ = MATCH);\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n    return out - outs;\n}\nstatic s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {\n    if (n < LZP_MIN_MATCH + 32) return -1;\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n    return lzp_encode_block(in, in + n, out, out + n, lut);\n}\nstatic s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {\n    if (n < 4) return -1;\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n    return lzp_decode_block(in, in + n, lut, out, out + max);\n}\nstatic int mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen, s32 maxin) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    if(maxin < 32)\n        return 1;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen && ip < maxin) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255 && ip < maxin; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n    return op != outlen;\n}\ntypedef struct {\n    u8 *in_queue, *out_queue;\n    s32 input_ptr, output_ptr, input_max;\n    u16 C0[256], C1[256][256], C2[512][17];\n} state;\n#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)\n#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)\n#define update0(p, x) (p) = ((p) - ((p) >> x))\n#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))\nstatic void begin(state * s) {\n    prefetch(s);\n    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;\n    for (int i = 0; i < 256; i++)\n        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 256; j++)\n            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.\n}\nstatic void encode_bytes(state * s, u8 * buf, s32 size) {\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;\n    for (s32 i = 0; i < size; i++) {\n        u8 c = buf[i];\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n        const int f = run > 2;\n        int ctx = 1;\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n            if (c & 128) {\n                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;\n                // Write identical bits.\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);  // Same as high >> 24\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n            c <<= 1;\n        }\n        c2 = c1;\n        c1 = ctx & 255;\n    }\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n}\nstatic void decode_bytes(state * s, u8 * c, s32 size) {\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    for (s32 i = 0; i < size; i++) {\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n        const int f = run > 2;\n        int ctx = 1;\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n            const u8 bit = code <= mid;\n            if (bit)\n                high = mid;\n            else\n                low = mid + 1;\n            while ((low ^ high) < (1 << 24)) {\n                low <<= 8;\n                high = (high << 8) + 255;\n                code = (code << 8) + read_in(s);\n            }\n            if (bit) {\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n        }\n        c2 = c1;\n        c[i] = c1 = ctx & 255;\n    }\n}\nstruct bz3_state {\n    u8 * swap_buffer;\n    s32 block_size;\n    s32 *sais_array, *lzp_lut;\n    state * cm_state;\n    s8 last_error;\n};\nBZIP3_API \nBZIP3_API \nBZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\nBZIP3_API \nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\n}\nBZIP3_API \n#define swap(x, y)    \\\n    {                 \\\n        u8 * tmp = x; \\\n        x = y;        \\\n        y = tmp;      \\\n    }\nBZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n    if (data_size > state->block_size) {\n        state->last_error = BZ3_ERR_DATA_TOO_BIG;\n        return -1;\n    }\n    u32 crc32 = crc32sum(1, b1, data_size);\n    // Ignore small blocks. They won't benefit from the entropy coding step.\n    if (data_size < 64) {\n        memmove(b1 + 8, b1, data_size);\n        write_neutral_s32(b1, crc32);\n        write_neutral_s32(b1 + 4, -1);\n        return data_size + 8;\n    }\n    // Back to front:\n    // bit 1: lzp | no lzp\n    // bit 2: srt | no srt\n    s8 model = 0;\n    s32 lzp_size, rle_size;\n    rle_size = mrlec(b1, data_size, b2);\n    if (rle_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = rle_size;\n        model |= 4;\n    }\n    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);\n    if (lzp_size > 0 && lzp_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = lzp_size;\n        model |= 2;\n    }\n    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);\n    if (bwt_idx < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    // Compute the amount of overhead dwords.\n    s32 overhead = 2;           // CRC32 + BWT index\n    if (model & 2) overhead++;  // LZP\n    if (model & 4) overhead++;  // RLE\n    begin(state->cm_state);\n    state->cm_state->out_queue = b1 + overhead * 4 + 1;\n    state->cm_state->output_ptr = 0;\n    encode_bytes(state->cm_state, b2, data_size);\n    data_size = state->cm_state->output_ptr;\n    // Write the header. Starting with common entries.\n    write_neutral_s32(b1, crc32);\n    write_neutral_s32(b1 + 4, bwt_idx);\n    b1[8] = model;\n    s32 p = 0;\n    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);\n    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);\n    state->last_error = BZ3_OK;\n    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);\n    return data_size + overhead * 4 + 1;\n}\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64 || data_size < 8) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n        memmove(buffer, buffer + 8, data_size - 8);\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        return data_size - 8;\n    }\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    p += 2;\n    data_size -= p * 4 + 1;\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n    s32 size_src;\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n    if (model & 4) {\n        int err = mrled(b1, b2, orig_size, size_src);\n        if(err) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n    state->last_error = BZ3_OK;\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n    return size_src;\n}\n#undef swap\n#ifdef PTHREAD\n    #include <pthread.h>\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n} encode_thread_msg;\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n    s32 orig_size;\n} decode_thread_msg;\nstatic void * bz3_init_encode_thread(void * _msg) {\n    encode_thread_msg * msg = _msg;\n    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\nstatic void * bz3_init_decode_thread(void * _msg) {\n    decode_thread_msg * msg = _msg;\n    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\nBZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {\n    encode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;\n}\nBZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {\n    decode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        messages[i].orig_size = orig_sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n}\n#endif\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n    size_t buf_max = *out_size;\n    *out_size = 0;\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        bz3_free(state);\n        free(compression_buf);\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n    out[0] = 'B';\n    out[1] = 'Z';\n    out[2] = '3';\n    out[3] = 'v';\n    out[4] = '1';\n    write_neutral_s32(out + 5, block_size);\n    write_neutral_s32(out + 9, n_blocks);\n    *out_size += 13;\n    // Compress and write the blocks.\n    for (u32 i = 0; i < n_blocks; i++) {\n        s32 size = block_size;\n        if (i == n_blocks - 1) size = in_size % block_size;\n        memcpy(compression_buf, in, size);\n        s32 out_size_block = bz3_encode_block(state, compression_buf, size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size + 8, compression_buf, out_size_block);\n        write_neutral_s32(out + *out_size, out_size_block);\n        write_neutral_s32(out + *out_size + 4, size);\n        *out_size += out_size_block + 8;\n    }\n    bz3_free(state);\n    free(compression_buf);\n    return BZ3_OK;\n}\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    u32 n_blocks = read_neutral_s32(in + 9);\n    in_size -= 13;\n    in += 13;\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n    size_t buf_max = *out_size;\n    *out_size = 0;\n    for (u32 i = 0; i < n_blocks; i++) {\n        if (in_size < 8) {\n        malformed_header:\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_MALFORMED_HEADER;\n        }\n        s32 size = read_neutral_s32(in);\n        if (size < 0 || size > block_size) goto malformed_header;\n        if (in_size < size + 8) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_TRUNCATED_DATA;\n        }\n        s32 orig_size = read_neutral_s32(in + 4);\n        if (orig_size < 0) goto malformed_header;\n        if (buf_max < *out_size + orig_size) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_DATA_TOO_BIG;\n        }\n        memcpy(compression_buf, in + 8, size);\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size, compression_buf, orig_size);\n        *out_size += orig_size;\n        in += size + 8;\n        in_size -= size + 8;\n    }\n    bz3_free(state);\n    return BZ3_OK;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_11326.c",
        "project": "kspalaiologos/bzip3",
        "url": "https://github.com/kspalaiologos/bzip3/commit/bb06deb85f1c249838eb938e0dab271d4194f8fa",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```hivex_open (const char *filename, int flags)\n  hive_h *h = NULL;\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n  DEBUG (2, \"created handle %p\", h);\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n  if (h->fd == -1)\n    goto error;\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n  h->size = statbuf.st_size;\n  if (h->size < 0x2000) {\n  }\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n  } else {\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <assert.h>\n#ifdef HAVE_MMAP\n#include <sys/mman.h>\n#else\n#include \"mmap.h\"\n#endif\n#include \"full-read.h\"\n#include \"full-write.h\"\n#include \"c-ctype.h\"\n#include \"hivex.h\"\n#include \"hivex-internal.h\"\nstatic uint32_t\nheader_checksum (const hive_h *h)\n{\n  uint32_t *daddr = (uint32_t *) h->addr;\n  size_t i;\n  uint32_t sum = 0;\n  for (i = 0; i < 0x1fc / 4; ++i) {\n    sum ^= le32toh (*daddr);\n    daddr++;\n  }\n  return sum;\n}\n#define HIVEX_OPEN_MSGLVL_MASK (HIVEX_OPEN_VERBOSE|HIVEX_OPEN_DEBUG)\nhive_h *\nhivex_open (const char *filename, int flags)\n{\n  hive_h *h = NULL;\n  assert (sizeof (struct ntreg_header) == 0x1000);\n  assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n  const char *debug = getenv (\"HIVEX_DEBUG\");\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n  DEBUG (2, \"created handle %p\", h);\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n#ifdef O_CLOEXEC\n  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n#else\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n#endif\n  if (h->fd == -1)\n    goto error;\n#ifndef O_CLOEXEC\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n#endif\n  struct stat statbuf;\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n  h->size = statbuf.st_size;\n  if (h->size < 0x2000) {\n    SET_ERRNO (EINVAL,\n               \"%s: file is too small to be a Windows NT Registry hive file\",\n               filename);\n    goto error;\n  }\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n    if (h->addr == MAP_FAILED)\n      goto error;\n    DEBUG (2, \"mapped file at %p\", h->addr);\n  } else {\n    h->addr = malloc (h->size);\n    if (h->addr == NULL)\n      goto error;\n    if (full_read (h->fd, h->addr, h->size) < h->size)\n      goto error;\n    if (close (h->fd) == -1)\n      goto error;\n    h->fd = -1;\n  }\n  if (h->hdr->magic[0] != 'r' ||\n      h->hdr->magic[1] != 'e' ||\n      h->hdr->magic[2] != 'g' ||\n      h->hdr->magic[3] != 'f') {\n    SET_ERRNO (ENOTSUP,\n               \"%s: not a Windows NT Registry hive file\", filename);\n    goto error;\n  }\n  uint32_t major_ver = le32toh (h->hdr->major_ver);\n  if (major_ver != 1) {\n    SET_ERRNO (ENOTSUP,\n               \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n               filename, major_ver);\n    goto error;\n  }\n  h->bitmap = calloc (1 + h->size / 32, 1);\n  if (h->bitmap == NULL)\n    goto error;\n  uint32_t sum = header_checksum (h);\n  if (sum != le32toh (h->hdr->csum)) {\n    SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n    goto error;\n  }\n  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n  if (h->msglvl >= 2) {\n    char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);\n    fprintf (stderr,\n             \"hivex_open: header fields:\\n\"\n             \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n             \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n             \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n             \"  last modified            %\" PRIu64 \"\\n\"\n             \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n             \"  original file name       %s\\n\"\n             \"    (only 32 chars are stored, name is probably truncated)\\n\"\n             \"  root offset              0x%x + 0x1000\\n\"\n             \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n             \"  checksum                 0x%x (calculated 0x%x)\\n\",\n             major_ver, le32toh (h->hdr->minor_ver),\n             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n             h->last_modified,\n             name ? name : \"(conversion failed)\",\n             le32toh (h->hdr->offset),\n             le32toh (h->hdr->blocks), h->size,\n             le32toh (h->hdr->csum), sum);\n    free (name);\n  }\n  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n  h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n  DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n  int seen_root_block = 0, bad_root_block = 0;\n  size_t pages = 0;           \n  size_t smallest_page = SIZE_MAX, largest_page = 0;\n  size_t blocks = 0;          \n  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n  size_t used_blocks = 0;     \n  size_t used_size = 0;       \n  size_t off;\n  struct ntreg_hbin_page *page;\n  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n    if (off >= h->endpages)\n      break;\n    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n    if (page->magic[0] != 'h' ||\n        page->magic[1] != 'b' ||\n        page->magic[2] != 'i' ||\n        page->magic[3] != 'n') {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: trailing garbage at end of file \"\n                 \"(at 0x%zx, after %zu pages)\",\n                 filename, off, pages);\n      goto error;\n    }\n    size_t page_size = le32toh (page->page_size);\n    DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n    pages++;\n    if (page_size < smallest_page) smallest_page = page_size;\n    if (page_size > largest_page) largest_page = page_size;\n    if (page_size <= sizeof (struct ntreg_hbin_page) ||\n        (page_size & 0x0fff) != 0) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n    size_t blkoff;\n    struct ntreg_hbin_block *block;\n    size_t seg_len;\n    for (blkoff = off + 0x20;\n         blkoff < off + page_size;\n         blkoff += seg_len) {\n      blocks++;\n      int is_root = blkoff == h->rootoffs;\n      if (is_root)\n        seen_root_block = 1;\n      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n      int used;\n      seg_len = block_len (h, blkoff, &used);\n      if (seg_len <= 4 || (seg_len & 3) != 0) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s: block size %\" PRIu32 \" at 0x%zx, bad registry\",\n                   filename, le32toh (block->seg_len), blkoff);\n        goto error;\n      }\n      if (h->msglvl >= 2) {\n        unsigned char *id = (unsigned char *) block->id;\n        int id0 = id[0], id1 = id[1];\n        fprintf (stderr, \"%s: %s: \"\n                 \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                 \"hivex\", __func__,\n                 used ? \"used\" : \"free\",\n                 id0, id1,\n                 c_isprint (id0) ? id0 : '.',\n                 c_isprint (id1) ? id1 : '.',\n                 blkoff,\n                 seg_len, is_root ? \" (root)\" : \"\");\n      }\n      blocks_bytes += seg_len;\n      if (seg_len < smallest_block) smallest_block = seg_len;\n      if (seg_len > largest_block) largest_block = seg_len;\n      if (is_root && !used)\n        bad_root_block = 1;\n      if (used) {\n        used_blocks++;\n        used_size += seg_len;\n        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n          bad_root_block = 1;\n        BITMAP_SET (h->bitmap, blkoff);\n      }\n    }\n  }\n  if (!seen_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n    goto error;\n  }\n  if (bad_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n    goto error;\n  }\n  DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n         \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n         \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n         \"  blocks used:    %zu\\n\"\n         \"  bytes used:     %zu\",\n         pages, smallest_page, largest_page,\n         blocks, smallest_block, blocks_bytes / blocks, largest_block,\n         used_blocks, used_size);\n  return h;\n error:;\n  int err = errno;\n  if (h) {\n    free (h->bitmap);\n    if (h->addr && h->size && h->addr != MAP_FAILED) {\n      if (!h->writable)\n        munmap (h->addr, h->size);\n      else\n        free (h->addr);\n    }\n    if (h->fd >= 0)\n      close (h->fd);\n    free (h->filename);\n    free (h);\n  }\n  errno = err;\n  return NULL;\n}\nint\nhivex_commit (hive_h *h, const char *filename, int flags)\n{\n  int fd;\n  if (flags != 0) {\n    SET_ERRNO (EINVAL, \"flags != 0\");\n    return -1;\n  }\n  CHECK_WRITABLE (-1);\n  filename = filename ? : h->filename;\n#ifdef O_CLOEXEC\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_CLOEXEC|O_BINARY,\n             0666);\n#else\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_BINARY, 0666);\n#endif\n  if (fd == -1)\n    return -1;\n#ifndef O_CLOEXEC\n  fcntl (fd, F_SETFD, FD_CLOEXEC);\n#endif\n  uint32_t sequence = le32toh (h->hdr->sequence1);\n  sequence++;\n  h->hdr->sequence1 = htole32 (sequence);\n  h->hdr->sequence2 = htole32 (sequence);\n  h->hdr->blocks = htole32 (h->endpages - 0x1000);\n  uint32_t sum = header_checksum (h);\n  h->hdr->csum = htole32 (sum);\n  DEBUG (2, \"hivex_commit: new header checksum: 0x%x\", sum);\n  if (full_write (fd, h->addr, h->size) != h->size) {\n    int err = errno;\n    close (fd);\n    errno = err;\n    return -1;\n  }\n  if (close (fd) == -1)\n    return -1;\n  return 0;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_792.c",
        "project": "libguestfs/hivex",
        "url": "https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n}\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n}\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n}\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n}\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n    }\n    if (buf->offset + entry_length >= buf_maxlen) {\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n    }\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n        }\n        uint32_t ptagx_count = 0;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                i++;\n            }\n            if (value != 0) {\n                if (value == tagx->tags[i].bitmask) {\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                } else {\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            } else {\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            i++;\n        }\n    }\n}\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); \n    const uint32_t header_length = mobi_buffer_get32(buf); \n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n    mobi_buffer_seek(buf, 4); \n    const uint32_t type = mobi_buffer_get32(buf); \n    mobi_buffer_seek(buf, 4); \n    const uint32_t idxt_offset = mobi_buffer_get32(buf); \n    const uint32_t entries_count = mobi_buffer_get32(buf); \n    if (entries_count > INDX_RECORD_MAXCNT) {\n    }\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n    } else {\n        if (idxt_offset == 0) {\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n        }\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n            }\n        }\n    }\n}\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n    }\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n    }\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n    }\n}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit\nFile number 2:\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD \n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"index.h\"\n#include \"util.h\"\n#include \"memory.h\"\n#include \"debug.h\"\n#include \"buffer.h\"\nsize_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n    if (!output) {\n        buf->error = MOBI_PARAM_ERR;\n        return 0;\n    }\n    if (buf->offset + length > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    const unsigned char replacement = 0x3f;\n    size_t output_length = 0;\n    size_t i = 0;\n    while (i < length && output_length < INDX_LABEL_SIZEMAX) {\n        unsigned char c = mobi_buffer_get8(buf);\n        i++;\n        if (c == 0) {\n            debug_print(\"Invalid character: %u\\n\", c);\n            c = replacement;\n        }\n        if (c <= 5 && has_ligatures) {\n            unsigned char c2 = mobi_buffer_get8(buf);\n            c = mobi_ligature_to_cp1252(c, c2);\n            if (c == 0) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, -1);\n                c = replacement;\n            } else {\n                i++;\n            }\n        }\n        *output++ = c;\n        output_length++;\n    }\n    *output = '\\0';\n    return output_length;\n}\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n    mobi_buffer_setpos(buf, ordt->ordt1_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT1 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT1 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt1 = malloc(ordt->offsets_count * sizeof(*ordt->ordt1));\n        if (ordt->ordt1 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT1 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt1[i++] = mobi_buffer_get8(buf);\n        }\n        debug_print(\"ORDT1: read %zu entries\\n\", ordt->offsets_count);\n    }\n    mobi_buffer_setpos(buf, ordt->ordt2_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT2 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count * 2 + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT2 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt2 = malloc(ordt->offsets_count * sizeof(*ordt->ordt2));\n        if (ordt->ordt2 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT2 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt2[i++] = mobi_buffer_get16(buf);\n        }\n        debug_print(\"ORDT2: read %zu entries\\n\", ordt->offsets_count);\n    }\n    return MOBI_SUCCESS;\n}\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n    tagx->control_byte_count = 0;\n    tagx->tags_count = 0;\n    tagx->tags = NULL;\n    mobi_buffer_seek(buf, 4); \n    uint32_t tagx_record_length = mobi_buffer_get32(buf);\n    if (tagx_record_length < 12) {\n        debug_print(\"INDX record too short: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->control_byte_count = mobi_buffer_get32(buf);\n    tagx_record_length -= 12;\n    if (tagx_record_length + buf->offset > buf->maxlen) {\n        debug_print(\"INDX record too long: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags = malloc(tagx_record_length * sizeof(TAGXTags));\n    if (tagx->tags == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed for TAGX tags\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    const size_t tagx_data_length = tagx_record_length / 4;\n    size_t control_byte_count = 0;\n    while (i < tagx_data_length) {\n        tagx->tags[i].tag = mobi_buffer_get8(buf);\n        tagx->tags[i].values_count = mobi_buffer_get8(buf);\n        tagx->tags[i].bitmask = mobi_buffer_get8(buf);\n        const uint8_t control_byte = mobi_buffer_get8(buf);\n        if (control_byte) { control_byte_count++; }\n        tagx->tags[i].control_byte = control_byte;\n        debug_print(\"tagx[%zu]:\\t%i\\t%i\\t%i\\t%i\\n\", i, tagx->tags[i].tag, tagx->tags[i].values_count, tagx->tags[i].bitmask, control_byte);\n        i++;\n    }\n    if (tagx->control_byte_count != control_byte_count) {\n        debug_print(\"Wrong count of control bytes: %zu != %zu\\n\", tagx->control_byte_count, control_byte_count);\n        free(tagx->tags);\n        tagx->tags = NULL;\n        tagx->control_byte_count = 0;\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags_count = i;\n    return MOBI_SUCCESS;\n}\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n    size_t i = 0;\n    size_t output_length = 0;\n    const uint32_t bytemask = 0xbf;\n    const uint32_t bytemark = 0x80;\n    const uint32_t uni_replacement = 0xfffd;\n    const uint32_t surrogate_offset = 0x35fdc00;\n    static const uint8_t init_byte[7] = { 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc };\n    while (i < length) {\n        uint16_t offset;\n        i += mobi_ordt_getbuffer(ordt, buf, &offset);\n        uint32_t codepoint = mobi_ordt_lookup(ordt, offset);\n        if (codepoint <= 5) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            codepoint = mobi_ligature_to_utf16(codepoint, codepoint2);\n            if (codepoint == uni_replacement) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, - (int) k);\n            } else {\n                i += k;\n            }\n        }\n        if (codepoint >= 0xd800 && codepoint <= 0xdbff) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            if (codepoint2 >= 0xdc00 && codepoint2 <= 0xdfff) {\n                i += k;\n                codepoint = (codepoint << 10) + codepoint2 - surrogate_offset;\n            } else {\n                debug_print(\"Invalid code point: %u\\n\", codepoint);\n                mobi_buffer_seek(buf, - (int) k);\n                codepoint = uni_replacement;\n            }\n        }\n        if ((codepoint >= 0xdc00 && codepoint <= 0xdfff) \n            || (codepoint >= 0xfdd0 && codepoint <= 0xfdef) \n            || (codepoint & 0xfffe) == 0xfffe \n            || codepoint == 0 ) {\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        size_t bytes;\n        if (codepoint < 0x80) { bytes = 1; }\n        else if (codepoint < 0x800) { bytes = 2; }\n        else if (codepoint < 0x10000) { bytes = 3; }\n        else if (codepoint < 0x110000) { bytes = 4; }\n        else {\n            bytes = 3;\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        if (output_length + bytes >= INDX_LABEL_SIZEMAX) {\n            debug_print(\"%s\\n\", \"INDX label too long\");\n            break;\n        }\n        output += bytes;\n        switch (bytes) {\n            case 4: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 3: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 2: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 1: *--output = (uint8_t)(codepoint | init_byte[bytes]);\n        }\n        output += bytes;\n        output_length += bytes;\n    }\n    *output = '\\0';\n    return output_length;\n}\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                if (value == tagx->tags[i].bitmask) {\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            } else {\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n        debug_print(\"%s\", \"index structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); \n    const uint32_t header_length = mobi_buffer_get32(buf); \n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n        debug_print(\"INDX wrong magic: %s or header length: %u\\n\", indx_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_seek(buf, 4); \n    const uint32_t type = mobi_buffer_get32(buf); \n    mobi_buffer_seek(buf, 4); \n    const uint32_t idxt_offset = mobi_buffer_get32(buf); \n    const uint32_t entries_count = mobi_buffer_get32(buf); \n    if (entries_count > INDX_RECORD_MAXCNT) {\n        debug_print(\"Too many index entries (%u)\\n\", entries_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n        buf->maxlen = header_length;\n        uint32_t encoding = mobi_buffer_get32(buf); \n        if (encoding == MOBI_NOTSET) { encoding = MOBI_CP1252; }\n        mobi_buffer_seek(buf, 4); \n        const uint32_t total_entries_count = mobi_buffer_get32(buf); \n        if (total_entries_count > INDX_TOTAL_MAXCNT) {\n            debug_print(\"Too many total index entries (%u)\\n\", total_entries_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_offset = mobi_buffer_get32(buf); \n        if (ordt_offset + ORDT_RECORD_MAXCNT + 4 > indx_record->size) {\n            ordt_offset = 0;\n        }\n        uint32_t ligt_offset = mobi_buffer_get32(buf); \n        uint32_t ligt_entries_count = mobi_buffer_get32(buf); \n        if (ligt_offset + 4 * ligt_entries_count + 4 > indx_record->size) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        const uint32_t cncx_records_count = mobi_buffer_get32(buf); \n        if (cncx_records_count > CNCX_RECORD_MAXCNT) {\n            debug_print(\"Too many CNCX records (%u)\\n\", cncx_records_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_type = 0;\n        uint32_t ordt_entries_count = 0;\n        uint32_t ordt1_offset = 0;\n        uint32_t ordt2_offset = 0;\n        uint32_t index_name_offset = 0;\n        uint32_t index_name_length = 0;\n        if (header_length >= 180) {\n            mobi_buffer_setpos(buf, 164);\n            ordt_type = mobi_buffer_get32(buf); \n            ordt_entries_count = mobi_buffer_get32(buf); \n            ordt1_offset = mobi_buffer_get32(buf); \n            ordt2_offset = mobi_buffer_get32(buf); \n            const size_t entry_size = (ordt_type == 0) ? 1 : 2;\n            if (ordt1_offset + entry_size * ordt_entries_count > indx_record->size\n                || ordt2_offset + 2 * ordt_entries_count > indx_record->size) {\n                ordt1_offset = 0;\n                ordt2_offset = 0;\n                ordt_entries_count = 0;\n            }\n            index_name_offset = mobi_buffer_get32(buf); \n            index_name_length = mobi_buffer_get32(buf); \n        }\n        buf->maxlen = indx_record->size;\n        mobi_buffer_setpos(buf, header_length);\n        ret = mobi_parse_tagx(buf, tagx);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (ordt_entries_count > 0) {\n            ordt->offsets_count = ordt_entries_count;\n            ordt->type = ordt_type;\n            ordt->ordt1_pos = ordt1_offset;\n            ordt->ordt2_pos = ordt2_offset;\n            ret = mobi_parse_ordt(buf, ordt);\n            debug_print(\"ORDT: %u, %u, %u, %u\\n\", ordt_type, ordt_entries_count, ordt1_offset, ordt2_offset);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                return ret;\n            }\n        }\n        if (index_name_offset > 0 && index_name_length > 0) {\n            if (index_name_length <= header_length - index_name_offset && index_name_length < INDX_NAME_SIZEMAX) {\n                mobi_buffer_setpos(buf, index_name_offset);\n                char *name = malloc(index_name_length + 1);\n                if (name == NULL) {\n                    debug_print(\"%s\", \"Memory allocation failed\\n\");\n                    mobi_buffer_free_null(buf);\n                    return MOBI_MALLOC_FAILED;\n                }\n                mobi_buffer_getstring(name, buf, index_name_length);\n                indx->orth_index_name = name;\n                debug_print(\"Orth index name: %s\\n\", name);\n            }\n        }\n        indx->encoding = encoding;\n        indx->type = type;\n        indx->entries_count = entries_count;\n        indx->total_entries_count = total_entries_count;\n        if (ligt_entries_count != 0 && !mobi_buffer_match_magic_offset(buf, LIGT_MAGIC, ligt_offset)) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        indx->ligt_offset = ligt_offset;\n        indx->ligt_entries_count = ligt_entries_count;\n        indx->ordt_offset = ordt_offset;\n        indx->cncx_records_count = cncx_records_count;\n    } else {\n        if (idxt_offset == 0) {\n            debug_print(\"%s\", \"Missing IDXT offset\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n            debug_print(\"IDXT entries beyond record end%s\", \"\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        MOBIIdxt idxt;\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n            mobi_buffer_free_null(buf);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"IDXT parsing failed\\n\");\n            mobi_buffer_free_null(buf);\n            free(offsets);\n            return ret;\n        }\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    return ret;\n                }\n            }\n            indx->entries_count += entries_count;\n        }\n        free(offsets);\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBI_RET ret;\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n        mobi_free_indx(indx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return ret;\n    }\n    size_t count = indx->entries_count;\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_indx(indx);\n            mobi_free_tagx(tagx);\n            mobi_free_ordt(ordt);\n            return ret;\n        }\n    }\n    if (indx->entries_count != indx->total_entries_count) {\n        debug_print(\"Entries count %zu != total entries count %zu\\n\", indx->entries_count, indx->total_entries_count);\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (indx->cncx_records_count) {\n        indx->cncx_record = record->next;\n    }\n    mobi_free_tagx(tagx);\n    mobi_free_ordt(ordt);\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\nsize_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {\n    if (root == NULL) {\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 0;\n    size_t length = strlen(string);\n    MOBITrie *node = root;\n    while (node && length > 0) {\n        char **values = NULL;\n        size_t values_count = 0;\n        node = mobi_trie_get_next(&values, &values_count, node, string[length - 1]);\n        length--;\n        for (size_t j = 0; j < values_count; j++) {\n            if (count == INDX_INFLSTRINGS_MAX) {\n                debug_print(\"Inflection strings array too small (%d)\\n\", INDX_INFLSTRINGS_MAX);\n                break;\n            }\n            char infl_string[INDX_LABEL_SIZEMAX + 1];\n            const size_t suffix_length = strlen(values[j]);\n            if (length + suffix_length > INDX_LABEL_SIZEMAX) {\n                debug_print(\"Label too long (%zu + %zu)\\n\", length, suffix_length);\n                continue;\n            }\n            memcpy(infl_string, string, length);\n            memcpy(infl_string + length, values[j], suffix_length);\n            infl_string[length + suffix_length] = '\\0';\n            infl_strings[count++] = strdup(infl_string);\n        }\n    }\n    return count;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_7847.c",
        "project": "bfabiszewski/libmobi",
        "url": "https://github.com/bfabiszewski/libmobi/commit/eafc415bc6067e72577f70d6dd5acbf057ce6e6f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n    zip_uint8_t buf[CDENTRYSIZE];\n    bool from_buffer = (buffer != NULL);\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n        }\n    }\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n    }\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n    if (!_zip_buffer_ok(buffer)) {\n    }\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n        }\n    }\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t    }\n\t}\n    }\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n        if (ef == NULL) {\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t}\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t    }\n\t}\n    }\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n}\nstatic zip_string_t *\n_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)\n    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);\n    if (ef == NULL || ef_len < 5 || ef[0] != 1) {\n\treturn str;\n    }\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n        return str;\n    }\n    _zip_buffer_get_8(buffer);\n    ef_crc = _zip_buffer_get_32(buffer);\n    if (_zip_string_crc32(str) == ef_crc) {\n        zip_uint16_t len = (zip_uint16_t)_zip_buffer_left(buffer);\n        zip_string_t *ef_str = _zip_string_new(_zip_buffer_get(buffer, len), len, ZIP_FL_ENC_UTF_8, NULL);\n\tif (ef_str != NULL) {\n\t    str = ef_str;\n\t}\n    }\n    return str;\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\nThanks to Info-ZIP for info on the DOS-time/date conversion code,\nand some other general information gathered from their sources.\n\nThanks to these people for suggestions, testing, and bug reports:\n\nAlexander Galanin <al@galanin.nnov.ru>\nAlexandr Shadchin <alexandr.shadchin@gmail.com>\nAndrew Brampton <brampton@gmail.com>\nAndrew Molyneux <andrew@molyneuxfamily.co.uk>\nAnkur Kothari <ankz.kothari@gmail.com>\nBALATON Zoltan <balaton@eik.bme.hu>\nBenjamin Gilbert <bgilbert@backtick.net>\nBoaz Stolk <bstolk@aweta.nl>\nBogdan <bogiebog@gmail.com>\nBrian 'geeknik' Carpenter <geeknik@protonmail.ch>\nChris Nehren <cnehren+libzip@pobox.com>\nCoverity <info@coverity.com>\nDane Springmeyer <dane.springmeyer@gmail.com>\nDavid Demelier <demelier.david@gmail.com>\nDel Merritt <del@alum.mit.edu>\nDmytro Rybachenko <atmoliton@gmail.com>\nFran\u00e7ois Simon <AT.GFI.Francois.SIMON@sesam-vitale.fr>\nFrederik Ramm <frederik@remote.org>\nHanno B\u00f6ck <hanno@hboeck.de>\nHeiko Hund <heiko@ist.eigentlich.net>\nInfo-ZIP group\nJan Wei\u00df <jan@geheimwerk.de>\nJay Freeman (saurik) <saurik@saurik.com>\nJoel Ebrahimi <joel.ebrahimi@gmail.com>\nJono Spiro <jono.spiro@gmail.com>\nKeith Jones <keith@keithjjones.com>\nKohei Yoshida <kohei.yoshida@gmail.com>\nLeith Bade <leith@mapbox.com>\nLubomir I. Ivanov <neolit123@gmail.com>\nMartin Buchholz <martinrb@google.com>\nMartin Szulecki <m.szulecki@libimobiledevice.org>\nMichael Beck <mm.beck@gmx.net>\nMichal Vyskocil <mvyskocil@suse.cz>\nMikhail Gusarov <dottedmag@dottedmag.net>.\nOliver Kaiser <under.northern.sky@googlemail.com>\nOliver Kuckertz <oliver.kuckertz@mologie.de>\nPascal Terjan <pterjan@gmail.com>\nPatrick Spendrin <ps_ml@gmx.de>\nPaul Harris <harris.pc@gmail.com>\nPaul Sheppard <shepsoft@googlemail.com>\nPierre Joye <pierre.php@gmail.com>\nPierre-Louis Cabelguen <plcabelguen@googlemail.com>\nRemi Collet <remi@fedoraproject.org>\nRick Carback <carback1@umbc.edu>\nRobert Norris <rw_norris@hotmail.com>\nRoberto Tirabassi <rtirabassi@3di.it>\nRoland Ortloff <Ortloff.R@gmx.de>\nSergei Ozerov <ru.programmist@gmail.com>\nSimon Talbot <simont@nse.co.uk>\nStephen Bryant <steve@bawue.de>\nTarmo Pikaro <tapika@yahoo.com>\nTimo Warns <warns@pre-sense.de>\nTom Callaway <tcallawa@redhat.com>\nTomas Hoger <thoger@redhat.com>\nTorsten Paul <Torsten.Paul@gmx.de>\nVassili Courzakis <vcoxvco@googlemail.com>\nWojciech Michalski <wmichalski@quay.pl>\nWolfgang Glunz <Wolfgang.Glunz@gmx.de>\n\nFile number 2:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n#include \"zipint.h\"\nstatic time_t _zip_d2u_time(zip_uint16_t, zip_uint16_t);\nstatic zip_string_t *_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str);\nstatic zip_extra_field_t *_zip_ef_utf8(zip_uint16_t, zip_string_t *, zip_error_t *);\nstatic bool _zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error);\nzip_int64_t\n_zip_cdir_write(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors)\n{\n    zip_uint64_t offset, size;\n    zip_string_t *comment;\n    zip_uint8_t buf[EOCDLEN + EOCD64LEN + EOCD64LOCLEN];\n    zip_buffer_t *buffer;\n    zip_int64_t off;\n    zip_uint64_t i;\n    bool is_zip64;\n    int ret;\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    offset = (zip_uint64_t)off;\n    is_zip64 = false;\n    for (i=0; i<survivors; i++) {\n\tzip_entry_t *entry = za->entry+filelist[i].idx;\n\tif ((ret=_zip_dirent_write(za, entry->changes ? entry->changes : entry->orig, ZIP_FL_CENTRAL)) < 0)\n\t    return -1;\n\tif (ret)\n\t    is_zip64 = true;\n    }\n    if ((off = zip_source_tell_write(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return -1;\n    }\n    size = (zip_uint64_t)off - offset;\n    if (offset > ZIP_UINT32_MAX || survivors > ZIP_UINT16_MAX)\n\tis_zip64 = true;\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        return -1;\n    }\n    if (is_zip64) {\n\t_zip_buffer_put(buffer, EOCD64_MAGIC, 4);\n        _zip_buffer_put_64(buffer, EOCD64LEN-12);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_16(buffer, 45);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, survivors);\n\t_zip_buffer_put_64(buffer, size);\n\t_zip_buffer_put_64(buffer, offset);\n\t_zip_buffer_put(buffer, EOCD64LOC_MAGIC, 4);\n\t_zip_buffer_put_32(buffer, 0);\n\t_zip_buffer_put_64(buffer, offset+size);\n\t_zip_buffer_put_32(buffer, 1);\n    }\n    _zip_buffer_put(buffer, EOCD_MAGIC, 4);\n    _zip_buffer_put_32(buffer, 0);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));\n    _zip_buffer_put_32(buffer, size >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)size);\n    _zip_buffer_put_32(buffer, offset >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)offset);\n    comment = za->comment_changed ? za->comment_changes : za->comment_orig;\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(comment ? comment->length : 0));\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return -1;\n    }\n    if (_zip_write(za, _zip_buffer_data(buffer), _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n\treturn -1;\n    }\n    _zip_buffer_free(buffer);\n    if (comment) {\n\tif (_zip_write(za, comment->raw, comment->length) < 0) {\n\t    return -1;\n\t}\n    }\n    return (zip_int64_t)size;\n}\nvoid\n_zip_dirent_init(zip_dirent_t *de)\n{\n    de->changed = 0;\n    de->local_extra_fields_read = 0;\n    de->cloned = 0;\n    de->crc_valid = true;\n    de->version_madeby = 63 | (ZIP_OPSYS_DEFAULT << 8);\n    de->version_needed = 10; \n    de->bitflags = 0;\n    de->comp_method = ZIP_CM_DEFAULT;\n    de->last_mod = 0;\n    de->crc = 0;\n    de->comp_size = 0;\n    de->uncomp_size = 0;\n    de->filename = NULL;\n    de->extra_fields = NULL;\n    de->comment = NULL;\n    de->disk_number = 0;\n    de->int_attrib = 0;\n    de->ext_attrib = ZIP_EXT_ATTRIB_DEFAULT;\n    de->offset = 0;\n    de->compression_level = 0;\n    de->encryption_method = ZIP_EM_NONE;\n    de->password = NULL;\n}\nzip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n    bool from_buffer = (buffer != NULL);\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n            (void)_zip_buffer_skip(ef_buffer, 8); \n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\treturn -1;\n    }\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n    return (zip_int64_t)(size + variable_size);\n}\nstatic zip_string_t *\n_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)\n{\n    zip_uint16_t ef_len;\n    zip_uint32_t ef_crc;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);\n    if (ef == NULL || ef_len < 5 || ef[0] != 1) {\n\treturn str;\n    }\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n        return str;\n    }\n    _zip_buffer_get_8(buffer);\n    ef_crc = _zip_buffer_get_32(buffer);\n    if (_zip_string_crc32(str) == ef_crc) {\n        zip_uint16_t len = (zip_uint16_t)_zip_buffer_left(buffer);\n        zip_string_t *ef_str = _zip_string_new(_zip_buffer_get(buffer, len), len, ZIP_FL_ENC_UTF_8, NULL);\n\tif (ef_str != NULL) {\n\t    _zip_string_free(str);\n\t    str = ef_str;\n\t}\n    }\n    _zip_buffer_free(buffer);\n    return str;\n}\nstatic bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t enc_method;\n    if (de->comp_method != ZIP_CM_WINZIP_AES) {\n\treturn true;\n    }\n    ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, ZIP_EF_WINZIP_AES, 0, ZIP_EF_BOTH, NULL);\n    if (ef == NULL || ef_len < 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn false;\n    }\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n\tzip_error_set(error, ZIP_ER_INTERNAL, 0);\n        return false;\n    }\n    crc_valid = true;\n    switch (_zip_buffer_get_16(buffer)) {\n    case 1:\n\tbreak;\n    case 2:\n\tif (de->uncomp_size < 20 ) {\n\t    crc_valid = false;\n\t}\n\tbreak;\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n    if (memcmp(_zip_buffer_get(buffer, 2), \"AE\", 2) != 0) {\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n    switch (_zip_buffer_get_8(buffer)) {\n    case 1:\n\tenc_method = ZIP_EM_AES_128;\n\tbreak;\n    case 2:\n\tenc_method = ZIP_EM_AES_192;\n\tbreak;\n    case 3:\n\tenc_method = ZIP_EM_AES_256;\n\tbreak;\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n    if (ef_len != 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n    de->crc_valid = crc_valid;\n    de->encryption_method = enc_method;\n    de->comp_method = _zip_buffer_get_16(buffer);\n    _zip_buffer_free(buffer);\n    return true;\n}\nint\n_zip_dirent_write(zip_t *za, zip_dirent_t *de, zip_flags_t flags)\n{\n    zip_uint16_t dostime, dosdate;\n    zip_encoding_type_t com_enc, name_enc;\n    zip_extra_field_t *ef;\n    zip_extra_field_t *ef64;\n    zip_uint32_t ef_total_size;\n    bool is_zip64;\n    bool is_really_zip64;\n    bool is_winzip_aes;\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_buffer_t *buffer;\n    ef = NULL;\n    name_enc = _zip_guess_encoding(de->filename, ZIP_ENCODING_UNKNOWN);\n    com_enc = _zip_guess_encoding(de->comment, ZIP_ENCODING_UNKNOWN);\n    if ((name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_ASCII) ||\n\t(name_enc == ZIP_ENCODING_ASCII && com_enc == ZIP_ENCODING_UTF8_KNOWN) ||\n\t(name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_UTF8_KNOWN))\n\tde->bitflags |= ZIP_GPBF_ENCODING_UTF_8;\n    else {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCODING_UTF_8;\n\tif (name_enc == ZIP_ENCODING_UTF8_KNOWN) {\n\t    ef = _zip_ef_utf8(ZIP_EF_UTF_8_NAME, de->filename, &za->error);\n\t    if (ef == NULL)\n\t\treturn -1;\n\t}\n\tif ((flags & ZIP_FL_LOCAL) == 0 && com_enc == ZIP_ENCODING_UTF8_KNOWN){\n\t    zip_extra_field_t *ef2 = _zip_ef_utf8(ZIP_EF_UTF_8_COMMENT, de->comment, &za->error);\n\t    if (ef2 == NULL) {\n\t\t_zip_ef_free(ef);\n\t\treturn -1;\n\t    }\n\t    ef2->next = ef;\n\t    ef = ef2;\n\t}\n    }\n    if (de->encryption_method == ZIP_EM_NONE) {\n\tde->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCRYPTED;\n    }\n    else {\n\tde->bitflags |= (zip_uint16_t)ZIP_GPBF_ENCRYPTED;\n    }\n    is_really_zip64 = _zip_dirent_needs_zip64(de, flags);\n    is_zip64 = (flags & (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64)) == (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64) || is_really_zip64;\n    is_winzip_aes = de->encryption_method == ZIP_EM_AES_128 || de->encryption_method == ZIP_EM_AES_192 || de->encryption_method == ZIP_EM_AES_256;\n    if (is_zip64) {\n        zip_uint8_t ef_zip64[EFZIP64SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n        if (flags & ZIP_FL_LOCAL) {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX) {\n                _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                _zip_buffer_put_64(ef_buffer, de->comp_size);\n            }\n        }\n        else {\n            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX || de->offset > ZIP_UINT32_MAX) {\n                if (de->uncomp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->uncomp_size);\n                }\n                if (de->comp_size >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->comp_size);\n                }\n                if (de->offset >= ZIP_UINT32_MAX) {\n                    _zip_buffer_put_64(ef_buffer, de->offset);\n                }\n            }\n        }\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n        ef64 = _zip_ef_new(ZIP_EF_ZIP64, (zip_uint16_t)(_zip_buffer_offset(ef_buffer)), ef_zip64, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef64->next = ef;\n        ef = ef64;\n    }\n    if (is_winzip_aes) {\n\tzip_uint8_t data[EF_WINZIP_AES_SIZE];\n        zip_buffer_t *ef_buffer = _zip_buffer_new(data, sizeof(data));\n\tzip_extra_field_t *ef_winzip;\n        if (ef_buffer == NULL) {\n            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n\t_zip_buffer_put_16(ef_buffer, 2);\n\t_zip_buffer_put(ef_buffer, \"AE\", 2);\n\t_zip_buffer_put_8(ef_buffer, (zip_uint8_t)(de->encryption_method & 0xff));\n\t_zip_buffer_put_16(ef_buffer, (zip_uint16_t)de->comp_method);\n        if (!_zip_buffer_ok(ef_buffer)) {\n            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n            _zip_buffer_free(ef_buffer);\n\t    _zip_ef_free(ef);\n            return -1;\n        }\n        ef_winzip = _zip_ef_new(ZIP_EF_WINZIP_AES, EF_WINZIP_AES_SIZE, data, ZIP_EF_BOTH);\n        _zip_buffer_free(ef_buffer);\n        ef_winzip->next = ef;\n        ef = ef_winzip;\n    }\n    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {\n        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);\n        _zip_ef_free(ef);\n        return -1;\n    }\n    _zip_buffer_put(buffer, (flags & ZIP_FL_LOCAL) ? LOCAL_MAGIC : CENTRAL_MAGIC, 4);\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n        _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_madeby));\n    }\n    _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_needed));\n    _zip_buffer_put_16(buffer, de->bitflags);\n    if (is_winzip_aes) {\n\t_zip_buffer_put_16(buffer, ZIP_CM_WINZIP_AES);\n    }\n    else {\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->comp_method);\n    }\n    _zip_u2d_time(de->last_mod, &dostime, &dosdate);\n    _zip_buffer_put_16(buffer, dostime);\n    _zip_buffer_put_16(buffer, dosdate);\n    if (is_winzip_aes && de->uncomp_size < 20)  {\n\t_zip_buffer_put_32(buffer, 0);\n    }\n    else {\n\t_zip_buffer_put_32(buffer, de->crc);\n    }\n    if (((flags & ZIP_FL_LOCAL) == ZIP_FL_LOCAL) && ((de->comp_size >= ZIP_UINT32_MAX) || (de->uncomp_size >= ZIP_UINT32_MAX))) {\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n\t_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n    else {\n        if (de->comp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->comp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n        if (de->uncomp_size < ZIP_UINT32_MAX) {\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->uncomp_size);\n        }\n        else {\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n        }\n    }\n    _zip_buffer_put_16(buffer, _zip_string_length(de->filename));\n    ef_total_size = (zip_uint32_t)_zip_ef_size(de->extra_fields, flags) + (zip_uint32_t)_zip_ef_size(ef, ZIP_EF_BOTH);\n    _zip_buffer_put_16(buffer, (zip_uint16_t)ef_total_size);\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\t_zip_buffer_put_16(buffer, _zip_string_length(de->comment));\n\t_zip_buffer_put_16(buffer, (zip_uint16_t)de->disk_number);\n\t_zip_buffer_put_16(buffer, de->int_attrib);\n\t_zip_buffer_put_32(buffer, de->ext_attrib);\n\tif (de->offset < ZIP_UINT32_MAX)\n\t    _zip_buffer_put_32(buffer, (zip_uint32_t)de->offset);\n\telse\n\t    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);\n    }\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n    if (_zip_write(za, buf, _zip_buffer_offset(buffer)) < 0) {\n        _zip_buffer_free(buffer);\n        _zip_ef_free(ef);\n        return -1;\n    }\n    _zip_buffer_free(buffer);\n    if (de->filename) {\n\tif (_zip_string_write(za, de->filename) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n    if (ef) {\n\tif (_zip_ef_write(za, ef, ZIP_EF_BOTH) < 0) {\n            _zip_ef_free(ef);\n\t    return -1;\n\t}\n    }\n    _zip_ef_free(ef);\n    if (de->extra_fields) {\n\tif (_zip_ef_write(za, de->extra_fields, flags) < 0) {\n\t    return -1;\n\t}\n    }\n    if ((flags & ZIP_FL_LOCAL) == 0) {\n\tif (de->comment) {\n\t    if (_zip_string_write(za, de->comment) < 0) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n    return is_zip64;\n}\nstatic time_t\n_zip_d2u_time(zip_uint16_t dtime, zip_uint16_t ddate)\n{\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n    tm.tm_isdst = -1;\n    tm.tm_year = ((ddate>>9)&127) + 1980 - 1900;\n    tm.tm_mon = ((ddate>>5)&15) - 1;\n    tm.tm_mday = ddate&31;\n    tm.tm_hour = (dtime>>11)&31;\n    tm.tm_min = (dtime>>5)&63;\n    tm.tm_sec = (dtime<<1)&62;\n    return mktime(&tm);\n}\nstatic zip_extra_field_t *\n_zip_ef_utf8(zip_uint16_t id, zip_string_t *str, zip_error_t *error)\n{\n    const zip_uint8_t *raw;\n    zip_uint32_t len;\n    zip_buffer_t *buffer;\n    zip_extra_field_t *ef;\n    if ((raw=_zip_string_get(str, &len, ZIP_FL_ENC_RAW, NULL)) == NULL) {\n\treturn NULL;\n    }\n    if (len+5 > ZIP_UINT16_MAX) {\n        zip_error_set(error, ZIP_ER_INVAL, 0); \n        return NULL;\n    }\n    if ((buffer = _zip_buffer_new(NULL, len+5)) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n    _zip_buffer_put_8(buffer, 1);\n    _zip_buffer_put_32(buffer, _zip_string_crc32(str));\n    _zip_buffer_put(buffer, raw, len);\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        _zip_buffer_free(buffer);\n        return NULL;\n    }\n    ef = _zip_ef_new(id, (zip_uint16_t)(_zip_buffer_offset(buffer)), _zip_buffer_data(buffer), ZIP_EF_BOTH);\n    _zip_buffer_free(buffer);\n    return ef;\n}\n",
        "cwe": "CWE-415",
        "file_name": "safe_respovul_idx_2195.c",
        "project": "nih-at/libzip",
        "url": "https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t  void **data_page, size_t len, int cpu, int full)\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out_unlock;\n\tevent = rb_reader_event(cpu_buffer);\n\tread = reader->read;\n\tcommit = rb_page_commit(reader);\n\tmissed_events = cpu_buffer->lost_events;\n\tif (read || (len < (commit - read)) ||\n\t    cpu_buffer->reader_page == cpu_buffer->commit_page) {\n\t\tstruct buffer_data_page *rpage = cpu_buffer->reader_page->page;\n\t\tunsigned int rpos = read;\n\t\tunsigned int pos = 0;\n\t\tif (full)\n\t\t\tgoto out_unlock;\n\t\tif (len > (commit - read))\n\t\t\tlen = (commit - read);\n\t\tsize = rb_event_ts_length(event);\n\t\tsave_timestamp = cpu_buffer->read_stamp;\n\t\tdo {\n\t\t\tsize = rb_event_length(event);\n\t\t\tmemcpy(bpage->data + pos, rpage->data + rpos, size);\n\t\t\tlen -= size;\n\t\t\trb_advance_reader(cpu_buffer);\n\t\t\trpos = reader->read;\n\t\t\tpos += size;\n\t\t\tif (rpos >= commit)\n\t\t\t\tbreak;\n\t\t\tevent = rb_reader_event(cpu_buffer);\n\t\t\tsize = rb_event_ts_length(event);\n\t\t} while (len >= size);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/trace_events.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_clock.h>\n#include <linux/trace_seq.h>\n#include <linux/spinlock.h>\n#include <linux/irq_work.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\t\n#include <linux/kmemcheck.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n#include <asm/local.h>\nstatic void update_pages_handler(struct work_struct *work);\n#define RB_BUFFER_OFF\t\t(1 << 20)\n#define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)\n#define RB_EVNT_HDR_SIZE (offsetof(struct ring_buffer_event, array))\n#define RB_ALIGNMENT\t\t4U\n#define RB_MAX_SMALL_DATA\t(RB_ALIGNMENT * RINGBUF_TYPE_DATA_TYPE_LEN_MAX)\n#define RB_EVNT_MIN_SIZE\t8U\t\n#ifndef CONFIG_HAVE_64BIT_ALIGNED_ACCESS\n# define RB_FORCE_8BYTE_ALIGNMENT\t0\n# define RB_ARCH_ALIGNMENT\t\tRB_ALIGNMENT\n#else\n# define RB_FORCE_8BYTE_ALIGNMENT\t1\n# define RB_ARCH_ALIGNMENT\t\t8U\n#endif\n#define RB_ALIGN_DATA\t\t__aligned(RB_ARCH_ALIGNMENT)\n#define RINGBUF_TYPE_DATA 0 ... RINGBUF_TYPE_DATA_TYPE_LEN_MAX\nenum {\n\tRB_LEN_TIME_EXTEND = 8,\n\tRB_LEN_TIME_STAMP = 16,\n};\n#define skip_time_extend(event) \\\n\t((struct ring_buffer_event *)((char *)event + RB_LEN_TIME_EXTEND))\nEXPORT_SYMBOL_GPL(ring_buffer_event_data);\n#define for_each_buffer_cpu(buffer, cpu)\t\t\\\n\tfor_each_cpu(cpu, buffer->cpumask)\n#define TS_SHIFT\t27\n#define TS_MASK\t\t((1ULL << TS_SHIFT) - 1)\n#define TS_DELTA_TEST\t(~TS_MASK)\n#define RB_MISSED_EVENTS\t(1 << 31)\n#define RB_MISSED_STORED\t(1 << 30)\nstruct buffer_data_page {\n\tu64\t\t time_stamp;\t\n\tlocal_t\t\t commit;\t\n\tunsigned char\t data[] RB_ALIGN_DATA;\t\n};\nstruct buffer_page {\n\tstruct list_head list;\t\t\n\tlocal_t\t\t write;\t\t\n\tunsigned\t read;\t\t\n\tlocal_t\t\t entries;\t\n\tunsigned long\t real_end;\t\n\tstruct buffer_data_page *page;\t\n};\n#define RB_WRITE_MASK\t\t0xfffff\n#define RB_WRITE_INTCNT\t\t(1 << 20)\nstatic void rb_init_page(struct buffer_data_page *bpage)\n{\n\tlocal_set(&bpage->commit, 0);\n}\nstatic void free_buffer_page(struct buffer_page *bpage)\n{\n\tfree_page((unsigned long)bpage->page);\n\tkfree(bpage);\n}\n#define BUF_PAGE_SIZE (PAGE_SIZE - BUF_PAGE_HDR_SIZE)\n#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))\nstruct rb_irq_work {\n\tstruct irq_work\t\t\twork;\n\twait_queue_head_t\t\twaiters;\n\twait_queue_head_t\t\tfull_waiters;\n\tbool\t\t\t\twaiters_pending;\n\tbool\t\t\t\tfull_waiters_pending;\n\tbool\t\t\t\twakeup_full;\n};\nstruct rb_event_info {\n\tu64\t\t\tts;\n\tu64\t\t\tdelta;\n\tunsigned long\t\tlength;\n\tstruct buffer_page\t*tail_page;\n\tint\t\t\tadd_timestamp;\n};\nenum {\n\tRB_CTX_NMI,\n\tRB_CTX_IRQ,\n\tRB_CTX_SOFTIRQ,\n\tRB_CTX_NORMAL,\n\tRB_CTX_MAX\n};\nstruct ring_buffer_per_cpu {\n\tint\t\t\t\tcpu;\n\tatomic_t\t\t\trecord_disabled;\n\tstruct ring_buffer\t\t*buffer;\n\traw_spinlock_t\t\t\treader_lock;\t\n\tarch_spinlock_t\t\t\tlock;\n\tstruct lock_class_key\t\tlock_key;\n\tunsigned long\t\t\tnr_pages;\n\tunsigned int\t\t\tcurrent_context;\n\tstruct list_head\t\t*pages;\n\tstruct buffer_page\t\t*head_page;\t\n\tstruct buffer_page\t\t*tail_page;\t\n\tstruct buffer_page\t\t*commit_page;\t\n\tstruct buffer_page\t\t*reader_page;\n\tunsigned long\t\t\tlost_events;\n\tunsigned long\t\t\tlast_overrun;\n\tlocal_t\t\t\t\tentries_bytes;\n\tlocal_t\t\t\t\tentries;\n\tlocal_t\t\t\t\toverrun;\n\tlocal_t\t\t\t\tcommit_overrun;\n\tlocal_t\t\t\t\tdropped_events;\n\tlocal_t\t\t\t\tcommitting;\n\tlocal_t\t\t\t\tcommits;\n\tunsigned long\t\t\tread;\n\tunsigned long\t\t\tread_bytes;\n\tu64\t\t\t\twrite_stamp;\n\tu64\t\t\t\tread_stamp;\n\tlong\t\t\t\tnr_pages_to_update;\n\tstruct list_head\t\tnew_pages; \n\tstruct work_struct\t\tupdate_pages_work;\n\tstruct completion\t\tupdate_done;\n\tstruct rb_irq_work\t\tirq_work;\n};\nstruct ring_buffer {\n\tunsigned\t\t\tflags;\n\tint\t\t\t\tcpus;\n\tatomic_t\t\t\trecord_disabled;\n\tatomic_t\t\t\tresize_disabled;\n\tcpumask_var_t\t\t\tcpumask;\n\tstruct lock_class_key\t\t*reader_lock_key;\n\tstruct mutex\t\t\tmutex;\n\tstruct ring_buffer_per_cpu\t**buffers;\n#ifdef CONFIG_HOTPLUG_CPU\n\tstruct notifier_block\t\tcpu_notify;\n#endif\n\tu64\t\t\t\t(*clock)(void);\n\tstruct rb_irq_work\t\tirq_work;\n};\nstruct ring_buffer_iter {\n\tstruct ring_buffer_per_cpu\t*cpu_buffer;\n\tunsigned long\t\t\thead;\n\tstruct buffer_page\t\t*head_page;\n\tstruct buffer_page\t\t*cache_reader_page;\n\tunsigned long\t\t\tcache_read;\n\tu64\t\t\t\tread_stamp;\n};\nint ring_buffer_wait(struct ring_buffer *buffer, int cpu, bool full)\n{\n\tDEFINE_WAIT(wait);\n\tstruct rb_irq_work *work;\n\tint ret = 0;\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\twork = &buffer->irq_work;\n\t\tfull = false;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn -ENODEV;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\twork = &cpu_buffer->irq_work;\n\t}\n\twhile (true) {\n\t\tif (full)\n\t\t\tprepare_to_wait(&work->full_waiters, &wait, TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tprepare_to_wait(&work->waiters, &wait, TASK_INTERRUPTIBLE);\n\t\tif (full)\n\t\t\twork->full_waiters_pending = true;\n\t\telse\n\t\t\twork->waiters_pending = true;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (cpu == RING_BUFFER_ALL_CPUS && !ring_buffer_empty(buffer))\n\t\t\tbreak;\n\t\tif (cpu != RING_BUFFER_ALL_CPUS &&\n\t\t    !ring_buffer_empty_cpu(buffer, cpu)) {\n\t\t\tunsigned long flags;\n\t\t\tbool pagebusy;\n\t\t\tif (!full)\n\t\t\t\tbreak;\n\t\t\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\t\t\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n\t\t\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\t\t\tif (!pagebusy)\n\t\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\tif (full)\n\t\tfinish_wait(&work->full_waiters, &wait);\n\telse\n\t\tfinish_wait(&work->waiters, &wait);\n\treturn ret;\n}\nint ring_buffer_poll_wait(struct ring_buffer *buffer, int cpu,\n\t\t\t  struct file *filp, poll_table *poll_table)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct rb_irq_work *work;\n\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\twork = &buffer->irq_work;\n\telse {\n\t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn -EINVAL;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\twork = &cpu_buffer->irq_work;\n\t}\n\tpoll_wait(filp, &work->waiters, poll_table);\n\twork->waiters_pending = true;\n\tsmp_mb();\n\tif ((cpu == RING_BUFFER_ALL_CPUS && !ring_buffer_empty(buffer)) ||\n\t    (cpu != RING_BUFFER_ALL_CPUS && !ring_buffer_empty_cpu(buffer, cpu)))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}\n#define RB_WARN_ON(b, cond)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint _____ret = unlikely(cond);\t\t\t\t\\\n\t\tif (_____ret) {\t\t\t\t\t\t\\\n\t\t\tif (__same_type(*(b), struct ring_buffer_per_cpu)) { \\\n\t\t\t\tstruct ring_buffer_per_cpu *__b =\t\\\n\t\t\t\t\t(void *)b;\t\t\t\\\n\t\t\t\tatomic_inc(&__b->buffer->record_disabled); \\\n\t\t\t} else\t\t\t\t\t\t\\\n\t\t\t\tatomic_inc(&b->record_disabled);\t\\\n\t\t\tWARN_ON(1);\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t_____ret;\t\t\t\t\t\t\\\n\t})\n#define DEBUG_SHIFT 0\nEXPORT_SYMBOL_GPL(ring_buffer_time_stamp);\nEXPORT_SYMBOL_GPL(ring_buffer_normalize_time_stamp);\n#define RB_PAGE_NORMAL\t\t0UL\n#define RB_PAGE_HEAD\t\t1UL\n#define RB_PAGE_UPDATE\t\t2UL\n#define RB_FLAG_MASK\t\t3UL\n#define RB_PAGE_MOVED\t\t4UL\nstatic struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}\nstatic inline int\nrb_is_head_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\tstruct buffer_page *page, struct list_head *list)\n{\n\tunsigned long val;\n\tval = (unsigned long)list->next;\n\tif ((val & ~RB_FLAG_MASK) != (unsigned long)&page->list)\n\t\treturn RB_PAGE_MOVED;\n\treturn val & RB_FLAG_MASK;\n}\nstatic void rb_set_list_to_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\tstruct list_head *list)\n{\n\tunsigned long *ptr;\n\tptr = (unsigned long *)&list->next;\n\t*ptr |= RB_PAGE_HEAD;\n\t*ptr &= ~RB_PAGE_UPDATE;\n}\nstatic void rb_head_page_activate(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *head;\n\thead = cpu_buffer->head_page;\n\tif (!head)\n\t\treturn;\n\trb_set_list_to_head(cpu_buffer, head->list.prev);\n}\nstatic void rb_list_head_clear(struct list_head *list)\n{\n\tunsigned long *ptr = (unsigned long *)&list->next;\n\t*ptr &= ~RB_FLAG_MASK;\n}\nstatic void\nrb_head_page_deactivate(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *hd;\n\trb_list_head_clear(cpu_buffer->pages);\n\tlist_for_each(hd, cpu_buffer->pages)\n\t\trb_list_head_clear(hd);\n}\nstatic inline void rb_inc_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t       struct buffer_page **bpage)\n{\n\tstruct list_head *p = rb_list_head((*bpage)->list.next);\n\t*bpage = list_entry(p, struct buffer_page, list);\n}\nstatic struct buffer_page *\nrb_set_head_page(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *head;\n\tstruct buffer_page *page;\n\tstruct list_head *list;\n\tint i;\n\tif (RB_WARN_ON(cpu_buffer, !cpu_buffer->head_page))\n\t\treturn NULL;\n\tlist = cpu_buffer->pages;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev->next) != list))\n\t\treturn NULL;\n\tpage = head = cpu_buffer->head_page;\n\tfor (i = 0; i < 3; i++) {\n\t\tdo {\n\t\t\tif (rb_is_head_page(cpu_buffer, page, page->list.prev)) {\n\t\t\t\tcpu_buffer->head_page = page;\n\t\t\t\treturn page;\n\t\t\t}\n\t\t\trb_inc_page(cpu_buffer, &page);\n\t\t} while (page != head);\n\t}\n\tRB_WARN_ON(cpu_buffer, 1);\n\treturn NULL;\n}\nstatic void rb_tail_page_update(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t       struct buffer_page *tail_page,\n\t\t\t       struct buffer_page *next_page)\n{\n\tunsigned long old_entries;\n\tunsigned long old_write;\n\told_write = local_add_return(RB_WRITE_INTCNT, &next_page->write);\n\told_entries = local_add_return(RB_WRITE_INTCNT, &next_page->entries);\n\tbarrier();\n\tif (tail_page == READ_ONCE(cpu_buffer->tail_page)) {\n\t\tunsigned long val = old_write & ~RB_WRITE_MASK;\n\t\tunsigned long eval = old_entries & ~RB_WRITE_MASK;\n\t\t(void)local_cmpxchg(&next_page->write, old_write, val);\n\t\t(void)local_cmpxchg(&next_page->entries, old_entries, eval);\n\t\tlocal_set(&next_page->page->commit, 0);\n\t\t(void)cmpxchg(&cpu_buffer->tail_page, tail_page, next_page);\n\t}\n}\nstatic int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}\nstatic int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *head = cpu_buffer->pages;\n\tstruct buffer_page *bpage, *tmp;\n\tif (cpu_buffer->head_page)\n\t\trb_set_head_page(cpu_buffer);\n\trb_head_page_deactivate(cpu_buffer);\n\tif (RB_WARN_ON(cpu_buffer, head->next->prev != head))\n\t\treturn -1;\n\tif (RB_WARN_ON(cpu_buffer, head->prev->next != head))\n\t\treturn -1;\n\tif (rb_check_list(cpu_buffer, head))\n\t\treturn -1;\n\tlist_for_each_entry_safe(bpage, tmp, head, list) {\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       bpage->list.next->prev != &bpage->list))\n\t\t\treturn -1;\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       bpage->list.prev->next != &bpage->list))\n\t\t\treturn -1;\n\t\tif (rb_check_list(cpu_buffer, &bpage->list))\n\t\t\treturn -1;\n\t}\n\trb_head_page_activate(cpu_buffer);\n\treturn 0;\n}\nstatic int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)\n{\n\tstruct buffer_page *bpage, *tmp;\n\tlong i;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tbpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),\n\t\t\t\t    GFP_KERNEL | __GFP_NORETRY,\n\t\t\t\t    cpu_to_node(cpu));\n\t\tif (!bpage)\n\t\t\tgoto free_pages;\n\t\tlist_add(&bpage->list, pages);\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto free_pages;\n\t\tbpage->page = page_address(page);\n\t\trb_init_page(bpage->page);\n\t}\n\treturn 0;\nfree_pages:\n\tlist_for_each_entry_safe(bpage, tmp, pages, list) {\n\t\tlist_del_init(&bpage->list);\n\t\tfree_buffer_page(bpage);\n\t}\n\treturn -ENOMEM;\n}\nstatic struct ring_buffer_per_cpu *\nrb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_page *bpage;\n\tstruct page *page;\n\tint ret;\n\tcpu_buffer = kzalloc_node(ALIGN(sizeof(*cpu_buffer), cache_line_size()),\n\t\t\t\t  GFP_KERNEL, cpu_to_node(cpu));\n\tif (!cpu_buffer)\n\t\treturn NULL;\n\tcpu_buffer->cpu = cpu;\n\tcpu_buffer->buffer = buffer;\n\traw_spin_lock_init(&cpu_buffer->reader_lock);\n\tlockdep_set_class(&cpu_buffer->reader_lock, buffer->reader_lock_key);\n\tcpu_buffer->lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tINIT_WORK(&cpu_buffer->update_pages_work, update_pages_handler);\n\tinit_completion(&cpu_buffer->update_done);\n\tinit_irq_work(&cpu_buffer->irq_work.work, rb_wake_up_waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.full_waiters);\n\tbpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),\n\t\t\t    GFP_KERNEL, cpu_to_node(cpu));\n\tif (!bpage)\n\t\tgoto fail_free_buffer;\n\trb_check_bpage(cpu_buffer, bpage);\n\tcpu_buffer->reader_page = bpage;\n\tpage = alloc_pages_node(cpu_to_node(cpu), GFP_KERNEL, 0);\n\tif (!page)\n\t\tgoto fail_free_reader;\n\tbpage->page = page_address(page);\n\trb_init_page(bpage->page);\n\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);\n\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\tret = rb_allocate_pages(cpu_buffer, nr_pages);\n\tif (ret < 0)\n\t\tgoto fail_free_reader;\n\tcpu_buffer->head_page\n\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);\n\tcpu_buffer->tail_page = cpu_buffer->commit_page = cpu_buffer->head_page;\n\trb_head_page_activate(cpu_buffer);\n\treturn cpu_buffer;\n fail_free_reader:\n\tfree_buffer_page(cpu_buffer->reader_page);\n fail_free_buffer:\n\tkfree(cpu_buffer);\n\treturn NULL;\n}\n#ifdef CONFIG_HOTPLUG_CPU\nstatic int rb_cpu_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu);\n#endif\nstruct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,\n\t\t\t\t\tstruct lock_class_key *key)\n{\n\tstruct ring_buffer *buffer;\n\tlong nr_pages;\n\tint bsize;\n\tint cpu;\n\tbuffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),\n\t\t\t GFP_KERNEL);\n\tif (!buffer)\n\t\treturn NULL;\n\tif (!alloc_cpumask_var(&buffer->cpumask, GFP_KERNEL))\n\t\tgoto fail_free_buffer;\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tbuffer->flags = flags;\n\tbuffer->clock = trace_clock_local;\n\tbuffer->reader_lock_key = key;\n\tinit_irq_work(&buffer->irq_work.work, rb_wake_up_waiters);\n\tinit_waitqueue_head(&buffer->irq_work.waiters);\n\tif (nr_pages < 2)\n\t\tnr_pages = 2;\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpu_notifier_register_begin();\n\tcpumask_copy(buffer->cpumask, cpu_online_mask);\n#else\n\tcpumask_copy(buffer->cpumask, cpu_possible_mask);\n#endif\n\tbuffer->cpus = nr_cpu_ids;\n\tbsize = sizeof(void *) * nr_cpu_ids;\n\tbuffer->buffers = kzalloc(ALIGN(bsize, cache_line_size()),\n\t\t\t\t  GFP_KERNEL);\n\tif (!buffer->buffers)\n\t\tgoto fail_free_cpumask;\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tbuffer->buffers[cpu] =\n\t\t\trb_allocate_cpu_buffer(buffer, nr_pages, cpu);\n\t\tif (!buffer->buffers[cpu])\n\t\t\tgoto fail_free_buffers;\n\t}\n#ifdef CONFIG_HOTPLUG_CPU\n\tbuffer->cpu_notify.notifier_call = rb_cpu_notify;\n\tbuffer->cpu_notify.priority = 0;\n\t__register_cpu_notifier(&buffer->cpu_notify);\n\tcpu_notifier_register_done();\n#endif\n\tmutex_init(&buffer->mutex);\n\treturn buffer;\n fail_free_buffers:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tif (buffer->buffers[cpu])\n\t\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\t}\n\tkfree(buffer->buffers);\n fail_free_cpumask:\n\tfree_cpumask_var(buffer->cpumask);\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpu_notifier_register_done();\n#endif\n fail_free_buffer:\n\tkfree(buffer);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__ring_buffer_alloc);\nEXPORT_SYMBOL_GPL(ring_buffer_free);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic inline unsigned long rb_page_entries(struct buffer_page *bpage)\n{\n\treturn local_read(&bpage->entries) & RB_WRITE_MASK;\n}\nstatic int\nrb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}\nstatic int\nrb_insert_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *pages = &cpu_buffer->new_pages;\n\tint retries, success;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tretries = 10;\n\tsuccess = 0;\n\twhile (retries--) {\n\t\tstruct list_head *head_page, *prev_page, *r;\n\t\tstruct list_head *last_page, *first_page;\n\t\tstruct list_head *head_page_with_bit;\n\t\thead_page = &rb_set_head_page(cpu_buffer)->list;\n\t\tif (!head_page)\n\t\t\tbreak;\n\t\tprev_page = head_page->prev;\n\t\tfirst_page = pages->next;\n\t\tlast_page  = pages->prev;\n\t\thead_page_with_bit = (struct list_head *)\n\t\t\t\t     ((unsigned long)head_page | RB_PAGE_HEAD);\n\t\tlast_page->next = head_page_with_bit;\n\t\tfirst_page->prev = prev_page;\n\t\tr = cmpxchg(&prev_page->next, head_page_with_bit, first_page);\n\t\tif (r == head_page_with_bit) {\n\t\t\thead_page->prev = last_page;\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (success)\n\t\tINIT_LIST_HEAD(pages);\n\tRB_WARN_ON(cpu_buffer, !success);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tif (!success) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\t list) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\treturn success;\n}\nstatic void rb_update_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tint success;\n\tif (cpu_buffer->nr_pages_to_update > 0)\n\t\tsuccess = rb_insert_pages(cpu_buffer);\n\telse\n\t\tsuccess = rb_remove_pages(cpu_buffer,\n\t\t\t\t\t-cpu_buffer->nr_pages_to_update);\n\tif (success)\n\t\tcpu_buffer->nr_pages += cpu_buffer->nr_pages_to_update;\n}\nint ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\tif (!buffer)\n\t\treturn size;\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\tsize = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tsize *= BUF_PAGE_SIZE;\n\tif (size < BUF_PAGE_SIZE * 2)\n\t\tsize = BUF_PAGE_SIZE * 2;\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\tmutex_lock(&buffer->mutex);\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tget_online_cpus();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\t\tput_online_cpus();\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tget_online_cpus();\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n out:\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_resize);\nEXPORT_SYMBOL_GPL(ring_buffer_change_overwrite);\nstatic int\nrb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct buffer_page *tail_page,\n\t\t    struct buffer_page *next_page)\n{\n\tstruct buffer_page *new_head;\n\tint entries;\n\tint type;\n\tint ret;\n\tentries = rb_page_entries(next_page);\n\ttype = rb_head_page_set_update(cpu_buffer, next_page, tail_page,\n\t\t\t\t       RB_PAGE_HEAD);\n\tswitch (type) {\n\tcase RB_PAGE_HEAD:\n\t\tlocal_add(entries, &cpu_buffer->overrun);\n\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\tbreak;\n\tcase RB_PAGE_UPDATE:\n\t\tbreak;\n\tcase RB_PAGE_NORMAL:\n\t\treturn 1;\n\tcase RB_PAGE_MOVED:\n\t\treturn 1;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1); \n\t\treturn -1;\n\t}\n\tnew_head = next_page;\n\trb_inc_page(cpu_buffer, &new_head);\n\tret = rb_head_page_set_head(cpu_buffer, new_head, next_page,\n\t\t\t\t    RB_PAGE_NORMAL);\n\tswitch (ret) {\n\tcase RB_PAGE_HEAD:\n\tcase RB_PAGE_NORMAL:\n\t\tbreak;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1);\n\t\treturn -1;\n\t}\n\tif (ret == RB_PAGE_NORMAL) {\n\t\tstruct buffer_page *buffer_tail_page;\n\t\tbuffer_tail_page = READ_ONCE(cpu_buffer->tail_page);\n\t\tif (buffer_tail_page != tail_page &&\n\t\t    buffer_tail_page != next_page)\n\t\t\trb_head_page_set_normal(cpu_buffer, new_head,\n\t\t\t\t\t\tnext_page,\n\t\t\t\t\t\tRB_PAGE_HEAD);\n\t}\n\tif (type == RB_PAGE_HEAD) {\n\t\tret = rb_head_page_set_normal(cpu_buffer, next_page,\n\t\t\t\t\t      tail_page,\n\t\t\t\t\t      RB_PAGE_UPDATE);\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       ret != RB_PAGE_UPDATE))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic inline void\nrb_reset_tail(struct ring_buffer_per_cpu *cpu_buffer,\n\t      unsigned long tail, struct rb_event_info *info)\n{\n\tstruct buffer_page *tail_page = info->tail_page;\n\tstruct ring_buffer_event *event;\n\tunsigned long length = info->length;\n\tif (tail >= BUF_PAGE_SIZE) {\n\t\tif (tail == BUF_PAGE_SIZE)\n\t\t\ttail_page->real_end = 0;\n\t\tlocal_sub(length, &tail_page->write);\n\t\treturn;\n\t}\n\tevent = __rb_page_index(tail_page, tail);\n\tkmemcheck_annotate_bitfield(event, bitfield);\n\tlocal_add(BUF_PAGE_SIZE - tail, &cpu_buffer->entries_bytes);\n\ttail_page->real_end = tail;\n\tif (tail > (BUF_PAGE_SIZE - RB_EVNT_MIN_SIZE)) {\n\t\trb_event_set_padding(event);\n\t\tlocal_sub(length, &tail_page->write);\n\t\treturn;\n\t}\n\tevent->array[0] = (BUF_PAGE_SIZE - tail) - RB_EVNT_HDR_SIZE;\n\tevent->type_len = RINGBUF_TYPE_PADDING;\n\tevent->time_delta = 1;\n\tlength = (tail + length) - BUF_PAGE_SIZE;\n\tlocal_sub(length, &tail_page->write);\n}\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct ring_buffer_event *\nrb_move_tail(struct ring_buffer_per_cpu *cpu_buffer,\n\t     unsigned long tail, struct rb_event_info *info)\n{\n\tstruct buffer_page *tail_page = info->tail_page;\n\tstruct buffer_page *commit_page = cpu_buffer->commit_page;\n\tstruct ring_buffer *buffer = cpu_buffer->buffer;\n\tstruct buffer_page *next_page;\n\tint ret;\n\tnext_page = tail_page;\n\trb_inc_page(cpu_buffer, &next_page);\n\tif (unlikely(next_page == commit_page)) {\n\t\tlocal_inc(&cpu_buffer->commit_overrun);\n\t\tgoto out_reset;\n\t}\n\tif (rb_is_head_page(cpu_buffer, next_page, &tail_page->list)) {\n\t\tif (!rb_is_reader_page(cpu_buffer->commit_page)) {\n\t\t\tif (!(buffer->flags & RB_FL_OVERWRITE)) {\n\t\t\t\tlocal_inc(&cpu_buffer->dropped_events);\n\t\t\t\tgoto out_reset;\n\t\t\t}\n\t\t\tret = rb_handle_head_page(cpu_buffer,\n\t\t\t\t\t\t  tail_page,\n\t\t\t\t\t\t  next_page);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_reset;\n\t\t\tif (ret)\n\t\t\t\tgoto out_again;\n\t\t} else {\n\t\t\tif (unlikely((cpu_buffer->commit_page !=\n\t\t\t\t      cpu_buffer->tail_page) &&\n\t\t\t\t     (cpu_buffer->commit_page ==\n\t\t\t\t      cpu_buffer->reader_page))) {\n\t\t\t\tlocal_inc(&cpu_buffer->commit_overrun);\n\t\t\t\tgoto out_reset;\n\t\t\t}\n\t\t}\n\t}\n\trb_tail_page_update(cpu_buffer, tail_page, next_page);\n out_again:\n\trb_reset_tail(cpu_buffer, tail, info);\n\trb_end_commit(cpu_buffer);\n\tlocal_inc(&cpu_buffer->committing);\n\treturn ERR_PTR(-EAGAIN);\n out_reset:\n\trb_reset_tail(cpu_buffer, tail, info);\n\treturn NULL;\n}\nstatic noinline struct ring_buffer_event *\nrb_add_time_stamp(struct ring_buffer_event *event, u64 delta)\n{\n\tevent->type_len = RINGBUF_TYPE_TIME_EXTEND;\n\tif (rb_event_index(event)) {\n\t\tevent->time_delta = delta & TS_MASK;\n\t\tevent->array[0] = delta >> TS_SHIFT;\n\t} else {\n\t\tevent->time_delta = 0;\n\t\tevent->array[0] = 0;\n\t}\n\treturn skip_time_extend(event);\n}\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}\n#ifndef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n#endif\nstatic inline int\nrb_try_to_discard(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t  struct ring_buffer_event *event)\n{\n\tunsigned long new_index, old_index;\n\tstruct buffer_page *bpage;\n\tunsigned long index;\n\tunsigned long addr;\n\tnew_index = rb_event_index(event);\n\told_index = new_index + rb_event_ts_length(event);\n\taddr = (unsigned long)event;\n\taddr &= PAGE_MASK;\n\tbpage = READ_ONCE(cpu_buffer->tail_page);\n\tif (bpage->page == (void *)addr && rb_page_write(bpage) == old_index) {\n\t\tunsigned long write_mask =\n\t\t\tlocal_read(&bpage->write) & ~RB_WRITE_MASK;\n\t\tunsigned long event_length = rb_event_length(event);\n\t\told_index += write_mask;\n\t\tnew_index += write_mask;\n\t\tindex = local_cmpxchg(&bpage->write, old_index, new_index);\n\t\tif (index == old_index) {\n\t\t\tlocal_sub(event_length, &cpu_buffer->entries_bytes);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic void\nrb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned long max_count;\n again:\n\tmax_count = cpu_buffer->nr_pages * 100;\n\twhile (cpu_buffer->commit_page != READ_ONCE(cpu_buffer->tail_page)) {\n\t\tif (RB_WARN_ON(cpu_buffer, !(--max_count)))\n\t\t\treturn;\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       rb_is_reader_page(cpu_buffer->tail_page)))\n\t\t\treturn;\n\t\tlocal_set(&cpu_buffer->commit_page->page->commit,\n\t\t\t  rb_page_write(cpu_buffer->commit_page));\n\t\trb_inc_page(cpu_buffer, &cpu_buffer->commit_page);\n\t\tif (rb_page_write(cpu_buffer->commit_page))\n\t\t\tcpu_buffer->write_stamp =\n\t\t\t\tcpu_buffer->commit_page->page->time_stamp;\n\t\tbarrier();\n\t}\n\twhile (rb_commit_index(cpu_buffer) !=\n\t       rb_page_write(cpu_buffer->commit_page)) {\n\t\tlocal_set(&cpu_buffer->commit_page->page->commit,\n\t\t\t  rb_page_write(cpu_buffer->commit_page));\n\t\tRB_WARN_ON(cpu_buffer,\n\t\t\t   local_read(&cpu_buffer->commit_page->page->commit) &\n\t\t\t   ~RB_WRITE_MASK);\n\t\tbarrier();\n\t}\n\tbarrier();\n\tif (unlikely(cpu_buffer->commit_page != READ_ONCE(cpu_buffer->tail_page)))\n\t\tgoto again;\n}\nstatic __always_inline void\nrb_wakeups(struct ring_buffer *buffer, struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tbool pagebusy;\n\tif (buffer->irq_work.waiters_pending) {\n\t\tbuffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&buffer->irq_work.work);\n\t}\n\tif (cpu_buffer->irq_work.waiters_pending) {\n\t\tcpu_buffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n\tif (!pagebusy && cpu_buffer->irq_work.full_waiters_pending) {\n\t\tcpu_buffer->irq_work.wakeup_full = true;\n\t\tcpu_buffer->irq_work.full_waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n}\nstatic __always_inline int\ntrace_recursive_lock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned int val = cpu_buffer->current_context;\n\tint bit;\n\tif (in_interrupt()) {\n\t\tif (in_nmi())\n\t\t\tbit = RB_CTX_NMI;\n\t\telse if (in_irq())\n\t\t\tbit = RB_CTX_IRQ;\n\t\telse\n\t\t\tbit = RB_CTX_SOFTIRQ;\n\t} else\n\t\tbit = RB_CTX_NORMAL;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn 1;\n\tval |= (1 << bit);\n\tcpu_buffer->current_context = val;\n\treturn 0;\n}\nstatic __always_inline void\ntrace_recursive_unlock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tcpu_buffer->current_context &= cpu_buffer->current_context - 1;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_unlock_commit);\nstatic noinline void\nrb_handle_timestamp(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct rb_event_info *info)\n{\n\tWARN_ONCE(info->delta > (1ULL << 59),\n\t\t  KERN_WARNING \"Delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t  (unsigned long long)info->delta,\n\t\t  (unsigned long long)info->ts,\n\t\t  (unsigned long long)cpu_buffer->write_stamp,\n\t\t  sched_clock_stable() ? \"\" :\n\t\t  \"If you just came from a suspend/resume,\\n\"\n\t\t  \"please switch to the trace global clock:\\n\"\n\t\t  \"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\");\n\tinfo->add_timestamp = 1;\n}\nstatic struct ring_buffer_event *\n__rb_reserve_next(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t  struct rb_event_info *info)\n{\n\tstruct ring_buffer_event *event;\n\tstruct buffer_page *tail_page;\n\tunsigned long tail, write;\n\tif (unlikely(info->add_timestamp))\n\t\tinfo->length += RB_LEN_TIME_EXTEND;\n\ttail_page = info->tail_page = READ_ONCE(cpu_buffer->tail_page);\n\twrite = local_add_return(info->length, &tail_page->write);\n\twrite &= RB_WRITE_MASK;\n\ttail = write - info->length;\n\tif (!tail)\n\t\tinfo->delta = 0;\n\tif (unlikely(write > BUF_PAGE_SIZE))\n\t\treturn rb_move_tail(cpu_buffer, tail, info);\n\tevent = __rb_page_index(tail_page, tail);\n\tkmemcheck_annotate_bitfield(event, bitfield);\n\trb_update_event(cpu_buffer, event, info);\n\tlocal_inc(&tail_page->entries);\n\tif (!tail)\n\t\ttail_page->page->time_stamp = info->ts;\n\tlocal_add(info->length, &cpu_buffer->entries_bytes);\n\treturn event;\n}\nstatic struct ring_buffer_event *\nrb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_lock_reserve);\nEXPORT_SYMBOL_GPL(ring_buffer_discard_commit);\nEXPORT_SYMBOL_GPL(ring_buffer_write);\nEXPORT_SYMBOL_GPL(ring_buffer_record_disable);\nEXPORT_SYMBOL_GPL(ring_buffer_record_enable);\nEXPORT_SYMBOL_GPL(ring_buffer_record_off);\nEXPORT_SYMBOL_GPL(ring_buffer_record_on);\nEXPORT_SYMBOL_GPL(ring_buffer_record_disable_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_record_enable_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_oldest_event_ts);\nEXPORT_SYMBOL_GPL(ring_buffer_bytes_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_entries_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_overrun_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_commit_overrun_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_dropped_events_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_read_events_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_entries);\nEXPORT_SYMBOL_GPL(ring_buffer_overruns);\nEXPORT_SYMBOL_GPL(ring_buffer_iter_reset);\nEXPORT_SYMBOL_GPL(ring_buffer_iter_empty);\nstatic struct buffer_page *\nrb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *reader = NULL;\n\tunsigned long overwrite;\n\tunsigned long flags;\n\tint nr_loops = 0;\n\tint ret;\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n again:\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 3)) {\n\t\treader = NULL;\n\t\tgoto out;\n\t}\n\treader = cpu_buffer->reader_page;\n\tif (cpu_buffer->reader_page->read < rb_page_size(reader))\n\t\tgoto out;\n\tif (RB_WARN_ON(cpu_buffer,\n\t\t       cpu_buffer->reader_page->read > rb_page_size(reader)))\n\t\tgoto out;\n\treader = NULL;\n\tif (cpu_buffer->commit_page == cpu_buffer->reader_page)\n\t\tgoto out;\n\tif (rb_num_of_entries(cpu_buffer) == 0)\n\t\tgoto out;\n\tlocal_set(&cpu_buffer->reader_page->write, 0);\n\tlocal_set(&cpu_buffer->reader_page->entries, 0);\n\tlocal_set(&cpu_buffer->reader_page->page->commit, 0);\n\tcpu_buffer->reader_page->real_end = 0;\n spin:\n\treader = rb_set_head_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out;\n\tcpu_buffer->reader_page->list.next = rb_list_head(reader->list.next);\n\tcpu_buffer->reader_page->list.prev = reader->list.prev;\n\tcpu_buffer->pages = reader->list.prev;\n\trb_set_list_to_head(cpu_buffer, &cpu_buffer->reader_page->list);\n\tsmp_mb();\n\toverwrite = local_read(&(cpu_buffer->overrun));\n\tret = rb_head_page_replace(reader, cpu_buffer->reader_page);\n\tif (!ret)\n\t\tgoto spin;\n\trb_list_head(reader->list.next)->prev = &cpu_buffer->reader_page->list;\n\trb_inc_page(cpu_buffer, &cpu_buffer->head_page);\n\tcpu_buffer->reader_page = reader;\n\tcpu_buffer->reader_page->read = 0;\n\tif (overwrite != cpu_buffer->last_overrun) {\n\t\tcpu_buffer->lost_events = overwrite - cpu_buffer->last_overrun;\n\t\tcpu_buffer->last_overrun = overwrite;\n\t}\n\tgoto again;\n out:\n\tif (reader && reader->read == 0)\n\t\tcpu_buffer->read_stamp = reader->page->time_stamp;\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\treturn reader;\n}\nstatic void rb_advance_iter(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned length;\n\tcpu_buffer = iter->cpu_buffer;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\tif (iter->head_page == cpu_buffer->commit_page)\n\t\t\treturn;\n\t\trb_inc_iter(iter);\n\t\treturn;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tlength = rb_event_length(event);\n\tif (RB_WARN_ON(cpu_buffer,\n\t\t       (iter->head_page == cpu_buffer->commit_page) &&\n\t\t       (iter->head + length > rb_commit_index(cpu_buffer))))\n\t\treturn;\n\trb_update_iter_read_stamp(iter, event);\n\titer->head += length;\n\tif ((iter->head >= rb_page_size(iter->head_page)) &&\n\t    (iter->head_page != cpu_buffer->commit_page))\n\t\trb_inc_iter(iter);\n}\nstatic struct ring_buffer_event *\nrb_buffer_peek(struct ring_buffer_per_cpu *cpu_buffer, u64 *ts,\n\t       unsigned long *lost_events)\n{\n\tstruct ring_buffer_event *event;\n\tstruct buffer_page *reader;\n\tint nr_loops = 0;\n again:\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 2))\n\t\treturn NULL;\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\treturn NULL;\n\tevent = rb_reader_event(cpu_buffer);\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event))\n\t\t\tRB_WARN_ON(cpu_buffer, 1);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_reader(cpu_buffer);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\trb_advance_reader(cpu_buffer);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts) {\n\t\t\t*ts = cpu_buffer->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(cpu_buffer->buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\tif (lost_events)\n\t\t\t*lost_events = rb_lost_events(cpu_buffer);\n\t\treturn event;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_peek);\nstatic struct ring_buffer_event *\nrb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer *buffer;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint nr_loops = 0;\n\tcpu_buffer = iter->cpu_buffer;\n\tbuffer = cpu_buffer->buffer;\n\tif (unlikely(iter->cache_read != cpu_buffer->read ||\n\t\t     iter->cache_reader_page != cpu_buffer->reader_page))\n\t\trb_iter_reset(iter);\n again:\n\tif (ring_buffer_iter_empty(iter))\n\t\treturn NULL;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 3))\n\t\treturn NULL;\n\tif (rb_per_cpu_empty(cpu_buffer))\n\t\treturn NULL;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\trb_inc_iter(iter);\n\t\tgoto again;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event)) {\n\t\t\trb_inc_iter(iter);\n\t\t\tgoto again;\n\t\t}\n\t\trb_advance_iter(iter);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts) {\n\t\t\t*ts = iter->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\treturn event;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_iter_peek);\nEXPORT_SYMBOL_GPL(ring_buffer_consume);\nEXPORT_SYMBOL_GPL(ring_buffer_read_prepare);\nEXPORT_SYMBOL_GPL(ring_buffer_read_prepare_sync);\nEXPORT_SYMBOL_GPL(ring_buffer_read_start);\nEXPORT_SYMBOL_GPL(ring_buffer_read_finish);\nEXPORT_SYMBOL_GPL(ring_buffer_read);\nEXPORT_SYMBOL_GPL(ring_buffer_size);\nstatic void\nrb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\trb_head_page_deactivate(cpu_buffer);\n\tcpu_buffer->head_page\n\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);\n\tlocal_set(&cpu_buffer->head_page->write, 0);\n\tlocal_set(&cpu_buffer->head_page->entries, 0);\n\tlocal_set(&cpu_buffer->head_page->page->commit, 0);\n\tcpu_buffer->head_page->read = 0;\n\tcpu_buffer->tail_page = cpu_buffer->head_page;\n\tcpu_buffer->commit_page = cpu_buffer->head_page;\n\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);\n\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\tlocal_set(&cpu_buffer->reader_page->write, 0);\n\tlocal_set(&cpu_buffer->reader_page->entries, 0);\n\tlocal_set(&cpu_buffer->reader_page->page->commit, 0);\n\tcpu_buffer->reader_page->read = 0;\n\tlocal_set(&cpu_buffer->entries_bytes, 0);\n\tlocal_set(&cpu_buffer->overrun, 0);\n\tlocal_set(&cpu_buffer->commit_overrun, 0);\n\tlocal_set(&cpu_buffer->dropped_events, 0);\n\tlocal_set(&cpu_buffer->entries, 0);\n\tlocal_set(&cpu_buffer->committing, 0);\n\tlocal_set(&cpu_buffer->commits, 0);\n\tcpu_buffer->read = 0;\n\tcpu_buffer->read_bytes = 0;\n\tcpu_buffer->write_stamp = 0;\n\tcpu_buffer->read_stamp = 0;\n\tcpu_buffer->lost_events = 0;\n\tcpu_buffer->last_overrun = 0;\n\trb_head_page_activate(cpu_buffer);\n}\nEXPORT_SYMBOL_GPL(ring_buffer_reset_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_reset);\nEXPORT_SYMBOL_GPL(ring_buffer_empty);\nEXPORT_SYMBOL_GPL(ring_buffer_empty_cpu);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\nint ring_buffer_swap_cpu(struct ring_buffer *buffer_a,\n\t\t\t struct ring_buffer *buffer_b, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer_a;\n\tstruct ring_buffer_per_cpu *cpu_buffer_b;\n\tint ret = -EINVAL;\n\tif (!cpumask_test_cpu(cpu, buffer_a->cpumask) ||\n\t    !cpumask_test_cpu(cpu, buffer_b->cpumask))\n\t\tgoto out;\n\tcpu_buffer_a = buffer_a->buffers[cpu];\n\tcpu_buffer_b = buffer_b->buffers[cpu];\n\tif (cpu_buffer_a->nr_pages != cpu_buffer_b->nr_pages)\n\t\tgoto out;\n\tret = -EAGAIN;\n\tif (atomic_read(&buffer_a->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&buffer_b->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&cpu_buffer_a->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&cpu_buffer_b->record_disabled))\n\t\tgoto out;\n\tatomic_inc(&cpu_buffer_a->record_disabled);\n\tatomic_inc(&cpu_buffer_b->record_disabled);\n\tret = -EBUSY;\n\tif (local_read(&cpu_buffer_a->committing))\n\t\tgoto out_dec;\n\tif (local_read(&cpu_buffer_b->committing))\n\t\tgoto out_dec;\n\tbuffer_a->buffers[cpu] = cpu_buffer_b;\n\tbuffer_b->buffers[cpu] = cpu_buffer_a;\n\tcpu_buffer_b->buffer = buffer_a;\n\tcpu_buffer_a->buffer = buffer_b;\n\tret = 0;\nout_dec:\n\tatomic_dec(&cpu_buffer_a->record_disabled);\n\tatomic_dec(&cpu_buffer_b->record_disabled);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_swap_cpu);\n#endif \nEXPORT_SYMBOL_GPL(ring_buffer_alloc_read_page);\nEXPORT_SYMBOL_GPL(ring_buffer_free_read_page);\nint ring_buffer_read_page(struct ring_buffer *buffer,\n\t\t\t  void **data_page, size_t len, int cpu, int full)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tstruct buffer_data_page *bpage;\n\tstruct buffer_page *reader;\n\tunsigned long missed_events;\n\tunsigned long flags;\n\tunsigned int commit;\n\tunsigned int read;\n\tu64 save_timestamp;\n\tint ret = -1;\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\tif (len <= BUF_PAGE_HDR_SIZE)\n\t\tgoto out;\n\tlen -= BUF_PAGE_HDR_SIZE;\n\tif (!data_page)\n\t\tgoto out;\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out_unlock;\n\tevent = rb_reader_event(cpu_buffer);\n\tread = reader->read;\n\tcommit = rb_page_commit(reader);\n\tmissed_events = cpu_buffer->lost_events;\n\tif (read || (len < (commit - read)) ||\n\t    cpu_buffer->reader_page == cpu_buffer->commit_page) {\n\t\tstruct buffer_data_page *rpage = cpu_buffer->reader_page->page;\n\t\tunsigned int rpos = read;\n\t\tunsigned int pos = 0;\n\t\tunsigned int size;\n\t\tif (full)\n\t\t\tgoto out_unlock;\n\t\tif (len > (commit - read))\n\t\t\tlen = (commit - read);\n\t\tsize = rb_event_ts_length(event);\n\t\tif (len < size)\n\t\t\tgoto out_unlock;\n\t\tsave_timestamp = cpu_buffer->read_stamp;\n\t\tdo {\n\t\t\tsize = rb_event_length(event);\n\t\t\tmemcpy(bpage->data + pos, rpage->data + rpos, size);\n\t\t\tlen -= size;\n\t\t\trb_advance_reader(cpu_buffer);\n\t\t\trpos = reader->read;\n\t\t\tpos += size;\n\t\t\tif (rpos >= commit)\n\t\t\t\tbreak;\n\t\t\tevent = rb_reader_event(cpu_buffer);\n\t\t\tsize = rb_event_ts_length(event);\n\t\t} while (len >= size);\n\t\tlocal_set(&bpage->commit, pos);\n\t\tbpage->time_stamp = save_timestamp;\n\t\tread = 0;\n\t} else {\n\t\tcpu_buffer->read += rb_page_entries(reader);\n\t\tcpu_buffer->read_bytes += BUF_PAGE_SIZE;\n\t\trb_init_page(bpage);\n\t\tbpage = reader->page;\n\t\treader->page = *data_page;\n\t\tlocal_set(&reader->write, 0);\n\t\tlocal_set(&reader->entries, 0);\n\t\treader->read = 0;\n\t\t*data_page = bpage;\n\t\tif (reader->real_end)\n\t\t\tlocal_set(&bpage->commit, reader->real_end);\n\t}\n\tret = read;\n\tcpu_buffer->lost_events = 0;\n\tcommit = local_read(&bpage->commit);\n\tif (missed_events) {\n\t\tif (BUF_PAGE_SIZE - commit >= sizeof(missed_events)) {\n\t\t\tmemcpy(&bpage->data[commit], &missed_events,\n\t\t\t       sizeof(missed_events));\n\t\t\tlocal_add(RB_MISSED_STORED, &bpage->commit);\n\t\t\tcommit += sizeof(missed_events);\n\t\t}\n\t\tlocal_add(RB_MISSED_EVENTS, &bpage->commit);\n\t}\n\tif (commit < BUF_PAGE_SIZE)\n\t\tmemset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);\n out_unlock:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_read_page);\n#ifdef CONFIG_HOTPLUG_CPU\nstatic int rb_cpu_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tstruct ring_buffer *buffer =\n\t\tcontainer_of(self, struct ring_buffer, cpu_notify);\n\tlong cpu = (long)hcpu;\n\tlong nr_pages_same;\n\tint cpu_i;\n\tunsigned long nr_pages;\n\tswitch (action) {\n\tcase CPU_UP_PREPARE:\n\tcase CPU_UP_PREPARE_FROZEN:\n\t\tif (cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn NOTIFY_OK;\n\t\tnr_pages = 0;\n\t\tnr_pages_same = 1;\n\t\tfor_each_buffer_cpu(buffer, cpu_i) {\n\t\t\tif (nr_pages == 0)\n\t\t\t\tnr_pages = buffer->buffers[cpu_i]->nr_pages;\n\t\t\tif (nr_pages != buffer->buffers[cpu_i]->nr_pages) {\n\t\t\t\tnr_pages_same = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!nr_pages_same)\n\t\t\tnr_pages = 2;\n\t\tbuffer->buffers[cpu] =\n\t\t\trb_allocate_cpu_buffer(buffer, nr_pages, cpu);\n\t\tif (!buffer->buffers[cpu]) {\n\t\t\tWARN(1, \"failed to allocate ring buffer on CPU %ld\\n\",\n\t\t\t     cpu);\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\t\tsmp_wmb();\n\t\tcpumask_set_cpu(cpu, buffer->cpumask);\n\t\tbreak;\n\tcase CPU_DOWN_PREPARE:\n\tcase CPU_DOWN_PREPARE_FROZEN:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n#endif\n#ifdef CONFIG_RING_BUFFER_STARTUP_TEST\nstatic struct task_struct *rb_threads[NR_CPUS] __initdata;\nstruct rb_test_data {\n\tstruct ring_buffer\t*buffer;\n\tunsigned long\t\tevents;\n\tunsigned long\t\tbytes_written;\n\tunsigned long\t\tbytes_alloc;\n\tunsigned long\t\tbytes_dropped;\n\tunsigned long\t\tevents_nested;\n\tunsigned long\t\tbytes_written_nested;\n\tunsigned long\t\tbytes_alloc_nested;\n\tunsigned long\t\tbytes_dropped_nested;\n\tint\t\t\tmin_size_nested;\n\tint\t\t\tmax_size_nested;\n\tint\t\t\tmax_size;\n\tint\t\t\tmin_size;\n\tint\t\t\tcpu;\n\tint\t\t\tcnt;\n};\nstatic struct rb_test_data rb_data[NR_CPUS] __initdata;\n#define RB_TEST_BUFFER_SIZE\t1048576\nstatic char rb_string[] __initdata =\n\t\"abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()?+\\\\\"\n\t\"?+|:';\\\",.<>/?abcdefghijklmnopqrstuvwxyz1234567890\"\n\t\"!@#$%^&*()?+\\\\?+|:';\\\",.<>/?abcdefghijklmnopqrstuv\";\nstatic bool rb_test_started __initdata;\nstruct rb_item {\n\tint size;\n\tchar str[];\n};\nstatic __init int rb_write_something(struct rb_test_data *data, bool nested)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_item *item;\n\tbool started;\n\tint event_len;\n\tint size;\n\tint len;\n\tint cnt;\n\tcnt = data->cnt + (nested ? 27 : 0);\n\tsize = (data->cnt * 68 / 25) % (sizeof(rb_string) - 1);\n\tlen = size + sizeof(struct rb_item);\n\tstarted = rb_test_started;\n\tsmp_rmb();\n\tevent = ring_buffer_lock_reserve(data->buffer, len);\n\tif (!event) {\n\t\tif (started) {\n\t\t\tif (nested)\n\t\t\t\tdata->bytes_dropped += len;\n\t\t\telse\n\t\t\t\tdata->bytes_dropped_nested += len;\n\t\t}\n\t\treturn len;\n\t}\n\tevent_len = ring_buffer_event_length(event);\n\tif (RB_WARN_ON(data->buffer, event_len < len))\n\t\tgoto out;\n\titem = ring_buffer_event_data(event);\n\titem->size = size;\n\tmemcpy(item->str, rb_string, size);\n\tif (nested) {\n\t\tdata->bytes_alloc_nested += event_len;\n\t\tdata->bytes_written_nested += len;\n\t\tdata->events_nested++;\n\t\tif (!data->min_size_nested || len < data->min_size_nested)\n\t\t\tdata->min_size_nested = len;\n\t\tif (len > data->max_size_nested)\n\t\t\tdata->max_size_nested = len;\n\t} else {\n\t\tdata->bytes_alloc += event_len;\n\t\tdata->bytes_written += len;\n\t\tdata->events++;\n\t\tif (!data->min_size || len < data->min_size)\n\t\t\tdata->max_size = len;\n\t\tif (len > data->max_size)\n\t\t\tdata->max_size = len;\n\t}\n out:\n\tring_buffer_unlock_commit(data->buffer, event);\n\treturn 0;\n}\nstatic __init int rb_test(void *arg)\n{\n\tstruct rb_test_data *data = arg;\n\twhile (!kthread_should_stop()) {\n\t\trb_write_something(data, false);\n\t\tdata->cnt++;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tusleep_range(((data->cnt % 3) + 1) * 100, 1000);\n\t}\n\treturn 0;\n}\nstatic __init void rb_ipi(void *ignore)\n{\n\tstruct rb_test_data *data;\n\tint cpu = smp_processor_id();\n\tdata = &rb_data[cpu];\n\trb_write_something(data, true);\n}\nstatic __init int rb_hammer_test(void *arg)\n{\n\twhile (!kthread_should_stop()) {\n\t\tsmp_call_function(rb_ipi, NULL, 1);\n\t\tschedule();\n\t}\n\treturn 0;\n}\nstatic __init int test_ringbuffer(void)\n{\n\tstruct task_struct *rb_hammer;\n\tstruct ring_buffer *buffer;\n\tint cpu;\n\tint ret = 0;\n\tpr_info(\"Running ring buffer tests...\\n\");\n\tbuffer = ring_buffer_alloc(RB_TEST_BUFFER_SIZE, RB_FL_OVERWRITE);\n\tif (WARN_ON(!buffer))\n\t\treturn 0;\n\tring_buffer_record_off(buffer);\n\tfor_each_online_cpu(cpu) {\n\t\trb_data[cpu].buffer = buffer;\n\t\trb_data[cpu].cpu = cpu;\n\t\trb_data[cpu].cnt = cpu;\n\t\trb_threads[cpu] = kthread_create(rb_test, &rb_data[cpu],\n\t\t\t\t\t\t \"rbtester/%d\", cpu);\n\t\tif (WARN_ON(!rb_threads[cpu])) {\n\t\t\tpr_cont(\"FAILED\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out_free;\n\t\t}\n\t\tkthread_bind(rb_threads[cpu], cpu);\n \t\twake_up_process(rb_threads[cpu]);\n\t}\n\trb_hammer = kthread_run(rb_hammer_test, NULL, \"rbhammer\");\n\tif (WARN_ON(!rb_hammer)) {\n\t\tpr_cont(\"FAILED\\n\");\n\t\tret = -1;\n\t\tgoto out_free;\n\t}\n\tring_buffer_record_on(buffer);\n\tsmp_wmb();\n\trb_test_started = true;\n\tset_current_state(TASK_INTERRUPTIBLE);\n\t;\n\tschedule_timeout(10 * HZ);\n\tkthread_stop(rb_hammer);\n out_free:\n\tfor_each_online_cpu(cpu) {\n\t\tif (!rb_threads[cpu])\n\t\t\tbreak;\n\t\tkthread_stop(rb_threads[cpu]);\n\t}\n\tif (ret) {\n\t\tring_buffer_free(buffer);\n\t\treturn ret;\n\t}\n\tpr_info(\"finished\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tstruct ring_buffer_event *event;\n\t\tstruct rb_test_data *data = &rb_data[cpu];\n\t\tstruct rb_item *item;\n\t\tunsigned long total_events;\n\t\tunsigned long total_dropped;\n\t\tunsigned long total_written;\n\t\tunsigned long total_alloc;\n\t\tunsigned long total_read = 0;\n\t\tunsigned long total_size = 0;\n\t\tunsigned long total_len = 0;\n\t\tunsigned long total_lost = 0;\n\t\tunsigned long lost;\n\t\tint big_event_size;\n\t\tint small_event_size;\n\t\tret = -1;\n\t\ttotal_events = data->events + data->events_nested;\n\t\ttotal_written = data->bytes_written + data->bytes_written_nested;\n\t\ttotal_alloc = data->bytes_alloc + data->bytes_alloc_nested;\n\t\ttotal_dropped = data->bytes_dropped + data->bytes_dropped_nested;\n\t\tbig_event_size = data->max_size + data->max_size_nested;\n\t\tsmall_event_size = data->min_size + data->min_size_nested;\n\t\tpr_info(\"CPU %d:\\n\", cpu);\n\t\tpr_info(\"              events:    %ld\\n\", total_events);\n\t\tpr_info(\"       dropped bytes:    %ld\\n\", total_dropped);\n\t\tpr_info(\"       alloced bytes:    %ld\\n\", total_alloc);\n\t\tpr_info(\"       written bytes:    %ld\\n\", total_written);\n\t\tpr_info(\"       biggest event:    %d\\n\", big_event_size);\n\t\tpr_info(\"      smallest event:    %d\\n\", small_event_size);\n\t\tif (RB_WARN_ON(buffer, total_dropped))\n\t\t\tbreak;\n\t\tret = 0;\n\t\twhile ((event = ring_buffer_consume(buffer, cpu, NULL, &lost))) {\n\t\t\ttotal_lost += lost;\n\t\t\titem = ring_buffer_event_data(event);\n\t\t\ttotal_len += ring_buffer_event_length(event);\n\t\t\ttotal_size += item->size + sizeof(struct rb_item);\n\t\t\tif (memcmp(&item->str[0], rb_string, item->size) != 0) {\n\t\t\t\tpr_info(\"FAILED!\\n\");\n\t\t\t\tpr_info(\"buffer had: %.*s\\n\", item->size, item->str);\n\t\t\t\tpr_info(\"expected:   %.*s\\n\", item->size, rb_string);\n\t\t\t\tRB_WARN_ON(buffer, 1);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal_read++;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -1;\n\t\tpr_info(\"         read events:   %ld\\n\", total_read);\n\t\tpr_info(\"         lost events:   %ld\\n\", total_lost);\n\t\tpr_info(\"        total events:   %ld\\n\", total_lost + total_read);\n\t\tpr_info(\"  recorded len bytes:   %ld\\n\", total_len);\n\t\tpr_info(\" recorded size bytes:   %ld\\n\", total_size);\n\t\tif (total_lost)\n\t\t\tpr_info(\" With dropped events, record len and size may not match\\n\"\n\t\t\t\t\" alloced and written from above\\n\");\n\t\tif (!total_lost) {\n\t\t\tif (RB_WARN_ON(buffer, total_len != total_alloc ||\n\t\t\t\t       total_size != total_written))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (RB_WARN_ON(buffer, total_lost + total_read != total_events))\n\t\t\tbreak;\n\t\tret = 0;\n\t}\n\tif (!ret)\n\t\tpr_info(\"Ring buffer PASSED!\\n\");\n\tring_buffer_free(buffer);\n\treturn 0;\n}\nlate_initcall(test_ringbuffer);\n#endif \n",
        "cwe": "CWE-190",
        "file_name": "vul_respovul_idx_1524.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int lookup_node(unsigned long addr)\n\terr = get_user_pages(addr & PAGE_MASK, 1, 0, &p, NULL);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\t\t\t     unsigned long addr, unsigned long flags)\n\tstruct mm_struct *mm = current->mm;\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t}\n\tif (flags & MPOL_F_ADDR) {\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\tif (!pol)\n\t\tpol = &default_policy;\t\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t} else if (pol == current->mempolicy &&\n\t} else {\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/mempolicy.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task.h>\n#include <linux/nodemask.h>\n#include <linux/cpuset.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/nsproxy.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/migrate.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ctype.h>\n#include <linux/mm_inline.h>\n#include <linux/mmu_notifier.h>\n#include <linux/printk.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\nenum zone_type policy_zone = 0;\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), \n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\treturn policy;\n}\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\nstruct queue_pages {\n\tstruct list_head *pagelist;\n\tunsigned long flags;\n\tnodemask_t *nmask;\n\tstruct vm_area_struct *prev;\n};\nstatic int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint nid, ret;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tif (pmd_trans_huge(*pmd)) {\n\t\tptl = pmd_lock(walk->mm, pmd);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tpage = pmd_page(*pmd);\n\t\t\tif (is_huge_zero_page(page)) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tget_page(page);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tlock_page(page);\n\t\t\t\tret = split_huge_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t}\n\t}\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\nretry:\n\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tnid = page_to_nid(page);\n\t\tif (node_isset(nid, *qp->nmask) == !!(flags & MPOL_MF_INVERT))\n\t\t\tcontinue;\n\t\tif (PageTransCompound(page)) {\n\t\t\tget_page(page);\n\t\t\tpte_unmap_unlock(pte, ptl);\n\t\t\tlock_page(page);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (ret) {\n\t\t\t\tpte = pte_offset_map_lock(walk->mm, pmd,\n\t\t\t\t\t\taddr, &ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t}\n\t\tmigrate_page_add(page, qp->pagelist, flags);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}\n#ifdef CONFIG_NUMA_BALANCING\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, 0, 1);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\treturn nr_updated;\n}\n#else\n#endif \nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n out:\n\treturn err;\n}\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\nstatic int lookup_node(unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\terr = get_user_pages(addr & PAGE_MASK, 1, 0, &p, NULL);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\treturn err;\n}\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy;\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\tif (flags & MPOL_F_ADDR) {\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\tif (!pol)\n\t\tpol = &default_policy;\t\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\terr = lookup_node(addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&current->mm->mmap_sem);\n\treturn err;\n}\n#ifdef CONFIG_MIGRATION\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(page) == 1) {\n\t\tif (!isolate_lru_page(page)) {\n\t\t\tlist_add_tail(&page->lru, pagelist);\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t    page_is_file_cache(page));\n\t\t}\n\t}\n}\nstatic struct page *new_node_page(struct page *page, unsigned long node, int **x)\n{\n\tif (PageHuge(page))\n\t\treturn alloc_huge_page_node(page_hstate(compound_head(page)),\n\t\t\t\t\tnode);\n\telse\n\t\treturn __alloc_pages_node(node, GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE, 0);\n}\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\treturn err;\n}\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\tdown_read(&mm->mmap_sem);\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\t\tfor_each_node_mask(s, tmp) {\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\t\t\tsource = s;\t\n\t\t\tdest = d;\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n}\nstatic struct page *new_page(struct page *page, unsigned long start, int **x)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long uninitialized_var(address);\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\tif (PageHuge(page)) {\n\t\tBUG_ON(!vma);\n\t\treturn alloc_huge_page_noerr(vma, address, 1);\n\t}\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE | __GFP_RETRY_MAYFAIL,\n\t\t\tvma, address);\n}\n#else\n#endif\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\tif (!err) {\n\t\tint nr_failed = 0;\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tif (nlongs > PAGE_SIZE/sizeof(long))\n\t\t\treturn -EINVAL;\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tunsigned long t;\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}\nSYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned, flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}\nSYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}\nSYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\terr = -EINVAL;\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\ttask_nodes = cpuset_mems_allowed(task);\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\tif (!nodes_subset(*new, node_states[N_MEMORY])) {\n\t\terr = -EINVAL;\n\t\tgoto out_put;\n\t}\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn err;\nout_put:\n\tput_task_struct(task);\n\tgoto out;\n}\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\tint err;\n\tint uninitialized_var(pval);\n\tnodemask_t nodes;\n\tif (nmask != NULL && maxnode < MAX_NUMNODES)\n\t\treturn -EINVAL;\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\tif (err)\n\t\treturn err;\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\treturn err;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\terr = sys_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\treturn err;\n}\nCOMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}\nCOMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}\n#endif\n#ifdef CONFIG_HUGETLBFS\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\treturn true;\n}\n#endif\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\t\tif (pol->mode == MPOL_PREFERRED &&\n\t\t\t\t\t\t!(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\tgfp | __GFP_THISNODE, order);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\tBUG_ON(!vma);\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tBUG_ON(addr >= vma->vm_end);\n\t\tBUG_ON(addr < vma->vm_start);\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, vma, pgoff);\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\tcase MPOL_BIND:\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = z->zone->node;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\treturn ret;\n}\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\treturn ret;\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\tsp->root = RB_ROOT;\t\t\n\trwlock_init(&sp->lock);\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; \n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\t\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\t\tpvma.vm_end = TASK_SIZE;\t\n\t\tmpol_set_shared_policy(sp, &pvma, new); \nput_new:\n\t\tmpol_put(new);\t\t\t\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t\n\t}\n}\n#ifdef CONFIG_NUMA_BALANCING\nstatic int __initdata numabalancing_override;\nstatic void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}\nstatic int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\treturn ret;\n}\n__setup(\"numa_balancing=\", setup_numabalancing);\n#else\nstatic inline void __init check_numabalancing_enable(void)\n{\n}\n#endif \nvoid __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\tcheck_numabalancing_enable();\n}\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n#ifdef CONFIG_TMPFS\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1;\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tfor (mode = 0; mode < MPOL_MAX; mode++) {\n\t\tif (!strcmp(str, policy_modes[mode])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode >= MPOL_MAX)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}\n#endif \nvoid mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_2893.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t}\nint group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n\tret = check_kill_permission(sig, info, p);\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\nint __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp)\n\tstruct task_struct *p = NULL;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p);\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n\tfor (;;) {\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p);\n\t}\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n\tif (pid > 0) {\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t}\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/user.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/coredump.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/signalfd.h>\n#include <linux/ratelimit.h>\n#include <linux/tracehook.h>\n#include <linux/capability.h>\n#include <linux/freezer.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/uprobes.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/compiler.h>\n#include <linux/posix-timers.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/signal.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/siginfo.h>\n#include <asm/cacheflush.h>\n#include \"audit.h\"\t\nstatic struct kmem_cache *sigqueue_cachep;\nint print_fatal_signals __read_mostly;\nstatic void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}\nstatic int sig_handler_ignored(void __user *handler, int sig)\n{\n\treturn handler == SIG_IGN ||\n\t\t(handler == SIG_DFL && sig_kernel_ignore(sig));\n}\nstatic int sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\thandler = sig_handler(t, sig);\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\thandler == SIG_DFL && !force)\n\t\treturn 1;\n\treturn sig_handler_ignored(handler, sig);\n}\nstatic int sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn 0;\n\tif (!sig_task_ignored(t, sig, force))\n\t\treturn 0;\n\treturn !t->ptrace;\n}\n#define PENDING(p,b) has_pending_signals(&(p)->signal, (b))\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tif (!print_fatal_signals)\n\t\treturn;\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\ttask->jobctl |= mask;\n\treturn true;\n}\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\ttask->jobctl &= ~mask;\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\treturn q;\n}\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}\n#ifdef CONFIG_POSIX_TIMERS\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\tsigorsets(&pending->signal, &signal, &retain);\n}\nvoid flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}\n#endif\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\t}\n#endif\n\treturn signr;\n}\nstatic int flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn 0;\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\treturn 1;\n}\nstatic inline int is_si_special(const struct siginfo *info)\n{\n\treturn info <= SEND_SIG_FORCED;\n}\nstatic inline bool si_fromuser(const struct siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}\nstatic int kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\tif (uid_eq(cred->euid, tcred->suid) ||\n\t    uid_eq(cred->euid, tcred->uid)  ||\n\t    uid_eq(cred->uid,  tcred->suid) ||\n\t    uid_eq(cred->uid,  tcred->uid))\n\t\treturn 1;\n\tif (ns_capable(tcred->user_ns, CAP_KILL))\n\t\treturn 1;\n\treturn 0;\n}\nstatic int check_kill_permission(int sig, struct siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\terror = audit_signal_info(sig, t); \n\tif (error)\n\t\treturn error;\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\treturn security_task_kill(t, info, sig, 0);\n}\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t} else if (sig_kernel_stop(sig)) {\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\t\tif (why) {\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\treturn !sig_ignored(p, sig, force);\n}\nstatic inline int wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn 0;\n\tif (p->flags & PF_EXITING)\n\t\treturn 0;\n\tif (sig == SIGKILL)\n\t\treturn 1;\n\tif (task_is_stopped_or_traced(p))\n\t\treturn 0;\n\treturn task_curr(p) || !signal_pending(p);\n}\nstatic void complete_signal(int sig, struct task_struct *p, int group)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if (!group || thread_group_empty(p))\n\t\treturn;\n\telse {\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !t->ptrace)) {\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}\nstatic inline int legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}\n#ifdef CONFIG_USER_NS\nstatic inline void userns_fixup_signal_uid(struct siginfo *info, struct task_struct *t)\n{\n\tif (current_user_ns() == task_cred_xxx(t, user_ns))\n\t\treturn;\n\tif (SI_FROMKERNEL(info))\n\t\treturn;\n\trcu_read_lock();\n\tinfo->si_uid = from_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\tmake_kuid(current_user_ns(), info->si_uid));\n\trcu_read_unlock();\n}\n#else\nstatic inline void userns_fixup_signal_uid(struct siginfo *info, struct task_struct *t)\n{\n\treturn;\n}\n#endif\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\tassert_spin_locked(&t->sighand->siglock);\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_FORCED)))\n\t\tgoto ret;\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\tresult = TRACE_SIGNAL_DELIVERED;\n\tif (info == SEND_SIG_FORCED)\n\t\tgoto out_set;\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nret:\n\ttrace_signal_generate(sig, info, t, group, result);\n\treturn ret;\n}\nstatic int send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group)\n{\n\tint from_ancestor_ns = 0;\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\treturn __send_signal(sig, info, t, group, from_ancestor_ns);\n}\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\treturn 1;\n}\n__setup(\"print-fatal-signals=\", setup_print_fatal_signals);\nint do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,\n\t\t\tbool group)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, group);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\treturn ret;\n}\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\tfor (;;) {\n\t\tlocal_irq_save(*flags);\n\t\trcu_read_lock();\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL)) {\n\t\t\trcu_read_unlock();\n\t\t\tlocal_irq_restore(*flags);\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock(&sighand->siglock);\n\t\tif (likely(sighand == tsk->sighand)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&sighand->siglock);\n\t\trcu_read_unlock();\n\t\tlocal_irq_restore(*flags);\n\t}\n\treturn sighand;\n}\nint group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)\n{\n\tint ret;\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, true);\n\treturn ret;\n}\nint __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}\nint kill_pid_info(int sig, struct siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\t}\n}\nstatic int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}\n#define __si_special(priv) \\\n\t((priv) ? SEND_SIG_PRIV : SEND_SIG_NOINFO)\nEXPORT_SYMBOL(kill_pid);\nint send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret, result;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, group, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\tBUG_ON(sig == -1);\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\tif (sig != SIGCHLD) {\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn autoreap;\n}\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\tset_current_state(TASK_TRACED);\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\ttask_clear_jobctl_trapping(current);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\trecalc_sigpending_tsk(current);\n}\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn false;\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\t\tsig->group_stop_count = 0;\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\t\t__set_current_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}\nstatic int ptrace_signal(int signr, siginfo_t *info)\n{\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tptrace_stop(signr, CLD_TRAPPED, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}\nint get_signal(struct ksignal *ksig)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\tif (unlikely(current->task_works))\n\t\ttask_work_run();\n\tif (unlikely(uprobe_deny_signal()))\n\t\treturn 0;\n\ttry_to_freeze();\nrelock:\n\tspin_lock_irq(&sighand->siglock);\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why;\n\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)\n\t\t\twhy = CLD_CONTINUED;\n\t\telse\n\t\t\twhy = CLD_STOPPED;\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\t\tspin_unlock_irq(&sighand->siglock);\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, false, why);\n\t\tif (ptrace_reparented(current->group_leader))\n\t\t\tdo_notify_parent_cldstop(current->group_leader,\n\t\t\t\t\t\ttrue, why);\n\t\tread_unlock(&tasklist_lock);\n\t\tgoto relock;\n\t}\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n\t\t    do_signal_stop(0))\n\t\t\tgoto relock;\n\t\tif (unlikely(current->jobctl & JOBCTL_TRAP_MASK)) {\n\t\t\tdo_jobctl_trap();\n\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\tgoto relock;\n\t\t}\n\t\tsignr = dequeue_signal(current, &current->blocked, &ksig->info);\n\t\tif (!signr)\n\t\t\tbreak; \n\t\tif (unlikely(current->ptrace) && signr != SIGKILL) {\n\t\t\tsignr = ptrace_signal(signr, &ksig->info);\n\t\t\tif (!signr)\n\t\t\t\tcontinue;\n\t\t}\n\t\tka = &sighand->action[signr-1];\n\t\ttrace_signal_deliver(signr, &ksig->info, ka);\n\t\tif (ka->sa.sa_handler == SIG_IGN) \n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\tksig->ka = *ka;\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\t\tbreak; \n\t\t}\n\t\tif (sig_kernel_ignore(signr)) \n\t\t\tcontinue;\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t\tcurrent->flags |= PF_SIGNALED;\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(ksig->info.si_signo);\n\t\t\tproc_coredump_connector(current);\n\t\t\tdo_coredump(&ksig->info);\n\t\t}\n\t\tdo_group_exit(ksig->info.si_signo);\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\tksig->sig = signr;\n\treturn ksig->sig > 0;\n}\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\tcgroup_threadgroup_change_begin(tsk);\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\tspin_lock_irq(&tsk->sighand->siglock);\n\ttsk->flags |= PF_EXITING;\n\tcgroup_threadgroup_change_end(tsk);\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\nEXPORT_SYMBOL(recalc_sigpending);\nEXPORT_SYMBOL_GPL(dequeue_signal);\nEXPORT_SYMBOL(flush_signals);\nEXPORT_SYMBOL(force_sig);\nEXPORT_SYMBOL(send_sig);\nEXPORT_SYMBOL(send_sig_info);\nEXPORT_SYMBOL(sigprocmask);\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tsigset_t old_set, new_set;\n\tint error;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\told_set = current->blocked;\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n\t\tcompat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n#ifdef __BIG_ENDIAN\n\tsigset_t old_set = current->blocked;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (nset) {\n\t\tcompat_sigset_t new32;\n\t\tsigset_t new_set;\n\t\tint error;\n\t\tif (copy_from_user(&new32, nset, sizeof(compat_sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&new_set, &new32);\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (oset) {\n\t\tcompat_sigset_t old32;\n\t\tsigset_to_compat(&old32, &old_set);\n\t\tif (copy_to_user(oset, &old32, sizeof(compat_sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n#else\n\treturn sys_rt_sigprocmask(how, (sigset_t __user *)nset,\n\t\t\t\t  (sigset_t __user *)oset, sigsetsize);\n#endif\n}\n#endif\nSYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, uset, size_t, sigsetsize)\n{\n\tsigset_t set;\n\tint err = do_sigpending(&set, sigsetsize);\n\tif (!err && copy_to_user(uset, &set, sigsetsize))\n\t\terr = -EFAULT;\n\treturn err;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n\t\tcompat_size_t, sigsetsize)\n{\n#ifdef __BIG_ENDIAN\n\tsigset_t set;\n\tint err = do_sigpending(&set, sigsetsize);\n\tif (!err) {\n\t\tcompat_sigset_t set32;\n\t\tsigset_to_compat(&set32, &set);\n\t\tif (copy_to_user(uset, &set32, sigsetsize))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n#else\n\treturn sys_rt_sigpending((sigset_t __user *)uset, sigsetsize);\n#endif\n}\n#endif\n#ifndef HAVE_ARCH_COPY_SIGINFO_TO_USER\nint copy_siginfo_to_user(siginfo_t __user *to, const siginfo_t *from)\n{\n\tint err;\n\tif (!access_ok (VERIFY_WRITE, to, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (from->si_code < 0)\n\t\treturn __copy_to_user(to, from, sizeof(siginfo_t))\n\t\t\t? -EFAULT : 0;\n\terr = __put_user(from->si_signo, &to->si_signo);\n\terr |= __put_user(from->si_errno, &to->si_errno);\n\terr |= __put_user((short)from->si_code, &to->si_code);\n\tswitch (from->si_code & __SI_MASK) {\n\tcase __SI_KILL:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\tcase __SI_TIMER:\n\t\t err |= __put_user(from->si_tid, &to->si_tid);\n\t\t err |= __put_user(from->si_overrun, &to->si_overrun);\n\t\t err |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n\tcase __SI_POLL:\n\t\terr |= __put_user(from->si_band, &to->si_band);\n\t\terr |= __put_user(from->si_fd, &to->si_fd);\n\t\tbreak;\n\tcase __SI_FAULT:\n\t\terr |= __put_user(from->si_addr, &to->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\terr |= __put_user(from->si_trapno, &to->si_trapno);\n#endif\n#ifdef BUS_MCEERR_AO\n\t\tif (from->si_signo == SIGBUS &&\n\t\t    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))\n\t\t\terr |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);\n#endif\n#ifdef SEGV_BNDERR\n\t\tif (from->si_signo == SIGSEGV && from->si_code == SEGV_BNDERR) {\n\t\t\terr |= __put_user(from->si_lower, &to->si_lower);\n\t\t\terr |= __put_user(from->si_upper, &to->si_upper);\n\t\t}\n#endif\n#ifdef SEGV_PKUERR\n\t\tif (from->si_signo == SIGSEGV && from->si_code == SEGV_PKUERR)\n\t\t\terr |= __put_user(from->si_pkey, &to->si_pkey);\n#endif\n\t\tbreak;\n\tcase __SI_CHLD:\n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_status, &to->si_status);\n\t\terr |= __put_user(from->si_utime, &to->si_utime);\n\t\terr |= __put_user(from->si_stime, &to->si_stime);\n\t\tbreak;\n\tcase __SI_RT: \n\tcase __SI_MESGQ: \n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\terr |= __put_user(from->si_ptr, &to->si_ptr);\n\t\tbreak;\n#ifdef __ARCH_SIGSYS\n\tcase __SI_SYS:\n\t\terr |= __put_user(from->si_call_addr, &to->si_call_addr);\n\t\terr |= __put_user(from->si_syscall, &to->si_syscall);\n\t\terr |= __put_user(from->si_arch, &to->si_arch);\n\t\tbreak;\n#endif\n\tdefault: \n\t\terr |= __put_user(from->si_pid, &to->si_pid);\n\t\terr |= __put_user(from->si_uid, &to->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}\n#endif\nstatic int do_sigtimedwait(const sigset_t *which, siginfo_t *info,\n\t\t    const struct timespec *ts)\n{\n\tktime_t *to = NULL, timeout = KTIME_MAX;\n\tstruct task_struct *tsk = current;\n\tsigset_t mask = *which;\n\tint sig, ret = 0;\n\tif (ts) {\n\t\tif (!timespec_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec_to_ktime(*ts);\n\t\tto = &timeout;\n\t}\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info);\n\tif (!sig && timeout) {\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n\t\t\t\t\t\t\t HRTIMER_MODE_REL);\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsigemptyset(&tsk->real_blocked);\n\t\tsig = dequeue_signal(tsk, &mask, info);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (sig)\n\t\treturn sig;\n\treturn ret ? -EINTR : -EAGAIN;\n}\nSYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo, const struct timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec ts;\n\tsiginfo_t info;\n\tint ret;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\tif (uts) {\n\t\tif (copy_from_user(&ts, uts, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t}\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigtimedwait, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct compat_timespec __user *, uts, compat_size_t, sigsetsize)\n{\n\tcompat_sigset_t s32;\n\tsigset_t s;\n\tstruct timespec t;\n\tsiginfo_t info;\n\tlong ret;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&s32, uthese, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tsigset_from_compat(&s, &s32);\n\tif (uts) {\n\t\tif (compat_get_timespec(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}\n#endif\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE3(rt_sigqueueinfo,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tsiginfo_t info = {};\n\tint ret = copy_siginfo_from_user32(&info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}\n#endif\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,\n\t\t\tcompat_pid_t, tgid,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tsiginfo_t info = {};\n\tif (copy_siginfo_from_user32(&info, uinfo))\n\t\treturn -EFAULT;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}\n#endif\nEXPORT_SYMBOL(kernel_sigaction);\nvoid __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *p = current, *t;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\tk = &p->sighand->action[sig-1];\n\tspin_lock_irq(&p->sighand->siglock);\n\tif (oact)\n\t\t*oact = *k;\n\tsigaction_compat_abi(act, oact);\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);\n\t\t\tfor_each_thread(p, t)\n\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);\n\t\t}\n\t}\n\tspin_unlock_irq(&p->sighand->siglock);\n\treturn 0;\n}\nSYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\tstack_t new, old;\n\tint err;\n\tif (uss && copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\terr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n\t\t\t      current_user_stack_pointer());\n\tif (!err && uoss && copy_to_user(uoss, &old, sizeof(stack_t)))\n\t\terr = -EFAULT;\n\treturn err;\n}\nint restore_altstack(const stack_t __user *uss)\n{\n\tstack_t new;\n\tif (copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\t(void)do_sigaltstack(&new, NULL, current_user_stack_pointer());\n\treturn 0;\n}\nint __save_altstack(stack_t __user *uss, unsigned long sp)\n{\n\tstruct task_struct *t = current;\n\tint err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(sigaltstack,\n\t\t\tconst compat_stack_t __user *, uss_ptr,\n\t\t\tcompat_stack_t __user *, uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer());\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}\nint compat_restore_altstack(const compat_stack_t __user *uss)\n{\n\tint err = compat_sys_sigaltstack(uss, NULL);\n\treturn err == -EFAULT ? err : 0;\n}\nint __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n\tint err;\n\tstruct task_struct *t = current;\n\terr = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n\t\t\t &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}\n#endif\n#ifdef __ARCH_WANT_SYS_SIGPENDING\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, set)\n{\n\treturn sys_rt_sigpending((sigset_t __user *)set, sizeof(old_sigset_t)); \n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n\tsigset_t set;\n\tint err = do_sigpending(&set, sizeof(old_sigset_t)); \n\tif (err == 0)\n\t\tif (copy_to_user(set32, &set, sizeof(old_sigset_t)))\n\t\t\terr = -EFAULT;\n\treturn err;\n}\n#endif\n#endif\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n\t\told_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\told_set = current->blocked.sig[0];\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(*nset)))\n\t\t\treturn -EFAULT;\n\t\tnew_blocked = current->blocked;\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tnew_blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tset_current_blocked(&new_blocked);\n\t}\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n#endif \n#ifndef CONFIG_ODD_RT_SIGACTION\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret = -EINVAL;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\tgoto out;\n\tif (act) {\n\t\tif (copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\tif (!ret && oact) {\n\t\tif (copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\t\treturn -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tcompat_sigset_t mask;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= copy_from_user(&mask, &act->sa_mask, sizeof(mask));\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&new_ka.sa.sa_mask, &mask);\n\t}\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tsigset_to_compat(&mask, &old_ka.sa.sa_mask);\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= copy_to_user(&oact->sa_mask, &mask, sizeof(mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}\n#endif\n#endif \n#ifdef CONFIG_OLD_SIGACTION\nSYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct old_sigaction __user *, act,\n\t        struct old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tif (act) {\n\t\told_sigset_t mask;\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n\t\t    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n\t\t    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}\n#endif\n#ifdef CONFIG_COMPAT_OLD_SIGACTION\nCOMPAT_SYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct compat_old_sigaction __user *, act,\n\t        struct compat_old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tcompat_old_sigset_t mask;\n\tcompat_uptr_t handler, restorer;\n\tif (act) {\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(handler, &act->sa_handler) ||\n\t\t    __get_user(restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n\t\t\t       &oact->sa_handler) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t       &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}\n#endif\n#ifdef CONFIG_SGETMASK_SYSCALL\nSYSCALL_DEFINE0(sgetmask)\n{\n\treturn current->blocked.sig[0];\n}\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\treturn old;\n}\n#endif \n#ifdef __ARCH_WANT_SYS_SIGNAL\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n#endif \n#ifdef __ARCH_WANT_SYS_PAUSE\nSYSCALL_DEFINE0(pause)\n{\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn -ERESTARTNOHAND;\n}\n#endif\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n#ifdef __BIG_ENDIAN\n\tsigset_t newset;\n\tcompat_sigset_t newset32;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&newset32, unewset, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tsigset_from_compat(&newset, &newset32);\n\treturn sigsuspend(&newset);\n#else\n\treturn sys_rt_sigsuspend((sigset_t __user *)unewset, sigsetsize);\n#endif\n}\n#endif\n#ifdef CONFIG_OLD_SIGSUSPEND\nSYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}\n#endif\n#ifdef CONFIG_OLD_SIGSUSPEND3\nSYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}\n#endif\n__weak \nvoid __init signals_init(void)\n{\n\tBUILD_BUG_ON(__ARCH_SI_PREAMBLE_SIZE\n\t\t!= offsetof(struct siginfo, _sifields._pad));\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);\n}\n#ifdef CONFIG_KGDB_KDB\n#include <linux/kdb.h>\nvoid\nkdb_send_sig_info(struct task_struct *t, struct siginfo *info)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint sig, new_t;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tspin_unlock(&t->sighand->siglock);\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tsig = info->si_signo;\n\tif (send_sig_info(sig, info, t))\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}\n#endif\t\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_2835.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/4ea77014af0d6205b05503d1c7aac6eace11d473",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\nstatic enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\tstrcat(s, \"\\n\");\n\tlen++;\n\twhile (len > 0 ) {\n\t\tsent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);\n\t\tif (sent < 0) {\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\nbool stratum_send(struct pool *pool, char *s, ssize_t len)\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"SEND: %s\", s);\n\tmutex_lock(&pool->stratum_lock);\n\tif (pool->stratum_active)\n\t\tret = __stratum_send(pool, s, len);\nstatic void clear_sock(struct pool *pool)\n\tmutex_lock(&pool->stratum_lock);\n\tdo {\n\t\tif (pool->sock)\n\t\t\tn = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);\n\t} while (n > 0);\n\tmutex_unlock(&pool->stratum_lock);\n\tclear_sockbuf(pool);\nchar *recv_line(struct pool *pool)\n\tif (!strstr(pool->sockbuf, \"\\n\")) {\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\t}\n\t\tdo {\n\t\t\tchar s[RBUFSIZE];\n\t\t\tmemset(s, 0, RBUFSIZE);\n\t\t\tn = recv(pool->sock, s, RECVSIZE, 0);\n\t\t\tif (!n) {\n\t\t\t\tsuspend_stratum(pool);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tif (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {\n\t\t\t\t\tsuspend_stratum(pool);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslen = strlen(s);\n\t\t\t\trecalloc_sock(pool, slen);\n\t\t\t\tstrcat(pool->sockbuf, s);\n\t\t\t}\n\t\t} while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));\n\t}\n\tbuflen = strlen(pool->sockbuf);\n\ttok = strtok(pool->sockbuf, \"\\n\");\n\tif (!tok) {\n\t}\n\tsret = strdup(tok);\n\tlen = strlen(sret);\n\tif (buflen > len + 1)\n\t\tmemmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);\n\telse\n\t\tstrcpy(pool->sockbuf, \"\");\n\tif (!sret)\n\t\tclear_sock(pool);\nstatic bool parse_reconnect(struct pool *pool, json_t *val)\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tpool->stratum_port = stratum_port;\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t}\nstatic bool send_version(struct pool *pool, json_t *val)\n\tchar s[RBUFSIZE];\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\nbool parse_method(struct pool *pool, char *s)\n\tif (!s)\n\t\treturn ret;\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t}\n\tmethod = json_object_get(val, \"method\");\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\tif (!buf) {\n\t}\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t}\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {\n\t}\n\tif (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {\n\t}\n\tif (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {\n\t}\n\tif (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {\n\t}\nbool subscribe_extranonce(struct pool *pool)\n\tchar s[RBUFSIZE], *sret = NULL;\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",\n\t\tswork_id++);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\twhile (42) {\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {\n\t\t}\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t}\nbool auth_stratum(struct pool *pool)\n\tchar s[RBUFSIZE], *sret = NULL;\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",\n\t\tswork_id++, pool->rpc_user, pool->rpc_pass);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\twhile (42) {\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t}\nstatic bool socks4_negotiate(struct pool *pool, int sockd, bool socks4a)\n\tchar buf[515];\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x01;\n\tport = atoi(pool->stratum_port);\n\tbuf[2] = port >> 8;\n\tbuf[3] = port & 0xff;\n\tsprintf(&buf[8], \"SGMINER\");\n\tinp = inet_addr(pool->sockaddr_url);\n\tif ((int)inp != -1)\n\t\tsocks4a = false;\n\telse {\n\t\tservinfo = &servinfobase;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET; \n\t\tret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);\n\t}\n\tif (!socks4a) {\n\t} else {\n\t\tbuf[4] = 0;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t\tlen = strlen(pool->sockaddr_url);\n\t\tif (len > 255)\n\t\t\tlen = 255;\n\t\tmemcpy(&buf[16], pool->sockaddr_url, len);\n\t}\nstatic bool setup_stratum_socket(struct pool *pool)\n\tmutex_lock(&pool->stratum_lock);\n\tpool->stratum_active = false;\n\tif (pool->sock) {\n\t\tapplog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));\n\t}\n\tpool->sock = 0;\n\tmutex_unlock(&pool->stratum_lock);\n\thints = &pool->stratum_hints;\n\tmemset(hints, 0, sizeof(struct addrinfo));\n\thints->ai_family = AF_UNSPEC;\n\thints->ai_socktype = SOCK_STREAM;\n\tservinfo = &servinfobase;\n\tif (!pool->rpc_proxy && opt_socks_proxy) {\n\t\tpool->rpc_proxy = opt_socks_proxy;\n\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\tpool->rpc_proxytype = PROXY_SOCKS5;\n\t}\n\tif (pool->rpc_proxy) {\n\t\tsockaddr_url = pool->sockaddr_proxy_url;\n\t\tsockaddr_port = pool->sockaddr_proxy_port;\n\t} else {\n\t\tsockaddr_url = pool->sockaddr_url;\n\t\tsockaddr_port = pool->stratum_port;\n\t}\n\tret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);\n\tif (ret) {\n\t\tif (!pool->probed) {\n\t\t\tpool->probed = true;\n\t\t} else {\n\t}\n\tfor (p = servinfo; p != NULL; p = p->ai_next) {\n\t\tsockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (sockd == -1) {\n\t\t}\n\t\tnoblock_socket(sockd);\n\t\tif (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {\n\t\t\tstruct timeval tv_timeout = {1, 0};\n\t\t\tif (!sock_connecting()) {\n\t\t\t\tCLOSESOCKET(sockd);\n\t\t\t}\n\t\t\tFD_ZERO(&rw);\n\t\t\tFD_SET(sockd, &rw);\n\t\t\tselret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);\n\t\t\tif  (selret > 0 && FD_ISSET(sockd, &rw)) {\n\t\t\t\tlen = sizeof(err);\n\t\t\t\tn = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);\n\t\t\t\tif (!n && !err) {\n\t\t\t\t\tblock_socket(sockd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCLOSESOCKET(sockd);\n\t\t}\n\t\tblock_socket(sockd);\n\t}\n\tif (pool->rpc_proxy) {\n\t\t\t\tif (!socks4_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tif (!socks4_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t}\nbool initiate_stratum(struct pool *pool)\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tif (!setup_stratum_socket(pool)) {\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t}\n\tif (recvd) {\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t}\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t}\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t}\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\tval = JSON_LOADS(sret, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t}\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tgoto out;\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\tif (ret) {\n\t\tif (opt_protocol) {\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\t\t}\n\t}\nbool restart_stratum(struct pool *pool)\n\tapplog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));\n\tif (pool->stratum_active)\n\t\tsuspend_stratum(pool);\n\tif (!initiate_stratum(pool))\n\t\treturn false;\n\tif (pool->extranonce_subscribe && !subscribe_extranonce(pool))\n\t\treturn false;\n\tif (!auth_stratum(pool))\n\t\treturn false;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <jansson.h>\n#ifdef HAVE_LIBCURL\n#include <curl/curl.h>\n#endif\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifndef WIN32\n#include <fcntl.h>\n# ifdef __linux__\n#  include <sys/prctl.h>\n# endif\n# include <sys/socket.h>\n# include <netinet/in.h>\n# include <netinet/tcp.h>\n# include <netdb.h>\n#else\n# include <windows.h>\n# include <winsock2.h>\n# include <ws2tcpip.h>\n# include <mmsystem.h>\n#endif\n#include \"miner.h\"\n#include \"elist.h\"\n#include \"compat.h\"\n#include \"util.h\"\n#include \"pool.h\"\n#define DEFAULT_SOCKWAIT 60\nextern double opt_diff_mult;\nbool successful_connect = false;\nstatic void keep_sockalive(SOCKETTYPE fd)\n{\n\tconst int tcp_one = 1;\n#ifndef WIN32\n\tconst int tcp_keepidle = 45;\n\tconst int tcp_keepintvl = 30;\n\tint flags = fcntl(fd, F_GETFL, 0);\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n\tsetsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one));\n\tif (!opt_delaynet)\n#ifndef __linux\n\t\tsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&tcp_one, sizeof(tcp_one));\n#else \n\t\tsetsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif \n#ifdef __APPLE_CC__\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif \n}\nstruct tq_ent {\n\tvoid\t\t\t*data;\n\tstruct list_head\tq_node;\n};\n#ifdef HAVE_LIBCURL\nstruct timeval nettime;\nstruct data_buffer {\n\tvoid\t\t*buf;\n\tsize_t\t\tlen;\n};\nstruct upload_buffer {\n\tconst void\t*buf;\n\tsize_t\t\tlen;\n};\nstruct header_info {\n\tchar\t\t*lp_path;\n\tint\t\trolltime;\n\tchar\t\t*reason;\n\tchar\t\t*stratum_url;\n\tbool\t\thadrolltime;\n\tbool\t\tcanroll;\n\tbool\t\thadexpire;\n};\nstatic void databuf_free(struct data_buffer *db)\n{\n\tif (!db)\n\t\treturn;\n\tfree(db->buf);\n\tmemset(db, 0, sizeof(*db));\n}\nstatic size_t all_data_cb(const void *ptr, size_t size, size_t nmemb,\n\t\t\t  void *user_data)\n{\n\tstruct data_buffer *db = (struct data_buffer *)user_data;\n\tsize_t len = size * nmemb;\n\tsize_t oldlen, newlen;\n\tvoid *newmem;\n\tstatic const unsigned char zero = 0;\n\toldlen = db->len;\n\tnewlen = oldlen + len;\n\tnewmem = realloc(db->buf, newlen + 1);\n\tif (!newmem)\n\t\treturn 0;\n\tdb->buf = newmem;\n\tdb->len = newlen;\n\tmemcpy((uint8_t*)db->buf + oldlen, ptr, len);\n\tmemcpy((uint8_t*)db->buf + newlen, &zero, 1);\t\n\treturn len;\n}\nstatic size_t upload_data_cb(void *ptr, size_t size, size_t nmemb,\n\t\t\t     void *user_data)\n{\n\tstruct upload_buffer *ub = (struct upload_buffer *)user_data;\n\tunsigned int len = size * nmemb;\n\tif (len > ub->len)\n\t\tlen = ub->len;\n\tif (len) {\n\t\tmemcpy(ptr, ub->buf, len);\n\t\tub->buf = (uint8_t*)ub->buf + len;\n\t\tub->len -= len;\n\t}\n\treturn len;\n}\nstatic size_t resp_hdr_cb(void *ptr, size_t size, size_t nmemb, void *user_data)\n{\n\tstruct header_info *hi = (struct header_info *)user_data;\n\tsize_t remlen, slen, ptrlen = size * nmemb;\n\tchar *rem, *val = NULL, *key = NULL;\n\tvoid *tmp;\n\tval = (char *)calloc(1, ptrlen);\n\tkey = (char *)calloc(1, ptrlen);\n\tif (!key || !val)\n\t\tgoto out;\n\ttmp = memchr(ptr, ':', ptrlen);\n\tif (!tmp || (tmp == ptr))\t\n\t\tgoto out;\n\tslen = (uint8_t*)tmp - (uint8_t*)ptr;\n\tif ((slen + 1) == ptrlen)\t\n\t\tgoto out;\n\tmemcpy(key, ptr, slen);\t\t\n\tkey[slen] = 0;\n\trem = (char*)ptr + slen + 1;\t\n\tremlen = ptrlen - slen - 1;\n\twhile ((remlen > 0) && (isspace(*rem))) {\n\t\tremlen--;\n\t\trem++;\n\t}\n\tmemcpy(val, rem, remlen);\t\n\tval[remlen] = 0;\n\twhile ((*val) && (isspace(val[strlen(val) - 1])))\n\t\tval[strlen(val) - 1] = 0;\n\tif (!*val)\t\t\t\n\t\tgoto out;\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);\n\tif (!strcasecmp(\"X-Roll-Ntime\", key)) {\n\t\thi->hadrolltime = true;\n\t\tif (!strncasecmp(\"N\", val, 1))\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime: N found\");\n\t\telse {\n\t\t\thi->canroll = true;\n\t\t\tif (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {\n\t\t\t\tsscanf(val + 7, \"%d\", &hi->rolltime);\n\t\t\t\thi->hadexpire = true;\n\t\t\t} else\n\t\t\t\thi->rolltime = opt_scantime;\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);\n\t\t}\n\t}\n\tif (!strcasecmp(\"X-Long-Polling\", key)) {\n\t\thi->lp_path = val;\t\n\t\tval = NULL;\n\t}\n\tif (!strcasecmp(\"X-Reject-Reason\", key)) {\n\t\thi->reason = val;\t\n\t\tval = NULL;\n\t}\n\tif (!strcasecmp(\"X-Stratum\", key)) {\n\t\thi->stratum_url = val;\n\t\tval = NULL;\n\t}\nout:\n\tfree(key);\n\tfree(val);\n\treturn ptrlen;\n}\nstatic void last_nettime(struct timeval *last)\n{\n\trd_lock(&netacc_lock);\n\tlast->tv_sec = nettime.tv_sec;\n\tlast->tv_usec = nettime.tv_usec;\n\trd_unlock(&netacc_lock);\n}\nstatic void set_nettime(void)\n{\n\twr_lock(&netacc_lock);\n\tcgtime(&nettime);\n\twr_unlock(&netacc_lock);\n}\n#if CURL_HAS_KEEPALIVE\nstatic void keep_curlalive(CURL *curl)\n{\n\tconst long int keepalive = 1;\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, opt_tcp_keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, opt_tcp_keepalive);\n}\n#else\nstatic void keep_curlalive(CURL *curl)\n{\n\tSOCKETTYPE sock;\n\tcurl_easy_getinfo(curl, CURLINFO_LASTSOCKET, (long *)&sock);\n\tkeep_sockalive(sock);\n}\n#endif\nstatic int curl_debug_cb(__maybe_unused CURL *handle, curl_infotype type,\n\t\t\t __maybe_unused char *data, size_t size, void *userdata)\n{\n\tstruct pool *pool = (struct pool *)userdata;\n\tswitch(type) {\n\t\tcase CURLINFO_HEADER_IN:\n\t\tcase CURLINFO_DATA_IN:\n\t\tcase CURLINFO_SSL_DATA_IN:\n\t\t\tpool->sgminer_pool_stats.net_bytes_received += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_HEADER_OUT:\n\t\tcase CURLINFO_DATA_OUT:\n\t\tcase CURLINFO_SSL_DATA_OUT:\n\t\t\tpool->sgminer_pool_stats.net_bytes_sent += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_TEXT:\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\njson_t *json_rpc_call(CURL *curl, const char *url,\n\t\t      const char *userpass, const char *rpc_req,\n\t\t      bool probe, bool longpoll, int *rolltime,\n\t\t      struct pool *pool, bool share)\n{\n\tlong timeout = longpoll ? (60 * 60) : 60;\n\tstruct data_buffer all_data = {NULL, 0};\n\tstruct header_info hi = {NULL, 0, NULL, NULL, false, false, false};\n\tchar len_hdr[64], user_agent_hdr[128];\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tstruct curl_slist *headers = NULL;\n\tstruct upload_buffer upload_data;\n\tjson_t *val, *err_val, *res_val;\n\tbool probing = false;\n\tdouble byte_count;\n\tjson_error_t err;\n\tint rc;\n\tmemset(&err, 0, sizeof(err));\n\tif (probe)\n\t\tprobing = !pool->probed;\n\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);\n\t// CURLOPT_VERBOSE won't write to stderr if we use CURLOPT_DEBUGFUNCTION\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);\n\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_ENCODING, \"\");\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\tif (!opt_delaynet || share)\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);\n\tcurl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_READDATA, &upload_data);\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);\n\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERDATA, &hi);\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\tif (pool->rpc_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, pool->rpc_proxytype);\n\t} else if (opt_socks_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);\n\t}\n\tif (userpass) {\n\t\tcurl_easy_setopt(curl, CURLOPT_USERPWD, userpass);\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n\t}\n\tif (longpoll)\n\t\tkeep_curlalive(curl);\n\tcurl_easy_setopt(curl, CURLOPT_POST, 1);\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);\n\tupload_data.buf = rpc_req;\n\tupload_data.len = strlen(rpc_req);\n\tsprintf(len_hdr, \"Content-Length: %lu\",\n\t\t(unsigned long) upload_data.len);\n\tsprintf(user_agent_hdr, \"User-Agent: %s\", PACKAGE_STRING);\n\theaders = curl_slist_append(headers,\n\t\t\"Content-type: application/json\");\n\theaders = curl_slist_append(headers,\n\t\t\"X-Mining-Extensions: longpoll midstate rollntime submitold\");\n\tif (likely(global_hashrate)) {\n\t\tchar ghashrate[255];\n\t\tsprintf(ghashrate, \"X-Mining-Hashrate: %llu\", global_hashrate);\n\t\theaders = curl_slist_append(headers, ghashrate);\n\t}\n\theaders = curl_slist_append(headers, len_hdr);\n\theaders = curl_slist_append(headers, user_agent_hdr);\n\theaders = curl_slist_append(headers, \"Expect:\"); \n\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\tif (opt_delaynet) {\n\t\tif (!share) {\n\t\t\tlong long now_msecs, last_msecs;\n\t\t\tstruct timeval now, last;\n\t\t\tcgtime(&now);\n\t\t\tlast_nettime(&last);\n\t\t\tnow_msecs = (long long)now.tv_sec * 1000;\n\t\t\tnow_msecs += now.tv_usec / 1000;\n\t\t\tlast_msecs = (long long)last.tv_sec * 1000;\n\t\t\tlast_msecs += last.tv_usec / 1000;\n\t\t\tif (now_msecs > last_msecs && now_msecs - last_msecs < 250) {\n\t\t\t\tstruct timespec rgtp;\n\t\t\t\trgtp.tv_sec = 0;\n\t\t\t\trgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;\n\t\t\t\tnanosleep(&rgtp, NULL);\n\t\t\t}\n\t\t}\n\t\tset_nettime();\n\t}\n\trc = curl_easy_perform(curl);\n\tif (rc) {\n\t\tapplog(LOG_INFO, \"HTTP request failed: %s\", curl_err_str);\n\t\tgoto err_out;\n\t}\n\tif (!all_data.buf) {\n\t\tapplog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");\n\t\tgoto err_out;\n\t}\n\tpool->sgminer_pool_stats.times_sent++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_sent += byte_count;\n\tpool->sgminer_pool_stats.times_received++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_received += byte_count;\n\tif (probing) {\n\t\tpool->probed = true;\n\t\tif (hi.lp_path) {\n\t\t\tif (pool->hdr_path != NULL)\n\t\t\t\tfree(pool->hdr_path);\n\t\t\tpool->hdr_path = hi.lp_path;\n\t\t} else\n\t\t\tpool->hdr_path = NULL;\n\t\tif (hi.stratum_url) {\n\t\t\tpool->stratum_url = hi.stratum_url;\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t} else {\n\t\tif (hi.lp_path) {\n\t\t\tfree(hi.lp_path);\n\t\t\thi.lp_path = NULL;\n\t\t}\n\t\tif (hi.stratum_url) {\n\t\t\tfree(hi.stratum_url);\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t}\n\t*rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.hadrolltime = hi.hadrolltime;\n\tpool->sgminer_pool_stats.canroll = hi.canroll;\n\tpool->sgminer_pool_stats.hadexpire = hi.hadexpire;\n\tval = JSON_LOADS((const char *)all_data.buf, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tif (opt_protocol)\n\t\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char *)(all_data.buf));\n\t\tgoto err_out;\n\t}\n\tif (opt_protocol) {\n\t\tchar *s = json_dumps(val, JSON_INDENT(3));\n\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);\n\t\tfree(s);\n\t}\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tif (!res_val ||(err_val && !json_is_null(err_val))) {\n\t\tchar *s;\n\t\tif (err_val)\n\t\t\ts = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\ts = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"JSON-RPC call failed: %s\", s);\n\t\tfree(s);\n\t\tgoto err_out;\n\t}\n\tif (hi.reason) {\n\t\tjson_object_set_new(val, \"reject-reason\", json_string(hi.reason));\n\t\tfree(hi.reason);\n\t\thi.reason = NULL;\n\t}\n\tsuccessful_connect = true;\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\treturn val;\nerr_out:\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\tif (!successful_connect)\n\t\tapplog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\treturn NULL;\n}\n#define PROXY_HTTP\tCURLPROXY_HTTP\n#define PROXY_HTTP_1_0\tCURLPROXY_HTTP_1_0\n#define PROXY_SOCKS4\tCURLPROXY_SOCKS4\n#define PROXY_SOCKS5\tCURLPROXY_SOCKS5\n#define PROXY_SOCKS4A\tCURLPROXY_SOCKS4A\n#define PROXY_SOCKS5H\tCURLPROXY_SOCKS5_HOSTNAME\n#else \n#define PROXY_HTTP\t0\n#define PROXY_HTTP_1_0\t1\n#define PROXY_SOCKS4\t2\n#define PROXY_SOCKS5\t3\n#define PROXY_SOCKS4A\t4\n#define PROXY_SOCKS5H\t5\n#endif \nstatic struct {\n\tconst char *name;\n\tproxytypes_t proxytype;\n} proxynames[] = {\n\t{ \"http:\",\tPROXY_HTTP },\n\t{ \"http0:\",\tPROXY_HTTP_1_0 },\n\t{ \"socks4:\",\tPROXY_SOCKS4 },\n\t{ \"socks5:\",\tPROXY_SOCKS5 },\n\t{ \"socks4a:\",\tPROXY_SOCKS4A },\n\t{ \"socks5h:\",\tPROXY_SOCKS5H },\n\t{ NULL,\t(proxytypes_t)NULL }\n};\nstatic const int hex2bin_tbl[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};\nbool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n{\n\tint nibble1, nibble2;\n\tunsigned char idx;\n\tbool ret = false;\n\twhile (*hexstr && len) {\n\t\tif (unlikely(!hexstr[1])) {\n\t\t\tapplog(LOG_ERR, \"hex2bin str truncated\");\n\t\t\treturn ret;\n\t\t}\n\t\tidx = *hexstr++;\n\t\tnibble1 = hex2bin_tbl[idx];\n\t\tidx = *hexstr++;\n\t\tnibble2 = hex2bin_tbl[idx];\n\t\tif (unlikely((nibble1 < 0) || (nibble2 < 0))) {\n\t\t\tapplog(LOG_ERR, \"hex2bin scan failed\");\n\t\t\treturn ret;\n\t\t}\n\t\t*p++ = (((unsigned char)nibble1) << 4) | ((unsigned char)nibble2);\n\t\t--len;\n\t}\n\tif (likely(len == 0 && *hexstr == 0))\n\t\tret = true;\n\treturn ret;\n}\nstatic int __maybe_unused timespec_to_ms(struct timespec *ts)\n{\n\treturn ts->tv_sec * 1000 + ts->tv_nsec / 1000000;\n}\nstatic void __maybe_unused timersubspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec -= b->tv_sec;\n\ta->tv_nsec -= b->tv_nsec;\n\tif (a->tv_nsec < 0) {\n\t\ta->tv_nsec += 1000000000;\n\t\ta->tv_sec--;\n\t}\n}\n#ifdef WIN32\n#define EPOCHFILETIME (116444736000000000LL)\nstatic void decius_time(lldiv_t *lidiv)\n{\n\tFILETIME ft;\n\tLARGE_INTEGER li;\n\tGetSystemTimeAsFileTime(&ft);\n\tli.LowPart  = ft.dwLowDateTime;\n\tli.HighPart = ft.dwHighDateTime;\n\tli.QuadPart -= EPOCHFILETIME;\n\t*lidiv = lldiv(li.QuadPart, 10000000);\n}\nvoid cgtime(struct timeval *tv)\n{\n\tlldiv_t lidiv;\n\tdecius_time(&lidiv);\n\ttv->tv_sec = lidiv.quot;\n\ttv->tv_usec = lidiv.rem / 10;\n}\n#else \nvoid cgtime(struct timeval *tv)\n{\n\tgettimeofday(tv, NULL);\n}\n#endif \n#ifdef CLOCK_MONOTONIC \nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_gettime(CLOCK_MONOTONIC, ts_start);\n}\nstatic void nanosleep_abstime(struct timespec *ts_end)\n{\n\tint ret;\n\tdo {\n\t\tret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);\n\t} while (ret == EINTR);\n}\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tstruct timespec ts_end;\n\tms_to_timespec(&ts_end, ms);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_end;\n\tus_to_timespec(&ts_end, us);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\n#else \n#ifdef __MACH__\n#include <mach/clock.h>\n#include <mach/mach.h>\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_serv_t cclock;\n\tmach_timespec_t mts;\n\thost_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);\n\tclock_get_time(cclock, &mts);\n\tmach_port_deallocate(mach_task_self(), cclock);\n\tts_start->tv_sec = mts.tv_sec;\n\tts_start->tv_nsec = mts.tv_nsec;\n}\n#elif !defined(WIN32) \n#endif \n#ifdef WIN32\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn (int)(cgt->QuadPart / 10000LL);\n}\nvoid cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)\n{\n\tres->QuadPart = a->QuadPart - b->QuadPart;\n}\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tFILETIME ft;\n\tGetSystemTimeAsFileTime(&ft);\n\tts_start->LowPart = ft.dwLowDateTime;\n\tts_start->HighPart = ft.dwHighDateTime;\n}\nstatic void liSleep(LARGE_INTEGER *li, int timeout)\n{\n\tHANDLE hTimer;\n\tDWORD ret;\n\tif (unlikely(timeout <= 0))\n\t\treturn;\n\thTimer = CreateWaitableTimer(NULL, TRUE, NULL);\n\tif (unlikely(!hTimer))\n\t\tquit(1, \"Failed to create hTimer in liSleep\");\n\tret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);\n\tif (unlikely(!ret))\n\t\tquit(1, \"Failed to SetWaitableTimer in liSleep\");\n\tret = WaitForSingleObject(hTimer, timeout);\n\tif (unlikely(ret != WAIT_OBJECT_0 && ret != WAIT_TIMEOUT))\n\t\tquit(1, \"Failed to WaitForSingleObject in liSleep\");\n\tCloseHandle(hTimer);\n}\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tLARGE_INTEGER li;\n\tli.QuadPart = ts_start->QuadPart + (int64_t)ms * 10000LL;\n\tliSleep(&li, ms);\n}\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tLARGE_INTEGER li;\n\tint ms;\n\tli.QuadPart = ts_start->QuadPart + us * 10LL;\n\tms = us / 1000;\n\tif (!ms)\n\t\tms = 1;\n\tliSleep(&li, ms);\n}\n#else \n#endif \n#endif \ndouble tdiff(struct timeval *end, struct timeval *start)\n{\n\treturn end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;\n}\nbool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len) {\n\t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}\nenum send_ret {\n\tSEND_OK,\n\tSEND_SELECTFAIL,\n\tSEND_SENDFAIL,\n\tSEND_INACTIVE\n};\nstatic enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\tstrcat(s, \"\\n\");\n\tlen++;\n\twhile (len > 0 ) {\n\t\tstruct timeval timeout = {1, 0};\n\t\tssize_t sent;\n\t\tfd_set wd;\nretry:\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(sock, &wd);\n\t\tif (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {\n\t\t\tif (interrupted())\n\t\t\t\tgoto retry;\n\t\t\treturn SEND_SELECTFAIL;\n\t\t}\n#ifdef __APPLE__\n\t\tsent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);\n#elif WIN32\n\t\tsent = send(pool->sock, s + ssent, len, 0);\n#else\n\t\tsent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);\n#endif\n\t\tif (sent < 0) {\n\t\t\tif (!sock_blocks())\n\t\t\t\treturn SEND_SENDFAIL;\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\n\tpool->sgminer_pool_stats.times_sent++;\n\tpool->sgminer_pool_stats.bytes_sent += ssent;\n\tpool->sgminer_pool_stats.net_bytes_sent += ssent;\n\treturn SEND_OK;\n}\nbool stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tenum send_ret ret = SEND_INACTIVE;\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"SEND: %s\", s);\n\tmutex_lock(&pool->stratum_lock);\n\tif (pool->stratum_active)\n\t\tret = __stratum_send(pool, s, len);\n\tmutex_unlock(&pool->stratum_lock);\n\tswitch (ret) {\n\t\tdefault:\n\t\tcase SEND_OK:\n\t\t\tbreak;\n\t\tcase SEND_SELECTFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Write select failed on %s sock\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_SENDFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Failed to send in stratum_send\");\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_INACTIVE:\n\t\t\tapplog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");\n\t\t\tbreak;\n\t}\n\treturn (ret == SEND_OK);\n}\nstatic bool socket_full(struct pool *pool, int wait)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tstruct timeval timeout;\n\tfd_set rd;\n\tif (unlikely(wait < 0))\n\t\twait = 0;\n\tFD_ZERO(&rd);\n\tFD_SET(sock, &rd);\n\ttimeout.tv_usec = 0;\n\ttimeout.tv_sec = wait;\n\tif (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)\n\t\treturn true;\n\treturn false;\n}\nstatic void clear_sockbuf(struct pool *pool)\n{\n\tstrcpy(pool->sockbuf, \"\");\n}\nstatic void clear_sock(struct pool *pool)\n{\n\tssize_t n;\n\tmutex_lock(&pool->stratum_lock);\n\tdo {\n\t\tif (pool->sock)\n\t\t\tn = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);\n\t\telse\n\t\t\tn = 0;\n\t} while (n > 0);\n\tmutex_unlock(&pool->stratum_lock);\n\tclear_sockbuf(pool);\n}\nstatic void recalloc_sock(struct pool *pool, size_t len)\n{\n\tsize_t old, newlen;\n\told = strlen(pool->sockbuf);\n\tnewlen = old + len + 1;\n\tif (newlen < pool->sockbuf_size)\n\t\treturn;\n\tnewlen = newlen + (RBUFSIZE - (newlen % RBUFSIZE));\n\t// Avoid potentially recursive locking\n\t// applog(LOG_DEBUG, \"Recallocing pool sockbuf to %d\", new);\n\tpool->sockbuf = (char *)realloc(pool->sockbuf, newlen);\n\tif (!pool->sockbuf)\n\t\tquithere(1, \"Failed to realloc pool sockbuf\");\n\tmemset(pool->sockbuf + old, 0, newlen - old);\n\tpool->sockbuf_size = newlen;\n}\nchar *recv_line(struct pool *pool)\n{\n\tchar *tok, *sret = NULL;\n\tssize_t len, buflen;\n\tint waited = 0;\n\tif (!strstr(pool->sockbuf, \"\\n\")) {\n\t\tstruct timeval rstart, now;\n\t\tcgtime(&rstart);\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");\n\t\t\tgoto out;\n\t\t}\n\t\tdo {\n\t\t\tchar s[RBUFSIZE];\n\t\t\tsize_t slen;\n\t\t\tssize_t n;\n\t\t\tmemset(s, 0, RBUFSIZE);\n\t\t\tn = recv(pool->sock, s, RECVSIZE, 0);\n\t\t\tif (!n) {\n\t\t\t\tapplog(LOG_DEBUG, \"Socket closed waiting in recv_line\");\n\t\t\t\tsuspend_stratum(pool);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcgtime(&now);\n\t\t\twaited = tdiff(&now, &rstart);\n\t\t\tif (n < 0) {\n\t\t\t\tif (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Failed to recv sock in recv_line\");\n\t\t\t\t\tsuspend_stratum(pool);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslen = strlen(s);\n\t\t\t\trecalloc_sock(pool, slen);\n\t\t\t\tstrcat(pool->sockbuf, s);\n\t\t\t}\n\t\t} while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));\n\t}\n\tbuflen = strlen(pool->sockbuf);\n\ttok = strtok(pool->sockbuf, \"\\n\");\n\tif (!tok) {\n\t\tapplog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");\n\t\tgoto out;\n\t}\n\tsret = strdup(tok);\n\tlen = strlen(sret);\n\tif (buflen > len + 1)\n\t\tmemmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);\n\telse\n\t\tstrcpy(pool->sockbuf, \"\");\n\tpool->sgminer_pool_stats.times_received++;\n\tpool->sgminer_pool_stats.bytes_received += len;\n\tpool->sgminer_pool_stats.net_bytes_received += len;\nout:\n\tif (!sret)\n\t\tclear_sock(pool);\n\telse if (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"RECVD: %s\", sret);\n\treturn sret;\n}\nstatic char *__json_array_string(json_t *val, unsigned int entry)\n{\n\tjson_t *arr_entry;\n\tif (json_is_null(val))\n\t\treturn NULL;\n\tif (!json_is_array(val))\n\t\treturn NULL;\n\tif (entry > json_array_size(val))\n\t\treturn NULL;\n\tarr_entry = json_array_get(val, entry);\n\tif (!json_is_string(arr_entry))\n\t\treturn NULL;\n\treturn (char *)json_string_value(arr_entry);\n}\nstatic char *json_array_string(json_t *val, unsigned int entry)\n{\n\tchar *buf = __json_array_string(val, entry);\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}\nstatic char *blank_merkel = \"0000000000000000000000000000000000000000000000000000000000000000\";\nstatic bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, *header;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tunsigned char *cb1, *cb2;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\tmerkles = json_array_size(arr);\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = json_array_string(val, 5);\n\tnbit = json_array_string(val, 6);\n\tntime = json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (prev_hash)\n\t\t\tfree(prev_hash);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tif (bbversion)\n\t\t\tfree(bbversion);\n\t\tif (nbit)\n\t\t\tfree(nbit);\n\t\tif (ntime)\n\t\t\tfree(ntime);\n\t\tgoto out;\n\t}\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tfree(pool->swork.prev_hash);\n\tfree(pool->swork.bbversion);\n\tfree(pool->swork.nbit);\n\tfree(pool->swork.ntime);\n\tpool->swork.job_id = job_id;\n\tpool->swork.prev_hash = prev_hash;\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tpool->swork.bbversion = bbversion;\n\tpool->swork.nbit = nbit;\n\tpool->swork.ntime = ntime;\n\tpool->swork.clean = clean;\n\talloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\tfor (i = 0; i < pool->swork.merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\t\t\tpool->swork.merkle_bin[i] = (unsigned char *)malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\thex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t}\n\t}\n\tpool->swork.merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n\tpool->merkle_offset = strlen(pool->swork.bbversion) +\n\t\t\t      strlen(pool->swork.prev_hash);\n\tpool->swork.header_len = pool->merkle_offset +\n\t\t 32 +\n\t\t\t\t strlen(pool->swork.ntime) +\n\t\t\t\t strlen(pool->swork.nbit) +\n\t\t\t 8 +\n\t\t 96;\n\tpool->merkle_offset /= 2;\n\tpool->swork.header_len = pool->swork.header_len * 2 + 1;\n\talign_len(&pool->swork.header_len);\n\theader = (char *)alloca(pool->swork.header_len);\n\tsnprintf(header, pool->swork.header_len,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->swork.bbversion,\n\t\tpool->swork.prev_hash,\n\t\tblank_merkel,\n\t\tpool->swork.ntime,\n\t\tpool->swork.nbit,\n\t\t\"00000000\", \n\t\tworkpadding);\n\tif (unlikely(!hex2bin(pool->header_bin, header, 128)))\n\t\tquit(1, \"Failed to convert header to header_bin in parse_notify\");\n\tcb1 = (unsigned char *)calloc(cb1_len, 1);\n\tif (unlikely(!cb1))\n\t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n\thex2bin(cb1, coinbase1, cb1_len);\n\tcb2 = (unsigned char *)calloc(cb2_len, 1);\n\tif (unlikely(!cb2))\n\t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n\thex2bin(cb2, coinbase2, cb2_len);\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tcg_wunlock(&pool->data_lock);\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\tfree(cb1);\n\tfree(cb2);\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tret = true;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\nstatic bool parse_diff(struct pool *pool, json_t *val)\n{\n\tdouble old_diff, diff;\n\tif (opt_diff_mult == 0.0)\n\t\tdiff = json_number_value(json_array_get(val, 0)) * pool->algorithm.diff_multiplier1;\n\telse\n\t\tdiff = json_number_value(json_array_get(val, 0)) * opt_diff_mult;\n\tif (diff == 0)\n\t\treturn false;\n\tcg_wlock(&pool->data_lock);\n\told_diff = pool->swork.diff;\n\tpool->swork.diff = diff;\n\tcg_wunlock(&pool->data_lock);\n\tif (old_diff != diff) {\n\t\tint idiff = diff;\n\t\tif ((double)idiff == diff)\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %d\", get_pool_name(pool), idiff);\n\t\telse\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %.3f\", get_pool_name(pool), diff);\n\t} else\n\t\tapplog(LOG_DEBUG, \"%s difficulty set to %f\", get_pool_name(pool), diff);\n\treturn true;\n}\nstatic bool parse_extranonce(struct pool *pool, json_t *val)\n{\n\tchar *nonce1;\n\tint n2size;\n\tnonce1 = json_array_string(val, 0);\n\tif (!nonce1) {\n\t\treturn false;\n\t}\n\tn2size = json_integer_value(json_array_get(val, 1));\n\tif (!n2size) {\n\t\tfree(nonce1);\n\t\treturn false;\n\t}\n\tcg_wlock(&pool->data_lock);\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\tapplog(LOG_NOTICE, \"%s extranonce change requested\", get_pool_name(pool));\n\treturn true;\n}\nstatic void __suspend_stratum(struct pool *pool)\n{\n\tclear_sockbuf(pool);\n\tpool->stratum_active = pool->stratum_notify = false;\n\tif (pool->sock)\n\t\tCLOSESOCKET(pool->sock);\n\tpool->sock = 0;\n}\nstatic bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect forbidden, aborting.\");\n\t\treturn false;\n\t}\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic bool send_version(struct pool *pool, json_t *val)\n{\n\tchar s[RBUFSIZE];\n\tint id = json_integer_value(json_object_get(val, \"id\"));\n\tif (!id)\n\t\treturn false;\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"result\\\": \\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"error\\\": null}\", id);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\n\treturn true;\n}\nstatic bool show_message(struct pool *pool, json_t *val)\n{\n\tchar *msg;\n\tif (!json_is_array(val))\n\t\treturn false;\n\tmsg = (char *)json_string_value(json_array_get(val, 0));\n\tif (!msg)\n\t\treturn false;\n\tapplog(LOG_NOTICE, \"%s message: %s\", get_pool_name(pool), msg);\n\treturn true;\n}\nbool parse_method(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *method, *err_val, *params;\n\tjson_error_t err;\n\tbool ret = false;\n\tchar *buf;\n\tif (!s)\n\t\treturn ret;\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\treturn ret;\n\t}\n\tmethod = json_object_get(val, \"method\");\n\tif (!method) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\tif (err_val && !json_is_null(err_val)) {\n\t\tchar *ss;\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);\n\t\tjson_decref(val);\n\t\tfree(ss);\n\t\treturn ret;\n\t}\n\tbuf = (char *)json_string_value(method);\n\tif (!buf) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t\tif (parse_notify(pool, params))\n\t\t\tpool->stratum_notify = ret = true;\n\t\telse\n\t\t\tpool->stratum_notify = ret = false;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tif (!strncasecmp(buf, \"client.show_message\", 19) && show_message(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tjson_decref(val);\n\treturn ret;\n}\nbool subscribe_extranonce(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",\n\t\tswork_id++);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\twhile (42) {\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for response extranonce.subscribe\");\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\t\tif (err_val) {\n\t\t\tss = __json_array_string(err_val, 1);\n\t\t\tif (!ss)\n\t\t\t\tss = (char *)json_string_value(err_val);\n\t\t\tif (ss && (strcmp(ss, \"Method 'subscribe' not found for service 'mining.extranonce'\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ss && (strcmp(ss, \"Unrecognized request provided\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\t}\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\t\tgoto out;\n\t}\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum extranonce subscribe for %s\", get_pool_name(pool));\nout:\n\tjson_decref(val);\n\treturn ret;\n}\nbool auth_stratum(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",\n\t\tswork_id++, pool->rpc_user, pool->rpc_pass);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\twhile (42) {\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\t\tsuspend_stratum(pool);\n\t\tgoto out;\n\t}\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum authorisation success for %s\", get_pool_name(pool));\n\tpool->probed = true;\n\tsuccessful_connect = true;\nout:\n\tjson_decref(val);\n\treturn ret;\n}\nstatic int recv_byte(int sockd)\n{\n\tchar c;\n\tif (recv(sockd, &c, 1, 0) != -1)\n\t\treturn c;\n\treturn -1;\n}\nstatic bool http_negotiate(struct pool *pool, int sockd, bool http0)\n{\n\tchar buf[1024];\n\tint i, len;\n\tif (http0) {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.0\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port);\n\t} else {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s:%s\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port, pool->sockaddr_url,\n\t\t\tpool->stratum_port);\n\t}\n\tapplog(LOG_DEBUG, \"Sending proxy %s:%s - %s\",\n\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tsend(sockd, buf, strlen(buf), 0);\n\tlen = recv(sockd, buf, 12, 0);\n\tif (len <= 0) {\n\t\tapplog(LOG_WARNING, \"Couldn't read from proxy %s:%s after sending CONNECT\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\tbuf[len] = '\\0';\n\tapplog(LOG_DEBUG, \"Received from proxy %s:%s - %s\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tif (strcmp(buf, \"HTTP/1.1 200\") && strcmp(buf, \"HTTP/1.0 200\")) {\n\t\tapplog(LOG_WARNING, \"HTTP Error from proxy %s:%s - %s\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = recv_byte(sockd);\n\t\tif (buf[i] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\twhile (strncmp(buf, \"\\r\\n\\r\\n\", 4)) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tbuf[i] = buf[i + 1];\n\t\tbuf[3] = recv_byte(sockd);\n\t\tif (buf[3] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s HTTP proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\nstatic bool socks5_negotiate(struct pool *pool, int sockd)\n{\n\tunsigned char atyp, uclen;\n\tunsigned short port;\n\tchar buf[515];\n\tint i, len;\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tapplog(LOG_DEBUG, \"Attempting to negotiate with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\tsend(sockd, buf, 3, 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != buf[2]) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x03;\n\tlen = (strlen(pool->sockaddr_url));\n\tif (len > 255)\n\t\tlen = 255;\n\tuclen = len;\n\tbuf[4] = (uclen & 0xff);\n\tmemcpy(buf + 5, pool->sockaddr_url, len);\n\tport = atoi(pool->stratum_port);\n\tbuf[5 + len] = (port >> 8);\n\tbuf[6 + len] = (port & 0xff);\n\tsend(sockd, buf, (7 + len), 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != 0x00) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\trecv_byte(sockd);\n\tatyp = recv_byte(sockd);\n\tif (atyp == 0x01) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\trecv_byte(sockd);\n\t} else if (atyp == 0x03) {\n\t\tlen = recv_byte(sockd);\n\t\tfor (i = 0; i < len; i++)\n\t\t\trecv_byte(sockd);\n\t} else {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 2; i++)\n\t\trecv_byte(sockd);\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\nstatic bool socks4_negotiate(struct pool *pool, int sockd, bool socks4a)\n{\n\tunsigned short port;\n\tin_addr_t inp;\n\tchar buf[515];\n\tint i, len;\n\tint ret;\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x01;\n\tport = atoi(pool->stratum_port);\n\tbuf[2] = port >> 8;\n\tbuf[3] = port & 0xff;\n\tsprintf(&buf[8], \"SGMINER\");\n\tinp = inet_addr(pool->sockaddr_url);\n\tinp = ntohl(inp);\n\tif ((int)inp != -1)\n\t\tsocks4a = false;\n\telse {\n\t\tstruct addrinfo servinfobase, *servinfo, hints;\n\t\tservinfo = &servinfobase;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET; \n\t\tret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);\n\t\tif (!ret) {\n\t\t\tapplog(LOG_ERR, \"getaddrinfo() in socks4_negotiate() returned %i: %s\", ret, gai_strerror(ret));\n\t\t\tstruct sockaddr_in *saddr_in = (struct sockaddr_in *)servinfo->ai_addr;\n\t\t\tinp = ntohl(saddr_in->sin_addr.s_addr);\n\t\t\tsocks4a = false;\n\t\t\tfreeaddrinfo(servinfo);\n\t\t}\n\t}\n\tif (!socks4a) {\n\t\tif ((int)inp == -1) {\n\t\t\tapplog(LOG_WARNING, \"Invalid IP address specified for socks4 proxy: %s\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tbuf[4] = (inp >> 24) & 0xFF;\n\t\tbuf[5] = (inp >> 16) & 0xFF;\n\t\tbuf[6] = (inp >>  8) & 0xFF;\n\t\tbuf[7] = (inp >>  0) & 0xFF;\n\t\tsend(sockd, buf, 16, 0);\n\t} else {\n\t\tbuf[4] = 0;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t\tlen = strlen(pool->sockaddr_url);\n\t\tif (len > 255)\n\t\t\tlen = 255;\n\t\tmemcpy(&buf[16], pool->sockaddr_url, len);\n\t\tlen += 16;\n\t\tbuf[len++] = '\\0';\n\t\tsend(sockd, buf, len, 0);\n\t}\n\tif (recv_byte(sockd) != 0x00 || recv_byte(sockd) != 0x5a) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS4 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\trecv_byte(sockd);\n\treturn true;\n}\nstatic void noblock_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\nstatic void block_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n#else\n\tu_long flags = 0;\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\nstatic bool sock_connecting(void)\n{\n#ifndef WIN32\n\treturn errno == EINPROGRESS;\n#else\n\treturn WSAGetLastError() == WSAEWOULDBLOCK;\n#endif\n}\nstatic bool setup_stratum_socket(struct pool *pool)\n{\n\tstruct addrinfo servinfobase, *servinfo, *hints, *p;\n\tchar *sockaddr_url, *sockaddr_port;\n\tint sockd;\n\tint ret;\n\tmutex_lock(&pool->stratum_lock);\n\tpool->stratum_active = false;\n\tif (pool->sock) {\n\t\tapplog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));\n\t\tCLOSESOCKET(pool->sock);\n\t}\n\tpool->sock = 0;\n\tmutex_unlock(&pool->stratum_lock);\n\thints = &pool->stratum_hints;\n\tmemset(hints, 0, sizeof(struct addrinfo));\n\thints->ai_family = AF_UNSPEC;\n\thints->ai_socktype = SOCK_STREAM;\n\tservinfo = &servinfobase;\n\tif (!pool->rpc_proxy && opt_socks_proxy) {\n\t\tpool->rpc_proxy = opt_socks_proxy;\n\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\tpool->rpc_proxytype = PROXY_SOCKS5;\n\t}\n\tif (pool->rpc_proxy) {\n\t\tsockaddr_url = pool->sockaddr_proxy_url;\n\t\tsockaddr_port = pool->sockaddr_proxy_port;\n\t} else {\n\t\tsockaddr_url = pool->sockaddr_url;\n\t\tsockaddr_port = pool->stratum_port;\n\t}\n\tret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);\n\tif (ret) {\n\t\tapplog(LOG_INFO, \"getaddrinfo() in setup_stratum_socket() returned %i: %s\", ret, gai_strerror(ret));\n\t\tif (!pool->probed) {\n\t\t\tapplog(LOG_WARNING, \"Failed to resolve (wrong URL?) %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t\tpool->probed = true;\n\t\t} else {\n\t\t\tapplog(LOG_INFO, \"Failed to getaddrinfo for %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t}\n\t\treturn false;\n\t}\n\tfor (p = servinfo; p != NULL; p = p->ai_next) {\n\t\tsockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (sockd == -1) {\n\t\t\tapplog(LOG_DEBUG, \"Failed socket\");\n\t\t\tcontinue;\n\t\t}\n\t\tnoblock_socket(sockd);\n\t\tif (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {\n\t\t\tstruct timeval tv_timeout = {1, 0};\n\t\t\tint selret;\n\t\t\tfd_set rw;\n\t\t\tif (!sock_connecting()) {\n\t\t\t\tCLOSESOCKET(sockd);\n\t\t\t\tapplog(LOG_DEBUG, \"Failed sock connect\");\n\t\t\t\tcontinue;\n\t\t\t}\nretry:\n\t\t\tFD_ZERO(&rw);\n\t\t\tFD_SET(sockd, &rw);\n\t\t\tselret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);\n\t\t\tif  (selret > 0 && FD_ISSET(sockd, &rw)) {\n\t\t\t\tsocklen_t len;\n\t\t\t\tint err, n;\n\t\t\t\tlen = sizeof(err);\n\t\t\t\tn = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);\n\t\t\t\tif (!n && !err) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Succeeded delayed connect\");\n\t\t\t\t\tblock_socket(sockd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selret < 0 && interrupted())\n\t\t\t\tgoto retry;\n\t\t\tCLOSESOCKET(sockd);\n\t\t\tapplog(LOG_DEBUG, \"Select timeout/failed connect\");\n\t\t\tcontinue;\n\t\t}\n\t\tapplog(LOG_WARNING, \"Succeeded immediate connect\");\n\t\tblock_socket(sockd);\n\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\tapplog(LOG_INFO, \"Failed to connect to stratum on %s:%s\",\n\t\t       sockaddr_url, sockaddr_port);\n\t\tfreeaddrinfo(servinfo);\n\t\treturn false;\n\t}\n\tfreeaddrinfo(servinfo);\n\tif (pool->rpc_proxy) {\n\t\tswitch (pool->rpc_proxytype) {\n\t\t\tcase PROXY_HTTP_1_0:\n\t\t\t\tif (!http_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_HTTP:\n\t\t\t\tif (!http_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS5:\n\t\t\tcase PROXY_SOCKS5H:\n\t\t\t\tif (!socks5_negotiate(pool, sockd))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4A:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_WARNING, \"Unsupported proxy type for %s:%s\",\n\t\t\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!pool->sockbuf) {\n\t\tpool->sockbuf = (char *)calloc(RBUFSIZE, 1);\n\t\tif (!pool->sockbuf)\n\t\t\tquithere(1, \"Failed to calloc pool sockbuf\");\n\t\tpool->sockbuf_size = RBUFSIZE;\n\t}\n\tpool->sock = sockd;\n\tkeep_sockalive(sockd);\n\treturn true;\n}\nstatic char *get_sessionid(json_t *val)\n{\n\tchar *ret = NULL;\n\tjson_t *arr_val;\n\tint arrsize, i;\n\tarr_val = json_array_get(val, 0);\n\tif (!arr_val || !json_is_array(arr_val))\n\t\tgoto out;\n\tarrsize = json_array_size(arr_val);\n\tfor (i = 0; i < arrsize; i++) {\n\t\tjson_t *arr = json_array_get(arr_val, i);\n\t\tchar *notify;\n\t\tif (!arr | !json_is_array(arr))\n\t\t\tbreak;\n\t\tnotify = __json_array_string(arr, 0);\n\t\tif (!notify)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(notify, \"mining.notify\", 13)) {\n\t\t\tret = json_array_string(arr, 1);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\nvoid suspend_stratum(struct pool *pool)\n{\n\tapplog(LOG_INFO, \"Closing socket for stratum %s\", get_pool_name(pool));\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\tmutex_unlock(&pool->stratum_lock);\n}\nbool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\nresend:\n\tif (!setup_stratum_socket(pool)) {\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\tsockd = true;\n\tif (recvd) {\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);\n\t}\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\trecvd = true;\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\t\tfree(ss);\n\t\tgoto out;\n\t}\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\tret = true;\nout:\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       get_pool_name(pool), pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tnoresume = true;\n\t\t\tjson_decref(val);\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));\n\t\tif (sockd) {\n\t\t  applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t}\n\t}\n\tjson_decref(val);\n\treturn ret;\n}\nbool restart_stratum(struct pool *pool)\n{\n\tapplog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));\n\tif (pool->stratum_active)\n\t\tsuspend_stratum(pool);\n\tif (!initiate_stratum(pool))\n\t\treturn false;\n\tif (pool->extranonce_subscribe && !subscribe_extranonce(pool))\n\t\treturn false;\n\tif (!auth_stratum(pool))\n\t\treturn false;\n\treturn true;\n}\n#ifdef __APPLE__\nvoid _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint flags, fd, i;\n\tif (pipe(cgsem->pipefd) == -1)\n\t\tquitfrom(1, file, func, line, \"Failed pipe errno=%d\", errno);\n\tfor (i = 0; i < 2; i++) {\n\t\tfd = cgsem->pipefd[i];\n\t\tflags = fcntl(fd, F_GETFD, 0);\n\t\tflags |= FD_CLOEXEC;\n\t\tif (fcntl(fd, F_SETFD, flags) == -1)\n\t\t\tquitfrom(1, file, func, line, \"Failed to fcntl errno=%d\", errno);\n\t}\n}\nvoid _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tconst char buf = 1;\n\tint ret;\nretry:\n\tret = write(cgsem->pipefd[1], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to write errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\nvoid _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tchar buf;\n\tint ret;\nretry:\n\tret = read(cgsem->pipefd[0], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to read errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\nvoid cgsem_destroy(cgsem_t *cgsem)\n{\n\tclose(cgsem->pipefd[1]);\n\tclose(cgsem->pipefd[0]);\n}\nint _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)\n{\n\tstruct timeval timeout;\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\nretry:\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tms_to_timeval(&timeout, ms);\n\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\tif (ret > 0) {\n\t\tret = read(fd, &buf, 1);\n\t\treturn 0;\n\t}\n\tif (likely(!ret))\n\t\treturn ETIMEDOUT;\n\tif (interrupted())\n\t\tgoto retry;\n\tquitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);\n\treturn 0;\n}\nvoid cgsem_reset(cgsem_t *cgsem)\n{\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tdo {\n\t\tstruct timeval timeout = {0, 0};\n\t\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\t\tif (ret > 0)\n\t\t\tret = read(fd, &buf, 1);\n\t\telse if (unlikely(ret < 0 && interrupted()))\n\t\t\tret = 1;\n\t} while (ret > 0);\n}\n#else\n#endif\nstruct cg_completion {\n\tcgsem_t cgsem;\n\tvoid (*fn)(void *fnarg);\n\tvoid *fnarg;\n};\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_638.c",
        "project": "sgminer-dev/sgminer",
        "url": "https://github.com/sgminer-dev/sgminer/commit/78cc408369bdbbd440196c93574098d1482efbce",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```__rb_reserve_next(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t  struct rb_event_info *info)\n\tif (unlikely(info->add_timestamp))\n\t\tinfo->length += RB_LEN_TIME_EXTEND;\n\ttail_page = info->tail_page = READ_ONCE(cpu_buffer->tail_page);\n\twrite = local_add_return(info->length, &tail_page->write);\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n\tint nr_loops = 0;\n\trb_start_commit(cpu_buffer);\n\tinfo.length = rb_calculate_event_length(length);\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/trace_events.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_clock.h>\n#include <linux/trace_seq.h>\n#include <linux/spinlock.h>\n#include <linux/irq_work.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\t\n#include <linux/kmemcheck.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n#include <asm/local.h>\nstatic void update_pages_handler(struct work_struct *work);\n#define RB_BUFFER_OFF\t\t(1 << 20)\n#define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)\n#define RB_EVNT_HDR_SIZE (offsetof(struct ring_buffer_event, array))\n#define RB_ALIGNMENT\t\t4U\n#define RB_MAX_SMALL_DATA\t(RB_ALIGNMENT * RINGBUF_TYPE_DATA_TYPE_LEN_MAX)\n#define RB_EVNT_MIN_SIZE\t8U\t\n#ifndef CONFIG_HAVE_64BIT_ALIGNED_ACCESS\n# define RB_FORCE_8BYTE_ALIGNMENT\t0\n# define RB_ARCH_ALIGNMENT\t\tRB_ALIGNMENT\n#else\n# define RB_FORCE_8BYTE_ALIGNMENT\t1\n# define RB_ARCH_ALIGNMENT\t\t8U\n#endif\n#define RB_ALIGN_DATA\t\t__aligned(RB_ARCH_ALIGNMENT)\n#define RINGBUF_TYPE_DATA 0 ... RINGBUF_TYPE_DATA_TYPE_LEN_MAX\nenum {\n\tRB_LEN_TIME_EXTEND = 8,\n\tRB_LEN_TIME_STAMP = 16,\n};\n#define skip_time_extend(event) \\\n\t((struct ring_buffer_event *)((char *)event + RB_LEN_TIME_EXTEND))\nEXPORT_SYMBOL_GPL(ring_buffer_event_data);\n#define for_each_buffer_cpu(buffer, cpu)\t\t\\\n\tfor_each_cpu(cpu, buffer->cpumask)\n#define TS_SHIFT\t27\n#define TS_MASK\t\t((1ULL << TS_SHIFT) - 1)\n#define TS_DELTA_TEST\t(~TS_MASK)\n#define RB_MISSED_EVENTS\t(1 << 31)\n#define RB_MISSED_STORED\t(1 << 30)\nstruct buffer_data_page {\n\tu64\t\t time_stamp;\t\n\tlocal_t\t\t commit;\t\n\tunsigned char\t data[] RB_ALIGN_DATA;\t\n};\nstruct buffer_page {\n\tstruct list_head list;\t\t\n\tlocal_t\t\t write;\t\t\n\tunsigned\t read;\t\t\n\tlocal_t\t\t entries;\t\n\tunsigned long\t real_end;\t\n\tstruct buffer_data_page *page;\t\n};\n#define RB_WRITE_MASK\t\t0xfffff\n#define RB_WRITE_INTCNT\t\t(1 << 20)\nstatic void rb_init_page(struct buffer_data_page *bpage)\n{\n\tlocal_set(&bpage->commit, 0);\n}\nstatic void free_buffer_page(struct buffer_page *bpage)\n{\n\tfree_page((unsigned long)bpage->page);\n\tkfree(bpage);\n}\n#define BUF_PAGE_SIZE (PAGE_SIZE - BUF_PAGE_HDR_SIZE)\n#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))\nstruct rb_irq_work {\n\tstruct irq_work\t\t\twork;\n\twait_queue_head_t\t\twaiters;\n\twait_queue_head_t\t\tfull_waiters;\n\tbool\t\t\t\twaiters_pending;\n\tbool\t\t\t\tfull_waiters_pending;\n\tbool\t\t\t\twakeup_full;\n};\nstruct rb_event_info {\n\tu64\t\t\tts;\n\tu64\t\t\tdelta;\n\tunsigned long\t\tlength;\n\tstruct buffer_page\t*tail_page;\n\tint\t\t\tadd_timestamp;\n};\nenum {\n\tRB_CTX_NMI,\n\tRB_CTX_IRQ,\n\tRB_CTX_SOFTIRQ,\n\tRB_CTX_NORMAL,\n\tRB_CTX_MAX\n};\nstruct ring_buffer_per_cpu {\n\tint\t\t\t\tcpu;\n\tatomic_t\t\t\trecord_disabled;\n\tstruct ring_buffer\t\t*buffer;\n\traw_spinlock_t\t\t\treader_lock;\t\n\tarch_spinlock_t\t\t\tlock;\n\tstruct lock_class_key\t\tlock_key;\n\tunsigned long\t\t\tnr_pages;\n\tunsigned int\t\t\tcurrent_context;\n\tstruct list_head\t\t*pages;\n\tstruct buffer_page\t\t*head_page;\t\n\tstruct buffer_page\t\t*tail_page;\t\n\tstruct buffer_page\t\t*commit_page;\t\n\tstruct buffer_page\t\t*reader_page;\n\tunsigned long\t\t\tlost_events;\n\tunsigned long\t\t\tlast_overrun;\n\tlocal_t\t\t\t\tentries_bytes;\n\tlocal_t\t\t\t\tentries;\n\tlocal_t\t\t\t\toverrun;\n\tlocal_t\t\t\t\tcommit_overrun;\n\tlocal_t\t\t\t\tdropped_events;\n\tlocal_t\t\t\t\tcommitting;\n\tlocal_t\t\t\t\tcommits;\n\tunsigned long\t\t\tread;\n\tunsigned long\t\t\tread_bytes;\n\tu64\t\t\t\twrite_stamp;\n\tu64\t\t\t\tread_stamp;\n\tlong\t\t\t\tnr_pages_to_update;\n\tstruct list_head\t\tnew_pages; \n\tstruct work_struct\t\tupdate_pages_work;\n\tstruct completion\t\tupdate_done;\n\tstruct rb_irq_work\t\tirq_work;\n};\nstruct ring_buffer {\n\tunsigned\t\t\tflags;\n\tint\t\t\t\tcpus;\n\tatomic_t\t\t\trecord_disabled;\n\tatomic_t\t\t\tresize_disabled;\n\tcpumask_var_t\t\t\tcpumask;\n\tstruct lock_class_key\t\t*reader_lock_key;\n\tstruct mutex\t\t\tmutex;\n\tstruct ring_buffer_per_cpu\t**buffers;\n#ifdef CONFIG_HOTPLUG_CPU\n\tstruct notifier_block\t\tcpu_notify;\n#endif\n\tu64\t\t\t\t(*clock)(void);\n\tstruct rb_irq_work\t\tirq_work;\n};\nstruct ring_buffer_iter {\n\tstruct ring_buffer_per_cpu\t*cpu_buffer;\n\tunsigned long\t\t\thead;\n\tstruct buffer_page\t\t*head_page;\n\tstruct buffer_page\t\t*cache_reader_page;\n\tunsigned long\t\t\tcache_read;\n\tu64\t\t\t\tread_stamp;\n};\nint ring_buffer_wait(struct ring_buffer *buffer, int cpu, bool full)\n{\n\tDEFINE_WAIT(wait);\n\tstruct rb_irq_work *work;\n\tint ret = 0;\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\twork = &buffer->irq_work;\n\t\tfull = false;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn -ENODEV;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\twork = &cpu_buffer->irq_work;\n\t}\n\twhile (true) {\n\t\tif (full)\n\t\t\tprepare_to_wait(&work->full_waiters, &wait, TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tprepare_to_wait(&work->waiters, &wait, TASK_INTERRUPTIBLE);\n\t\tif (full)\n\t\t\twork->full_waiters_pending = true;\n\t\telse\n\t\t\twork->waiters_pending = true;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (cpu == RING_BUFFER_ALL_CPUS && !ring_buffer_empty(buffer))\n\t\t\tbreak;\n\t\tif (cpu != RING_BUFFER_ALL_CPUS &&\n\t\t    !ring_buffer_empty_cpu(buffer, cpu)) {\n\t\t\tunsigned long flags;\n\t\t\tbool pagebusy;\n\t\t\tif (!full)\n\t\t\t\tbreak;\n\t\t\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\t\t\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n\t\t\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\t\t\tif (!pagebusy)\n\t\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\tif (full)\n\t\tfinish_wait(&work->full_waiters, &wait);\n\telse\n\t\tfinish_wait(&work->waiters, &wait);\n\treturn ret;\n}\nint ring_buffer_poll_wait(struct ring_buffer *buffer, int cpu,\n\t\t\t  struct file *filp, poll_table *poll_table)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct rb_irq_work *work;\n\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\twork = &buffer->irq_work;\n\telse {\n\t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn -EINVAL;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\twork = &cpu_buffer->irq_work;\n\t}\n\tpoll_wait(filp, &work->waiters, poll_table);\n\twork->waiters_pending = true;\n\tsmp_mb();\n\tif ((cpu == RING_BUFFER_ALL_CPUS && !ring_buffer_empty(buffer)) ||\n\t    (cpu != RING_BUFFER_ALL_CPUS && !ring_buffer_empty_cpu(buffer, cpu)))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}\n#define RB_WARN_ON(b, cond)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint _____ret = unlikely(cond);\t\t\t\t\\\n\t\tif (_____ret) {\t\t\t\t\t\t\\\n\t\t\tif (__same_type(*(b), struct ring_buffer_per_cpu)) { \\\n\t\t\t\tstruct ring_buffer_per_cpu *__b =\t\\\n\t\t\t\t\t(void *)b;\t\t\t\\\n\t\t\t\tatomic_inc(&__b->buffer->record_disabled); \\\n\t\t\t} else\t\t\t\t\t\t\\\n\t\t\t\tatomic_inc(&b->record_disabled);\t\\\n\t\t\tWARN_ON(1);\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t_____ret;\t\t\t\t\t\t\\\n\t})\n#define DEBUG_SHIFT 0\nEXPORT_SYMBOL_GPL(ring_buffer_time_stamp);\nEXPORT_SYMBOL_GPL(ring_buffer_normalize_time_stamp);\n#define RB_PAGE_NORMAL\t\t0UL\n#define RB_PAGE_HEAD\t\t1UL\n#define RB_PAGE_UPDATE\t\t2UL\n#define RB_FLAG_MASK\t\t3UL\n#define RB_PAGE_MOVED\t\t4UL\nstatic struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}\nstatic inline int\nrb_is_head_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\tstruct buffer_page *page, struct list_head *list)\n{\n\tunsigned long val;\n\tval = (unsigned long)list->next;\n\tif ((val & ~RB_FLAG_MASK) != (unsigned long)&page->list)\n\t\treturn RB_PAGE_MOVED;\n\treturn val & RB_FLAG_MASK;\n}\nstatic void rb_set_list_to_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\tstruct list_head *list)\n{\n\tunsigned long *ptr;\n\tptr = (unsigned long *)&list->next;\n\t*ptr |= RB_PAGE_HEAD;\n\t*ptr &= ~RB_PAGE_UPDATE;\n}\nstatic void rb_head_page_activate(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *head;\n\thead = cpu_buffer->head_page;\n\tif (!head)\n\t\treturn;\n\trb_set_list_to_head(cpu_buffer, head->list.prev);\n}\nstatic void rb_list_head_clear(struct list_head *list)\n{\n\tunsigned long *ptr = (unsigned long *)&list->next;\n\t*ptr &= ~RB_FLAG_MASK;\n}\nstatic void\nrb_head_page_deactivate(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *hd;\n\trb_list_head_clear(cpu_buffer->pages);\n\tlist_for_each(hd, cpu_buffer->pages)\n\t\trb_list_head_clear(hd);\n}\nstatic inline void rb_inc_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t       struct buffer_page **bpage)\n{\n\tstruct list_head *p = rb_list_head((*bpage)->list.next);\n\t*bpage = list_entry(p, struct buffer_page, list);\n}\nstatic struct buffer_page *\nrb_set_head_page(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *head;\n\tstruct buffer_page *page;\n\tstruct list_head *list;\n\tint i;\n\tif (RB_WARN_ON(cpu_buffer, !cpu_buffer->head_page))\n\t\treturn NULL;\n\tlist = cpu_buffer->pages;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev->next) != list))\n\t\treturn NULL;\n\tpage = head = cpu_buffer->head_page;\n\tfor (i = 0; i < 3; i++) {\n\t\tdo {\n\t\t\tif (rb_is_head_page(cpu_buffer, page, page->list.prev)) {\n\t\t\t\tcpu_buffer->head_page = page;\n\t\t\t\treturn page;\n\t\t\t}\n\t\t\trb_inc_page(cpu_buffer, &page);\n\t\t} while (page != head);\n\t}\n\tRB_WARN_ON(cpu_buffer, 1);\n\treturn NULL;\n}\nstatic void rb_tail_page_update(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t       struct buffer_page *tail_page,\n\t\t\t       struct buffer_page *next_page)\n{\n\tunsigned long old_entries;\n\tunsigned long old_write;\n\told_write = local_add_return(RB_WRITE_INTCNT, &next_page->write);\n\told_entries = local_add_return(RB_WRITE_INTCNT, &next_page->entries);\n\tbarrier();\n\tif (tail_page == READ_ONCE(cpu_buffer->tail_page)) {\n\t\tunsigned long val = old_write & ~RB_WRITE_MASK;\n\t\tunsigned long eval = old_entries & ~RB_WRITE_MASK;\n\t\t(void)local_cmpxchg(&next_page->write, old_write, val);\n\t\t(void)local_cmpxchg(&next_page->entries, old_entries, eval);\n\t\tlocal_set(&next_page->page->commit, 0);\n\t\t(void)cmpxchg(&cpu_buffer->tail_page, tail_page, next_page);\n\t}\n}\nstatic int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}\nstatic int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *head = cpu_buffer->pages;\n\tstruct buffer_page *bpage, *tmp;\n\tif (cpu_buffer->head_page)\n\t\trb_set_head_page(cpu_buffer);\n\trb_head_page_deactivate(cpu_buffer);\n\tif (RB_WARN_ON(cpu_buffer, head->next->prev != head))\n\t\treturn -1;\n\tif (RB_WARN_ON(cpu_buffer, head->prev->next != head))\n\t\treturn -1;\n\tif (rb_check_list(cpu_buffer, head))\n\t\treturn -1;\n\tlist_for_each_entry_safe(bpage, tmp, head, list) {\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       bpage->list.next->prev != &bpage->list))\n\t\t\treturn -1;\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       bpage->list.prev->next != &bpage->list))\n\t\t\treturn -1;\n\t\tif (rb_check_list(cpu_buffer, &bpage->list))\n\t\t\treturn -1;\n\t}\n\trb_head_page_activate(cpu_buffer);\n\treturn 0;\n}\nstatic int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)\n{\n\tstruct buffer_page *bpage, *tmp;\n\tlong i;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tbpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),\n\t\t\t\t    GFP_KERNEL | __GFP_NORETRY,\n\t\t\t\t    cpu_to_node(cpu));\n\t\tif (!bpage)\n\t\t\tgoto free_pages;\n\t\tlist_add(&bpage->list, pages);\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto free_pages;\n\t\tbpage->page = page_address(page);\n\t\trb_init_page(bpage->page);\n\t}\n\treturn 0;\nfree_pages:\n\tlist_for_each_entry_safe(bpage, tmp, pages, list) {\n\t\tlist_del_init(&bpage->list);\n\t\tfree_buffer_page(bpage);\n\t}\n\treturn -ENOMEM;\n}\nstatic struct ring_buffer_per_cpu *\nrb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_page *bpage;\n\tstruct page *page;\n\tint ret;\n\tcpu_buffer = kzalloc_node(ALIGN(sizeof(*cpu_buffer), cache_line_size()),\n\t\t\t\t  GFP_KERNEL, cpu_to_node(cpu));\n\tif (!cpu_buffer)\n\t\treturn NULL;\n\tcpu_buffer->cpu = cpu;\n\tcpu_buffer->buffer = buffer;\n\traw_spin_lock_init(&cpu_buffer->reader_lock);\n\tlockdep_set_class(&cpu_buffer->reader_lock, buffer->reader_lock_key);\n\tcpu_buffer->lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tINIT_WORK(&cpu_buffer->update_pages_work, update_pages_handler);\n\tinit_completion(&cpu_buffer->update_done);\n\tinit_irq_work(&cpu_buffer->irq_work.work, rb_wake_up_waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.full_waiters);\n\tbpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),\n\t\t\t    GFP_KERNEL, cpu_to_node(cpu));\n\tif (!bpage)\n\t\tgoto fail_free_buffer;\n\trb_check_bpage(cpu_buffer, bpage);\n\tcpu_buffer->reader_page = bpage;\n\tpage = alloc_pages_node(cpu_to_node(cpu), GFP_KERNEL, 0);\n\tif (!page)\n\t\tgoto fail_free_reader;\n\tbpage->page = page_address(page);\n\trb_init_page(bpage->page);\n\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);\n\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\tret = rb_allocate_pages(cpu_buffer, nr_pages);\n\tif (ret < 0)\n\t\tgoto fail_free_reader;\n\tcpu_buffer->head_page\n\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);\n\tcpu_buffer->tail_page = cpu_buffer->commit_page = cpu_buffer->head_page;\n\trb_head_page_activate(cpu_buffer);\n\treturn cpu_buffer;\n fail_free_reader:\n\tfree_buffer_page(cpu_buffer->reader_page);\n fail_free_buffer:\n\tkfree(cpu_buffer);\n\treturn NULL;\n}\n#ifdef CONFIG_HOTPLUG_CPU\nstatic int rb_cpu_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu);\n#endif\nstruct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,\n\t\t\t\t\tstruct lock_class_key *key)\n{\n\tstruct ring_buffer *buffer;\n\tlong nr_pages;\n\tint bsize;\n\tint cpu;\n\tbuffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),\n\t\t\t GFP_KERNEL);\n\tif (!buffer)\n\t\treturn NULL;\n\tif (!alloc_cpumask_var(&buffer->cpumask, GFP_KERNEL))\n\t\tgoto fail_free_buffer;\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tbuffer->flags = flags;\n\tbuffer->clock = trace_clock_local;\n\tbuffer->reader_lock_key = key;\n\tinit_irq_work(&buffer->irq_work.work, rb_wake_up_waiters);\n\tinit_waitqueue_head(&buffer->irq_work.waiters);\n\tif (nr_pages < 2)\n\t\tnr_pages = 2;\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpu_notifier_register_begin();\n\tcpumask_copy(buffer->cpumask, cpu_online_mask);\n#else\n\tcpumask_copy(buffer->cpumask, cpu_possible_mask);\n#endif\n\tbuffer->cpus = nr_cpu_ids;\n\tbsize = sizeof(void *) * nr_cpu_ids;\n\tbuffer->buffers = kzalloc(ALIGN(bsize, cache_line_size()),\n\t\t\t\t  GFP_KERNEL);\n\tif (!buffer->buffers)\n\t\tgoto fail_free_cpumask;\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tbuffer->buffers[cpu] =\n\t\t\trb_allocate_cpu_buffer(buffer, nr_pages, cpu);\n\t\tif (!buffer->buffers[cpu])\n\t\t\tgoto fail_free_buffers;\n\t}\n#ifdef CONFIG_HOTPLUG_CPU\n\tbuffer->cpu_notify.notifier_call = rb_cpu_notify;\n\tbuffer->cpu_notify.priority = 0;\n\t__register_cpu_notifier(&buffer->cpu_notify);\n\tcpu_notifier_register_done();\n#endif\n\tmutex_init(&buffer->mutex);\n\treturn buffer;\n fail_free_buffers:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tif (buffer->buffers[cpu])\n\t\t\trb_free_cpu_buffer(buffer->buffers[cpu]);\n\t}\n\tkfree(buffer->buffers);\n fail_free_cpumask:\n\tfree_cpumask_var(buffer->cpumask);\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpu_notifier_register_done();\n#endif\n fail_free_buffer:\n\tkfree(buffer);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__ring_buffer_alloc);\nEXPORT_SYMBOL_GPL(ring_buffer_free);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic inline unsigned long rb_page_entries(struct buffer_page *bpage)\n{\n\treturn local_read(&bpage->entries) & RB_WRITE_MASK;\n}\nstatic int\nrb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}\nstatic int\nrb_insert_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *pages = &cpu_buffer->new_pages;\n\tint retries, success;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tretries = 10;\n\tsuccess = 0;\n\twhile (retries--) {\n\t\tstruct list_head *head_page, *prev_page, *r;\n\t\tstruct list_head *last_page, *first_page;\n\t\tstruct list_head *head_page_with_bit;\n\t\thead_page = &rb_set_head_page(cpu_buffer)->list;\n\t\tif (!head_page)\n\t\t\tbreak;\n\t\tprev_page = head_page->prev;\n\t\tfirst_page = pages->next;\n\t\tlast_page  = pages->prev;\n\t\thead_page_with_bit = (struct list_head *)\n\t\t\t\t     ((unsigned long)head_page | RB_PAGE_HEAD);\n\t\tlast_page->next = head_page_with_bit;\n\t\tfirst_page->prev = prev_page;\n\t\tr = cmpxchg(&prev_page->next, head_page_with_bit, first_page);\n\t\tif (r == head_page_with_bit) {\n\t\t\thead_page->prev = last_page;\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (success)\n\t\tINIT_LIST_HEAD(pages);\n\tRB_WARN_ON(cpu_buffer, !success);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tif (!success) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\t list) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\treturn success;\n}\nstatic void rb_update_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tint success;\n\tif (cpu_buffer->nr_pages_to_update > 0)\n\t\tsuccess = rb_insert_pages(cpu_buffer);\n\telse\n\t\tsuccess = rb_remove_pages(cpu_buffer,\n\t\t\t\t\t-cpu_buffer->nr_pages_to_update);\n\tif (success)\n\t\tcpu_buffer->nr_pages += cpu_buffer->nr_pages_to_update;\n}\nint ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\tif (!buffer)\n\t\treturn size;\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tif (nr_pages < 2)\n\t\tnr_pages = 2;\n\tsize = nr_pages * BUF_PAGE_SIZE;\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\tmutex_lock(&buffer->mutex);\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tget_online_cpus();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\t\tput_online_cpus();\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tget_online_cpus();\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n out:\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_resize);\nEXPORT_SYMBOL_GPL(ring_buffer_change_overwrite);\nstatic int\nrb_handle_head_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct buffer_page *tail_page,\n\t\t    struct buffer_page *next_page)\n{\n\tstruct buffer_page *new_head;\n\tint entries;\n\tint type;\n\tint ret;\n\tentries = rb_page_entries(next_page);\n\ttype = rb_head_page_set_update(cpu_buffer, next_page, tail_page,\n\t\t\t\t       RB_PAGE_HEAD);\n\tswitch (type) {\n\tcase RB_PAGE_HEAD:\n\t\tlocal_add(entries, &cpu_buffer->overrun);\n\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\tbreak;\n\tcase RB_PAGE_UPDATE:\n\t\tbreak;\n\tcase RB_PAGE_NORMAL:\n\t\treturn 1;\n\tcase RB_PAGE_MOVED:\n\t\treturn 1;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1); \n\t\treturn -1;\n\t}\n\tnew_head = next_page;\n\trb_inc_page(cpu_buffer, &new_head);\n\tret = rb_head_page_set_head(cpu_buffer, new_head, next_page,\n\t\t\t\t    RB_PAGE_NORMAL);\n\tswitch (ret) {\n\tcase RB_PAGE_HEAD:\n\tcase RB_PAGE_NORMAL:\n\t\tbreak;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1);\n\t\treturn -1;\n\t}\n\tif (ret == RB_PAGE_NORMAL) {\n\t\tstruct buffer_page *buffer_tail_page;\n\t\tbuffer_tail_page = READ_ONCE(cpu_buffer->tail_page);\n\t\tif (buffer_tail_page != tail_page &&\n\t\t    buffer_tail_page != next_page)\n\t\t\trb_head_page_set_normal(cpu_buffer, new_head,\n\t\t\t\t\t\tnext_page,\n\t\t\t\t\t\tRB_PAGE_HEAD);\n\t}\n\tif (type == RB_PAGE_HEAD) {\n\t\tret = rb_head_page_set_normal(cpu_buffer, next_page,\n\t\t\t\t\t      tail_page,\n\t\t\t\t\t      RB_PAGE_UPDATE);\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       ret != RB_PAGE_UPDATE))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic inline void\nrb_reset_tail(struct ring_buffer_per_cpu *cpu_buffer,\n\t      unsigned long tail, struct rb_event_info *info)\n{\n\tstruct buffer_page *tail_page = info->tail_page;\n\tstruct ring_buffer_event *event;\n\tunsigned long length = info->length;\n\tif (tail >= BUF_PAGE_SIZE) {\n\t\tif (tail == BUF_PAGE_SIZE)\n\t\t\ttail_page->real_end = 0;\n\t\tlocal_sub(length, &tail_page->write);\n\t\treturn;\n\t}\n\tevent = __rb_page_index(tail_page, tail);\n\tkmemcheck_annotate_bitfield(event, bitfield);\n\tlocal_add(BUF_PAGE_SIZE - tail, &cpu_buffer->entries_bytes);\n\ttail_page->real_end = tail;\n\tif (tail > (BUF_PAGE_SIZE - RB_EVNT_MIN_SIZE)) {\n\t\trb_event_set_padding(event);\n\t\tlocal_sub(length, &tail_page->write);\n\t\treturn;\n\t}\n\tevent->array[0] = (BUF_PAGE_SIZE - tail) - RB_EVNT_HDR_SIZE;\n\tevent->type_len = RINGBUF_TYPE_PADDING;\n\tevent->time_delta = 1;\n\tlength = (tail + length) - BUF_PAGE_SIZE;\n\tlocal_sub(length, &tail_page->write);\n}\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct ring_buffer_event *\nrb_move_tail(struct ring_buffer_per_cpu *cpu_buffer,\n\t     unsigned long tail, struct rb_event_info *info)\n{\n\tstruct buffer_page *tail_page = info->tail_page;\n\tstruct buffer_page *commit_page = cpu_buffer->commit_page;\n\tstruct ring_buffer *buffer = cpu_buffer->buffer;\n\tstruct buffer_page *next_page;\n\tint ret;\n\tnext_page = tail_page;\n\trb_inc_page(cpu_buffer, &next_page);\n\tif (unlikely(next_page == commit_page)) {\n\t\tlocal_inc(&cpu_buffer->commit_overrun);\n\t\tgoto out_reset;\n\t}\n\tif (rb_is_head_page(cpu_buffer, next_page, &tail_page->list)) {\n\t\tif (!rb_is_reader_page(cpu_buffer->commit_page)) {\n\t\t\tif (!(buffer->flags & RB_FL_OVERWRITE)) {\n\t\t\t\tlocal_inc(&cpu_buffer->dropped_events);\n\t\t\t\tgoto out_reset;\n\t\t\t}\n\t\t\tret = rb_handle_head_page(cpu_buffer,\n\t\t\t\t\t\t  tail_page,\n\t\t\t\t\t\t  next_page);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_reset;\n\t\t\tif (ret)\n\t\t\t\tgoto out_again;\n\t\t} else {\n\t\t\tif (unlikely((cpu_buffer->commit_page !=\n\t\t\t\t      cpu_buffer->tail_page) &&\n\t\t\t\t     (cpu_buffer->commit_page ==\n\t\t\t\t      cpu_buffer->reader_page))) {\n\t\t\t\tlocal_inc(&cpu_buffer->commit_overrun);\n\t\t\t\tgoto out_reset;\n\t\t\t}\n\t\t}\n\t}\n\trb_tail_page_update(cpu_buffer, tail_page, next_page);\n out_again:\n\trb_reset_tail(cpu_buffer, tail, info);\n\trb_end_commit(cpu_buffer);\n\tlocal_inc(&cpu_buffer->committing);\n\treturn ERR_PTR(-EAGAIN);\n out_reset:\n\trb_reset_tail(cpu_buffer, tail, info);\n\treturn NULL;\n}\nstatic noinline struct ring_buffer_event *\nrb_add_time_stamp(struct ring_buffer_event *event, u64 delta)\n{\n\tevent->type_len = RINGBUF_TYPE_TIME_EXTEND;\n\tif (rb_event_index(event)) {\n\t\tevent->time_delta = delta & TS_MASK;\n\t\tevent->array[0] = delta >> TS_SHIFT;\n\t} else {\n\t\tevent->time_delta = 0;\n\t\tevent->array[0] = 0;\n\t}\n\treturn skip_time_extend(event);\n}\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}\n#ifndef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n#endif\nstatic inline int\nrb_try_to_discard(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t  struct ring_buffer_event *event)\n{\n\tunsigned long new_index, old_index;\n\tstruct buffer_page *bpage;\n\tunsigned long index;\n\tunsigned long addr;\n\tnew_index = rb_event_index(event);\n\told_index = new_index + rb_event_ts_length(event);\n\taddr = (unsigned long)event;\n\taddr &= PAGE_MASK;\n\tbpage = READ_ONCE(cpu_buffer->tail_page);\n\tif (bpage->page == (void *)addr && rb_page_write(bpage) == old_index) {\n\t\tunsigned long write_mask =\n\t\t\tlocal_read(&bpage->write) & ~RB_WRITE_MASK;\n\t\tunsigned long event_length = rb_event_length(event);\n\t\told_index += write_mask;\n\t\tnew_index += write_mask;\n\t\tindex = local_cmpxchg(&bpage->write, old_index, new_index);\n\t\tif (index == old_index) {\n\t\t\tlocal_sub(event_length, &cpu_buffer->entries_bytes);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic void\nrb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned long max_count;\n again:\n\tmax_count = cpu_buffer->nr_pages * 100;\n\twhile (cpu_buffer->commit_page != READ_ONCE(cpu_buffer->tail_page)) {\n\t\tif (RB_WARN_ON(cpu_buffer, !(--max_count)))\n\t\t\treturn;\n\t\tif (RB_WARN_ON(cpu_buffer,\n\t\t\t       rb_is_reader_page(cpu_buffer->tail_page)))\n\t\t\treturn;\n\t\tlocal_set(&cpu_buffer->commit_page->page->commit,\n\t\t\t  rb_page_write(cpu_buffer->commit_page));\n\t\trb_inc_page(cpu_buffer, &cpu_buffer->commit_page);\n\t\tif (rb_page_write(cpu_buffer->commit_page))\n\t\t\tcpu_buffer->write_stamp =\n\t\t\t\tcpu_buffer->commit_page->page->time_stamp;\n\t\tbarrier();\n\t}\n\twhile (rb_commit_index(cpu_buffer) !=\n\t       rb_page_write(cpu_buffer->commit_page)) {\n\t\tlocal_set(&cpu_buffer->commit_page->page->commit,\n\t\t\t  rb_page_write(cpu_buffer->commit_page));\n\t\tRB_WARN_ON(cpu_buffer,\n\t\t\t   local_read(&cpu_buffer->commit_page->page->commit) &\n\t\t\t   ~RB_WRITE_MASK);\n\t\tbarrier();\n\t}\n\tbarrier();\n\tif (unlikely(cpu_buffer->commit_page != READ_ONCE(cpu_buffer->tail_page)))\n\t\tgoto again;\n}\nstatic __always_inline void\nrb_wakeups(struct ring_buffer *buffer, struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tbool pagebusy;\n\tif (buffer->irq_work.waiters_pending) {\n\t\tbuffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&buffer->irq_work.work);\n\t}\n\tif (cpu_buffer->irq_work.waiters_pending) {\n\t\tcpu_buffer->irq_work.waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n\tpagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n\tif (!pagebusy && cpu_buffer->irq_work.full_waiters_pending) {\n\t\tcpu_buffer->irq_work.wakeup_full = true;\n\t\tcpu_buffer->irq_work.full_waiters_pending = false;\n\t\tirq_work_queue(&cpu_buffer->irq_work.work);\n\t}\n}\nstatic __always_inline int\ntrace_recursive_lock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tunsigned int val = cpu_buffer->current_context;\n\tint bit;\n\tif (in_interrupt()) {\n\t\tif (in_nmi())\n\t\t\tbit = RB_CTX_NMI;\n\t\telse if (in_irq())\n\t\t\tbit = RB_CTX_IRQ;\n\t\telse\n\t\t\tbit = RB_CTX_SOFTIRQ;\n\t} else\n\t\tbit = RB_CTX_NORMAL;\n\tif (unlikely(val & (1 << bit)))\n\t\treturn 1;\n\tval |= (1 << bit);\n\tcpu_buffer->current_context = val;\n\treturn 0;\n}\nstatic __always_inline void\ntrace_recursive_unlock(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tcpu_buffer->current_context &= cpu_buffer->current_context - 1;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_unlock_commit);\nstatic noinline void\nrb_handle_timestamp(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct rb_event_info *info)\n{\n\tWARN_ONCE(info->delta > (1ULL << 59),\n\t\t  KERN_WARNING \"Delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t  (unsigned long long)info->delta,\n\t\t  (unsigned long long)info->ts,\n\t\t  (unsigned long long)cpu_buffer->write_stamp,\n\t\t  sched_clock_stable() ? \"\" :\n\t\t  \"If you just came from a suspend/resume,\\n\"\n\t\t  \"please switch to the trace global clock:\\n\"\n\t\t  \"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\");\n\tinfo->add_timestamp = 1;\n}\nstatic struct ring_buffer_event *\n__rb_reserve_next(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t  struct rb_event_info *info)\n{\n\tstruct ring_buffer_event *event;\n\tstruct buffer_page *tail_page;\n\tunsigned long tail, write;\n\tif (unlikely(info->add_timestamp))\n\t\tinfo->length += RB_LEN_TIME_EXTEND;\n\ttail_page = info->tail_page = READ_ONCE(cpu_buffer->tail_page);\n\twrite = local_add_return(info->length, &tail_page->write);\n\twrite &= RB_WRITE_MASK;\n\ttail = write - info->length;\n\tif (!tail)\n\t\tinfo->delta = 0;\n\tif (unlikely(write > BUF_PAGE_SIZE))\n\t\treturn rb_move_tail(cpu_buffer, tail, info);\n\tevent = __rb_page_index(tail_page, tail);\n\tkmemcheck_annotate_bitfield(event, bitfield);\n\trb_update_event(cpu_buffer, event, info);\n\tlocal_inc(&tail_page->entries);\n\tif (!tail)\n\t\ttail_page->page->time_stamp = info->ts;\n\tlocal_add(info->length, &cpu_buffer->entries_bytes);\n\treturn event;\n}\nstatic struct ring_buffer_event *\nrb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_lock_reserve);\nEXPORT_SYMBOL_GPL(ring_buffer_discard_commit);\nEXPORT_SYMBOL_GPL(ring_buffer_write);\nEXPORT_SYMBOL_GPL(ring_buffer_record_disable);\nEXPORT_SYMBOL_GPL(ring_buffer_record_enable);\nEXPORT_SYMBOL_GPL(ring_buffer_record_off);\nEXPORT_SYMBOL_GPL(ring_buffer_record_on);\nEXPORT_SYMBOL_GPL(ring_buffer_record_disable_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_record_enable_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_oldest_event_ts);\nEXPORT_SYMBOL_GPL(ring_buffer_bytes_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_entries_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_overrun_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_commit_overrun_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_dropped_events_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_read_events_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_entries);\nEXPORT_SYMBOL_GPL(ring_buffer_overruns);\nEXPORT_SYMBOL_GPL(ring_buffer_iter_reset);\nEXPORT_SYMBOL_GPL(ring_buffer_iter_empty);\nstatic struct buffer_page *\nrb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *reader = NULL;\n\tunsigned long overwrite;\n\tunsigned long flags;\n\tint nr_loops = 0;\n\tint ret;\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n again:\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 3)) {\n\t\treader = NULL;\n\t\tgoto out;\n\t}\n\treader = cpu_buffer->reader_page;\n\tif (cpu_buffer->reader_page->read < rb_page_size(reader))\n\t\tgoto out;\n\tif (RB_WARN_ON(cpu_buffer,\n\t\t       cpu_buffer->reader_page->read > rb_page_size(reader)))\n\t\tgoto out;\n\treader = NULL;\n\tif (cpu_buffer->commit_page == cpu_buffer->reader_page)\n\t\tgoto out;\n\tif (rb_num_of_entries(cpu_buffer) == 0)\n\t\tgoto out;\n\tlocal_set(&cpu_buffer->reader_page->write, 0);\n\tlocal_set(&cpu_buffer->reader_page->entries, 0);\n\tlocal_set(&cpu_buffer->reader_page->page->commit, 0);\n\tcpu_buffer->reader_page->real_end = 0;\n spin:\n\treader = rb_set_head_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out;\n\tcpu_buffer->reader_page->list.next = rb_list_head(reader->list.next);\n\tcpu_buffer->reader_page->list.prev = reader->list.prev;\n\tcpu_buffer->pages = reader->list.prev;\n\trb_set_list_to_head(cpu_buffer, &cpu_buffer->reader_page->list);\n\tsmp_mb();\n\toverwrite = local_read(&(cpu_buffer->overrun));\n\tret = rb_head_page_replace(reader, cpu_buffer->reader_page);\n\tif (!ret)\n\t\tgoto spin;\n\trb_list_head(reader->list.next)->prev = &cpu_buffer->reader_page->list;\n\trb_inc_page(cpu_buffer, &cpu_buffer->head_page);\n\tcpu_buffer->reader_page = reader;\n\tcpu_buffer->reader_page->read = 0;\n\tif (overwrite != cpu_buffer->last_overrun) {\n\t\tcpu_buffer->lost_events = overwrite - cpu_buffer->last_overrun;\n\t\tcpu_buffer->last_overrun = overwrite;\n\t}\n\tgoto again;\n out:\n\tif (reader && reader->read == 0)\n\t\tcpu_buffer->read_stamp = reader->page->time_stamp;\n\tarch_spin_unlock(&cpu_buffer->lock);\n\tlocal_irq_restore(flags);\n\treturn reader;\n}\nstatic void rb_advance_iter(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned length;\n\tcpu_buffer = iter->cpu_buffer;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\tif (iter->head_page == cpu_buffer->commit_page)\n\t\t\treturn;\n\t\trb_inc_iter(iter);\n\t\treturn;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tlength = rb_event_length(event);\n\tif (RB_WARN_ON(cpu_buffer,\n\t\t       (iter->head_page == cpu_buffer->commit_page) &&\n\t\t       (iter->head + length > rb_commit_index(cpu_buffer))))\n\t\treturn;\n\trb_update_iter_read_stamp(iter, event);\n\titer->head += length;\n\tif ((iter->head >= rb_page_size(iter->head_page)) &&\n\t    (iter->head_page != cpu_buffer->commit_page))\n\t\trb_inc_iter(iter);\n}\nstatic struct ring_buffer_event *\nrb_buffer_peek(struct ring_buffer_per_cpu *cpu_buffer, u64 *ts,\n\t       unsigned long *lost_events)\n{\n\tstruct ring_buffer_event *event;\n\tstruct buffer_page *reader;\n\tint nr_loops = 0;\n again:\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 2))\n\t\treturn NULL;\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\treturn NULL;\n\tevent = rb_reader_event(cpu_buffer);\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event))\n\t\t\tRB_WARN_ON(cpu_buffer, 1);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_reader(cpu_buffer);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\trb_advance_reader(cpu_buffer);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts) {\n\t\t\t*ts = cpu_buffer->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(cpu_buffer->buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\tif (lost_events)\n\t\t\t*lost_events = rb_lost_events(cpu_buffer);\n\t\treturn event;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_peek);\nstatic struct ring_buffer_event *\nrb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer *buffer;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint nr_loops = 0;\n\tcpu_buffer = iter->cpu_buffer;\n\tbuffer = cpu_buffer->buffer;\n\tif (unlikely(iter->cache_read != cpu_buffer->read ||\n\t\t     iter->cache_reader_page != cpu_buffer->reader_page))\n\t\trb_iter_reset(iter);\n again:\n\tif (ring_buffer_iter_empty(iter))\n\t\treturn NULL;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 3))\n\t\treturn NULL;\n\tif (rb_per_cpu_empty(cpu_buffer))\n\t\treturn NULL;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\trb_inc_iter(iter);\n\t\tgoto again;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event)) {\n\t\t\trb_inc_iter(iter);\n\t\t\tgoto again;\n\t\t}\n\t\trb_advance_iter(iter);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts) {\n\t\t\t*ts = iter->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\treturn event;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_iter_peek);\nEXPORT_SYMBOL_GPL(ring_buffer_consume);\nEXPORT_SYMBOL_GPL(ring_buffer_read_prepare);\nEXPORT_SYMBOL_GPL(ring_buffer_read_prepare_sync);\nEXPORT_SYMBOL_GPL(ring_buffer_read_start);\nEXPORT_SYMBOL_GPL(ring_buffer_read_finish);\nEXPORT_SYMBOL_GPL(ring_buffer_read);\nEXPORT_SYMBOL_GPL(ring_buffer_size);\nstatic void\nrb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\trb_head_page_deactivate(cpu_buffer);\n\tcpu_buffer->head_page\n\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);\n\tlocal_set(&cpu_buffer->head_page->write, 0);\n\tlocal_set(&cpu_buffer->head_page->entries, 0);\n\tlocal_set(&cpu_buffer->head_page->page->commit, 0);\n\tcpu_buffer->head_page->read = 0;\n\tcpu_buffer->tail_page = cpu_buffer->head_page;\n\tcpu_buffer->commit_page = cpu_buffer->head_page;\n\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);\n\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\tlocal_set(&cpu_buffer->reader_page->write, 0);\n\tlocal_set(&cpu_buffer->reader_page->entries, 0);\n\tlocal_set(&cpu_buffer->reader_page->page->commit, 0);\n\tcpu_buffer->reader_page->read = 0;\n\tlocal_set(&cpu_buffer->entries_bytes, 0);\n\tlocal_set(&cpu_buffer->overrun, 0);\n\tlocal_set(&cpu_buffer->commit_overrun, 0);\n\tlocal_set(&cpu_buffer->dropped_events, 0);\n\tlocal_set(&cpu_buffer->entries, 0);\n\tlocal_set(&cpu_buffer->committing, 0);\n\tlocal_set(&cpu_buffer->commits, 0);\n\tcpu_buffer->read = 0;\n\tcpu_buffer->read_bytes = 0;\n\tcpu_buffer->write_stamp = 0;\n\tcpu_buffer->read_stamp = 0;\n\tcpu_buffer->lost_events = 0;\n\tcpu_buffer->last_overrun = 0;\n\trb_head_page_activate(cpu_buffer);\n}\nEXPORT_SYMBOL_GPL(ring_buffer_reset_cpu);\nEXPORT_SYMBOL_GPL(ring_buffer_reset);\nEXPORT_SYMBOL_GPL(ring_buffer_empty);\nEXPORT_SYMBOL_GPL(ring_buffer_empty_cpu);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\nint ring_buffer_swap_cpu(struct ring_buffer *buffer_a,\n\t\t\t struct ring_buffer *buffer_b, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer_a;\n\tstruct ring_buffer_per_cpu *cpu_buffer_b;\n\tint ret = -EINVAL;\n\tif (!cpumask_test_cpu(cpu, buffer_a->cpumask) ||\n\t    !cpumask_test_cpu(cpu, buffer_b->cpumask))\n\t\tgoto out;\n\tcpu_buffer_a = buffer_a->buffers[cpu];\n\tcpu_buffer_b = buffer_b->buffers[cpu];\n\tif (cpu_buffer_a->nr_pages != cpu_buffer_b->nr_pages)\n\t\tgoto out;\n\tret = -EAGAIN;\n\tif (atomic_read(&buffer_a->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&buffer_b->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&cpu_buffer_a->record_disabled))\n\t\tgoto out;\n\tif (atomic_read(&cpu_buffer_b->record_disabled))\n\t\tgoto out;\n\tatomic_inc(&cpu_buffer_a->record_disabled);\n\tatomic_inc(&cpu_buffer_b->record_disabled);\n\tret = -EBUSY;\n\tif (local_read(&cpu_buffer_a->committing))\n\t\tgoto out_dec;\n\tif (local_read(&cpu_buffer_b->committing))\n\t\tgoto out_dec;\n\tbuffer_a->buffers[cpu] = cpu_buffer_b;\n\tbuffer_b->buffers[cpu] = cpu_buffer_a;\n\tcpu_buffer_b->buffer = buffer_a;\n\tcpu_buffer_a->buffer = buffer_b;\n\tret = 0;\nout_dec:\n\tatomic_dec(&cpu_buffer_a->record_disabled);\n\tatomic_dec(&cpu_buffer_b->record_disabled);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_swap_cpu);\n#endif \nEXPORT_SYMBOL_GPL(ring_buffer_alloc_read_page);\nEXPORT_SYMBOL_GPL(ring_buffer_free_read_page);\nint ring_buffer_read_page(struct ring_buffer *buffer,\n\t\t\t  void **data_page, size_t len, int cpu, int full)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tstruct buffer_data_page *bpage;\n\tstruct buffer_page *reader;\n\tunsigned long missed_events;\n\tunsigned long flags;\n\tunsigned int commit;\n\tunsigned int read;\n\tu64 save_timestamp;\n\tint ret = -1;\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\tif (len <= BUF_PAGE_HDR_SIZE)\n\t\tgoto out;\n\tlen -= BUF_PAGE_HDR_SIZE;\n\tif (!data_page)\n\t\tgoto out;\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\treader = rb_get_reader_page(cpu_buffer);\n\tif (!reader)\n\t\tgoto out_unlock;\n\tevent = rb_reader_event(cpu_buffer);\n\tread = reader->read;\n\tcommit = rb_page_commit(reader);\n\tmissed_events = cpu_buffer->lost_events;\n\tif (read || (len < (commit - read)) ||\n\t    cpu_buffer->reader_page == cpu_buffer->commit_page) {\n\t\tstruct buffer_data_page *rpage = cpu_buffer->reader_page->page;\n\t\tunsigned int rpos = read;\n\t\tunsigned int pos = 0;\n\t\tunsigned int size;\n\t\tif (full)\n\t\t\tgoto out_unlock;\n\t\tif (len > (commit - read))\n\t\t\tlen = (commit - read);\n\t\tsize = rb_event_ts_length(event);\n\t\tif (len < size)\n\t\t\tgoto out_unlock;\n\t\tsave_timestamp = cpu_buffer->read_stamp;\n\t\tdo {\n\t\t\tsize = rb_event_length(event);\n\t\t\tmemcpy(bpage->data + pos, rpage->data + rpos, size);\n\t\t\tlen -= size;\n\t\t\trb_advance_reader(cpu_buffer);\n\t\t\trpos = reader->read;\n\t\t\tpos += size;\n\t\t\tif (rpos >= commit)\n\t\t\t\tbreak;\n\t\t\tevent = rb_reader_event(cpu_buffer);\n\t\t\tsize = rb_event_ts_length(event);\n\t\t} while (len >= size);\n\t\tlocal_set(&bpage->commit, pos);\n\t\tbpage->time_stamp = save_timestamp;\n\t\tread = 0;\n\t} else {\n\t\tcpu_buffer->read += rb_page_entries(reader);\n\t\tcpu_buffer->read_bytes += BUF_PAGE_SIZE;\n\t\trb_init_page(bpage);\n\t\tbpage = reader->page;\n\t\treader->page = *data_page;\n\t\tlocal_set(&reader->write, 0);\n\t\tlocal_set(&reader->entries, 0);\n\t\treader->read = 0;\n\t\t*data_page = bpage;\n\t\tif (reader->real_end)\n\t\t\tlocal_set(&bpage->commit, reader->real_end);\n\t}\n\tret = read;\n\tcpu_buffer->lost_events = 0;\n\tcommit = local_read(&bpage->commit);\n\tif (missed_events) {\n\t\tif (BUF_PAGE_SIZE - commit >= sizeof(missed_events)) {\n\t\t\tmemcpy(&bpage->data[commit], &missed_events,\n\t\t\t       sizeof(missed_events));\n\t\t\tlocal_add(RB_MISSED_STORED, &bpage->commit);\n\t\t\tcommit += sizeof(missed_events);\n\t\t}\n\t\tlocal_add(RB_MISSED_EVENTS, &bpage->commit);\n\t}\n\tif (commit < BUF_PAGE_SIZE)\n\t\tmemset(&bpage->data[commit], 0, BUF_PAGE_SIZE - commit);\n out_unlock:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ring_buffer_read_page);\n#ifdef CONFIG_HOTPLUG_CPU\nstatic int rb_cpu_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tstruct ring_buffer *buffer =\n\t\tcontainer_of(self, struct ring_buffer, cpu_notify);\n\tlong cpu = (long)hcpu;\n\tlong nr_pages_same;\n\tint cpu_i;\n\tunsigned long nr_pages;\n\tswitch (action) {\n\tcase CPU_UP_PREPARE:\n\tcase CPU_UP_PREPARE_FROZEN:\n\t\tif (cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn NOTIFY_OK;\n\t\tnr_pages = 0;\n\t\tnr_pages_same = 1;\n\t\tfor_each_buffer_cpu(buffer, cpu_i) {\n\t\t\tif (nr_pages == 0)\n\t\t\t\tnr_pages = buffer->buffers[cpu_i]->nr_pages;\n\t\t\tif (nr_pages != buffer->buffers[cpu_i]->nr_pages) {\n\t\t\t\tnr_pages_same = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!nr_pages_same)\n\t\t\tnr_pages = 2;\n\t\tbuffer->buffers[cpu] =\n\t\t\trb_allocate_cpu_buffer(buffer, nr_pages, cpu);\n\t\tif (!buffer->buffers[cpu]) {\n\t\t\tWARN(1, \"failed to allocate ring buffer on CPU %ld\\n\",\n\t\t\t     cpu);\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\t\tsmp_wmb();\n\t\tcpumask_set_cpu(cpu, buffer->cpumask);\n\t\tbreak;\n\tcase CPU_DOWN_PREPARE:\n\tcase CPU_DOWN_PREPARE_FROZEN:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n#endif\n#ifdef CONFIG_RING_BUFFER_STARTUP_TEST\nstatic struct task_struct *rb_threads[NR_CPUS] __initdata;\nstruct rb_test_data {\n\tstruct ring_buffer\t*buffer;\n\tunsigned long\t\tevents;\n\tunsigned long\t\tbytes_written;\n\tunsigned long\t\tbytes_alloc;\n\tunsigned long\t\tbytes_dropped;\n\tunsigned long\t\tevents_nested;\n\tunsigned long\t\tbytes_written_nested;\n\tunsigned long\t\tbytes_alloc_nested;\n\tunsigned long\t\tbytes_dropped_nested;\n\tint\t\t\tmin_size_nested;\n\tint\t\t\tmax_size_nested;\n\tint\t\t\tmax_size;\n\tint\t\t\tmin_size;\n\tint\t\t\tcpu;\n\tint\t\t\tcnt;\n};\nstatic struct rb_test_data rb_data[NR_CPUS] __initdata;\n#define RB_TEST_BUFFER_SIZE\t1048576\nstatic char rb_string[] __initdata =\n\t\"abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()?+\\\\\"\n\t\"?+|:';\\\",.<>/?abcdefghijklmnopqrstuvwxyz1234567890\"\n\t\"!@#$%^&*()?+\\\\?+|:';\\\",.<>/?abcdefghijklmnopqrstuv\";\nstatic bool rb_test_started __initdata;\nstruct rb_item {\n\tint size;\n\tchar str[];\n};\nstatic __init int rb_write_something(struct rb_test_data *data, bool nested)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_item *item;\n\tbool started;\n\tint event_len;\n\tint size;\n\tint len;\n\tint cnt;\n\tcnt = data->cnt + (nested ? 27 : 0);\n\tsize = (data->cnt * 68 / 25) % (sizeof(rb_string) - 1);\n\tlen = size + sizeof(struct rb_item);\n\tstarted = rb_test_started;\n\tsmp_rmb();\n\tevent = ring_buffer_lock_reserve(data->buffer, len);\n\tif (!event) {\n\t\tif (started) {\n\t\t\tif (nested)\n\t\t\t\tdata->bytes_dropped += len;\n\t\t\telse\n\t\t\t\tdata->bytes_dropped_nested += len;\n\t\t}\n\t\treturn len;\n\t}\n\tevent_len = ring_buffer_event_length(event);\n\tif (RB_WARN_ON(data->buffer, event_len < len))\n\t\tgoto out;\n\titem = ring_buffer_event_data(event);\n\titem->size = size;\n\tmemcpy(item->str, rb_string, size);\n\tif (nested) {\n\t\tdata->bytes_alloc_nested += event_len;\n\t\tdata->bytes_written_nested += len;\n\t\tdata->events_nested++;\n\t\tif (!data->min_size_nested || len < data->min_size_nested)\n\t\t\tdata->min_size_nested = len;\n\t\tif (len > data->max_size_nested)\n\t\t\tdata->max_size_nested = len;\n\t} else {\n\t\tdata->bytes_alloc += event_len;\n\t\tdata->bytes_written += len;\n\t\tdata->events++;\n\t\tif (!data->min_size || len < data->min_size)\n\t\t\tdata->max_size = len;\n\t\tif (len > data->max_size)\n\t\t\tdata->max_size = len;\n\t}\n out:\n\tring_buffer_unlock_commit(data->buffer, event);\n\treturn 0;\n}\nstatic __init int rb_test(void *arg)\n{\n\tstruct rb_test_data *data = arg;\n\twhile (!kthread_should_stop()) {\n\t\trb_write_something(data, false);\n\t\tdata->cnt++;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tusleep_range(((data->cnt % 3) + 1) * 100, 1000);\n\t}\n\treturn 0;\n}\nstatic __init void rb_ipi(void *ignore)\n{\n\tstruct rb_test_data *data;\n\tint cpu = smp_processor_id();\n\tdata = &rb_data[cpu];\n\trb_write_something(data, true);\n}\nstatic __init int rb_hammer_test(void *arg)\n{\n\twhile (!kthread_should_stop()) {\n\t\tsmp_call_function(rb_ipi, NULL, 1);\n\t\tschedule();\n\t}\n\treturn 0;\n}\nstatic __init int test_ringbuffer(void)\n{\n\tstruct task_struct *rb_hammer;\n\tstruct ring_buffer *buffer;\n\tint cpu;\n\tint ret = 0;\n\tpr_info(\"Running ring buffer tests...\\n\");\n\tbuffer = ring_buffer_alloc(RB_TEST_BUFFER_SIZE, RB_FL_OVERWRITE);\n\tif (WARN_ON(!buffer))\n\t\treturn 0;\n\tring_buffer_record_off(buffer);\n\tfor_each_online_cpu(cpu) {\n\t\trb_data[cpu].buffer = buffer;\n\t\trb_data[cpu].cpu = cpu;\n\t\trb_data[cpu].cnt = cpu;\n\t\trb_threads[cpu] = kthread_create(rb_test, &rb_data[cpu],\n\t\t\t\t\t\t \"rbtester/%d\", cpu);\n\t\tif (WARN_ON(!rb_threads[cpu])) {\n\t\t\tpr_cont(\"FAILED\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out_free;\n\t\t}\n\t\tkthread_bind(rb_threads[cpu], cpu);\n \t\twake_up_process(rb_threads[cpu]);\n\t}\n\trb_hammer = kthread_run(rb_hammer_test, NULL, \"rbhammer\");\n\tif (WARN_ON(!rb_hammer)) {\n\t\tpr_cont(\"FAILED\\n\");\n\t\tret = -1;\n\t\tgoto out_free;\n\t}\n\tring_buffer_record_on(buffer);\n\tsmp_wmb();\n\trb_test_started = true;\n\tset_current_state(TASK_INTERRUPTIBLE);\n\t;\n\tschedule_timeout(10 * HZ);\n\tkthread_stop(rb_hammer);\n out_free:\n\tfor_each_online_cpu(cpu) {\n\t\tif (!rb_threads[cpu])\n\t\t\tbreak;\n\t\tkthread_stop(rb_threads[cpu]);\n\t}\n\tif (ret) {\n\t\tring_buffer_free(buffer);\n\t\treturn ret;\n\t}\n\tpr_info(\"finished\\n\");\n\tfor_each_online_cpu(cpu) {\n\t\tstruct ring_buffer_event *event;\n\t\tstruct rb_test_data *data = &rb_data[cpu];\n\t\tstruct rb_item *item;\n\t\tunsigned long total_events;\n\t\tunsigned long total_dropped;\n\t\tunsigned long total_written;\n\t\tunsigned long total_alloc;\n\t\tunsigned long total_read = 0;\n\t\tunsigned long total_size = 0;\n\t\tunsigned long total_len = 0;\n\t\tunsigned long total_lost = 0;\n\t\tunsigned long lost;\n\t\tint big_event_size;\n\t\tint small_event_size;\n\t\tret = -1;\n\t\ttotal_events = data->events + data->events_nested;\n\t\ttotal_written = data->bytes_written + data->bytes_written_nested;\n\t\ttotal_alloc = data->bytes_alloc + data->bytes_alloc_nested;\n\t\ttotal_dropped = data->bytes_dropped + data->bytes_dropped_nested;\n\t\tbig_event_size = data->max_size + data->max_size_nested;\n\t\tsmall_event_size = data->min_size + data->min_size_nested;\n\t\tpr_info(\"CPU %d:\\n\", cpu);\n\t\tpr_info(\"              events:    %ld\\n\", total_events);\n\t\tpr_info(\"       dropped bytes:    %ld\\n\", total_dropped);\n\t\tpr_info(\"       alloced bytes:    %ld\\n\", total_alloc);\n\t\tpr_info(\"       written bytes:    %ld\\n\", total_written);\n\t\tpr_info(\"       biggest event:    %d\\n\", big_event_size);\n\t\tpr_info(\"      smallest event:    %d\\n\", small_event_size);\n\t\tif (RB_WARN_ON(buffer, total_dropped))\n\t\t\tbreak;\n\t\tret = 0;\n\t\twhile ((event = ring_buffer_consume(buffer, cpu, NULL, &lost))) {\n\t\t\ttotal_lost += lost;\n\t\t\titem = ring_buffer_event_data(event);\n\t\t\ttotal_len += ring_buffer_event_length(event);\n\t\t\ttotal_size += item->size + sizeof(struct rb_item);\n\t\t\tif (memcmp(&item->str[0], rb_string, item->size) != 0) {\n\t\t\t\tpr_info(\"FAILED!\\n\");\n\t\t\t\tpr_info(\"buffer had: %.*s\\n\", item->size, item->str);\n\t\t\t\tpr_info(\"expected:   %.*s\\n\", item->size, rb_string);\n\t\t\t\tRB_WARN_ON(buffer, 1);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal_read++;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -1;\n\t\tpr_info(\"         read events:   %ld\\n\", total_read);\n\t\tpr_info(\"         lost events:   %ld\\n\", total_lost);\n\t\tpr_info(\"        total events:   %ld\\n\", total_lost + total_read);\n\t\tpr_info(\"  recorded len bytes:   %ld\\n\", total_len);\n\t\tpr_info(\" recorded size bytes:   %ld\\n\", total_size);\n\t\tif (total_lost)\n\t\t\tpr_info(\" With dropped events, record len and size may not match\\n\"\n\t\t\t\t\" alloced and written from above\\n\");\n\t\tif (!total_lost) {\n\t\t\tif (RB_WARN_ON(buffer, total_len != total_alloc ||\n\t\t\t\t       total_size != total_written))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (RB_WARN_ON(buffer, total_lost + total_read != total_events))\n\t\t\tbreak;\n\t\tret = 0;\n\t}\n\tif (!ret)\n\t\tpr_info(\"Ring buffer PASSED!\\n\");\n\tring_buffer_free(buffer);\n\treturn 0;\n}\nlate_initcall(test_ringbuffer);\n#endif \n",
        "cwe": "CWE-190",
        "file_name": "safe_respovul_idx_1524.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```updateDevice(const struct header * headers, time_t t)\n\tstruct device * p = *pp;\t\n\t\t\tp->t = t;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\tpp = &p->next;\n\t\tp = *pp;\t\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr,\n\tunsigned int lifetime = 180;\t\n\tconst char * st = NULL;\n\tif(get_lan_for_peer(addr) == NULL) {\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint m = lineend - valuestart;\t\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\tconst char * name = valuestart;\t\n\t\t\t\tint rem = m;\t\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t}\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\tlinestart = lineend;\n\t\twhile((linestart < p + n) && (*linestart == '\\n' || *linestart == '\\r'))\n\t\t\tlinestart++;\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\nint main(int argc, char * * argv)\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tunsigned char ttl = 2;\t\n\tconst char * searched_device = NULL;\t\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&lan_addrs);\n\t\telse {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t}\n\tif(lan_addrs.lh_first == NULL)\n\tupnp_bootid = (unsigned int)time(NULL);\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\tif(sigaction(SIGINT, &sa, NULL))\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\tif(try_sendto(&writefds) < 0) {\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\telse\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\t}\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\treq = reqnext;\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"config.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#if 0\n#include <pwd.h>\n#include <grp.h>\n#endif\n#ifndef LOG_PERROR\n#define LOG_PERROR 0\n#endif \n#include \"getifaddr.h\"\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n#include \"minissdpdtypes.h\"\n#include \"asyncsendto.h\"\n#define SET_MAX(max, x)\tif((x) > (max)) (max) = (x)\n#ifndef MIN\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#endif\nstruct reqelem {\n\tint socket;\n\tint is_notify;\t\n\tLIST_ENTRY(reqelem) entries;\n\tunsigned char * output_buffer;\n\tint output_buffer_offset;\n\tint output_buffer_len;\n};\nstruct header {\n\tconst char * p; \n\tint l;          \n};\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 \n\tstruct header headers[3]; \n\tchar data[];\n};\nstruct service {\n\tchar * st;\t\n\tchar * usn;\t\n\tchar * server;\t\n\tchar * location;\t\n\tLIST_ENTRY(service) entries;\n};\n servicelisthead;\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\nenum request_type {\n\tMINISSDPD_GET_VERSION = 0,\n\tMINISSDPD_SEARCH_TYPE = 1,\n\tMINISSDPD_SEARCH_USN = 2,\n\tMINISSDPD_SEARCH_ALL = 3,\n\tMINISSDPD_SUBMIT = 4,\n\tMINISSDPD_NOTIF = 5\n};\nstruct device * devlist = 0;\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\nstruct lan_addr_list lan_addrs;\nLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n#define NOTIF_NEW    1\n#define NOTIF_UPDATE 2\n#define NOTIF_REMOVE 3\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv);\nstatic int\nparselanaddr(struct lan_addr_s * lan_addr, const char * str)\n{\n\tconst char * p;\n\tint n;\n\tchar tmp[16];\n\tmemset(lan_addr, 0, sizeof(struct lan_addr_s));\n\tp = str;\n\twhile(*p && *p != '/' && !isspace(*p))\n\t\tp++;\n\tn = p - str;\n\tif(!isdigit(str[0]) && n < (int)sizeof(lan_addr->ifname)) {\n\t\tmemcpy(lan_addr->ifname, str, n);\n\t\tlan_addr->ifname[n] = '\\0';\n\t\tif(getifaddr(lan_addr->ifname, lan_addr->str, sizeof(lan_addr->str),\n\t\t             &lan_addr->addr, &lan_addr->mask) < 0)\n\t\t\tgoto parselan_error;\n\t} else {\n\t\tif(n>15)\n\t\t\tgoto parselan_error;\n\t\tmemcpy(lan_addr->str, str, n);\n\t\tlan_addr->str[n] = '\\0';\n\t\tif(!inet_aton(lan_addr->str, &lan_addr->addr))\n\t\t\tgoto parselan_error;\n\t}\n\tif(*p == '/') {\n\t\tconst char * q = ++p;\n\t\twhile(*p && isdigit(*p))\n\t\t\tp++;\n\t\tif(*p=='.') {\n\t\t\twhile(*p && (*p=='.' || isdigit(*p)))\n\t\t\t\tp++;\n\t\t\tn = p - q;\n\t\t\tif(n>15)\n\t\t\t\tgoto parselan_error;\n\t\t\tmemcpy(tmp, q, n);\n\t\t\ttmp[n] = '\\0';\n\t\t\tif(!inet_aton(tmp, &lan_addr->mask))\n\t\t\t\tgoto parselan_error;\n\t\t} else {\n\t\t\tint nbits = atoi(q);\n\t\t\tif(nbits > 32 || nbits < 0)\n\t\t\t\tgoto parselan_error;\n\t\t\tlan_addr->mask.s_addr = htonl(nbits ? (0xffffffffu << (32 - nbits)) : 0);\n\t\t}\n\t} else if(lan_addr->mask.s_addr == 0) {\n\t\tlan_addr->mask.s_addr = htonl(0xffffff00u);\n\t}\n#ifdef ENABLE_IPV6\n\tif(lan_addr->ifname[0] != '\\0') {\n\t\tlan_addr->index = if_nametoindex(lan_addr->ifname);\n\t\tif(lan_addr->index == 0)\n\t\t\tfprintf(stderr, \"Cannot get index for network interface %s\",\n\t\t\t        lan_addr->ifname);\n\t} else {\n\t\tfprintf(stderr,\n\t\t        \"Error: please specify LAN network interface by name instead of IPv4 address : %s\\n\",\n\t\t        str);\n\t\treturn -1;\n\t}\n#endif \n\treturn 0;\nparselan_error:\n\tfprintf(stderr, \"Error parsing address/mask (or interface name) : %s\\n\",\n\t        str);\n\treturn -1;\n}\nstatic int\nwrite_buffer(struct reqelem * req)\n{\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\tint n = write(req->socket,\n\t\t              req->output_buffer + req->output_buffer_offset,\n\t\t              req->output_buffer_len);\n\t\tif(n >= 0) {\n\t\t\treq->output_buffer_offset += n;\n\t\t\treq->output_buffer_len -= n;\n\t\t} else if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn n;\n\t} else {\n\t\treturn 0;\n\t}\n}\nstatic int\nadd_to_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tunsigned char * tmp;\n\tif(req->output_buffer_offset > 0) {\n\t\tmemmove(req->output_buffer, req->output_buffer + req->output_buffer_offset, req->output_buffer_len);\n\t\treq->output_buffer_offset = 0;\n\t}\n\ttmp = realloc(req->output_buffer, req->output_buffer_len + len);\n\tif(tmp == NULL) {\n\t\tsyslog(LOG_ERR, \"%s: failed to allocate %d bytes\",\n\t\t       __func__, req->output_buffer_len + len);\n\t\treturn -1;\n\t}\n\treq->output_buffer = tmp;\n\tmemcpy(req->output_buffer + req->output_buffer_len, data, len);\n\treq->output_buffer_len += len;\n\treturn len;\n}\nstatic int\nwrite_or_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tif(write_buffer(req) < 0)\n\t\treturn -1;\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\treturn add_to_buffer(req, data, len);\n\t} else {\n\t\tint n = write(req->socket, data, len);\n\t\tif(n == len)\n\t\t\treturn len;\n\t\tif(n < 0) {\n\t\t\tif(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\t\tn = add_to_buffer(req, data, len);\n\t\t\t\tif(n < 0) return n;\n\t\t\t} else {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else {\n\t\t\tn = add_to_buffer(req, data + n, len - n);\n\t\t\tif(n < 0) return n;\n\t\t}\n\t}\n\treturn len;\n}\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv)\n{\n\tstruct reqelem * req;\n\tunsigned int m;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\tif(!req->is_notify) continue;\n\t\trbuf[0] = '\\xff'; \n\t\trbuf[1] = (unsigned char)notif_type;\n\t\trbuf[2] = 0;\n\t\trp = rbuf + 3;\n\t\tif(dev) {\n\t\t\tm = dev->headers[HEADER_LOCATION].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_LOCATION].p, dev->headers[HEADER_LOCATION].l);\n\t\t\trp += dev->headers[HEADER_LOCATION].l;\n\t\t\tm = dev->headers[HEADER_NT].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_NT].p, dev->headers[HEADER_NT].l);\n\t\t\trp += dev->headers[HEADER_NT].l;\n\t\t\tm = dev->headers[HEADER_USN].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_USN].p, dev->headers[HEADER_USN].l);\n\t\t\trp += dev->headers[HEADER_USN].l;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(serv) {\n\t\t\tm = strlen(serv->location);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->location, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->st);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->st, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->usn);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\trp += m;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(rbuf[2] > 0) {\n\t\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, size_t st_len, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[1024];\n\tsocklen_t sockname_len;\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t\"ST: %.*s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" \n\t\t\"01-NLS: %u\\r\\n\" \n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" \n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" \n\t\t\"\\r\\n\",\n\t\t(int)st_len, st, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\t\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\t\n\tn = sendto_or_schedule(s, buf, l, 0, sockname, sockname_len);\n\tif(n < 0) {\n\t\tsyslog(LOG_ERR, \"%s: sendto(udp): %m\", __func__);\n\t}\n}\nstatic void\nprocessMSEARCH(int s, const char * st, size_t st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif \n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, (int)st_len, st);\n#else\t\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       (int)st_len, st);\n#endif\t\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, strlen(serv->st), serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, strlen(serv->st), serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsize_t l;\n\t\tint st_ver = 0;\n\t\tchar atoi_buffer[8];\n\t\tfor (l = st_len; l > 0; l--) {\n\t\t\tif (st[l-1] == ':') {\n\t\t\t\tmemset(atoi_buffer, 0, sizeof(atoi_buffer));\n\t\t\t\tmemcpy(atoi_buffer, st + l, MIN((sizeof(atoi_buffer) - 1), st_len - l));\n\t\t\t\tst_ver = atoi(atoi_buffer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (l == 0)\n\t\t\tl = st_len;\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, l)) {\n\t\t\t\tsyslog(LOG_DEBUG, \"Found matching service : %s %s\", serv->st, serv->location);\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        st, st_len, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr,\n                const char * searched_device)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t\n\tconst char * st = NULL;\n\tint st_len = 0;\n\tif(get_lan_for_peer(addr) == NULL) {\n\t\tchar addr_str[64];\n\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\tsyslog(LOG_WARNING, \"peer %s is not from a LAN\",\n\t\t       addr_str);\n\t\treturn 0;\n\t}\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t\n\t\t\tint m = lineend - valuestart;\t\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\tconst char * name = valuestart;\t\n\t\t\t\tconst char * val;\t\t\t\t\n\t\t\t\tint rem = m;\t\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((linestart < p + n) && (*linestart == '\\n' || *linestart == '\\r'))\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(nts==NTS_SSDP_ALIVE || nts==NTS_SSDP_UPDATE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\t\tif(searched_device &&\n\t\t\t\t   0 != memcmp(headers[HEADER_NT].p, searched_device, headers[HEADER_NT].l))\n\t\t\t\t\tbreak;\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p location=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p,\n\t\t\t\t       headers[HEADER_LOCATION].p);\n\t\t\t}\n\t\t} else if(nts==NTS_SSDP_BYEBYE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tchar addr_str[64];\n\t\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do (from %s)\",\n\t\t\t       methodlen, p, addr_str);\n\t\t}\n\t}\n\treturn r;\n}\nstatic ssize_t processRequestSub(struct reqelem * req, const unsigned char * buf, ssize_t n);\nstatic ssize_t processRequestSub(struct reqelem * req, const unsigned char * buf, ssize_t n)\n{\n\tunsigned int l, m;\n\tunsigned int baselen;\t\n\tconst unsigned char * p;\n\tenum request_type type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(l > (unsigned)(buf+n-p)) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\",\n\t\t       l, (unsigned)n);\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != MINISSDPD_SEARCH_ALL\n\t   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0, type=%d)\", type);\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase MINISSDPD_GET_VERSION:\n\t\trp = rbuf;\n\t\tCODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);\n\t\tmemcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);\n\t\trp += (sizeof(MINISSDPD_VERSION) - 1);\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tp += l;\n\t\tbreak;\n\tcase MINISSDPD_SEARCH_TYPE:\t\n\tcase MINISSDPD_SEARCH_USN:\t\n\tcase MINISSDPD_SEARCH_ALL:\t\n\t\trp = rbuf+1;\n\t\tbaselen = l;\t\n\t\twhile(baselen > 0) {\n\t\t\tif(p[baselen-1] == ':')\n\t\t\t\tbreak;\n\t\t\tif(!(p[baselen-1] >= '0' && p[baselen-1] <= '9'))\n\t\t\t\tbreak;\n\t\t\tbaselen--;\n\t\t}\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, baselen))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tp += l;\n\t\tbreak;\n\tcase MINISSDPD_SUBMIT:\t\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(newserv, 0, sizeof(struct service));\t\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(l > (unsigned)(buf+n-p)) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\tp += l;\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service already in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn (p - buf);\n\t\t\t}\n\t\t}\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tsendNotifications(NOTIF_NEW, NULL, newserv);\n\t\tnewserv = NULL;\n\t\tbreak;\n\tcase MINISSDPD_NOTIF:\t\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\treq->is_notify = 1;\n\t\tp += l;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn (p - buf);\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\treturn -1;\n}\nstatic volatile sig_atomic_t quitting = 0;\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" \n#define UPNP_MCAST_SL_ADDR \"FF05::C\" \nstatic void ssdpDiscover(int s, int ipv6, const char * search)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: %s\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR,\n\t\t             (search ? search : \"ssdp:all\"), mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\t\tn = sendto_or_schedule(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t                       ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: sendto: %m\", __func__);\n\t\t}\n\t}\n}\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t\n#else\t\n#define s_ssdp6 (-1)\n#endif\t\n\tint s_unix = -1;\t\n\tint s_ifacewatch = -1;\t\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tfd_set writefds;\n\tstruct timeval now;\n\tint max_fd;\n\tstruct lan_addr_s * lan_addr;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n#ifdef ENABLE_IPV6\n\tint ipv6 = 0;\n#endif \n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\t\n\tunsigned char ttl = 2;\t\n\tconst char * searched_device = NULL;\t\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\tLIST_INIT(&lan_addrs);\n\tfor(i=1; i<argc; i++)\n\t{\n \t\tif(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\t\n\t\telse {\n\t\t\tif((i + 1) >= argc) {\n\t\t\t\tfprintf(stderr, \"option %s needs an argument.\\n\", argv[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\t\tfprintf(stderr, \"malloc(%d) FAILED\\n\", (int)sizeof(struct lan_addr_s));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t\tfprintf(stderr, \"can't parse \\\"%s\\\" as a valid address or interface name\\n\", argv[i]);\n\t\t\t\t\tfree(lan_addr);\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"unknown commandline option %s.\\n\", argv[i]);\n\t\t}\n\t}\n\tif(lan_addrs.lh_first == NULL)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] \"\n#ifdef ENABLE_IPV6\n\t\t        \"[-6] \"\n#endif \n\t\t        \"[-s socket] [-p pidfile] [-t TTL] \"\n\t\t        \"[-f device] \"\n\t\t        \"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address with mask such as\\n\"\n\t\t        \"  192.168.1.42/255.255.255.0, or an interface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"  and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) \n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\tupnp_bootid = (unsigned int)time(NULL);\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(1, ttl);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\t\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#if 0\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else  \n\t\tpid = daemonize();\n#endif \n\t}\n\twritepidfile(pidfilename, pid);\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\twhile(!quitting) {\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp6);\n\t\t}\n#endif \n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t}\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\t\tif(errno != EINTR) {\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(try_sendto(&writefds) < 0) {\n\t\t\tsyslog(LOG_ERR, \"try_sendto: %m\");\n\t\t\tbreak;\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\t\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\t}\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n\t\t}\n\t}\n\tsyslog(LOG_DEBUG, \"quitting...\");\n\tfinalize_sendto();\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\t\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\twhile(lan_addrs.lh_first != NULL) {\n\t\tlan_addr = lan_addrs.lh_first;\n\t\tLIST_REMOVE(lan_addrs.lh_first, list);\n\t\tfree(lan_addr);\n\t}\n\twhile(devlist != NULL) {\n\t\tstruct device * next = devlist->next;\n\t\tfree(devlist);\n\t\tdevlist = next;\n\t}\n\twhile(servicelisthead.lh_first != NULL) {\n\t\tstruct service * serv = servicelisthead.lh_first;\n\t\tLIST_REMOVE(servicelisthead.lh_first, entries);\n\t\tfree(serv->st);\n\t\tfree(serv->usn);\n\t\tfree(serv->server);\n\t\tfree(serv->location);\n\t\tfree(serv);\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_3524.c",
        "project": "miniupnp/miniupnp",
        "url": "https://github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <gpac/internal/isomedia_dev.h>\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n#ifndef GPAC_DISABLE_ISOM\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nvoid abst_box_del(GF_Box *s)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->movie_identifier)\n\t\tgf_free(ptr->movie_identifier);\n\tif (ptr->drm_data)\n\t\tgf_free(ptr->drm_data);\n\tif (ptr->meta_data)\n\t\tgf_free(ptr->meta_data);\n\twhile (gf_list_count(ptr->server_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->server_entry_table, 0));\n\t\tgf_list_rem(ptr->server_entry_table, 0);\n\t}\n\tgf_list_del(ptr->server_entry_table);\n\twhile (gf_list_count(ptr->quality_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->quality_entry_table, 0));\n\t\tgf_list_rem(ptr->quality_entry_table, 0);\n\t}\n\tgf_list_del(ptr->quality_entry_table);\n\twhile (gf_list_count(ptr->segment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->segment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->segment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->segment_run_table_entries);\n\twhile (gf_list_count(ptr->fragment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->fragment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_table_entries);\n\tgf_free(ptr);\n}\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tgf_free(tmp_str);\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err abst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->bootstrapinfo_version);\n\tgf_bs_write_int(bs, ptr->profile, 2);\n\tgf_bs_write_int(bs, ptr->live, 1);\n\tgf_bs_write_int(bs, ptr->update, 1);\n\tgf_bs_write_int(bs, ptr->reserved, 4);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u64(bs, ptr->current_media_time);\n\tgf_bs_write_u64(bs, ptr->smpte_time_code_offset);\n\tif (ptr->movie_identifier)\n\t\tgf_bs_write_data(bs, ptr->movie_identifier, (u32)strlen(ptr->movie_identifier) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->server_entry_count);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->server_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\tif (ptr->drm_data)\n\t\tgf_bs_write_data(bs, ptr->drm_data, (u32)strlen(ptr->drm_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\tif (ptr->meta_data)\n\t\tgf_bs_write_data(bs, ptr->meta_data, (u32)strlen(ptr->meta_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->segment_run_table_count);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->segment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_u8(bs, ptr->fragment_run_table_count);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\nGF_Err abst_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\ts->size += 25\n\t           + (ptr->movie_identifier ? (strlen(ptr->movie_identifier) + 1) : 1)\n\t           + 1;\n\tfor (i=0; i<ptr->server_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->server_entry_table, i)) + 1;\n\ts->size += 1;\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_entry_table, i)) + 1;\n\ts->size += (ptr->drm_data ? (strlen(ptr->drm_data) + 1) : 1)\n\t           + (ptr->meta_data ? (strlen(ptr->meta_data) + 1) : 1)\n\t           + 1;\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->segment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\ts->size += 1;\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\treturn GF_OK;\n}\n#endif \nGF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err afra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->long_ids, 1);\n\tgf_bs_write_int(bs, ptr->long_offsets, 1);\n\tgf_bs_write_int(bs, ptr->global_entries, 1);\n\tgf_bs_write_int(bs, 0, 5);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(ptr->local_access_entries, i);\n\t\tgf_bs_write_u64(bs, ae->time);\n\t\tif (ptr->long_offsets)\n\t\t\tgf_bs_write_u64(bs, ae->offset);\n\t\telse\n\t\t\tgf_bs_write_u32(bs, (u32)ae->offset);\n\t}\n\tif (ptr->global_entries) {\n\t\tgf_bs_write_u32(bs, ptr->global_entry_count);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(ptr->global_access_entries, i);\n\t\t\tgf_bs_write_u64(bs, gae->time);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tgf_bs_write_u32(bs, gae->segment);\n\t\t\t\tgf_bs_write_u32(bs, gae->fragment);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->segment);\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->fragment);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tgf_bs_write_u64(bs, gae->afra_offset);\n\t\t\t\tgf_bs_write_u64(bs, gae->offset_from_afra);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->afra_offset);\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->offset_from_afra);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif \nGF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->segment_run_entry_count*8)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \nGF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size-8;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->fragment_run_entry_count*16)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_ISOM_INVALID_FILE;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#endif \n#endif \n#endif \n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_5715.c",
        "project": "gpac/gpac",
        "url": "https://github.com/gpac/gpac/commit/093283e727f396130651280609e687cd4778e0d1",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\tstruct device_attribute *attr, const char *buf, size_t count)\n\tsize_t cnt = count;\n\tif (cnt >= 3 && strncmp(\"lcd\", buf, 3) == 0) {\n\t} else if (cnt >= 10 && strncmp(\"bootloader\", buf, 10) == 0) {\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n#include <linux/input.h>\n#include \"hid-ids.h\"\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include \"hid-picolcd.h\"\nstatic const unsigned short def_keymap[PICOLCD_KEYS] = {\n\tKEY_RESERVED,\t\n\tKEY_BACK,\t\n\tKEY_HOMEPAGE,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_SCROLLUP,\t\n\tKEY_OK,\t\t\n\tKEY_SCROLLDOWN,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n\tKEY_RESERVED,\t\n};\nstruct picolcd_pending *picolcd_send_and_wait(struct hid_device *hdev,\n\t\tint report_id, const u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tstruct picolcd_pending *work;\n\tstruct hid_report *report = picolcd_out_report(report_id, hdev);\n\tunsigned long flags;\n\tint i, j, k;\n\tif (!report || !data)\n\t\treturn NULL;\n\tif (data->status & PICOLCD_FAILED)\n\t\treturn NULL;\n\twork = kzalloc(sizeof(*work), GFP_KERNEL);\n\tif (!work)\n\t\treturn NULL;\n\tinit_completion(&work->ready);\n\twork->out_report = report;\n\twork->in_report  = NULL;\n\twork->raw_size   = 0;\n\tmutex_lock(&data->mutex);\n\tspin_lock_irqsave(&data->lock, flags);\n\tfor (i = k = 0; i < report->maxfield; i++)\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\thid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);\n\t\t\tk++;\n\t\t}\n\tif (data->status & PICOLCD_FAILED) {\n\t\tkfree(work);\n\t\twork = NULL;\n\t} else {\n\t\tdata->pending = work;\n\t\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\twait_for_completion_interruptible_timeout(&work->ready, HZ*2);\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tdata->pending = NULL;\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tmutex_unlock(&data->mutex);\n\treturn work;\n}\nstatic int picolcd_raw_keypad(struct picolcd_data *data,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tint i, j;\n\tfor (i = 0; i < size; i++) {\n\t\tunsigned int key_code;\n\t\tif (raw_data[i] == 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < sizeof(data->pressed_keys); j++)\n\t\t\tif (data->pressed_keys[j] == raw_data[i])\n\t\t\t\tgoto key_already_down;\n\t\tfor (j = 0; j < sizeof(data->pressed_keys); j++)\n\t\t\tif (data->pressed_keys[j] == 0) {\n\t\t\t\tdata->pressed_keys[j] = raw_data[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tinput_event(data->input_keys, EV_MSC, MSC_SCAN, raw_data[i]);\n\t\tif (raw_data[i] < PICOLCD_KEYS)\n\t\t\tkey_code = data->keycode[raw_data[i]];\n\t\telse\n\t\t\tkey_code = KEY_UNKNOWN;\n\t\tif (key_code != KEY_UNKNOWN) {\n\t\t\tdbg_hid(PICOLCD_NAME \" got key press for %u:%d\",\n\t\t\t\t\traw_data[i], key_code);\n\t\t\tinput_report_key(data->input_keys, key_code, 1);\n\t\t}\n\t\tinput_sync(data->input_keys);\nkey_already_down:\n\t\tcontinue;\n\t}\n\tfor (j = 0; j < sizeof(data->pressed_keys); j++) {\n\t\tunsigned int key_code;\n\t\tif (data->pressed_keys[j] == 0)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < size; i++)\n\t\t\tif (data->pressed_keys[j] == raw_data[i])\n\t\t\t\tgoto key_still_down;\n\t\tinput_event(data->input_keys, EV_MSC, MSC_SCAN, data->pressed_keys[j]);\n\t\tif (data->pressed_keys[j] < PICOLCD_KEYS)\n\t\t\tkey_code = data->keycode[data->pressed_keys[j]];\n\t\telse\n\t\t\tkey_code = KEY_UNKNOWN;\n\t\tif (key_code != KEY_UNKNOWN) {\n\t\t\tdbg_hid(PICOLCD_NAME \" got key release for %u:%d\",\n\t\t\t\t\tdata->pressed_keys[j], key_code);\n\t\t\tinput_report_key(data->input_keys, key_code, 0);\n\t\t}\n\t\tinput_sync(data->input_keys);\n\t\tdata->pressed_keys[j] = 0;\nkey_still_down:\n\t\tcontinue;\n\t}\n\treturn 1;\n}\nstatic ssize_t picolcd_operation_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\tstruct hid_report *report = NULL;\n\tsize_t cnt = count;\n\tint timeout = data->opmode_delay;\n\tunsigned long flags;\n\tif (cnt >= 3 && strncmp(\"lcd\", buf, 3) == 0) {\n\t\tif (data->status & PICOLCD_BOOTLOADER)\n\t\t\treport = picolcd_out_report(REPORT_EXIT_FLASHER, data->hdev);\n\t\tbuf += 3;\n\t\tcnt -= 3;\n\t} else if (cnt >= 10 && strncmp(\"bootloader\", buf, 10) == 0) {\n\t\tif (!(data->status & PICOLCD_BOOTLOADER))\n\t\t\treport = picolcd_out_report(REPORT_EXIT_KEYBOARD, data->hdev);\n\t\tbuf += 10;\n\t\tcnt -= 10;\n\t}\n\tif (!report || report->maxfield != 1)\n\t\treturn -EINVAL;\n\twhile (cnt > 0 && (buf[cnt-1] == '\\n' || buf[cnt-1] == '\\r'))\n\t\tcnt--;\n\tif (cnt != 0)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&data->lock, flags);\n\thid_set_field(report->field[0], 0, timeout & 0xff);\n\thid_set_field(report->field[0], 1, (timeout >> 8) & 0xff);\n\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn count;\n}\nstatic DEVICE_ATTR(operation_mode, 0644, picolcd_operation_mode_show,\n\t\tpicolcd_operation_mode_store);\nstatic DEVICE_ATTR(operation_mode_delay, 0644, picolcd_operation_mode_delay_show,\n\t\tpicolcd_operation_mode_delay_store);\nstatic int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\tif (!data)\n\t\treturn 1;\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n#ifdef CONFIG_PM\nstatic int picolcd_suspend(struct hid_device *hdev, pm_message_t message)\n{\n\tif (PMSG_IS_AUTO(message))\n\t\treturn 0;\n\tpicolcd_suspend_backlight(hid_get_drvdata(hdev));\n\tdbg_hid(PICOLCD_NAME \" device ready for suspend\\n\");\n\treturn 0;\n}\nstatic int picolcd_resume(struct hid_device *hdev)\n{\n\tint ret;\n\tret = picolcd_resume_backlight(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring backlight failed: %d\\n\", ret);\n\treturn 0;\n}\nstatic int picolcd_reset_resume(struct hid_device *hdev)\n{\n\tint ret;\n\tret = picolcd_reset(hdev);\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" resetting our device failed: %d\\n\", ret);\n\tret = picolcd_fb_reset(hid_get_drvdata(hdev), 0);\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring framebuffer content failed: %d\\n\", ret);\n\tret = picolcd_resume_lcd(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring lcd failed: %d\\n\", ret);\n\tret = picolcd_resume_backlight(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring backlight failed: %d\\n\", ret);\n\tpicolcd_leds_set(hid_get_drvdata(hdev));\n\treturn 0;\n}\n#endif\nstatic int picolcd_init_keys(struct picolcd_data *data,\n\t\tstruct hid_report *report)\n{\n\tstruct hid_device *hdev = data->hdev;\n\tstruct input_dev *idev;\n\tint error, i;\n\tif (!report)\n\t\treturn -ENODEV;\n\tif (report->maxfield != 1 || report->field[0]->report_count != 2 ||\n\t\t\treport->field[0]->report_size != 8) {\n\t\thid_err(hdev, \"unsupported KEY_STATE report\\n\");\n\t\treturn -EINVAL;\n\t}\n\tidev = input_allocate_device();\n\tif (idev == NULL) {\n\t\thid_err(hdev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tinput_set_drvdata(idev, hdev);\n\tmemcpy(data->keycode, def_keymap, sizeof(def_keymap));\n\tidev->name = hdev->name;\n\tidev->phys = hdev->phys;\n\tidev->uniq = hdev->uniq;\n\tidev->id.bustype = hdev->bus;\n\tidev->id.vendor  = hdev->vendor;\n\tidev->id.product = hdev->product;\n\tidev->id.version = hdev->version;\n\tidev->dev.parent = &hdev->dev;\n\tidev->keycode     = &data->keycode;\n\tidev->keycodemax  = PICOLCD_KEYS;\n\tidev->keycodesize = sizeof(data->keycode[0]);\n\tinput_set_capability(idev, EV_MSC, MSC_SCAN);\n\tset_bit(EV_REP, idev->evbit);\n\tfor (i = 0; i < PICOLCD_KEYS; i++)\n\t\tinput_set_capability(idev, EV_KEY, data->keycode[i]);\n\terror = input_register_device(idev);\n\tif (error) {\n\t\thid_err(hdev, \"error registering the input device\\n\");\n\t\tinput_free_device(idev);\n\t\treturn error;\n\t}\n\tdata->input_keys = idev;\n\treturn 0;\n}\nstatic int picolcd_probe_lcd(struct hid_device *hdev, struct picolcd_data *data)\n{\n\tint error;\n\terror = picolcd_init_keys(data, picolcd_in_report(REPORT_KEY_STATE, hdev));\n\tif (error)\n\t\tgoto err;\n\terror = picolcd_init_cir(data, picolcd_in_report(REPORT_IR_DATA, hdev));\n\tif (error)\n\t\tgoto err;\n\terror = picolcd_init_framebuffer(data);\n\tif (error)\n\t\tgoto err;\n\terror = picolcd_init_lcd(data, picolcd_out_report(REPORT_CONTRAST, hdev));\n\tif (error)\n\t\tgoto err;\n\terror = picolcd_init_backlight(data, picolcd_out_report(REPORT_BRIGHTNESS, hdev));\n\tif (error)\n\t\tgoto err;\n\terror = picolcd_init_leds(data, picolcd_out_report(REPORT_LED_STATE, hdev));\n\tif (error)\n\t\tgoto err;\n\tpicolcd_init_devfs(data, picolcd_out_report(REPORT_EE_READ, hdev),\n\t\t\tpicolcd_out_report(REPORT_EE_WRITE, hdev),\n\t\t\tpicolcd_out_report(REPORT_READ_MEMORY, hdev),\n\t\t\tpicolcd_out_report(REPORT_WRITE_MEMORY, hdev),\n\t\t\tpicolcd_out_report(REPORT_RESET, hdev));\n\treturn 0;\nerr:\n\tpicolcd_exit_leds(data);\n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\treturn error;\n}\nstatic int picolcd_probe(struct hid_device *hdev,\n\t\t     const struct hid_device_id *id)\n{\n\tstruct picolcd_data *data;\n\tint error = -ENOMEM;\n\tdbg_hid(PICOLCD_NAME \" hardware probe...\\n\");\n\tdata = kzalloc(sizeof(struct picolcd_data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\thid_err(hdev, \"can't allocate space for Minibox PicoLCD device data\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_no_cleanup;\n\t}\n\tspin_lock_init(&data->lock);\n\tmutex_init(&data->mutex);\n\tdata->hdev = hdev;\n\tdata->opmode_delay = 5000;\n\tif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\n\t\tdata->status |= PICOLCD_BOOTLOADER;\n\thid_set_drvdata(hdev, data);\n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"device report parse failed\\n\");\n\t\tgoto err_cleanup_data;\n\t}\n\terror = hid_hw_start(hdev, 0);\n\tif (error) {\n\t\thid_err(hdev, \"hardware start failed\\n\");\n\t\tgoto err_cleanup_data;\n\t}\n\terror = hid_hw_open(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"failed to open input interrupt pipe for key and IR events\\n\");\n\t\tgoto err_cleanup_hid_hw;\n\t}\n\terror = device_create_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\tif (error) {\n\t\thid_err(hdev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_cleanup_hid_ll;\n\t}\n\terror = device_create_file(&hdev->dev, &dev_attr_operation_mode);\n\tif (error) {\n\t\thid_err(hdev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_cleanup_sysfs1;\n\t}\n\tif (data->status & PICOLCD_BOOTLOADER)\n\t\terror = picolcd_probe_bootloader(hdev, data);\n\telse\n\t\terror = picolcd_probe_lcd(hdev, data);\n\tif (error)\n\t\tgoto err_cleanup_sysfs2;\n\tdbg_hid(PICOLCD_NAME \" activated and initialized\\n\");\n\treturn 0;\nerr_cleanup_sysfs2:\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\nerr_cleanup_sysfs1:\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\nerr_cleanup_hid_ll:\n\thid_hw_close(hdev);\nerr_cleanup_hid_hw:\n\thid_hw_stop(hdev);\nerr_cleanup_data:\n\tkfree(data);\nerr_no_cleanup:\n\thid_set_drvdata(hdev, NULL);\n\treturn error;\n}\nstatic void picolcd_remove(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tdbg_hid(PICOLCD_NAME \" hardware remove...\\n\");\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status |= PICOLCD_FAILED;\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tpicolcd_exit_devfs(data);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\tspin_lock_irqsave(&data->lock, flags);\n\tif (data->pending)\n\t\tcomplete(&data->pending->ready);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tpicolcd_exit_leds(data);\n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\thid_set_drvdata(hdev, NULL);\n\tmutex_destroy(&data->mutex);\n\tkfree(data);\n}\nstatic const struct hid_device_id picolcd_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD_BOOTLOADER) },\n\t{ }\n};\nstatic struct hid_driver picolcd_driver = {\n\t.name =          \"hid-picolcd\",\n\t.id_table =      picolcd_devices,\n\t.probe =         picolcd_probe,\n\t.remove =        picolcd_remove,\n\t.raw_event =     picolcd_raw_event,\n#ifdef CONFIG_PM\n\t.suspend =       picolcd_suspend,\n\t.resume =        picolcd_resume,\n\t.reset_resume =  picolcd_reset_resume,\n#endif\n};\nMODULE_DESCRIPTION(\"Minibox graphics PicoLCD Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_703.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int setcos_construct_fci_44(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n\tu8 *p = out;\n\tu8 buf[64];\n\t*p++ = 0x6F;\n\tp++;\n\tif (SETCOS_IS_EID_APPLET(card) &&\n\t    (file->type == SC_FILE_TYPE_INTERNAL_EF || \n\t     (file->type == SC_FILE_TYPE_WORKING_EF && file->ef_structure == 0x22)))\n\t     \tbuf[0] = buf[1] = 0x00;\n\telse {\n\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\tbuf[1] = file->size & 0xFF;\n\t}\n\tsc_asn1_put_tag(0x81, buf, 2, p, *outlen - (p - out), &p);\n\tif (file->type_attr_len) {\n\t\tmemcpy(buf, file->type_attr, file->type_attr_len);\n\t} else {\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#define _FINEID_BROKEN_SELECT_FLAG 1\nstatic const struct sc_atr_table setcos_atrs[] = {\n\t{ \"3B:1F:11:00:67:80:42:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_GENERIC, 0, NULL },\n\t{ \"3B:9F:94:40:1E:00:67:16:43:46:49:53:45:10:52:66:FF:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_PKI, 0, NULL },\n\t{ \"3b:9f:94:40:1e:00:67:00:43:46:49:53:45:10:52:66:ff:81:90:00\", \"ff:ff:ff:ff:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID, SC_CARD_FLAG_RNG, NULL },\n\t{ \"3b:6b:00:ff:80:62:00:a2:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:00:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:64:00:ff:80:62:00:a2\", \"ff:ff:00:ff:ff:ff:00:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:7b:00:00:00:80:62:00:51:56:46:69:6e:45:49:44\", \"ff:ff:00:ff:ff:ff:ff:f0:ff:ff:ff:ff:ff:ff:ff:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:64:00:00:80:62:00:51\", \"ff:ff:ff:ff:ff:ff:f0:ff\", NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:6e:00:00:00:62:00:00:57:41:56:41:4e:54:10:81:90:00\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:7b:94:00:00:80:62:11:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, 0, NULL },\n\t{ \"3b:7b:94:00:00:80:62:12:51:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2_2048, 0, NULL },\n\t{ \"3b:7b:18:00:00:80:62:01:54:56:46:69:6e:45:49:44\", NULL, NULL, SC_CARD_TYPE_SETCOS_FINEID_V2, _FINEID_BROKEN_SELECT_FLAG, NULL },\n\t{ \"3b:9f:94:80:1f:c3:00:68:10:44:05:01:46:49:53:45:31:c8:07:90:00:18\", NULL, NULL, SC_CARD_TYPE_SETCOS_NIDEL, 0, NULL },\n\t{ \"3b:9f:94:80:1f:c3:00:68:11:44:05:01:46:49:53:45:31:c8:00:00:00:00\", \"ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:00:00:00:00\", NULL, SC_CARD_TYPE_SETCOS_44, 0, NULL },\n\t{ NULL, NULL, NULL, 0, 0, NULL }\n};\n#define SETCOS_IS_EID_APPLET(card) ((card)->type == SC_CARD_TYPE_SETCOS_EID_V2_0 || (card)->type == SC_CARD_TYPE_SETCOS_EID_V2_1)\n#define SETEC_LCSI_CREATE      0x01\n#define SETEC_LCSI_INIT        0x03\n#define SETEC_LCSI_ACTIVATED   0x07\n#define SETEC_LCSI_DEACTIVATE  0x06\n#define SETEC_LCSI_TEMINATE    0x0F \nstatic struct sc_card_operations setcos_ops;\nstatic struct sc_card_driver setcos_drv = {\n\t\"Setec cards\",\n\t\"setcos\",\n\t&setcos_ops,\n\tNULL, 0, NULL\n};\nstatic int setcos_match_card(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tu8 buf[6];\n\tint i;\n\ti = _sc_match_atr(card, setcos_atrs, &card->type);\n\tif (i < 0) {\n\t\tif (match_hist_bytes(card, \"FinEID\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_FINEID_V2_2048;\n\t\t\treturn 1;\n\t\t}\n\t\tif (match_hist_bytes(card, \"FISE\", 0)) {\n\t\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t\t\treturn 1;\n\t\t}\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xCA, 0xDF, 0x30);\n\t\tapdu.cla = 0x00;\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = 5;\n\t\tapdu.le = 5;\n\t\ti = sc_transmit_apdu(card, &apdu);\n\t\tif (i == 0 && apdu.sw1 == 0x90 && apdu.sw2 == 0x00 && apdu.resplen == 5) {\n\t\t\tif (memcmp(buf, \"v2.0\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_0;\n\t\t\telse if (memcmp(buf, \"v2.1\", 4) == 0)\n\t\t\t\tcard->type = SC_CARD_TYPE_SETCOS_EID_V2_1;\n\t\t\telse {\n\t\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t\t\tsc_log(card->ctx,  \"SetCOS EID applet %s is not supported\", (char *) buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tcard->flags = setcos_atrs[i].flags;\n\treturn 1;\n}\nstatic int setcos_init(sc_card_t *card)\n{\n\tcard->name = \"SetCOS\";\n\tif (card->type < 0) {\n\t\tcard->type = SC_CARD_TYPE_SETCOS_GENERIC;\n\t}\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcard->cla = 0x00;\n\t\tselect_pkcs15_app(card);\n\t\tif (card->flags & SC_CARD_FLAG_RNG)\n\t\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\tcard->cla = 0x00;\n\t\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\t\tbreak;\n\tdefault:\n\t\tcard->cla = 0x80;\t\n\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\tbreak;\n\t}\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_SETCOS_PKI:\n\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\t{\n\t\t\tunsigned long flags;\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\tcase SC_CARD_TYPE_SETCOS_44:\n\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t{\n\t\t\tunsigned long flags;\n\t\t\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_RSA_PAD_PKCS1;\n\t\t\tflags |= SC_ALGORITHM_RSA_HASH_NONE | SC_ALGORITHM_RSA_HASH_SHA1;\n\t\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\t\t_sc_card_add_rsa_alg(card, 512, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 768, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t\t\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\nstatic const struct sc_card_operations *iso_ops = NULL;\nstatic int setcos_construct_fci_44(sc_card_t *card, const sc_file_t *file, u8 *out, size_t *outlen)\n{\n\tu8 *p = out;\n\tu8 buf[64];\n\tconst u8 *pin_key_info;\n\tint len;\n\t*p++ = 0x6F;\n\tp++;\n\tif (SETCOS_IS_EID_APPLET(card) &&\n\t    (file->type == SC_FILE_TYPE_INTERNAL_EF || \n\t     (file->type == SC_FILE_TYPE_WORKING_EF && file->ef_structure == 0x22)))\n\t     \tbuf[0] = buf[1] = 0x00;\n\telse {\n\t\tbuf[0] = (file->size >> 8) & 0xFF;\n\t\tbuf[1] = file->size & 0xFF;\n\t}\n\tsc_asn1_put_tag(0x81, buf, 2, p, *outlen - (p - out), &p);\n\tif (file->type_attr_len) {\n\t\tmemcpy(buf, file->type_attr, file->type_attr_len);\n\t\tsc_asn1_put_tag(0x82, buf, file->type_attr_len, p, *outlen - (p - out), &p);\n\t} else {\n\t\tu8\tbLen = 1;\n\t\tbuf[0] = file->shareable ? 0x40 : 0;\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\t\t\t\t\n\t\t\tbuf[0] = 0x11;\t\t\t\t\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\t\t\tif (file->ef_structure == 0x22) {\t\t\n\t\t\t\tbuf[0] = 0x0A;\t\t\t\t\n\t\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\t\tbLen = 1;\n\t\t\t\telse {\n\t\t\t\t\tbLen = 5;\n\t\t\t\t\tbuf[1] = 0x41;\t\t\t\t\n\t\t\t\t\tbuf[2] = file->record_length >> 8;\t\n\t\t\t\t\tbuf[3] = file->record_length & 0xFF;\n\t\t\t\t\tbuf[4] = file->size / file->record_length; \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf[0] |= file->ef_structure & 7;\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\t\n\t\t\tbuf[0] = 0x38;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tsc_asn1_put_tag(0x82, buf, bLen, p, *outlen - (p - out), &p);\n\t}\n\tbuf[0] = (file->id >> 8) & 0xFF;\n\tbuf[1] = file->id & 0xFF;\n\tsc_asn1_put_tag(0x83, buf, 2, p, *outlen - (p - out), &p);\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (file->name[0] != 0)\n\t\t\tsc_asn1_put_tag(0x84, (u8 *) file->name, file->namelen, p, *outlen - (p - out), &p);\n\t\telse { \n\t\t\tbuf[0] = (file->id >> 8) & 0xFF;\n\t\t\tbuf[1] = file->id & 0xFF;\n\t\t\tsc_asn1_put_tag(0x84, buf, 2, p, *outlen - (p - out), &p);\n\t\t}\n\t}\n\tmemcpy(buf, file->sec_attr, file->sec_attr_len);\n\tsc_asn1_put_tag(0x86, buf, file->sec_attr_len, p, *outlen - (p - out), &p);\n\tif (file->prop_attr_len) {\n\t\tmemcpy(buf, file->prop_attr, file->prop_attr_len);\n\t\tsc_asn1_put_tag(0x8A, buf, file->prop_attr_len, p, *outlen - (p - out), &p);\n\t}\n\tif (file->type == SC_FILE_TYPE_DF) {\n\t\tif (card->type == SC_CARD_TYPE_SETCOS_EID_V2_1) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\";\n\t\t\tlen = 6;\n\t\t}\n\t\telse if (card->type == SC_CARD_TYPE_SETCOS_EID_V2_0) {\n\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\"; \n\t\t\tlen = 4;\n\t\t}\n\t\telse {\n\t\t\tif(file->path.len == 2)\n\t\t\t\tpin_key_info = (const u8*)\"\\xC1\\x04\\x81\\x82\\x83\\x84\\xC2\\x00\";\t\n\t\t\telse\n\t\t\t\tpin_key_info = (const u8 *)\"\\xC1\\x04\\x01\\x02\\x03\\x04\\xC2\\x00\";\t\n\t\t\tlen = 8;\n\t\t}\n\t\tsc_asn1_put_tag(0xA5, pin_key_info, len, p, *outlen - (p - out), &p);\n\t}\n\tout[1] = p - out - 2;\n\t*outlen = p - out;\n\treturn 0;\n}\nstatic int setcos_create_file_44(sc_card_t *card, sc_file_t *file)\n{\n\tconst u8 bFileStatus = file->status == SC_FILE_STATUS_CREATION ?\n\t\tSETEC_LCSI_CREATE : SETEC_LCSI_ACTIVATED;\n\tu8 bCommands_always = 0;\n\tint pins[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n\tu8 bCommands_pin[sizeof(pins)/sizeof(pins[0])]; \n\tu8 bCommands_key = 0;\n\tu8 bNumber = 0;\n\tu8 bKeyNumber = 0;\n\tunsigned int bMethod = 0;\n\tconst int df_idx[8] = {  \n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {  \n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = {  \n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tsc_file_set_prop_attr(file, &bFileStatus, 1);\n\tif (file->sec_attr_len == 0) {\n\t\tconst int* p_idx;\n\t\tint\t       i;\n\t\tint\t       len = 0;\n\t\tu8         bBuf[64];\n\t\tswitch (file->type){\n\t\tcase SC_FILE_TYPE_DF:           \n\t\t\tp_idx = df_idx;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:  \n\t\t\tp_idx = efi_idx;\n\t\t\tbreak;\n\t\tdefault:                        \n\t\t\tp_idx = ef_idx;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(bCommands_pin, 0, sizeof(bCommands_pin));\n\t\tfor (i = 7; i >= 0; i--) {  \n\t\t\tbCommands_always <<= 1;\n\t\t\tbCommands_key <<= 1;\n\t\t\tif (p_idx[i] == -1)  \n\t\t\t\tcontinue;\n\t\t\tbMethod = acl_to_byte_44(file->acl[ p_idx[i] ], &bNumber);\n\t\t\tswitch(bMethod){\n\t\t\tcase SC_AC_NONE:\t\t\t\n\t\t\t\tbCommands_always |= 1;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_CHV:\t\t\t\t\n\t\t\t\tif ((bNumber & 0x7F) == 0 || (bNumber & 0x7F) > 7) {\n\t\t\t\t\tsc_log(card->ctx,  \"SetCOS 4.4 PIN refs can only be 1..7\\n\");\n\t\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t\t}\n\t\t\t\tbCommands_pin[setcos_pin_index_44(pins, sizeof(pins), (int) bNumber)] |= 1 << i;\n\t\t\t\tbreak;\n\t\t\tcase SC_AC_TERM:\t\t\t\n\t\t\t\tbKeyNumber = bNumber;\t\n\t\t\t\tbCommands_key |= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (bCommands_always) {\n\t\t\tbBuf[len++] = 1;\n\t\t\tbBuf[len++] = bCommands_always;\n\t\t}\n\t\tfor (i = 0; i < (int)sizeof(bCommands_pin) && pins[i] != -1; i++) {\n\t\t\tbBuf[len++] = 2;\n\t\t\tbBuf[len++] = bCommands_pin[i];\n\t\t\tif (SETCOS_IS_EID_APPLET(card))\n\t\t\t\tbBuf[len++] = pins[i];  \n\t\t\telse\n\t\t\t\tbBuf[len++] = pins[i] & 0x07;  \n\t\t}\n\t\tif (bCommands_key) {\n\t\t\tbBuf[len++] = 2 | 0x20;\t\t\t\n\t\t\tbBuf[len++] = bCommands_key;\n\t\t\tbBuf[len++] = bKeyNumber;\n\t\t}\n\t\tif ( (file->type == SC_FILE_TYPE_INTERNAL_EF) &&\n\t\t     (acl_to_byte_44(file->acl[SC_AC_OP_CRYPTO], &bNumber) == SC_AC_CHV) ) {\n\t\t\tbBuf[len++] = 0x83;\n\t\t\tbBuf[len++] = 0x01;\n\t\t\tbBuf[len++] = 0x2A;  \n\t\t\tbBuf[len++] = bNumber & 0x07;  \n\t\t}\n\t\tsc_file_set_sec_attr(file, bBuf, len);\n\t}\n\treturn iso_ops->create_file(card, file);\n}\nstatic int setcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_create_file_44(card, file);\n\tif (file->prop_attr_len == 0)\n\t\tsc_file_set_prop_attr(file, (const u8 *) \"\\x03\\x00\\x00\", 3);\n\tif (file->sec_attr_len == 0) {\n\t\tint idx[6], i;\n\t\tu8 buf[6];\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tconst int df_idx[6] = {\n\t\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = df_idx[i];\n\t\t} else {\n\t\t\tconst int ef_idx[6] = {\n\t\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = ef_idx[i];\n\t\t}\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\t\t\tentry = sc_file_get_acl_entry(file, idx[i]);\n\t\t\tbuf[i] = acl_to_byte(entry);\n\t\t}\n\t\tsc_file_set_sec_attr(file, buf, 6);\n\t}\n\treturn iso_ops->create_file(card, file);\n}\nstatic int setcos_set_security_env2(sc_card_t *card,\n\t\t\t\t    const sc_security_env_t *env, int se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r, locked = 0;\n\tassert(card != NULL && env != NULL);\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 ||\n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC) {\n\t\t\tsc_log(card->ctx,  \"symmetric keyref not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tif (se_num > 0) {\n\t\t\tsc_log(card->ctx,  \"restore security environment not supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation) {\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = ((card->type == SC_CARD_TYPE_SETCOS_FINEID_V2) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048) ||\n\t\t           (card->type == SC_CARD_TYPE_SETCOS_44) ||\n\t\t\t   (card->type == SC_CARD_TYPE_SETCOS_NIDEL) || \n\t\t\t   SETCOS_IS_EID_APPLET(card)) ? 0x41 : 0x81;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT) {\n\t\t*p++ = 0x80;\t\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT) {\n\t\t*p++ = 0x81;\n\t\t*p++ = env->file_ref.len;\n\t\tmemcpy(p, env->file_ref.value, env->file_ref.len);\n\t\tp += env->file_ref.len;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT &&\n\t    !(card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t      card->type == SC_CARD_TYPE_SETCOS_FINEID_V2_2048)) {\n\t\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t\t\t*p++ = 0x83;\n\t\telse\n\t\t\t*p++ = 0x84;\n\t\t*p++ = env->key_ref_len;\n\t\tmemcpy(p, env->key_ref, env->key_ref_len);\n\t\tp += env->key_ref_len;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (se_num > 0) {\n\t\tr = sc_lock(card);\n\t\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\t\tlocked = 1;\n\t}\n\tif (apdu.datalen != 0) {\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (se_num <= 0)\n\t\treturn 0;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0xF2, se_num);\n\tr = sc_transmit_apdu(card, &apdu);\n\tsc_unlock(card);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\nerr:\n\tif (locked)\n\t\tsc_unlock(card);\n\treturn r;\n}\nstatic int setcos_set_security_env(sc_card_t *card,\n\t\t\t\t   const sc_security_env_t *env, int se_num)\n{\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT) {\n\t\tsc_security_env_t tmp;\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\t\tif (tmp.algorithm != SC_ALGORITHM_RSA) {\n\t\t\tsc_log(card->ctx,  \"Only RSA algorithm supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tswitch (card->type) {\n\t\tcase SC_CARD_TYPE_SETCOS_PKI:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcase SC_CARD_TYPE_SETCOS_44:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx,  \"Card does not support RSA.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\ttmp.algorithm_ref = 0x00;\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\ttmp.algorithm_ref = 0x02;\n\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\ttmp.algorithm_ref |= 0x10;\n\t\treturn setcos_set_security_env2(card, &tmp, se_num);\n\t}\n\treturn setcos_set_security_env2(card, env, se_num);\n}\nstatic void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\tconst int df_idx[8] = {\t \n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { \n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\twhile (len > 1) {\t\t\t\t\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\t\tiMethod = SC_AC_NONE;\t\t\n\t\tif (buf[iOffset] & 0X80) { \n\t\t\tsize_t\tiParmLen = 1;\t\t\t\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t\n\t\t\t}\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  \n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  \n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { \n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            \n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   \n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         \n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t\n\t\t\t\tiPinCount--;\t\t\t\t\n\t\t\t}\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\tiOffset += iACLen +1;\t\t\n\t\tlen     -= iACLen +1;\n\t}\n}\nstatic int setcos_generate_store_key(sc_card_t *card,\n\tstruct sc_cardctl_setcos_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr, len;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tlen = 0;\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t\tsbuf[len++] = 0x92;\t\n\telse\n\t\tsbuf[len++] = 0x9A;\t\n\tsbuf[len++] = 0x00;\t\n\tsbuf[len++] = data->mod_len / 256;\t\n\tsbuf[len++] = data->mod_len % 256;\n\tsbuf[len++] = data->pubexp_len / 256;   \n\tsbuf[len++] = data->pubexp_len % 256;\n\tmemcpy(sbuf + len, data->pubexp, (data->pubexp_len + 7) / 8);\n\tlen += (data->pubexp_len + 7) / 8;\n\tif (data->op_type == OP_TYPE_STORE) {\n\t\tsbuf[len++] = data->primep_len / 256;\n\t\tsbuf[len++] = data->primep_len % 256;\n\t\tmemcpy(sbuf + len, data->primep, (data->primep_len + 7) / 8);\n\t\tlen += (data->primep_len + 7) / 8;\n\t\tsbuf[len++] = data->primeq_len / 256;\n\t\tsbuf[len++] = data->primeq_len % 256;\n\t\tmemcpy(sbuf + len, data->primeq, (data->primeq_len + 7) / 8);\n\t\tlen += (data->primeq_len + 7) / 8;\t\t\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\tapdu.cla = 0x00;\n\tapdu.data = sbuf;\n\tapdu.datalen = len;\n\tapdu.lc\t= len;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"STORE/GENERATE_KEY returned error\");\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_4247.c",
        "project": "opensc/opensc",
        "url": "https://github.com/OpenSC/OpenSC/commit/c3f23b836e5a1766c36617fe1da30d22f7b63de2",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n    if( key == NULL )\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n                uint8_t               decryptedKey[16] = { 0 };\n                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"atca_basic.h\"\n#include \"cryptoauthlib.h\"\n#include \"atca_devtypes.h\"\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"atecc608a-tnglora-se-hal.h\"\n#define NUM_OF_KEYS 15\n#define DEV_EUI_ASCII_SIZE_BYTE 16U\ntypedef struct sKey\n{\n    KeyIdentifier_t KeyID;\n    uint16_t KeySlotNumber;\n    uint8_t KeyBlockIndex;\n} Key_t;\ntypedef struct sSecureElementNvCtx\n{\n    uint8_t DevEui[SE_EUI_SIZE];\n    uint8_t JoinEui[SE_EUI_SIZE];\n    uint8_t Pin[SE_PIN_SIZE];\n    atca_aes_cmac_ctx_t AtcaAesCmacCtx;\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    .DevEui = { 0 },\n    .JoinEui = { 0 },\n    .Pin = SECURE_ELEMENT_PIN,\n    .KeyList = ATECC608A_SE_KEY_LIST\n};\nstatic SecureElementNvmEvent SeNvmCtxChanged;\nstatic ATCAIfaceCfg atecc608_i2c_config;\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI );\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI )\n{\n    for( size_t pos = 0; pos < DEV_EUI_ASCII_SIZE_BYTE; pos += 2 )\n    {\n        uint8_t temp = 0;\n        if( ( devEUI_ascii[pos] >= '0' ) && ( devEUI_ascii[pos] <= '9' ) )\n        {\n            temp = ( devEUI_ascii[pos] - '0' ) << 4;\n        }\n        else if( ( devEUI_ascii[pos] >= 'A' ) && ( devEUI_ascii[pos] <= 'F' ) )\n        {\n            temp = ( ( devEUI_ascii[pos] - 'A' ) + 10 ) << 4;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        if( ( devEUI_ascii[pos + 1] >= '0' ) && ( devEUI_ascii[pos + 1] <= '9' ) )\n        {\n            temp |= devEUI_ascii[pos + 1] - '0';\n        }\n        else if( ( devEUI_ascii[pos + 1] >= 'A' ) && ( devEUI_ascii[pos + 1] <= 'F' ) )\n        {\n            temp |= ( devEUI_ascii[pos + 1] - 'A' ) + 10;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        devEUI[pos / 2] = temp;\n    }\n    return ATCA_SUCCESS;\n}\nSecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    uint8_t Cmac[16] = { 0 };\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n    ATCA_STATUS status =\n        atcab_aes_cmac_init( &SeNvmCtx.AtcaAesCmacCtx, keyItem->KeySlotNumber, keyItem->KeyBlockIndex );\n    if( ATCA_SUCCESS == status )\n    {\n        if( micBxBuffer != NULL )\n        {\n            atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, micBxBuffer, 16 );\n        }\n        atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, buffer, size );\n        atcab_aes_cmac_finish( &SeNvmCtx.AtcaAesCmacCtx, Cmac, 16 );\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )\n#error \"ATECC608A is always pre-provisioned. Please set SECURE_ELEMENT_PRE_PROVISIONED to ON\"\n#endif\n    atecc608_i2c_config.iface_type            = ATCA_I2C_IFACE;\n    atecc608_i2c_config.atcai2c.baud          = ATCA_HAL_ATECC608A_I2C_FREQUENCY;\n    atecc608_i2c_config.atcai2c.bus           = ATCA_HAL_ATECC608A_I2C_BUS_PINS;\n    atecc608_i2c_config.atcai2c.slave_address = ATCA_HAL_ATECC608A_I2C_ADDRESS;\n    atecc608_i2c_config.devtype               = ATECC608A;\n    atecc608_i2c_config.rx_retries            = ATCA_HAL_ATECC608A_I2C_RX_RETRIES;\n    atecc608_i2c_config.wake_delay            = ATCA_HAL_ATECC608A_I2C_WAKEUP_DELAY;\n    if( atcab_init( &atecc608_i2c_config ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n    if( atcab_read_devEUI( SeNvmCtx.DevEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n    if( atcab_read_joinEUI( SeNvmCtx.JoinEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n    return SECURE_ELEMENT_SUCCESS;\n}\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n    retval = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n    return retval;\n}\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        uint8_t block = 0;\n        while( size != 0 )\n        {\n            atcab_aes_encrypt( pItem->KeySlotNumber, pItem->KeyBlockIndex, &buffer[block], &encBuffer[block] );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Source key slot is the LSB and target key slot is the MSB\n    uint16_t    source_target_ids = 0;\n    Key_t*      source_key;\n    Key_t*      target_key;\n    ATCA_STATUS status = ATCA_SUCCESS;\n    // In case of MC_KE_KEY, only McRootKey can be used as root key\n    if( targetKeyID == MC_KE_KEY )\n    {\n        if( rootKeyID != MC_ROOT_KEY )\n        {\n            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n        }\n    }\n    if( ( rootKeyID == APP_KEY ) || ( rootKeyID == MC_ROOT_KEY ) || ( rootKeyID == MC_KE_KEY ) )\n    {\n        // Allow the stack to move forward as these rootkeys dont exist inside SE.\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    if( GetKeyByID( rootKeyID, &source_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n    if( GetKeyByID( targetKeyID, &target_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n    source_target_ids = target_key->KeySlotNumber << 8;\n    source_target_ids += source_key->KeySlotNumber;\n    uint32_t detail = source_key->KeyBlockIndex;\n    status = atcab_kdf( KDF_MODE_ALG_AES | KDF_MODE_SOURCE_SLOT | KDF_MODE_TARGET_SLOT, source_target_ids, detail,\n                        input, NULL, NULL );\n    if( status == ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n    uint32_t mic = 0;\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n    return SECURE_ELEMENT_SUCCESS;\n}\nFile number 2:\n#include <stdlib.h>\n#include <stdint.h>\n#include \"lr1110.h\"\n#include \"lr1110_system.h\"\n#include \"lr1110_crypto_engine.h\"\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"lr1110-se-hal.h\"\n#define NUM_OF_KEYS 23\n#define MIC_BLOCK_BX_SIZE 16\n#define CRYPTO_MAXMESSAGE_SIZE 256\n#define CRYPTO_BUFFER_SIZE CRYPTO_MAXMESSAGE_SIZE + MIC_BLOCK_BX_SIZE\ntypedef struct sSecureElementNvCtx\n{\n    uint8_t DevEui[SE_EUI_SIZE];\n    uint8_t JoinEui[SE_EUI_SIZE];\n    uint8_t Pin[SE_PIN_SIZE];\n} SecureElementNvCtx_t;\nstatic SecureElementNvCtx_t SeContext = {\n    .DevEui = LORAWAN_DEVICE_EUI,\n    .JoinEui = LORAWAN_JOIN_EUI,\n    .Pin = SECURE_ELEMENT_PIN,\n};\nstatic SecureElementNvmEvent SeNvmCtxChanged;\nextern lr1110_t LR1110;\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id );\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n    if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n    {  // Decrypt the key if its a Mckey\n        lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                            convert_key_id_from_se_to_lr1110( MC_KE_KEY ),\n                                            convert_key_id_from_se_to_lr1110( keyID ), key );\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n    else\n    {\n        lr1110_crypto_set_key( &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( keyID ),\n                               key );\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n}\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n    // Try first to process LoRaWAN 1.0.x JoinAccept\n    uint8_t micHeader10[1] = { 0x20 };\n    //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n    //   CFListType)\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( NWK_KEY ), ( lr1110_crypto_lorawan_version_t ) 0, micHeader10,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 0 )\n        {\n            // Network server is operating according to LoRaWAN 1.0.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    // 1.0.x trial failed. Trying to process LoRaWAN 1.1.x JoinAccept\n    uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n    uint16_t bufItr                                     = 0;\n    //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n    //   DLSettings | RxDelay | CFList | CFListType)\n    micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n    memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n    micHeader11[bufItr++] = devNonce & 0xFF;\n    micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n    micHeader11[bufItr++] = 0x20;\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( J_S_INT_KEY ), ( lr1110_crypto_lorawan_version_t ) 1, micHeader11,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 1 )\n        {\n            // Network server is operating according to LoRaWAN 1.1.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n#endif\n    return status;\n}\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id )\n{\n    lr1110_crypto_keys_idx_t id = LR1110_CRYPTO_KEYS_IDX_GP0;\n    switch( key_id )\n    {\n        case APP_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_KEY;\n            break;\n        case NWK_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_KEY;\n            break;\n        case J_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_INT_KEY;\n            break;\n        case J_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_ENC_KEY;\n            break;\n        case F_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_F_NWK_S_INT_KEY;\n            break;\n        case S_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_S_NWK_S_INT_KEY;\n            break;\n        case NWK_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_S_ENC_KEY;\n            break;\n        case APP_S_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_S_KEY;\n            break;\n        case MC_ROOT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_5;\n            break;\n        case MC_KE_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_4;\n            break;\n        case MC_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_0;\n            break;\n        case MC_APP_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_0;\n            break;\n        case MC_NWK_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_0;\n            break;\n        case MC_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_1;\n            break;\n        case MC_APP_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_1;\n            break;\n        case MC_NWK_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_1;\n            break;\n        case MC_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_2;\n            break;\n        case MC_APP_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_2;\n            break;\n        case MC_NWK_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_2;\n            break;\n        case MC_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_3;\n            break;\n        case MC_APP_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_3;\n            break;\n        case MC_NWK_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_3;\n            break;\n        case SLOT_RAND_ZERO_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP0;\n            break;\n        default:\n            id = LR1110_CRYPTO_KEYS_IDX_GP1;\n            break;\n    }\n    return id;\n}\nFile number 3:\n#include <stdlib.h>\n#include <stdint.h>\n#include \"utilities.h\"\n#include \"aes.h\"\n#include \"cmac.h\"\n#include \"LoRaMacHeaderTypes.h\"\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"soft-se-hal.h\"\n#define NUM_OF_KEYS 23\ntypedef struct sKey\n{\n    KeyIdentifier_t KeyID;\n    uint8_t KeyValue[SE_KEY_SIZE];\n} Key_t;\ntypedef struct sSecureElementNvCtx\n{\n    uint8_t DevEui[SE_EUI_SIZE];\n    uint8_t JoinEui[SE_EUI_SIZE];\n    uint8_t Pin[SE_PIN_SIZE];\n    aes_context AesContext;\n    AES_CMAC_CTX AesCmacCtx[1];\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    .DevEui = LORAWAN_DEVICE_EUI,\n    .JoinEui = LORAWAN_JOIN_EUI,\n    .Pin = SECURE_ELEMENT_PIN,\n    .KeyList = SOFT_SE_KEY_LIST\n};\nstatic SecureElementNvmEvent SeNvmCtxChanged;\nstatic SecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    uint8_t Cmac[16];\n    AES_CMAC_Init( SeNvmCtx.AesCmacCtx );\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        AES_CMAC_SetKey( SeNvmCtx.AesCmacCtx, keyItem->KeyValue );\n        if( micBxBuffer != NULL )\n        {\n            AES_CMAC_Update( SeNvmCtx.AesCmacCtx, micBxBuffer, 16 );\n        }\n        AES_CMAC_Update( SeNvmCtx.AesCmacCtx, buffer, size );\n        AES_CMAC_Final( Cmac, SeNvmCtx.AesCmacCtx );\n        // Bring into the required format\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n    }\n    return retval;\n}\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n            {  // Decrypt the key if its a Mckey\n                SecureElementStatus_t retval           = SECURE_ELEMENT_ERROR;\n                uint8_t               decryptedKey[16] = { 0 };\n                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n                return retval;\n            }\n            else\n            {\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, key, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n                return SECURE_ELEMENT_SUCCESS;\n            }\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n    return retval;\n}\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n    memset1( SeNvmCtx.AesContext.ksch, '\\0', 240 );\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        aes_set_key( pItem->KeyValue, 16, &SeNvmCtx.AesContext );\n        uint8_t block = 0;\n        while( size != 0 )\n        {\n            aes_encrypt( &buffer[block], &encBuffer[block], &SeNvmCtx.AesContext );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n    uint32_t mic = 0;\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n    return SECURE_ELEMENT_SUCCESS;\n}\n",
        "cwe": "CWE-120",
        "file_name": "vul_respovul_idx_4849.c",
        "project": "lora-net/loramac-node",
        "url": "https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tstruct commonio_db *db,\n\tstruct commonio_entry *p);\nstatic bool name_is_nis (const char *name);\nint commonio_open (struct commonio_db *db, int mode)\n\tvoid *eptr = NULL;\n\tint flags = mode;\n\tmode &= ~O_CREAT;\n\tif (   db->isopen\n\t    || (   (O_RDONLY != mode)\n\t        && (O_RDWR != mode))) {\n\tdb->readonly = (mode == O_RDONLY);\n\tif (!db->readonly && !db->locked) {\n\t}\n\tdb->head = NULL;\n\tdb->tail = NULL;\n\tdb->cursor = NULL;\n\tdb->changed = false;\n\tfd = open (db->filename,\n\t             (db->readonly ? O_RDONLY : O_RDWR)\n\t           | O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);\n\tdb->fp = NULL;\n\tif (fd >= 0) {\n\t\tdb->fp = fdopen (fd, db->readonly ? \"r\" : \"r+\");\n\t\tif (NULL == db->fp) {\n\t\t}\n\t}\n\tif (NULL == db->fp) {\n\t}\n\tfcntl (fileno (db->fp), F_SETFD, FD_CLOEXEC);\n\tbuflen = BUFLEN;\n\tbuf = (char *) malloc (buflen);\n\tif (NULL == buf) {\n\t}\n\twhile (db->ops->fgets (buf, (int) buflen, db->fp) == buf) {\n\t\twhile (   ((cp = strrchr (buf, '\\n')) == NULL)\n\t\t       && (feof (db->fp) == 0)) {\n\t\t\tbuflen += BUFLEN;\n\t\t\tcp = (char *) realloc (buf, buflen);\n\t\t\tif (NULL == cp) {\n\t\t\t}\n\t\t\tbuf = cp;\n\t\t\tlen = strlen (buf);\n\t\t\tif (db->ops->fgets (buf + len,\n\t\t\t                    (int) (buflen - len),\n\t\t\t                    db->fp) == NULL) {\n\t\tcp = strrchr (buf, '\\n');\n\t\tif (NULL != cp) {\n\t\t\t*cp = '\\0';\n\t\t}\n\t\tline = strdup (buf);\n\t\tif (NULL == line) {\n\t\t}\n\t\tif (name_is_nis (line)) {\n\t\t\teptr = NULL;\n\t\t} else {\n\t\t\teptr = db->ops->parse (line);\n\t\t\tif (NULL != eptr) {\n\t\t\t\teptr = db->ops->dup (eptr);\n\t\t\t\tif (NULL == eptr) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (struct commonio_entry *) malloc (sizeof *p);\n\t\tif (NULL == p) {\n\t\t}\n\t\tp->eptr = eptr;\n\t\tp->line = line;\n\t\tp->changed = false;\n\t\tadd_one_entry (db, p);\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <config.h>\n#ident \"$Id$\"\n#include \"defines.h\"\n#include <assert.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <utime.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include \"nscd.h\"\n#ifdef WITH_TCB\n#include <tcb.h>\n#endif\t\t\t\t\n#include \"prototypes.h\"\n#include \"commonio.h\"\nstatic int lrename (const char *, const char *);\nstatic int check_link_count (const char *file);\nstatic int do_lock_file (const char *file, const char *lock, bool log);\nstatic  FILE *fopen_set_perms (\n\tconst char *name,\n\tconst char *mode,\n\tconst struct stat *sb);\nstatic int create_backup (const char *, FILE *);\nstatic void free_linked_list (struct commonio_db *);\nstatic void add_one_entry (\n\tstruct commonio_db *db,\n\tstruct commonio_entry *p);\nstatic bool name_is_nis (const char *name);\nstatic int write_all (const struct commonio_db *);\nstatic  struct commonio_entry *find_entry_by_name (\n\tstruct commonio_db *,\n\tconst char *);\nstatic  struct commonio_entry *next_entry_by_name (\n\tstruct commonio_db *,\n\tstruct commonio_entry *pos,\n\tconst char *);\nstatic int lock_count = 0;\nstatic bool nscd_need_reload = false;\nstatic int do_lock_file (const char *file, const char *lock, bool log)\n{\n\tint fd;\n\tpid_t pid;\n\tssize_t len;\n\tint retval;\n\tchar buf[32];\n\tfd = open (file, O_CREAT | O_EXCL | O_WRONLY, 0600);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\treturn 0;\n\t}\n\tpid = getpid ();\n\tsnprintf (buf, sizeof buf, \"%lu\", (unsigned long) pid);\n\tlen = (ssize_t) strlen (buf) + 1;\n\tif (write (fd, buf, (size_t) len) != len) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\t(void) close (fd);\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\tclose (fd);\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t\tunlink (file);\n\t\treturn retval;\n\t}\n\tfd = open (lock, O_RDWR);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tlen = read (fd, buf, sizeof (buf) - 1);\n\tclose (fd);\n\tif (len <= 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s without a PID\\n\",\n\t\t\t                Prog, lock);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tbuf[len] = '\\0';\n\tif (get_pid (buf, &pid) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s with an invalid PID '%s'\\n\",\n\t\t\t                Prog, lock, buf);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (kill (pid, 0) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: lock %s already used by PID %lu\\n\",\n\t\t\t                Prog, lock, (unsigned long) pid);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EEXIST;\n\t\treturn 0;\n\t}\n\tif (unlink (lock) != 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\tretval = 0;\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t} else {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t}\n\tunlink (file);\n\treturn retval;\n}\nint commonio_lock (struct commonio_db *db)\n{\n#ifdef HAVE_LCKPWDF\n\tif (0 == lock_count) {\n\t\tif (lckpwdf () == -1) {\n\t\t\tif (geteuid () != 0) {\n\t\t\t\t(void) fprintf (stderr,\n\t\t\t\t                \"%s: Permission denied.\\n\",\n\t\t\t\t                Prog);\n\t\t\t}\n\t\t\treturn 0;\t\n\t\t}\n\t}\n\tif (commonio_lock_nowait (db, true) != 0) {\n\t\treturn 1;\t\n\t}\n\tulckpwdf ();\n\treturn 0;\t\t\n#else\t\t\t\t\n\tint i;\n#ifndef LOCK_TRIES\n#define LOCK_TRIES 15\n#endif\n#ifndef LOCK_SLEEP\n#define LOCK_SLEEP 1\n#endif\n\tfor (i = 0; i < LOCK_TRIES; i++) {\n\t\tif (i > 0) {\n\t\t\tsleep (LOCK_SLEEP);\t\n\t\t}\n\t\tif (commonio_lock_nowait (db, i==LOCK_TRIES-1) != 0) {\n\t\t\treturn 1;\t\n\t\t}\n\t\tif (geteuid () != 0) {\n\t\t\t(void) fprintf (stderr, \"%s: Permission denied.\\n\",\n\t\t\t                Prog);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\t\t\n#endif\t\t\t\t\n}\n#ifndef KEEP_NIS_AT_END\n#define KEEP_NIS_AT_END 1\n#endif\n#if KEEP_NIS_AT_END\nstatic void add_one_entry_nis (struct commonio_db *db,\n                               struct commonio_entry *newp);\n#endif\t\t\t\t\n#define BUFLEN 4096\nint commonio_open (struct commonio_db *db, int mode)\n{\n\tchar *buf;\n\tchar *cp;\n\tchar *line;\n\tstruct commonio_entry *p;\n\tvoid *eptr = NULL;\n\tint flags = mode;\n\tsize_t buflen;\n\tint fd;\n\tint saved_errno;\n\tmode &= ~O_CREAT;\n\tif (   db->isopen\n\t    || (   (O_RDONLY != mode)\n\t        && (O_RDWR != mode))) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->readonly = (mode == O_RDONLY);\n\tif (!db->readonly && !db->locked) {\n\t\terrno = EACCES;\n\t\treturn 0;\n\t}\n\tdb->head = NULL;\n\tdb->tail = NULL;\n\tdb->cursor = NULL;\n\tdb->changed = false;\n\tfd = open (db->filename,\n\t             (db->readonly ? O_RDONLY : O_RDWR)\n\t           | O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);\n\tsaved_errno = errno;\n\tdb->fp = NULL;\n\tif (fd >= 0) {\n#ifdef WITH_TCB\n\t\tif (tcb_is_suspect (fd) != 0) {\n\t\t\t(void) close (fd);\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n#endif\t\t\t\t\n\t\tdb->fp = fdopen (fd, db->readonly ? \"r\" : \"r+\");\n\t\tsaved_errno = errno;\n\t\tif (NULL == db->fp) {\n\t\t\t(void) close (fd);\n\t\t}\n\t}\n\terrno = saved_errno;\n\tif (NULL == db->fp) {\n\t\tif (((flags & O_CREAT) != 0) && (ENOENT == errno)) {\n\t\t\tdb->isopen = true;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tfcntl (fileno (db->fp), F_SETFD, FD_CLOEXEC);\n\tbuflen = BUFLEN;\n\tbuf = (char *) malloc (buflen);\n\tif (NULL == buf) {\n\t\tgoto cleanup_ENOMEM;\n\t}\n\twhile (db->ops->fgets (buf, (int) buflen, db->fp) == buf) {\n\t\twhile (   ((cp = strrchr (buf, '\\n')) == NULL)\n\t\t       && (feof (db->fp) == 0)) {\n\t\t\tsize_t len;\n\t\t\tbuflen += BUFLEN;\n\t\t\tcp = (char *) realloc (buf, buflen);\n\t\t\tif (NULL == cp) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t\tbuf = cp;\n\t\t\tlen = strlen (buf);\n\t\t\tif (db->ops->fgets (buf + len,\n\t\t\t                    (int) (buflen - len),\n\t\t\t                    db->fp) == NULL) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t}\n\t\tcp = strrchr (buf, '\\n');\n\t\tif (NULL != cp) {\n\t\t\t*cp = '\\0';\n\t\t}\n\t\tline = strdup (buf);\n\t\tif (NULL == line) {\n\t\t\tgoto cleanup_buf;\n\t\t}\n\t\tif (name_is_nis (line)) {\n\t\t\teptr = NULL;\n\t\t} else {\n\t\t\teptr = db->ops->parse (line);\n\t\t\tif (NULL != eptr) {\n\t\t\t\teptr = db->ops->dup (eptr);\n\t\t\t\tif (NULL == eptr) {\n\t\t\t\t\tgoto cleanup_line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (struct commonio_entry *) malloc (sizeof *p);\n\t\tif (NULL == p) {\n\t\t\tgoto cleanup_entry;\n\t\t}\n\t\tp->eptr = eptr;\n\t\tp->line = line;\n\t\tp->changed = false;\n\t\tadd_one_entry (db, p);\n\t}\n\tfree (buf);\n\tif (ferror (db->fp) != 0) {\n\t\tgoto cleanup_errno;\n\t}\n\tif ((NULL != db->ops->open_hook) && (db->ops->open_hook () == 0)) {\n\t\tgoto cleanup_errno;\n\t}\n\tdb->isopen = true;\n\treturn 1;\n      cleanup_entry:\n\tif (NULL != eptr) {\n\t\tdb->ops->free (eptr);\n\t}\n      cleanup_line:\n\tfree (line);\n      cleanup_buf:\n\tfree (buf);\n      cleanup_ENOMEM:\n\terrno = ENOMEM;\n      cleanup_errno:\n\tsaved_errno = errno;\n\tfree_linked_list (db);\n\tfclose (db->fp);\n\tdb->fp = NULL;\n\terrno = saved_errno;\n\treturn 0;\n}\nint\ncommonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && ((NULL == ptr->line)\n\t         || (('+' != ptr->line[0])\n\t             && ('-' != ptr->line[0])))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif (NULL != ptr) {\n\t\tnis = ptr;\n\t}\n#endif\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n\t     ptr = ptr->next\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\tfree (entries);\n\tdb->changed = true;\n\treturn 0;\n}\nint commonio_sort_wrt (struct commonio_db *shadow,\n                       const struct commonio_db *passwd)\n{\n\tstruct commonio_entry *head = NULL, *pw_ptr, *spw_ptr;\n\tconst char *name;\n\tif ((NULL == shadow) || (NULL == shadow->head)) {\n\t\treturn 0;\n\t}\n\tfor (pw_ptr = passwd->head; NULL != pw_ptr; pw_ptr = pw_ptr->next) {\n\t\tif (NULL == pw_ptr->eptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = passwd->ops->getname (pw_ptr->eptr);\n\t\tfor (spw_ptr = shadow->head;\n\t\t     NULL != spw_ptr;\n\t\t     spw_ptr = spw_ptr->next) {\n\t\t\tif (NULL == spw_ptr->eptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp (name, shadow->ops->getname (spw_ptr->eptr))\n\t\t\t    == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (NULL == spw_ptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tcommonio_del_entry (shadow, spw_ptr);\n\t\tspw_ptr->next = head;\n\t\thead = spw_ptr;\n\t}\n\tfor (spw_ptr = head; NULL != spw_ptr; spw_ptr = head) {\n\t\thead = head->next;\n\t\tif (NULL != shadow->head) {\n\t\t\tshadow->head->prev = spw_ptr;\n\t\t}\n\t\tspw_ptr->next = shadow->head;\n\t\tshadow->head = spw_ptr;\n\t}\n\tshadow->head->prev = NULL;\n\tshadow->changed = true;\n\treturn 0;\n}\nint commonio_close (struct commonio_db *db)\n{\n\tchar buf[1024];\n\tint errors = 0;\n\tstruct stat sb;\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->isopen = false;\n\tif (!db->changed || db->readonly) {\n\t\t(void) fclose (db->fp);\n\t\tdb->fp = NULL;\n\t\tgoto success;\n\t}\n\tif ((NULL != db->ops->close_hook) && (db->ops->close_hook () == 0)) {\n\t\tgoto fail;\n\t}\n\tmemzero (&sb, sizeof sb);\n\tif (NULL != db->fp) {\n\t\tif (fstat (fileno (db->fp), &sb) != 0) {\n\t\t\t(void) fclose (db->fp);\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t\tsnprintf (buf, sizeof buf, \"%s-\", db->filename);\n#ifdef WITH_SELINUX\n\t\tif (set_selinux_file_context (buf) != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (create_backup (buf, db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n\t\tif (fclose (db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n#ifdef WITH_SELINUX\n\t\tif (reset_selinux_file_context () != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (errors != 0) {\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tsb.st_mode = db->st_mode;\n\t\tsb.st_uid = db->st_uid;\n\t\tsb.st_gid = db->st_gid;\n\t}\n\tsnprintf (buf, sizeof buf, \"%s+\", db->filename);\n#ifdef WITH_SELINUX\n\tif (set_selinux_file_context (buf) != 0) {\n\t\terrors++;\n\t}\n#endif\n\tdb->fp = fopen_set_perms (buf, \"w\", &sb);\n\tif (NULL == db->fp) {\n\t\tgoto fail;\n\t}\n\tif (write_all (db) != 0) {\n\t\terrors++;\n\t}\n\tif (fflush (db->fp) != 0) {\n\t\terrors++;\n\t}\n#ifdef HAVE_FSYNC\n\tif (fsync (fileno (db->fp)) != 0) {\n\t\terrors++;\n\t}\n#else\t\t\t\t\n\tsync ();\n#endif\t\t\t\t\n\tif (fclose (db->fp) != 0) {\n\t\terrors++;\n\t}\n\tdb->fp = NULL;\n\tif (errors != 0) {\n\t\tunlink (buf);\n\t\tgoto fail;\n\t}\n\tif (lrename (buf, db->filename) != 0) {\n\t\tgoto fail;\n\t}\n#ifdef WITH_SELINUX\n\tif (reset_selinux_file_context () != 0) {\n\t\tgoto fail;\n\t}\n#endif\n\tnscd_need_reload = true;\n\tgoto success;\n      fail:\n\terrors++;\n      success:\n\tfree_linked_list (db);\n\treturn errors == 0;\n}\nint commonio_update (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp = find_entry_by_name (db, db->ops->getname (eptr));\n\tif (NULL != p) {\n\t\tif (next_entry_by_name (db, p->next, db->ops->getname (eptr)) != NULL) {\n\t\t\tfprintf (stderr, _(\"Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\\n\"), db->ops->getname (eptr), db->filename);\n\t\t\tdb->ops->free (nentry);\n\t\t\treturn 0;\n\t\t}\n\t\tdb->ops->free (p->eptr);\n\t\tp->eptr = nentry;\n\t\tp->changed = true;\n\t\tdb->cursor = p;\n\t\tdb->changed = true;\n\t\treturn 1;\n\t}\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n#if KEEP_NIS_AT_END\n\tadd_one_entry_nis (db, p);\n#else\t\t\t\t\n\tadd_one_entry (db, p);\n#endif\t\t\t\t\n\tdb->changed = true;\n\treturn 1;\n}\n#ifdef ENABLE_SUBIDS\nint commonio_append (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n\tadd_one_entry (db, p);\n\tdb->changed = true;\n\treturn 1;\n}\n#endif\t\t\t\t\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_2245.c",
        "project": "shadow-maint/shadow",
        "url": "https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```BOOL xf_decode_color(xfContext* xfc, const UINT32 srcColor, XColor* color)\n\tBYTE r = 0, g = 0, b = 0, a = 0;\n\trdpGdi* gdi = xfc->common.context.gdi;\n\tif (!gdi)\n\t\treturn FALSE;\n\t\t\tSrcFormat = PIXEL_FORMAT_BGR24;\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB16;\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB15;\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB8;\n\tFreeRDPSplitColor(srcColor, SrcFormat, &r, &g, &b, &a, &gdi->palette);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <freerdp/config.h>\n#include <X11/Xlib.h>\n#include <X11/Xutil.h>\n#ifdef WITH_XCURSOR\n#include <X11/Xcursor/Xcursor.h>\n#endif\n#include <float.h>\n#include <math.h>\n#include <winpr/crt.h>\n#include <winpr/assert.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/codec/rfx.h>\n#include \"xf_graphics.h\"\n#include \"xf_event.h\"\n#include <freerdp/log.h>\n#define TAG CLIENT_TAG(\"x11\")\nstatic BOOL xf_Pointer_Set(rdpContext* context, rdpPointer* pointer);\nBOOL xf_decode_color(xfContext* xfc, const UINT32 srcColor, XColor* color)\n{\n\tUINT32 SrcFormat = 0;\n\tBYTE r = 0, g = 0, b = 0, a = 0;\n\tif (!xfc || !color)\n\t\treturn FALSE;\n\trdpGdi* gdi = xfc->common.context.gdi;\n\tif (!gdi)\n\t\treturn FALSE;\n\trdpSettings* settings = xfc->common.context.settings;\n\tif (!settings)\n\t\treturn FALSE;\n\tswitch (freerdp_settings_get_uint32(settings, FreeRDP_ColorDepth))\n\t{\n\t\tcase 32:\n\t\tcase 24:\n\t\t\tSrcFormat = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB16;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB15;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tSrcFormat = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\tFreeRDPSplitColor(srcColor, SrcFormat, &r, &g, &b, &a, &gdi->palette);\n\tcolor->blue = (unsigned short)(b << 8);\n\tcolor->green = (unsigned short)(g << 8);\n\tcolor->red = (unsigned short)(r << 8);\n\tcolor->flags = DoRed | DoGreen | DoBlue;\n\tif (XAllocColor(xfc->display, xfc->colormap, color) == 0)\n\t\treturn FALSE;\n\treturn TRUE;\n}\nstatic BOOL xf_Pointer_GetCursorForCurrentScale(rdpContext* context, rdpPointer* pointer,\n                                                Cursor* cursor)\n{\n#if defined(WITH_XCURSOR) && defined(WITH_XRENDER)\n\txfContext* xfc = (xfContext*)context;\n\txfPointer* xpointer = (xfPointer*)pointer;\n\tXcursorImage ci = { 0 };\n\tint cursorIndex = -1;\n\tif (!context || !pointer || !context->gdi)\n\t\treturn FALSE;\n\trdpSettings* settings = xfc->common.context.settings;\n\tif (!settings)\n\t\treturn FALSE;\n\tconst double xscale = (freerdp_settings_get_bool(settings, FreeRDP_SmartSizing)\n\t                           ? xfc->scaledWidth / (double)freerdp_settings_get_uint32(\n\t                                                    settings, FreeRDP_DesktopWidth)\n\t                           : 1);\n\tconst double yscale = (freerdp_settings_get_bool(settings, FreeRDP_SmartSizing)\n\t                           ? xfc->scaledHeight / (double)freerdp_settings_get_uint32(\n\t                                                     settings, FreeRDP_DesktopHeight)\n\t                           : 1);\n\tconst UINT32 xTargetSize = MAX(1, pointer->width * xscale);\n\tconst UINT32 yTargetSize = MAX(1, pointer->height * yscale);\n\tWLog_DBG(TAG, \"scaled: %\" PRIu32 \"x%\" PRIu32 \", desktop: %\" PRIu32 \"x%\" PRIu32,\n\t         xfc->scaledWidth, xfc->scaledHeight,\n\t         freerdp_settings_get_uint32(settings, FreeRDP_DesktopWidth),\n\t         freerdp_settings_get_uint32(settings, FreeRDP_DesktopHeight));\n\tfor (UINT32 i = 0; i < xpointer->nCursors; i++)\n\t{\n\t\tif ((xpointer->cursorWidths[i] == xTargetSize) &&\n\t\t    (xpointer->cursorHeights[i] == yTargetSize))\n\t\t{\n\t\t\tcursorIndex = i;\n\t\t}\n\t}\n\tif (cursorIndex == -1)\n\t{\n\t\tUINT32 CursorFormat = 0;\n\t\txf_lock_x11(xfc);\n\t\tif (!xfc->invert)\n\t\t\tCursorFormat = (!xfc->big_endian) ? PIXEL_FORMAT_RGBA32 : PIXEL_FORMAT_ABGR32;\n\t\telse\n\t\t\tCursorFormat = (!xfc->big_endian) ? PIXEL_FORMAT_BGRA32 : PIXEL_FORMAT_ARGB32;\n\t\tif (xpointer->nCursors == xpointer->mCursors)\n\t\t{\n\t\t\tvoid* tmp2;\n\t\t\txpointer->mCursors = (xpointer->mCursors == 0 ? 1 : xpointer->mCursors * 2);\n\t\t\ttmp2 = realloc(xpointer->cursorWidths, sizeof(UINT32) * xpointer->mCursors);\n\t\t\tif (!tmp2)\n\t\t\t{\n\t\t\t\txf_unlock_x11(xfc);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\txpointer->cursorWidths = tmp2;\n\t\t\ttmp2 = realloc(xpointer->cursorHeights, sizeof(UINT32) * xpointer->mCursors);\n\t\t\tif (!tmp2)\n\t\t\t{\n\t\t\t\txf_unlock_x11(xfc);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\txpointer->cursorHeights = (UINT32*)tmp2;\n\t\t\ttmp2 = realloc(xpointer->cursors, sizeof(Cursor) * xpointer->mCursors);\n\t\t\tif (!tmp2)\n\t\t\t{\n\t\t\t\txf_unlock_x11(xfc);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\txpointer->cursors = (Cursor*)tmp2;\n\t\t}\n\t\tci.version = XCURSOR_IMAGE_VERSION;\n\t\tci.size = sizeof(ci);\n\t\tci.width = xTargetSize;\n\t\tci.height = yTargetSize;\n\t\tci.xhot = pointer->xPos * xscale;\n\t\tci.yhot = pointer->yPos * yscale;\n\t\tconst size_t size = 1ull * ci.height * ci.width * FreeRDPGetBytesPerPixel(CursorFormat);\n\t\tvoid* tmp = winpr_aligned_malloc(size, 16);\n\t\tif (!tmp)\n\t\t{\n\t\t\txf_unlock_x11(xfc);\n\t\t\treturn FALSE;\n\t\t}\n\t\tci.pixels = (XcursorPixel*)tmp;\n\t\tconst double xs = fabs(fabs(xscale) - 1.0);\n\t\tconst double ys = fabs(fabs(yscale) - 1.0);\n\t\tWLog_DBG(TAG,\n\t\t         \"cursorIndex %\" PRId32 \" scaling pointer %\" PRIu32 \"x%\" PRIu32 \" --> %\" PRIu32\n\t\t         \"x%\" PRIu32 \" [%lfx%lf]\",\n\t\t         cursorIndex, pointer->width, pointer->height, ci.width, ci.height, xscale, yscale);\n\t\tif ((xs > DBL_EPSILON) || (ys > DBL_EPSILON))\n\t\t{\n\t\t\tif (!freerdp_image_scale((BYTE*)ci.pixels, CursorFormat, 0, 0, 0, ci.width, ci.height,\n\t\t\t                         (BYTE*)xpointer->cursorPixels, CursorFormat, 0, 0, 0,\n\t\t\t                         pointer->width, pointer->height))\n\t\t\t{\n\t\t\t\twinpr_aligned_free(tmp);\n\t\t\t\txf_unlock_x11(xfc);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tci.pixels = xpointer->cursorPixels;\n\t\t}\n\t\tcursorIndex = xpointer->nCursors;\n\t\txpointer->cursorWidths[cursorIndex] = ci.width;\n\t\txpointer->cursorHeights[cursorIndex] = ci.height;\n\t\txpointer->cursors[cursorIndex] = XcursorImageLoadCursor(xfc->display, &ci);\n\t\txpointer->nCursors += 1;\n\t\twinpr_aligned_free(tmp);\n\t\txf_unlock_x11(xfc);\n\t}\n\telse\n\t{\n\t\tWLog_DBG(TAG, \"using cached cursor %\" PRId32, cursorIndex);\n\t}\n\tcursor[0] = xpointer->cursors[cursorIndex];\n#endif\n\treturn TRUE;\n}\nstatic BOOL xf_Pointer_New(rdpContext* context, rdpPointer* pointer)\n{\n\tBOOL rc = FALSE;\n#ifdef WITH_XCURSOR\n\tUINT32 CursorFormat;\n\tsize_t size;\n\txfContext* xfc = (xfContext*)context;\n\txfPointer* xpointer = (xfPointer*)pointer;\n\tif (!context || !pointer || !context->gdi)\n\t\tgoto fail;\n\tif (!xfc->invert)\n\t\tCursorFormat = (!xfc->big_endian) ? PIXEL_FORMAT_RGBA32 : PIXEL_FORMAT_ABGR32;\n\telse\n\t\tCursorFormat = (!xfc->big_endian) ? PIXEL_FORMAT_BGRA32 : PIXEL_FORMAT_ARGB32;\n\txpointer->nCursors = 0;\n\txpointer->mCursors = 0;\n\tsize = 1ull * pointer->height * pointer->width * FreeRDPGetBytesPerPixel(CursorFormat);\n\tif (!(xpointer->cursorPixels = (XcursorPixel*)winpr_aligned_malloc(size, 16)))\n\t\tgoto fail;\n\tif (!freerdp_image_copy_from_pointer_data(\n\t        (BYTE*)xpointer->cursorPixels, CursorFormat, 0, 0, 0, pointer->width, pointer->height,\n\t        pointer->xorMaskData, pointer->lengthXorMask, pointer->andMaskData,\n\t        pointer->lengthAndMask, pointer->xorBpp, &context->gdi->palette))\n\t{\n\t\twinpr_aligned_free(xpointer->cursorPixels);\n\t\tgoto fail;\n\t}\n#endif\n\trc = TRUE;\nfail:\n\tWLog_DBG(TAG, \"%p\", rc ? pointer : NULL);\n\treturn rc;\n}\nstatic BOOL xf_Pointer_SetPosition(rdpContext* context, UINT32 x, UINT32 y)\n{\n\txfContext* xfc = (xfContext*)context;\n\tXWindowAttributes current = { 0 };\n\tXSetWindowAttributes tmp = { 0 };\n\tBOOL ret = FALSE;\n\tStatus rc = 0;\n\tWindow handle = xf_Pointer_get_window(xfc);\n\tif (!handle)\n\t{\n\t\tWLog_WARN(TAG, \"focus %d, handle%lu\", xfc->focused, handle);\n\t\treturn TRUE;\n\t}\n\tWLog_DBG(TAG, \"%\" PRIu32 \"x%\" PRIu32, x, y);\n\tif (!xfc->focused)\n\t\treturn TRUE;\n\txf_adjust_coordinates_to_screen(xfc, &x, &y);\n\txf_lock_x11(xfc);\n\trc = XGetWindowAttributes(xfc->display, handle, &current);\n\tif (rc == 0)\n\t{\n\t\tWLog_WARN(TAG, \"XGetWindowAttributes==%d\", rc);\n\t\tgoto out;\n\t}\n\ttmp.event_mask = (current.your_event_mask & ~(PointerMotionMask));\n\trc = XChangeWindowAttributes(xfc->display, handle, CWEventMask, &tmp);\n\tif (rc == 0)\n\t{\n\t\tWLog_WARN(TAG, \"XChangeWindowAttributes==%d\", rc);\n\t\tgoto out;\n\t}\n\trc = XWarpPointer(xfc->display, handle, handle, 0, 0, 0, 0, x, y);\n\tif (rc == 0)\n\t\tWLog_WARN(TAG, \"XWarpPointer==%d\", rc);\n\ttmp.event_mask = current.your_event_mask;\n\trc = XChangeWindowAttributes(xfc->display, handle, CWEventMask, &tmp);\n\tif (rc == 0)\n\t\tWLog_WARN(TAG, \"2.try XChangeWindowAttributes==%d\", rc);\n\tret = TRUE;\nout:\n\txf_unlock_x11(xfc);\n\treturn ret;\n}\nBOOL xf_register_pointer(rdpGraphics* graphics)\n{\n\trdpPointer pointer = { 0 };\n\tpointer.size = sizeof(xfPointer);\n\tpointer.New = xf_Pointer_New;\n\tpointer.Free = xf_Pointer_Free;\n\tpointer.Set = xf_Pointer_Set;\n\tpointer.SetNull = xf_Pointer_SetNull;\n\tpointer.SetDefault = xf_Pointer_SetDefault;\n\tpointer.SetPosition = xf_Pointer_SetPosition;\n\tgraphics_register_pointer(graphics, &pointer);\n\treturn TRUE;\n}\nFile number 2:\n/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * X11 Graphical Objects\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CLIENT_X11_GRAPHICS_H\n#define FREERDP_CLIENT_X11_GRAPHICS_H\n\n#include \"xf_client.h\"\n#include \"xfreerdp.h\"\n\nBOOL xf_register_pointer(rdpGraphics* graphics);\n\nBOOL xf_decode_color(xfContext* xfc, const UINT32 srcColor, XColor* color);\nUINT32 xf_get_local_color_format(xfContext* xfc, BOOL aligned);\n\nBOOL xf_pointer_update_scale(xfContext* xfc);\n\n#endif /* FREERDP_CLIENT_X11_GRAPHICS_H */\n\nFile number 3:\n/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * X11 Client\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Thincast Technologies GmbH\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CLIENT_X11_FREERDP_H\n#define FREERDP_CLIENT_X11_FREERDP_H\n\n#include <freerdp/config.h>\n\ntypedef struct xf_context xfContext;\n\n#ifdef WITH_XCURSOR\n#include <X11/Xcursor/Xcursor.h>\n#endif\n\n#ifdef WITH_XI\n#include <X11/extensions/XInput2.h>\n#endif\n\n#include <freerdp/api.h>\n\n#include \"xf_window.h\"\n#include \"xf_monitor.h\"\n#include \"xf_channels.h\"\n\n#if defined(CHANNEL_TSMF_CLIENT)\n#include <freerdp/client/tsmf.h>\n#endif\n\n#include <freerdp/gdi/gdi.h>\n#include <freerdp/codec/rfx.h>\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/clear.h>\n#include <freerdp/codec/color.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/codec/h264.h>\n#include <freerdp/codec/progressive.h>\n#include <freerdp/codec/region.h>\n\n#if !defined(XcursorUInt)\ntypedef unsigned int XcursorUInt;\n#endif\n\n#if !defined(XcursorPixel)\ntypedef XcursorUInt XcursorPixel;\n#endif\n\nstruct xf_FullscreenMonitors\n{\n\tUINT32 top;\n\tUINT32 bottom;\n\tUINT32 left;\n\tUINT32 right;\n};\ntypedef struct xf_FullscreenMonitors xfFullscreenMonitors;\n\nstruct xf_WorkArea\n{\n\tUINT32 x;\n\tUINT32 y;\n\tUINT32 width;\n\tUINT32 height;\n};\ntypedef struct xf_WorkArea xfWorkArea;\n\nstruct xf_pointer\n{\n\trdpPointer pointer;\n\tXcursorPixel* cursorPixels;\n\tUINT32 nCursors;\n\tUINT32 mCursors;\n\tUINT32* cursorWidths;\n\tUINT32* cursorHeights;\n\tCursor* cursors;\n\tCursor cursor;\n};\ntypedef struct xf_pointer xfPointer;\n\nstruct xf_bitmap\n{\n\trdpBitmap bitmap;\n\tPixmap pixmap;\n\tXImage* image;\n};\ntypedef struct xf_bitmap xfBitmap;\n\nstruct xf_glyph\n{\n\trdpGlyph glyph;\n\tPixmap pixmap;\n};\ntypedef struct xf_glyph xfGlyph;\n\ntypedef struct xf_clipboard xfClipboard;\ntypedef struct s_xfDispContext xfDispContext;\ntypedef struct s_xfVideoContext xfVideoContext;\ntypedef struct xf_rail_icon_cache xfRailIconCache;\n\n/* Number of buttons that are mapped from X11 to RDP button events. */\n#define NUM_BUTTONS_MAPPED 11\n\ntypedef struct\n{\n\tint button;\n\tUINT16 flags;\n} button_map;\n\n#if defined(WITH_XI)\n#define MAX_CONTACTS 20\n\ntypedef struct touch_contact\n{\n\tint id;\n\tint count;\n\tdouble pos_x;\n\tdouble pos_y;\n\tdouble last_x;\n\tdouble last_y;\n\n} touchContact;\n\n#endif\n\nstruct xf_context\n{\n\trdpClientContext common;\n\n\tGC gc;\n\tint xfds;\n\tint depth;\n\n\tGC gc_mono;\n\tBOOL invert;\n\tScreen* screen;\n\tXImage* image;\n\tPixmap primary;\n\tPixmap drawing;\n\tVisual* visual;\n\tDisplay* display;\n\tDrawable drawable;\n\tPixmap bitmap_mono;\n\tColormap colormap;\n\tint screen_number;\n\tint scanline_pad;\n\tBOOL big_endian;\n\tBOOL fullscreen;\n\tBOOL decorations;\n\tBOOL grab_keyboard;\n\tBOOL unobscured;\n\tBOOL debug;\n\tHANDLE x11event;\n\txfWindow* window;\n\txfAppWindow* appWindow;\n\txfPointer* pointer;\n\txfWorkArea workArea;\n\txfFullscreenMonitors fullscreenMonitors;\n\tint current_desktop;\n\tBOOL remote_app;\n\tHANDLE mutex;\n\tBOOL UseXThreads;\n\tBOOL cursorHidden;\n\n\tUINT32 bitmap_size;\n\tBYTE* bitmap_buffer;\n\n\tBOOL frame_begin;\n\n\tint XInputOpcode;\n\n\tint savedWidth;\n\tint savedHeight;\n\tint savedPosX;\n\tint savedPosY;\n\n#ifdef WITH_XRENDER\n\tint scaledWidth;\n\tint scaledHeight;\n\tint offset_x;\n\tint offset_y;\n#endif\n\n\tBOOL focused;\n\tBOOL mouse_active;\n\tBOOL fullscreen_toggle;\n\tUINT32 KeyboardLayout;\n\tBOOL KeyboardState[256];\n\tXModifierKeymap* modifierMap;\n\twArrayList* keyCombinations;\n\twArrayList* xevents;\n\tBOOL actionScriptExists;\n\n\tint attribs_mask;\n\tXSetWindowAttributes attribs;\n\tBOOL complex_regions;\n\tVIRTUAL_SCREEN vscreen;\n#if defined(CHANNEL_TSMF_CLIENT)\n\tvoid* xv_context;\n#endif\n\n\tAtom* supportedAtoms;\n\tunsigned long supportedAtomCount;\n\n\tAtom UTF8_STRING;\n\n\tAtom _XWAYLAND_MAY_GRAB_KEYBOARD;\n\n\tAtom _NET_WM_ICON;\n\tAtom _MOTIF_WM_HINTS;\n\tAtom _NET_CURRENT_DESKTOP;\n\tAtom _NET_WORKAREA;\n\n\tAtom _NET_SUPPORTED;\n\tAtom _NET_SUPPORTING_WM_CHECK;\n\n\tAtom _NET_WM_STATE;\n\tAtom _NET_WM_STATE_FULLSCREEN;\n\tAtom _NET_WM_STATE_MAXIMIZED_HORZ;\n\tAtom _NET_WM_STATE_MAXIMIZED_VERT;\n\tAtom _NET_WM_STATE_SKIP_TASKBAR;\n\tAtom _NET_WM_STATE_SKIP_PAGER;\n\n\tAtom _NET_WM_FULLSCREEN_MONITORS;\n\n\tAtom _NET_WM_NAME;\n\tAtom _NET_WM_PID;\n\n\tAtom _NET_WM_WINDOW_TYPE;\n\tAtom _NET_WM_WINDOW_TYPE_NORMAL;\n\tAtom _NET_WM_WINDOW_TYPE_DIALOG;\n\tAtom _NET_WM_WINDOW_TYPE_UTILITY;\n\tAtom _NET_WM_WINDOW_TYPE_POPUP;\n\tAtom _NET_WM_WINDOW_TYPE_POPUP_MENU;\n\tAtom _NET_WM_WINDOW_TYPE_DROPDOWN_MENU;\n\n\tAtom _NET_WM_MOVERESIZE;\n\tAtom _NET_MOVERESIZE_WINDOW;\n\n\tAtom WM_STATE;\n\tAtom WM_PROTOCOLS;\n\tAtom WM_DELETE_WINDOW;\n\n\t/* Channels */\n#if defined(CHANNEL_TSMF_CLIENT)\n\tTsmfClientContext* tsmf;\n#endif\n\n\txfClipboard* clipboard;\n\tCliprdrClientContext* cliprdr;\n\txfVideoContext* xfVideo;\n\txfDispContext* xfDisp;\n\n\tRailClientContext* rail;\n\twHashTable* railWindows;\n\txfRailIconCache* railIconCache;\n\n\tBOOL xkbAvailable;\n\tBOOL xrenderAvailable;\n\n\t/* value to be sent over wire for each logical client mouse button */\n\tbutton_map button_map[NUM_BUTTONS_MAPPED];\n\tBYTE savedMaximizedState;\n\tUINT32 locked;\n\tBOOL firstPressRightCtrl;\n\tBOOL ungrabKeyboardWithRightCtrl;\n\n#if defined(WITH_XI)\n\ttouchContact contacts[MAX_CONTACTS];\n\tint active_contacts;\n\tint lastEvType;\n\tXIDeviceEvent lastEvent;\n\tdouble firstDist;\n\tdouble lastDist;\n\tdouble z_vector;\n\tdouble px_vector;\n\tdouble py_vector;\n#endif\n\tBOOL xi_rawevent;\n\tBOOL xi_event;\n\tHANDLE pipethread;\n};\n\nBOOL xf_create_window(xfContext* xfc);\nBOOL xf_create_image(xfContext* xfc);\nvoid xf_toggle_fullscreen(xfContext* xfc);\n\nenum XF_EXIT_CODE\n{\n\t/* section 0-15: protocol-independent codes */\n\tXF_EXIT_SUCCESS = 0,\n\tXF_EXIT_DISCONNECT = 1,\n\tXF_EXIT_LOGOFF = 2,\n\tXF_EXIT_IDLE_TIMEOUT = 3,\n\tXF_EXIT_LOGON_TIMEOUT = 4,\n\tXF_EXIT_CONN_REPLACED = 5,\n\tXF_EXIT_OUT_OF_MEMORY = 6,\n\tXF_EXIT_CONN_DENIED = 7,\n\tXF_EXIT_CONN_DENIED_FIPS = 8,\n\tXF_EXIT_USER_PRIVILEGES = 9,\n\tXF_EXIT_FRESH_CREDENTIALS_REQUIRED = 10,\n\tXF_EXIT_DISCONNECT_BY_USER = 11,\n\n\t/* section 16-31: license error set */\n\tXF_EXIT_LICENSE_INTERNAL = 16,\n\tXF_EXIT_LICENSE_NO_LICENSE_SERVER = 17,\n\tXF_EXIT_LICENSE_NO_LICENSE = 18,\n\tXF_EXIT_LICENSE_BAD_CLIENT_MSG = 19,\n\tXF_EXIT_LICENSE_HWID_DOESNT_MATCH = 20,\n\tXF_EXIT_LICENSE_BAD_CLIENT = 21,\n\tXF_EXIT_LICENSE_CANT_FINISH_PROTOCOL = 22,\n\tXF_EXIT_LICENSE_CLIENT_ENDED_PROTOCOL = 23,\n\tXF_EXIT_LICENSE_BAD_CLIENT_ENCRYPTION = 24,\n\tXF_EXIT_LICENSE_CANT_UPGRADE = 25,\n\tXF_EXIT_LICENSE_NO_REMOTE_CONNECTIONS = 26,\n\n\t/* section 32-127: RDP protocol error set */\n\tXF_EXIT_RDP = 32,\n\n\t/* section 128-254: xfreerdp specific exit codes */\n\tXF_EXIT_PARSE_ARGUMENTS = 128,\n\tXF_EXIT_MEMORY = 129,\n\tXF_EXIT_PROTOCOL = 130,\n\tXF_EXIT_CONN_FAILED = 131,\n\tXF_EXIT_AUTH_FAILURE = 132,\n\tXF_EXIT_NEGO_FAILURE = 133,\n\tXF_EXIT_LOGON_FAILURE = 134,\n\tXF_EXIT_ACCOUNT_LOCKED_OUT = 135,\n\tXF_EXIT_PRE_CONNECT_FAILED = 136,\n\tXF_EXIT_CONNECT_UNDEFINED = 137,\n\tXF_EXIT_POST_CONNECT_FAILED = 138,\n\tXF_EXIT_DNS_ERROR = 139,\n\tXF_EXIT_DNS_NAME_NOT_FOUND = 140,\n\tXF_EXIT_CONNECT_FAILED = 141,\n\tXF_EXIT_MCS_CONNECT_INITIAL_ERROR = 142,\n\tXF_EXIT_TLS_CONNECT_FAILED = 143,\n\tXF_EXIT_INSUFFICIENT_PRIVILEGES = 144,\n\tXF_EXIT_CONNECT_CANCELLED = 145,\n\n\tXF_EXIT_CONNECT_TRANSPORT_FAILED = 147,\n\tXF_EXIT_CONNECT_PASSWORD_EXPIRED = 148,\n\tXF_EXIT_CONNECT_PASSWORD_MUST_CHANGE = 149,\n\tXF_EXIT_CONNECT_KDC_UNREACHABLE = 150,\n\tXF_EXIT_CONNECT_ACCOUNT_DISABLED = 151,\n\tXF_EXIT_CONNECT_PASSWORD_CERTAINLY_EXPIRED = 152,\n\tXF_EXIT_CONNECT_CLIENT_REVOKED = 153,\n\tXF_EXIT_CONNECT_WRONG_PASSWORD = 154,\n\tXF_EXIT_CONNECT_ACCESS_DENIED = 155,\n\tXF_EXIT_CONNECT_ACCOUNT_RESTRICTION = 156,\n\tXF_EXIT_CONNECT_ACCOUNT_EXPIRED = 157,\n\tXF_EXIT_CONNECT_LOGON_TYPE_NOT_GRANTED = 158,\n\tXF_EXIT_CONNECT_NO_OR_MISSING_CREDENTIALS = 159,\n\n\tXF_EXIT_UNKNOWN = 255,\n};\n\n#define xf_lock_x11(xfc) xf_lock_x11_(xfc, __func__)\n#define xf_unlock_x11(xfc) xf_unlock_x11_(xfc, __func__)\n\nvoid xf_lock_x11_(xfContext* xfc, const char* fkt);\nvoid xf_unlock_x11_(xfContext* xfc, const char* fkt);\n\nBOOL xf_picture_transform_required(xfContext* xfc);\n\n#define xf_draw_screen(_xfc, _x, _y, _w, _h) \\\n\txf_draw_screen_((_xfc), (_x), (_y), (_w), (_h), __func__, __FILE__, __LINE__)\nvoid xf_draw_screen_(xfContext* xfc, int x, int y, int w, int h, const char* fkt, const char* file,\n                     int line);\n\nBOOL xf_keyboard_update_modifier_map(xfContext* xfc);\n\nDWORD xf_exit_code_from_disconnect_reason(DWORD reason);\n\n#endif /* FREERDP_CLIENT_X11_FREERDP_H */\n\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_4609.c",
        "project": "freerdp/freerdp",
        "url": "https://github.com/FreeRDP/FreeRDP/commit/f02375e4ecbee752b40bed7bb08a0454f83e0bff",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```BZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n    }\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n    }\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n    }\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n    }\n}\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n}\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n    u8 * compression_buf = malloc(block_size);\n    for (u32 i = 0; i < n_blocks; i++) {\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n        }\n    }\n}\nstatic void version() {\n}\nstatic void help() {\n}\nstatic void xwrite(const void * data, size_t size, size_t len, FILE * des) {\n}\nstatic size_t xread(void * data, size_t size, size_t len, FILE * des) {\n}\nstatic size_t xread_eofcheck(void * data, size_t size, size_t len, FILE * des) {\n}\nstatic void xread_noeof(void * data, size_t size, size_t len, FILE * des) {\n}\nstatic void close_out_file(FILE * des) {\n}\nstatic int process(FILE * input_des, FILE * output_des, int mode, int block_size, int workers, int verbose, char * file_name) {\n    if ((mode == MODE_ENCODE && isatty(fileno(output_des))) ||\n        ((mode == MODE_DECODE || mode == MODE_TEST) && isatty(fileno(input_des)))) {\n    u8 byteswap_buf[4];\n            write_neutral_s32(byteswap_buf, block_size);\n            xwrite(byteswap_buf, 4, 1, output_des);\n            if (xread(signature, 5, 1, input_des) != 1 || strncmp(signature, \"BZ3v1\", 5) != 0) {\n            }\n            xread_noeof(byteswap_buf, 4, 1, input_des);\n            block_size = read_neutral_s32(byteswap_buf);\n            if (block_size < KiB(65) || block_size > MiB(511)) {\n            }\n    if (workers > 64 || workers < 0) {\n    }\n    if (workers <= 1) {\n        struct bz3_state * state = bz3_new(block_size);\n        if (state == NULL) {\n        }\n        u8 * buffer = malloc(block_size + block_size / 50 + 32);\n        if (!buffer) {\n        }\n        if (mode == MODE_ENCODE) {\n        } else if (mode == MODE_DECODE) {\n            while (!feof(input_des)) {\n                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n                }\n            }\n        } else if (mode == MODE_TEST) {\n            while (!feof(input_des)) {\n                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;\n                new_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(&byteswap_buf, 1, 4, input_des);\n                old_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(buffer, 1, new_size, input_des);\n                bytes_read += 8 + new_size;\n                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n                }\n            }\n        }\n    } else {\n}\nint main(int argc, char * argv[]) {\n    char *input = NULL, *output = NULL;\n    char *f1 = NULL, *f2 = NULL;\n    u32 block_size = MiB(16);\n    const char * short_options = \"Bb:cdefhktvVz\";\n    static struct option long_options[] = { { \"encode\", no_argument, 0, 'e' },\n                                            { \"decode\", no_argument, 0, 'd' },\n                                            { \"test\", no_argument, 0, 't' },\n                                            { \"stdout\", no_argument, 0, 'c' },\n                                            { \"force\", no_argument, 0, 'f' },\n                                            { \"help\", no_argument, 0, 'h' },\n                                            { \"keep\", no_argument, 0, 'k' },\n                                            { \"version\", no_argument, 0, 'V' },\n                                            { \"verbose\", no_argument, 0, 'v' },\n                                            { \"block\", required_argument, 0, 'b' },\n                                            { \"batch\", no_argument, 0, 'B' },\n                                            { 0, 0, 0, 0 } };\n    while (1) {\n        int option_index = 0;\n        int c = getopt_long(argc, argv, short_options, long_options, &option_index);\n        if (c == -1) break;\n                if (!is_numeric(optarg)) {\n                }\n                block_size = MiB(atoi(optarg));\n                break;\n    }\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n    }\n    if (batch) {\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    process(input_des, output_des, mode, block_size, workers, verbose, arg);\n                }\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    process(input_des, output_des, mode, block_size, workers, verbose, arg);\n                }\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    process(input_des, NULL, mode, block_size, workers, verbose, arg);\n                }\n    }\n    while (optind < argc) {\n        char * arg = argv[optind++];\n        if (f1 != NULL && f2 != NULL) {\n        }\n        if (f1 == NULL)\n            f1 = arg;\n        else\n            f2 = arg;\n    }\n    if (f1 == NULL && f2 == NULL)\n        input = NULL, output = NULL;\n    else if (mode == MODE_TEST)\n        input = f1;\n    else {\n        if (mode == MODE_ENCODE) {\n            if (f2 == NULL) {\n                input = f1;\n                if (force_stdstreams)\n                    output = NULL;\n                else {\n                }\n            } else {\n                input = f1;\n            }\n        } else if (mode == MODE_DECODE) {\n            if (f2 == NULL) {\n                input = f1;\n                if (force_stdstreams)\n                    output = NULL;\n                else {\n                }\n            } else {\n                input = f1;\n            }\n        }\n    }\n    input_des = open_input(input);\n    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n\n/*\n * BZip3 - A spiritual successor to BZip2.\n * Copyright (C) 2022 Kamila Szewczyk\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"libbz3.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libsais.h\"\n\n/* CRC32 implementation. Since CRC32 generally takes less than 1% of the runtime on real-world data (e.g. the\n   Silesia corpus), I decided against using hardware CRC32. This implementation is simple, fast, fool-proof and\n   good enough to be used with bzip3. */\n\nstatic const u32 crc32Table[256] = {\n    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,\n    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,\n    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,\n    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,\n    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,\n    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,\n    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,\n    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,\n    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,\n    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,\n    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,\n    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,\n    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,\n    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,\n    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,\n    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,\n    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,\n    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,\n    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,\n    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,\n    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,\n    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,\n    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,\n    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,\n    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,\n    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,\n    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,\n    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,\n    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L\n};\n\nstatic u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}\n\n/* LZP code. These constants were manually tuned to give the best compression ratio while using relatively\n   little resources. The LZP dictionary is only around 1MiB in size and the minimum match length was chosen\n   so that LZP would not interfere too much with the Burrows-Wheeler transform and the arithmetic coder, and\n   just collapse long redundant data instead (for a major speed-up at a low compression ratio cost - in fact,\n   LZP preprocessing often improves compression in some cases). */\n\n/* A heavily modified version of libbsc's LZP predictor w/ unaligned accesses follows. This one has single thread\n   performance and provides better compression ratio. It is also mostly UB-free and less brittle during\n   AFL fuzzing. */\n\n#define LZP_DICTIONARY 18\n#define LZP_MIN_MATCH 40\n\n#define MATCH 0xf2\n\nstatic s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,\n                            s32 * RESTRICT lut) {\n    const u8 * ins = in;\n    const u8 * outs = out;\n    const u8 * out_eob = out_end - 8;\n    const u8 * heur = in;\n\n    u32 ctx;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = in - ins;\n        if (val > 0) {\n            const u8 * RESTRICT ref = ins + val;\n            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&\n                memcmp(in, ref, sizeof(u32)) == 0) {\n                if (heur > in && *(u32 *)heur != *(u32 *)(ref + (heur - in))) goto not_found;\n\n                s32 len = 4;\n                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {\n                    if (*(u32 *)(in + len) != *(u32 *)(ref + len)) break;\n                }\n\n                if (len < LZP_MIN_MATCH) {\n                    if (heur < in + len) heur = in + len;\n                    goto not_found;\n                }\n\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n\n                in += len;\n                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n                *out++ = MATCH;\n\n                len -= LZP_MIN_MATCH;\n                while (len >= 254) {\n                    len -= 254;\n                    *out++ = 254;\n                    if (out >= out_eob) break;\n                }\n\n                *out++ = len;\n            } else {\n            not_found:;\n                u8 next = *out++ = *in++;\n                ctx = ctx << 8 | next;\n                if (next == MATCH) *out++ = 255;\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(in - ins);\n\n        u8 next = *out++ = *in++;\n        ctx = ctx << 8 | next;\n        if (next == MATCH && val > 0) *out++ = 255;\n    }\n\n    return out >= out_eob ? -1 : (s32)(out - outs);\n}\n\nstatic s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,\n                            const u8 * out_end) {\n    const u8 * outs = out;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n\n    while (in < in_end && out < out_end) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(out - outs);\n        if (*in == MATCH && val > 0) {\n            in++;\n            if (*in != 255) {\n                s32 len = LZP_MIN_MATCH;\n                while (1) {\n                    if (in == in_end) return -1;\n                    len += *in;\n                    if (*in++ != 254) break;\n                }\n\n                const u8 * ref = outs + val;\n                u8 * oe = out + len;\n                if (oe > out_end) oe = out_end;\n\n                while (out < oe) *out++ = *ref++;\n\n                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n            } else {\n                in++;\n                ctx = (ctx << 8) | (*out++ = MATCH);\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    return out - outs;\n}\n\nstatic s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {\n    if (n < LZP_MIN_MATCH + 32) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_encode_block(in, in + n, out, out + n, lut);\n}\n\nstatic s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {\n    if (n < 4) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_decode_block(in, in + n, lut, out, out + max);\n}\n\n/* RLE code. Unlike RLE in other compressors, we collapse all runs if they yield a net gain\n   for a given character and encode this as a set bit in the RLE metadata. This improves the\n   performance and reduces the amount of collapsing done in normal blocks (so that BWT+AC can\n   be more efficient) while we still filter out all the pathological data. */\n\nstatic s32 mrlec(u8 * in, s32 inlen, u8 * out) {\n    u8 * ip = in;\n    u8 * in_end = in + inlen;\n    s32 op = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    while ((c = (ip < in_end ? *ip++ : -1)) != -1) {\n        if (c == pc)\n            t[c] += (++run % 255) != 0;\n        else\n            --t[c], run = 0;\n        pc = c;\n    }\n    for (s32 i = 0; i < 32; ++i) {\n        c = 0;\n        for (s32 j = 0; j < 8; ++j) c += (t[i * 8 + j] > 0) << j;\n        out[op++] = c;\n    }\n    ip = in;\n    c = pc = -1;\n    run = 0;\n    do {\n        c = ip < in_end ? *ip++ : -1;\n        if (c == pc)\n            ++run;\n        else if (run > 0 && t[pc] > 0) {\n            out[op++] = pc;\n            for (; run > 255; run -= 255) out[op++] = 255;\n            out[op++] = run - 1;\n            run = 1;\n        } else\n            for (++run; run > 1; --run) out[op++] = pc;\n        pc = c;\n    } while (c != -1);\n\n    return op;\n}\n\nstatic void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}\n\n/* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */\n\ntypedef struct {\n    /* Input/output. */\n    u8 *in_queue, *out_queue;\n    s32 input_ptr, output_ptr, input_max;\n\n    /* C0, C1 - used for making the initial prediction, C2 used for an APM with a slightly low\n       learning rate (6) and 512 contexts. kanzi merges C0 and C1, uses slightly different\n       counter initialisation code and prediction code which from my tests tends to be suboptimal. */\n    u16 C0[256], C1[256][256], C2[512][17];\n} state;\n\n#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)\n#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)\n\n#define update0(p, x) (p) = ((p) - ((p) >> x))\n#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))\n\nstatic void begin(state * s) {\n    prefetch(s);\n    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;\n    for (int i = 0; i < 256; i++)\n        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 256; j++)\n            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.\n}\n\nstatic void encode_bytes(state * s, u8 * buf, s32 size) {\n    /* Arithmetic coding, detecting runs of characters in the file */\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;\n\n    for (s32 i = 0; i < size; i++) {\n        u8 c = buf[i];\n\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            if (c & 128) {\n                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;\n\n                // Write identical bits.\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);  // Same as high >> 24\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n\n            c <<= 1;\n        }\n\n        c2 = c1;\n        c1 = ctx & 255;\n    }\n\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n}\n\nstatic void decode_bytes(state * s, u8 * c, s32 size) {\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;\n\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n\n    for (s32 i = 0; i < size; i++) {\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n            const u8 bit = code <= mid;\n            if (bit)\n                high = mid;\n            else\n                low = mid + 1;\n            while ((low ^ high) < (1 << 24)) {\n                low <<= 8;\n                high = (high << 8) + 255;\n                code = (code << 8) + read_in(s);\n            }\n\n            if (bit) {\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n        }\n\n        c2 = c1;\n        c[i] = c1 = ctx & 255;\n    }\n}\n\n/* Public API. */\n\nstruct bz3_state {\n    u8 * swap_buffer;\n    s32 block_size;\n    s32 *sais_array, *lzp_lut;\n    state * cm_state;\n    s8 last_error;\n};\n\nBZIP3_API s8 bz3_last_error(struct bz3_state * state) { return state->last_error; }\n\nBZIP3_API const char * bz3_version(void) { return VERSION; }\n\nBZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\n\nBZIP3_API const char * bz3_strerror(struct bz3_state * state) {\n    switch (state->last_error) {\n        case BZ3_OK:\n            return \"No error\";\n        case BZ3_ERR_OUT_OF_BOUNDS:\n            return \"Data index out of bounds\";\n        case BZ3_ERR_BWT:\n            return \"Burrows-Wheeler transform failed\";\n        case BZ3_ERR_CRC:\n            return \"CRC32 check failed\";\n        case BZ3_ERR_MALFORMED_HEADER:\n            return \"Malformed header\";\n        case BZ3_ERR_TRUNCATED_DATA:\n            return \"Truncated data\";\n        case BZ3_ERR_DATA_TOO_BIG:\n            return \"Too much data\";\n        default:\n            return \"Unknown error\";\n    }\n}\n\nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n\n    if (!bz3_state) {\n        return NULL;\n    }\n\n    bz3_state->cm_state = malloc(sizeof(state));\n\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n\n    bz3_state->block_size = block_size;\n\n    bz3_state->last_error = BZ3_OK;\n\n    return bz3_state;\n}\n\nBZIP3_API void bz3_free(struct bz3_state * state) {\n    free(state->swap_buffer);\n    free(state->sais_array);\n    free(state->cm_state);\n    free(state->lzp_lut);\n    free(state);\n}\n\n#define swap(x, y)    \\\n    {                 \\\n        u8 * tmp = x; \\\n        x = y;        \\\n        y = tmp;      \\\n    }\n\nBZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    if (data_size > state->block_size) {\n        state->last_error = BZ3_ERR_DATA_TOO_BIG;\n        return -1;\n    }\n\n    u32 crc32 = crc32sum(1, b1, data_size);\n\n    // Ignore small blocks. They won't benefit from the entropy coding step.\n    if (data_size < 64) {\n        memmove(b1 + 8, b1, data_size);\n        write_neutral_s32(b1, crc32);\n        write_neutral_s32(b1 + 4, -1);\n        return data_size + 8;\n    }\n\n    // Back to front:\n    // bit 1: lzp | no lzp\n    // bit 2: srt | no srt\n    s8 model = 0;\n    s32 lzp_size, rle_size;\n\n    rle_size = mrlec(b1, data_size, b2);\n    if (rle_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = rle_size;\n        model |= 4;\n    }\n\n    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);\n    if (lzp_size > 0 && lzp_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = lzp_size;\n        model |= 2;\n    }\n\n    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);\n    if (bwt_idx < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n\n    // Compute the amount of overhead dwords.\n    s32 overhead = 2;           // CRC32 + BWT index\n    if (model & 2) overhead++;  // LZP\n    if (model & 4) overhead++;  // RLE\n\n    begin(state->cm_state);\n    state->cm_state->out_queue = b1 + overhead * 4 + 1;\n    state->cm_state->output_ptr = 0;\n    encode_bytes(state->cm_state, b2, data_size);\n    data_size = state->cm_state->output_ptr;\n\n    // Write the header. Starting with common entries.\n    write_neutral_s32(b1, crc32);\n    write_neutral_s32(b1 + 4, bwt_idx);\n    b1[8] = model;\n\n    s32 p = 0;\n    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);\n    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);\n\n    state->last_error = BZ3_OK;\n\n    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);\n\n    return data_size + overhead * 4 + 1;\n}\n\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n\n        memmove(buffer, buffer + 8, data_size - 8);\n\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n\n        return data_size - 8;\n    }\n\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n\n    p += 2;\n\n    data_size -= p * 4 + 1;\n\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n\n    s32 size_src;\n\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n\n    if (model & 4) {\n        mrled(b1, b2, orig_size);\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n\n    state->last_error = BZ3_OK;\n\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n\n    return size_src;\n}\n\n#undef swap\n\n#ifdef PTHREAD\n\n    #include <pthread.h>\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n} encode_thread_msg;\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n    s32 orig_size;\n} decode_thread_msg;\n\nstatic void * bz3_init_encode_thread(void * _msg) {\n    encode_thread_msg * msg = _msg;\n    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nstatic void * bz3_init_decode_thread(void * _msg) {\n    decode_thread_msg * msg = _msg;\n    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nBZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {\n    encode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;\n}\n\nBZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {\n    decode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        messages[i].orig_size = orig_sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n}\n\n#endif\n\n/* High level API implementations. */\n\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        bz3_free(state);\n        free(compression_buf);\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n\n    out[0] = 'B';\n    out[1] = 'Z';\n    out[2] = '3';\n    out[3] = 'v';\n    out[4] = '1';\n    write_neutral_s32(out + 5, block_size);\n    write_neutral_s32(out + 9, n_blocks);\n    *out_size += 13;\n\n    // Compress and write the blocks.\n    for (u32 i = 0; i < n_blocks; i++) {\n        s32 size = block_size;\n        if (i == n_blocks - 1) size = in_size % block_size;\n        memcpy(compression_buf, in, size);\n        s32 out_size_block = bz3_encode_block(state, compression_buf, size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size + 8, compression_buf, out_size_block);\n        write_neutral_s32(out + *out_size, out_size_block);\n        write_neutral_s32(out + *out_size + 4, size);\n        *out_size += out_size_block + 8;\n    }\n\n    bz3_free(state);\n    free(compression_buf);\n    return BZ3_OK;\n}\n\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    u32 n_blocks = read_neutral_s32(in + 9);\n    in_size -= 13;\n    in += 13;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    for (u32 i = 0; i < n_blocks; i++) {\n        if (in_size < 8) {\n        malformed_header:\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_MALFORMED_HEADER;\n        }\n        s32 size = read_neutral_s32(in);\n        if (size < 0 || size > block_size) goto malformed_header;\n        if (in_size < size + 8) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_TRUNCATED_DATA;\n        }\n        s32 orig_size = read_neutral_s32(in + 4);\n        if (orig_size < 0) goto malformed_header;\n        if (buf_max < *out_size + orig_size) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_DATA_TOO_BIG;\n        }\n        memcpy(compression_buf, in + 8, size);\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size, compression_buf, orig_size);\n        *out_size += orig_size;\n        in += size + 8;\n        in_size -= size + 8;\n    }\n\n    bz3_free(state);\n    return BZ3_OK;\n}\n\nFile number 2:\n#include <ctype.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#ifdef HAVE_GETOPT_LONG\n    #include <getopt.h>\n#else\n    #include \"getopt-shim.h\"\n#endif\n#if defined __MSVCRT__\n    #include <fcntl.h>\n    #include <io.h>\n#endif\n#include \"common.h\"\n#include \"libbz3.h\"\n#define MODE_DECODE 0\n#define MODE_ENCODE 1\n#define MODE_TEST 2\nstatic void version() {\n    fprintf(stdout, \"bzip3 \" VERSION\n                    \"\\n\"\n                    \"Copyright (C) by Kamila Szewczyk, 2022.\\n\"\n                    \"License: GNU Lesser GPL version 3 <https://www.gnu.org/licenses/lgpl-3.0.en.html>\\n\");\n}\nstatic void help() {\n    fprintf(stdout,\n            \"bzip3 - better and stronger spiritual successor to bzip2.\\n\"\n            \"Usage: bzip3 [-e/-z/-d/-t/-c/-h/-V] [-b block_size] [-j jobs] files...\\n\"\n            \"Operations:\\n\"\n            \"  -e/-z, --encode   compress data (default)\\n\"\n            \"  -d, --decode      decompress data\\n\"\n            \"  -t, --test        verify validity of compressed data\\n\"\n            \"  -h, --help        display an usage overview\\n\"\n            \"  -f, --force       force overwriting output if it already exists\\n\"\n            \"  -k, --keep        keep (don't delete) input files (default)\\n\"\n            \"  -v, --verbose     verbose mode (display more information)\\n\"\n            \"  -V, --version     display version information\\n\"\n            \"Extra flags:\\n\"\n            \"  -c, --stdout      force writing to standard output\\n\"\n            \"  -b N, --block=N   set block size in MiB {16}\\n\"\n            \"  -B, --batch       process all files specified as inputs\\n\"\n#ifdef PTHREAD\n            \"  -j N, --jobs=N    set the amount of parallel threads\\n\"\n#endif\n            \"\\n\"\n            \"Report bugs to: https://github.com/kspalaiologos/bzip3\\n\");\n}\nstatic void xwrite(const void * data, size_t size, size_t len, FILE * des) {\n    if (fwrite(data, size, len, des) != len) {\n        fprintf(stderr, \"Write error: %s\\n\", strerror(errno));\n        exit(1);\n    }\n}\nstatic size_t xread(void * data, size_t size, size_t len, FILE * des) {\n    size_t written = fread(data, size, len, des);\n    if (ferror(des)) {\n        fprintf(stderr, \"Read error: %s\\n\", strerror(errno));\n        exit(1);\n    }\n    return written;\n}\nstatic size_t xread_eofcheck(void * data, size_t size, size_t len, FILE * des) {\n    size_t written = xread(data, size, len, des);\n    if (!written) return 0;\n    if (feof(des)) {\n        fprintf(stderr, \"Error: Corrupt file\\n\");\n        exit(1);\n    }\n    return written;\n}\nstatic void xread_noeof(void * data, size_t size, size_t len, FILE * des) {\n    if (!xread_eofcheck(data, size, len, des)) {\n        fprintf(stderr, \"Error: Corrupt file\\n\");\n        exit(1);\n    }\n}\nstatic void close_out_file(FILE * des) {\n    if (des) {\n        int outfd = fileno(des);\n        if (fflush(des)) {\n            fprintf(stderr, \"Error: Failed on fflush: %s\\n\", strerror(errno));\n            exit(1);\n        }\n#ifdef __linux__\n        while (1) {\n            int status = fsync(outfd);\n            if (status == -1) {\n                if (errno == EINVAL) break;\n                if (errno == EINTR) continue;\n                fprintf(stderr, \"Error: Failed on fsync: %s\\n\", strerror(errno));\n                exit(1);\n            }\n            break;\n        }\n#endif\n        if (des != stdout && fclose(des)) {\n            fprintf(stderr, \"Error: Failed on fclose: %s\\n\", strerror(errno));\n            exit(1);\n        }\n    }\n}\nstatic int process(FILE * input_des, FILE * output_des, int mode, int block_size, int workers, int verbose, char * file_name) {\n    uint64_t bytes_read = 0, bytes_written = 0;\n    if ((mode == MODE_ENCODE && isatty(fileno(output_des))) ||\n        ((mode == MODE_DECODE || mode == MODE_TEST) && isatty(fileno(input_des)))) {\n        fprintf(stderr, \"Refusing to read/write binary data from/to the terminal.\\n\");\n        return 1;\n    }\n    // Reset errno after the isatty() call.\n    errno = 0;\n    u8 byteswap_buf[4];\n    switch (mode) {\n        case MODE_ENCODE:\n            xwrite(\"BZ3v1\", 5, 1, output_des);\n            write_neutral_s32(byteswap_buf, block_size);\n            xwrite(byteswap_buf, 4, 1, output_des);\n            bytes_written += 9;\n            break;\n        case MODE_DECODE:\n        case MODE_TEST: {\n            char signature[5];\n            if (xread(signature, 5, 1, input_des) != 1 || strncmp(signature, \"BZ3v1\", 5) != 0) {\n                fprintf(stderr, \"Invalid signature.\\n\");\n                return 1;\n            }\n            xread_noeof(byteswap_buf, 4, 1, input_des);\n            block_size = read_neutral_s32(byteswap_buf);\n            if (block_size < KiB(65) || block_size > MiB(511)) {\n                fprintf(stderr,\n                        \"The input file is corrupted. Reason: Invalid block \"\n                        \"size in the header.\\n\");\n                return 1;\n            }\n            bytes_read += 9;\n            break;\n        }\n    }\n#ifdef PTHREAD\n    if (workers > 64 || workers < 0) {\n        fprintf(stderr, \"Number of workers must be between 0 and 64.\\n\");\n        return 1;\n    }\n    if (workers <= 1) {\n#endif\n        struct bz3_state * state = bz3_new(block_size);\n        if (state == NULL) {\n            fprintf(stderr, \"Failed to create a block encoder state.\\n\");\n            return 1;\n        }\n        u8 * buffer = malloc(block_size + block_size / 50 + 32);\n        if (!buffer) {\n            fprintf(stderr, \"Failed to allocate memory.\\n\");\n            return 1;\n        }\n        if (mode == MODE_ENCODE) {\n            s32 read_count;\n            while (!feof(input_des)) {\n                read_count = xread(buffer, 1, block_size, input_des);\n                bytes_read += read_count;\n                if(read_count == 0)\n                    break;\n                s32 new_size = bz3_encode_block(state, buffer, read_count);\n                if (new_size == -1) {\n                    fprintf(stderr, \"Failed to encode a block: %s\\n\", bz3_strerror(state));\n                    return 1;\n                }\n                write_neutral_s32(byteswap_buf, new_size);\n                xwrite(byteswap_buf, 4, 1, output_des);\n                write_neutral_s32(byteswap_buf, read_count);\n                xwrite(byteswap_buf, 4, 1, output_des);\n                xwrite(buffer, new_size, 1, output_des);\n                bytes_written += 8 + new_size;\n            }\n            fflush(output_des);\n        } else if (mode == MODE_DECODE) {\n            s32 new_size, old_size;\n            while (!feof(input_des)) {\n                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;\n                new_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(&byteswap_buf, 1, 4, input_des);\n                old_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(buffer, 1, new_size, input_des);\n                bytes_read += 8 + new_size;\n                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n                    fprintf(stderr, \"Failed to decode a block: %s\\n\", bz3_strerror(state));\n                    return 1;\n                }\n                xwrite(buffer, old_size, 1, output_des);\n                bytes_written += old_size;\n            }\n            fflush(output_des);\n        } else if (mode == MODE_TEST) {\n            s32 new_size, old_size;\n            while (!feof(input_des)) {\n                if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;\n                new_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(&byteswap_buf, 1, 4, input_des);\n                old_size = read_neutral_s32(byteswap_buf);\n                xread_noeof(buffer, 1, new_size, input_des);\n                bytes_read += 8 + new_size;\n                if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n                    fprintf(stderr, \"Failed to decode a block: %s\\n\", bz3_strerror(state));\n                    return 1;\n                }\n            }\n        }\n        if (bz3_last_error(state) != BZ3_OK) {\n            fprintf(stderr, \"Failed to read data: %s\\n\", bz3_strerror(state));\n            return 1;\n        }\n        free(buffer);\n        bz3_free(state);\n#ifdef PTHREAD\n    } else {\n        struct bz3_state * states[workers];\n        u8 * buffers[workers];\n        s32 sizes[workers];\n        s32 old_sizes[workers];\n        for (s32 i = 0; i < workers; i++) {\n            states[i] = bz3_new(block_size);\n            if (states[i] == NULL) {\n                fprintf(stderr, \"Failed to create a block encoder state.\\n\");\n                return 1;\n            }\n            buffers[i] = malloc(block_size + block_size / 50 + 32);\n            if (!buffers[i]) {\n                fprintf(stderr, \"Failed to allocate memory.\\n\");\n                return 1;\n            }\n        }\n        if (mode == MODE_ENCODE) {\n            while (!feof(input_des)) {\n                s32 i = 0;\n                for (; i < workers; i++) {\n                    size_t read_count = xread(buffers[i], 1, block_size, input_des);\n                    bytes_read += read_count;\n                    sizes[i] = old_sizes[i] = read_count;\n                    if (read_count < block_size) {\n                        i++;\n                        break;\n                    }\n                }\n                bz3_encode_blocks(states, buffers, sizes, i);\n                for (s32 j = 0; j < i; j++) {\n                    if (bz3_last_error(states[j]) != BZ3_OK) {\n                        fprintf(stderr, \"Failed to encode data: %s\\n\", bz3_strerror(states[j]));\n                        return 1;\n                    }\n                }\n                for (s32 j = 0; j < i; j++) {\n                    write_neutral_s32(byteswap_buf, sizes[j]);\n                    xwrite(byteswap_buf, 4, 1, output_des);\n                    write_neutral_s32(byteswap_buf, old_sizes[j]);\n                    xwrite(byteswap_buf, 4, 1, output_des);\n                    xwrite(buffers[j], sizes[j], 1, output_des);\n                    bytes_written += 8 + sizes[j];\n                }\n            }\n            fflush(output_des);\n        } else if (mode == MODE_DECODE) {\n            while (!feof(input_des)) {\n                s32 i = 0;\n                for (; i < workers; i++) {\n                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;\n                    sizes[i] = read_neutral_s32(byteswap_buf);\n                    xread_noeof(&byteswap_buf, 1, 4, input_des);\n                    old_sizes[i] = read_neutral_s32(byteswap_buf);\n                    xread_noeof(buffers[i], 1, sizes[i], input_des);\n                    bytes_read += 8 + sizes[i];\n                }\n                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);\n                for (s32 j = 0; j < i; j++) {\n                    if (bz3_last_error(states[j]) != BZ3_OK) {\n                        fprintf(stderr, \"Failed to decode data: %s\\n\", bz3_strerror(states[j]));\n                        return 1;\n                    }\n                }\n                for (s32 j = 0; j < i; j++) {\n                    xwrite(buffers[j], old_sizes[j], 1, output_des);\n                    bytes_written += old_sizes[j];\n                }\n            }\n            fflush(output_des);\n        } else if (mode == MODE_TEST) {\n            while (!feof(input_des)) {\n                s32 i = 0;\n                for (; i < workers; i++) {\n                    if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) break;\n                    sizes[i] = read_neutral_s32(byteswap_buf);\n                    xread_noeof(&byteswap_buf, 1, 4, input_des);\n                    old_sizes[i] = read_neutral_s32(byteswap_buf);\n                    xread_noeof(buffers[i], 1, sizes[i], input_des);\n                    bytes_read += 8 + sizes[i];\n                }\n                bz3_decode_blocks(states, buffers, sizes, old_sizes, i);\n                for (s32 j = 0; j < i; j++) {\n                    if (bz3_last_error(states[j]) != BZ3_OK) {\n                        fprintf(stderr, \"Failed to decode data: %s\\n\", bz3_strerror(states[j]));\n                        return 1;\n                    }\n                }\n            }\n        }\n        for (s32 i = 0; i < workers; i++) {\n            free(buffers[i]);\n            bz3_free(states[i]);\n        }\n    }\n#endif\n    if(verbose) {\n        if(file_name) fprintf(stderr, \" %s:\", file_name);\n        if(mode == MODE_ENCODE)\n            fprintf(stderr, \"\\t%\"PRIu64\" -> %\"PRIu64\" bytes, %.2f%%, %.2f bpb\\n\", bytes_read, bytes_written, (double)bytes_written * 100.0 / bytes_read, (double)bytes_written * 8.0 / bytes_read);\n        else if(mode == MODE_DECODE)\n            fprintf(stderr, \"\\t%\"PRIu64\" -> %\"PRIu64\" bytes, %.2f%%, %.2f bpb\\n\", bytes_read, bytes_written, (double)bytes_read * 100.0 / bytes_written, (double)bytes_read * 8.0 / bytes_written);\n        else\n            fprintf(stderr, \"OK, %\"PRIu64\" bytes read.\\n\", bytes_read);\n    }\n    return 0;\n}\nstatic int is_dir(const char * path) {\n    struct stat sb;\n    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) return 1;\n    return 0;\n}\nstatic int is_numeric(const char * str) {\n    for (; *str; str++)\n        if (!isdigit(*str)) return 0;\n    return 1;\n}\nstatic FILE * open_output(char * output, int force) {\n    FILE * output_des = NULL;\n    if (output != NULL) {\n        if (is_dir(output)) {\n            fprintf(stderr, \"Error: output file `%s' is a directory.\\n\", output);\n            exit(1);\n        }\n        if (access(output, F_OK) == 0) {\n            if (!force) {\n                fprintf(stderr, \"Error: output file `%s' already exists. Use -f to force overwrite.\\n\", output);\n                exit(1);\n            }\n        }\n        output_des = fopen(output, \"wb\");\n        if (output_des == NULL) {\n            fprintf(stderr, \"Error: failed to open output file `%s': %s\\n\", output, strerror(errno));\n            exit(1);\n        }\n    } else {\n        output_des = stdout;\n    }\n    return output_des;\n}\nstatic FILE * open_input(char * input) {\n    FILE * input_des = NULL;\n    if (input != NULL) {\n        if (is_dir(input)) {\n            fprintf(stderr, \"Error: input `%s' is a directory.\\n\", input);\n            exit(1);\n        }\n        input_des = fopen(input, \"rb\");\n        if (input_des == NULL) {\n            fprintf(stderr, \"Error: failed to open input file `%s': %s\\n\", input, strerror(errno));\n            exit(1);\n        }\n    } else {\n        input_des = stdin;\n    }\n    return input_des;\n}\nint main(int argc, char * argv[]) {\n    int mode = MODE_ENCODE;\n    // input and output file names\n    char *input = NULL, *output = NULL;\n    char *f1 = NULL, *f2 = NULL;\n    int force = 0;\n    // command line arguments\n    int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;\n    // the block size\n    u32 block_size = MiB(16);\n#ifdef PTHREAD\n    const char * short_options = \"Bb:cdefhj:ktvVz\";\n#else\n    const char * short_options = \"Bb:cdefhktvVz\";\n#endif\n    static struct option long_options[] = { { \"encode\", no_argument, 0, 'e' },\n                                            { \"decode\", no_argument, 0, 'd' },\n                                            { \"test\", no_argument, 0, 't' },\n                                            { \"stdout\", no_argument, 0, 'c' },\n                                            { \"force\", no_argument, 0, 'f' },\n                                            { \"help\", no_argument, 0, 'h' },\n                                            { \"keep\", no_argument, 0, 'k' },\n                                            { \"version\", no_argument, 0, 'V' },\n                                            { \"verbose\", no_argument, 0, 'v' },\n                                            { \"block\", required_argument, 0, 'b' },\n                                            { \"batch\", no_argument, 0, 'B' },\n#ifdef PTHREAD\n                                            { \"jobs\", required_argument, 0, 'j' },\n#endif\n                                            { 0, 0, 0, 0 } };\n    while (1) {\n        int option_index = 0;\n        int c = getopt_long(argc, argv, short_options, long_options, &option_index);\n        if (c == -1) break;\n        switch (c) {\n            case '?':\n                fprintf(stderr, \"Try 'bzip3 --help' for more information.\\n\");\n                return 1;\n            case 'e': case 'z':\n                mode = MODE_ENCODE;\n                break;\n            case 'd':\n                mode = MODE_DECODE;\n                break;\n            case 't':\n                mode = MODE_TEST;\n                break;\n            case 'c':\n                force_stdstreams = 1;\n                break;\n            case 'f':\n                force = 1;\n                break;\n            case 'k':\n                break;\n            case 'h':\n                help();\n                return 0;\n            case 'V':\n                version();\n                return 0;\n            case 'B':\n                batch = 1;\n                break;\n            case 'v':\n                verbose = 1;\n                break;\n            case 'b':\n                if (!is_numeric(optarg)) {\n                    fprintf(stderr, \"bzip3: invalid block size: %s\\n\", optarg);\n                    return 1;\n                }\n                block_size = MiB(atoi(optarg));\n                break;\n#ifdef PTHREAD\n            case 'j':\n                if (!is_numeric(optarg)) {\n                    fprintf(stderr, \"bzip3: invalid amount of jobs: %s\\n\", optarg);\n                    return 1;\n                }\n                workers = atoi(optarg);\n                break;\n#endif\n        }\n    }\n#if defined(__MSVCRT__)\n    setmode(STDIN_FILENO, O_BINARY);\n    setmode(STDOUT_FILENO, O_BINARY);\n#endif\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        fprintf(stderr, \"Block size must be between 65 KiB and 511 MiB.\\n\");\n        return 1;\n    }\n    if (batch) {\n        switch (mode) {\n            case MODE_ENCODE:\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    char * output_name;\n                    if (force_stdstreams)\n                        output_name = NULL;\n                    else {\n                        output_name = malloc(strlen(arg) + 5);\n                        strcpy(output_name, arg);\n                        strcat(output_name, \".bz3\");\n                    }\n                    FILE * output_des = open_output(output_name, force);\n                    process(input_des, output_des, mode, block_size, workers, verbose, arg);\n                    fclose(input_des);\n                    close_out_file(output_des);\n                    if (!force_stdstreams) free(output_name);\n                }\n                break;\n            case MODE_DECODE:\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    char * output_name;\n                    if (force_stdstreams)\n                        output_name = NULL;\n                    else {\n                        output_name = malloc(strlen(arg) + 1);\n                        strcpy(output_name, arg);\n                        if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, \".bz3\"))\n                            output_name[strlen(output_name) - 4] = 0;\n                        else {\n                            fprintf(stderr, \"Warning: file %s has an unknown extension, skipping.\\n\", arg);\n                            return 1;\n                        }\n                    }\n                    FILE * output_des = open_output(output_name, force);\n                    process(input_des, output_des, mode, block_size, workers, verbose, arg);\n                    fclose(input_des);\n                    close_out_file(output_des);\n                    if (!force_stdstreams) free(output_name);\n                }\n                break;\n            case MODE_TEST:\n                while (optind < argc) {\n                    char * arg = argv[optind++];\n                    FILE * input_des = open_input(arg);\n                    process(input_des, NULL, mode, block_size, workers, verbose, arg);\n                    fclose(input_des);\n                }\n                break;\n        }\n        if (fclose(stdout)) {\n            fprintf(stderr, \"Error: Failed on fclose(stdout): %s\\n\", strerror(errno));\n            return 1;\n        }\n        return 0;\n    }\n    while (optind < argc) {\n        // Positional argument. Likely a file name.\n        char * arg = argv[optind++];\n        if (f1 != NULL && f2 != NULL) {\n            fprintf(stderr, \"Error: too many files specified.\\n\");\n            return 1;\n        }\n        if (f1 == NULL)\n            f1 = arg;\n        else\n            f2 = arg;\n    }\n    if (f1 == NULL && f2 == NULL)\n        input = NULL, output = NULL;\n    else if (mode == MODE_TEST)\n        input = f1;\n    else {\n        if (mode == MODE_ENCODE) {\n            if (f2 == NULL) {\n                // encode from f1?\n                input = f1;\n                if (force_stdstreams)\n                    output = NULL;\n                else {\n                    output = malloc(strlen(f1) + 5);\n                    strcpy(output, f1);\n                    strcat(output, \".bz3\");\n                }\n            } else {\n                // encode from f1 to f2.\n                input = f1;\n                output = f2;\n            }\n        } else if (mode == MODE_DECODE) {\n            if (f2 == NULL) {\n                // decode from f1 to stdout.\n                input = f1;\n                if (force_stdstreams)\n                    output = NULL;\n                else {\n                    output = malloc(strlen(f1) + 1);\n                    strcpy(output, f1);\n                    if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, \".bz3\"))\n                        output[strlen(output) - 4] = 0;\n                    else {\n                        fprintf(stderr, \"Warning: file %s has an unknown extension, skipping.\\n\", f1);\n                        return 1;\n                    }\n                }\n            } else {\n                // decode from f1 to f2.\n                input = f1;\n                output = f2;\n            }\n        }\n    }\n    FILE *input_des = NULL, *output_des = NULL;\n    output_des = mode != MODE_TEST ? open_output(output, force) : NULL;\n    input_des = open_input(input);\n    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);\n    fclose(input_des);\n    close_out_file(output_des);\n    if (fclose(stdout)) {\n        fprintf(stderr, \"Error: Failed on fclose(stdout): %s\\n\", strerror(errno));\n        return 1;\n    }\n    return r;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_11329.c",
        "project": "kspalaiologos/bzip3",
        "url": "https://github.com/kspalaiologos/bzip3/commit/aae16d107f804f69000c09cd92027a140968cc9d",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int usbhid_parse(struct hid_device *hid)\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tunsigned int rsize = 0;\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t}\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t}\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n#include \"usbhid.h\"\n#define DRIVER_DESC \"USB HID core driver\"\nstatic unsigned int hid_mousepoll_interval;\nmodule_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);\nMODULE_PARM_DESC(mousepoll, \"Polling interval of mice\");\nstatic unsigned int hid_jspoll_interval;\nmodule_param_named(jspoll, hid_jspoll_interval, uint, 0644);\nMODULE_PARM_DESC(jspoll, \"Polling interval of joysticks\");\nstatic unsigned int ignoreled;\nmodule_param_named(ignoreled, ignoreled, uint, 0644);\nMODULE_PARM_DESC(ignoreled, \"Autosuspend with active leds\");\nstatic char *quirks_param[MAX_USBHID_BOOT_QUIRKS];\nmodule_param_array_named(quirks, quirks_param, charp, NULL, 0444);\nMODULE_PARM_DESC(quirks, \"Add/modify USB HID quirks by specifying \"\n\t\t\" quirks=vendorID:productID:quirks\"\n\t\t\" where vendorID, productID, and quirks are all in\"\n\t\t\" 0x-prefixed hex\");\nstatic void hid_io_error(struct hid_device *hid);\nstatic int hid_submit_out(struct hid_device *hid);\nstatic int hid_submit_ctrl(struct hid_device *hid);\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid);\nstatic void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t\n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\nstatic int usbhid_restart_out_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\tif ((kicked = (usbhid->outhead != usbhid->outtail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->outhead, usbhid->outtail);\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\t\tset_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_out(hid)) {\n\t\t\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\nstatic int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\tWARN_ON(hid == NULL);\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\tif ((kicked = (usbhid->ctrlhead != usbhid->ctrltail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->ctrlhead, usbhid->ctrltail);\n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\t\tset_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_ctrl(hid)) {\n\t\t\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\nstatic void hid_irq_in(struct urb *urb)\n{\n\tstruct hid_device\t*hid = urb->context;\n\tstruct usbhid_device\t*usbhid = hid->driver_data;\n\tint\t\t\tstatus;\n\tswitch (urb->status) {\n\tcase 0:\t\t\t\n\t\tusbhid->retry_delay = 0;\n\t\tif (!test_bit(HID_OPENED, &usbhid->iofl))\n\t\t\tbreak;\n\t\tusbhid_mark_busy(usbhid);\n\t\tif (!test_bit(HID_RESUME_RUNNING, &usbhid->iofl)) {\n\t\t\thid_input_report(urb->context, HID_INPUT_REPORT,\n\t\t\t\t\t urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length, 1);\n\t\t\tif (hid_check_keys_pressed(hid))\n\t\t\t\tset_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t\telse\n\t\t\t\tclear_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t}\n\t\tbreak;\n\tcase -EPIPE:\t\t\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tset_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tschedule_work(&usbhid->reset_work);\n\t\treturn;\n\tcase -ECONNRESET:\t\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\t\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\treturn;\n\tcase -EILSEQ:\t\t\n\tcase -EPROTO:\t\t\n\tcase -ETIME:\t\t\n\tcase -ETIMEDOUT:\t\n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\thid_io_error(hid);\n\t\treturn;\n\tdefault:\t\t\n\t\thid_warn(urb->dev, \"input irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tif (status != -EPERM) {\n\t\t\thid_err(hid, \"can't resubmit intr, %s-%s/input%d, status %d\\n\",\n\t\t\t\thid_to_usb_dev(hid)->bus->bus_name,\n\t\t\t\thid_to_usb_dev(hid)->devpath,\n\t\t\t\tusbhid->ifnum, status);\n\t\t\thid_io_error(hid);\n\t\t}\n\t}\n}\nstatic int hid_submit_ctrl(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tunsigned char dir;\n\tchar *raw_report;\n\tint len, r;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\treport = usbhid->ctrl[usbhid->ctrltail].report;\n\traw_report = usbhid->ctrl[usbhid->ctrltail].raw_report;\n\tdir = usbhid->ctrl[usbhid->ctrltail].dir;\n\tlen = ((report->size - 1) >> 3) + 1 + (report->id > 0);\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->urbctrl->pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tusbhid->urbctrl->transfer_buffer_length = len;\n\t\tif (raw_report) {\n\t\t\tmemcpy(usbhid->ctrlbuf, raw_report, len);\n\t\t\tkfree(raw_report);\n\t\t\tusbhid->ctrl[usbhid->ctrltail].raw_report = NULL;\n\t\t}\n\t} else {\n\t\tint maxpacket, padlen;\n\t\tusbhid->urbctrl->pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tmaxpacket = usb_maxpacket(hid_to_usb_dev(hid),\n\t\t\t\t\t  usbhid->urbctrl->pipe, 0);\n\t\tif (maxpacket > 0) {\n\t\t\tpadlen = DIV_ROUND_UP(len, maxpacket);\n\t\t\tpadlen *= maxpacket;\n\t\t\tif (padlen > usbhid->bufsize)\n\t\t\t\tpadlen = usbhid->bufsize;\n\t\t} else\n\t\t\tpadlen = 0;\n\t\tusbhid->urbctrl->transfer_buffer_length = padlen;\n\t}\n\tusbhid->urbctrl->dev = hid_to_usb_dev(hid);\n\tusbhid->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;\n\tusbhid->cr->bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT :\n\t\t\t\t\t\t      HID_REQ_GET_REPORT;\n\tusbhid->cr->wValue = cpu_to_le16(((report->type + 1) << 8) |\n\t\t\t\t\t report->id);\n\tusbhid->cr->wIndex = cpu_to_le16(usbhid->ifnum);\n\tusbhid->cr->wLength = cpu_to_le16(len);\n\tdbg_hid(\"submitting ctrl urb: %s wValue=0x%04x wIndex=0x%04x wLength=%u\\n\",\n\t\tusbhid->cr->bRequest == HID_REQ_SET_REPORT ? \"Set_Report\" :\n\t\t\t\t\t\t\t     \"Get_Report\",\n\t\tusbhid->cr->wValue, usbhid->cr->wIndex, usbhid->cr->wLength);\n\tr = usb_submit_urb(usbhid->urbctrl, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(ctrl) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_ctrl = jiffies;\n\treturn 0;\n}\nstatic void hid_irq_out(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\tint unplug = 0;\n\tswitch (urb->status) {\n\tcase 0:\t\t\t\n\t\tbreak;\n\tcase -ESHUTDOWN:\t\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t\n\tcase -EPROTO:\t\t\n\tcase -ECONNRESET:\t\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\t\t\n\t\thid_warn(urb->dev, \"output irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\tif (unplug) {\n\t\tusbhid->outtail = usbhid->outhead;\n\t} else {\n\t\tusbhid->outtail = (usbhid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);\n\t\tif (usbhid->outhead != usbhid->outtail &&\n\t\t\t\thid_submit_out(hid) == 0) {\n\t\t\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\nstatic void hid_ctrl(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint unplug = 0, status = urb->status;\n\tswitch (status) {\n\tcase 0:\t\t\t\n\t\tif (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)\n\t\t\thid_input_report(urb->context,\n\t\t\t\tusbhid->ctrl[usbhid->ctrltail].report->type,\n\t\t\t\turb->transfer_buffer, urb->actual_length, 0);\n\t\tbreak;\n\tcase -ESHUTDOWN:\t\n\t\tunplug = 1;\n\tcase -EILSEQ:\t\t\n\tcase -EPROTO:\t\t\n\tcase -ECONNRESET:\t\n\tcase -ENOENT:\n\tcase -EPIPE:\t\t\n\t\tbreak;\n\tdefault:\t\t\n\t\thid_warn(urb->dev, \"ctrl urb status %d received\\n\", status);\n\t}\n\tspin_lock(&usbhid->lock);\n\tif (unplug) {\n\t\tusbhid->ctrltail = usbhid->ctrlhead;\n\t} else {\n\t\tusbhid->ctrltail = (usbhid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);\n\t\tif (usbhid->ctrlhead != usbhid->ctrltail &&\n\t\t\t\thid_submit_ctrl(hid) == 0) {\n\t\t\tspin_unlock(&usbhid->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\tspin_unlock(&usbhid->lock);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\nstatic void __usbhid_submit_report(struct hid_device *hid, struct hid_report *report,\n\t\t\t\t   unsigned char dir)\n{\n\tint head;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tif (((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN) ||\n\t\ttest_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\treturn;\n\tif (usbhid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {\n\t\tif ((head = (usbhid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == usbhid->outtail) {\n\t\t\thid_warn(hid, \"output queue full\\n\");\n\t\t\treturn;\n\t\t}\n\t\tusbhid->out[usbhid->outhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->out[usbhid->outhead].raw_report) {\n\t\t\thid_warn(hid, \"output queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->out[usbhid->outhead].raw_report);\n\t\tusbhid->out[usbhid->outhead].report = report;\n\t\tusbhid->outhead = head;\n\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl)) {\n\t\t\tusbhid_restart_out_queue(usbhid);\n\t\t} else if (time_after(jiffies, usbhid->last_out + HZ * 5)) {\n\t\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\t\t\tusb_block_urb(usbhid->urbout);\n\t\t\tspin_unlock(&usbhid->lock);\n\t\t\tusb_unlink_urb(usbhid->urbout);\n\t\t\tspin_lock(&usbhid->lock);\n\t\t\tusb_unblock_urb(usbhid->urbout);\n\t\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\t\tusbhid_restart_out_queue(usbhid);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\treturn;\n\t}\n\tif ((head = (usbhid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == usbhid->ctrltail) {\n\t\thid_warn(hid, \"control queue full\\n\");\n\t\treturn;\n\t}\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->ctrl[usbhid->ctrlhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {\n\t\t\thid_warn(hid, \"control queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->ctrl[usbhid->ctrlhead].raw_report);\n\t}\n\tusbhid->ctrl[usbhid->ctrlhead].report = report;\n\tusbhid->ctrl[usbhid->ctrlhead].dir = dir;\n\tusbhid->ctrlhead = head;\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl)) {\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\t} else if (time_after(jiffies, usbhid->last_ctrl + HZ * 5)) {\n\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\t\tusb_block_urb(usbhid->urbctrl);\n\t\tspin_unlock(&usbhid->lock);\n\t\tusb_unlink_urb(usbhid->urbctrl);\n\t\tspin_lock(&usbhid->lock);\n\t\tusb_unblock_urb(usbhid->urbctrl);\n\t\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusbhid_restart_ctrl_queue(usbhid);\n\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t}\n}\nstatic int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tHID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,\n\t\tifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\nstatic int hid_get_class_descriptor(struct usb_device *dev, int ifnum,\n\t\tunsigned char type, void *buf, int size)\n{\n\tint result, retries = 4;\n\tmemset(buf, 0, size);\n\tdo {\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t(type << 8), ifnum, buf, size, USB_CTRL_GET_TIMEOUT);\n\t\tretries--;\n\t} while (result < size && retries);\n\treturn result;\n}\nstatic int usbhid_open(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint res;\n\tset_bit(HID_OPENED, &usbhid->iofl);\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL)\n\t\treturn 0;\n\tres = usb_autopm_get_interface(usbhid->intf);\n\tif (res < 0) {\n\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\treturn -EIO;\n\t}\n\tusbhid->intf->needs_remote_wakeup = 1;\n\tset_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\tres = hid_start_in(hid);\n\tif (res) {\n\t\tif (res != -ENOSPC) {\n\t\t\thid_io_error(hid);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\tres = -EBUSY;\n\t\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t\t}\n\t}\n\tusb_autopm_put_interface(usbhid->intf);\n\tif (res == 0)\n\t\tmsleep(50);\n\tclear_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\treturn res;\n}\nstatic int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,\n\t\t\t\t __u8 *buf, size_t count, unsigned char rtype)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ret, skipped_report_id = 0;\n\tif ((rtype == HID_OUTPUT_REPORT) &&\n\t    (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORT_ID))\n\t\tbuf[0] = 0;\n\telse\n\t\tbuf[0] = reportnum;\n\tif (buf[0] == 0x0) {\n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tHID_REQ_SET_REPORT,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t((rtype + 1) << 8) | reportnum,\n\t\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\treturn ret;\n}\nstatic int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\thid->quirks |= quirks;\n\treturn 0;\nerr:\n\treturn ret;\n}\nstatic int usbhid_start(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned int n, insize = 0;\n\tint ret;\n\tclear_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tusbhid->bufsize = HID_MIN_BUFFER_SIZE;\n\thid_find_max_report(hid, HID_INPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_OUTPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_FEATURE_REPORT, &usbhid->bufsize);\n\tif (usbhid->bufsize > HID_MAX_BUFFER_SIZE)\n\t\tusbhid->bufsize = HID_MAX_BUFFER_SIZE;\n\thid_find_max_report(hid, HID_INPUT_REPORT, &insize);\n\tif (insize > HID_MAX_BUFFER_SIZE)\n\t\tinsize = HID_MAX_BUFFER_SIZE;\n\tif (hid_alloc_buffers(dev, hid)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++) {\n\t\tstruct usb_endpoint_descriptor *endpoint;\n\t\tint pipe;\n\t\tint interval;\n\t\tendpoint = &interface->endpoint[n].desc;\n\t\tif (!usb_endpoint_xfer_int(endpoint))\n\t\t\tcontinue;\n\t\tinterval = endpoint->bInterval;\n\t\tif (hid->quirks & HID_QUIRK_FULLSPEED_INTERVAL &&\n\t\t    dev->speed == USB_SPEED_HIGH) {\n\t\t\tinterval = fls(endpoint->bInterval*8);\n\t\t\tpr_info(\"%s: Fixing fullspeed to highspeed interval: %d -> %d\\n\",\n\t\t\t\thid->name, endpoint->bInterval, interval);\n\t\t}\n\t\tswitch (hid->collection->usage) {\n\t\tcase HID_GD_MOUSE:\n\t\t\tif (hid_mousepoll_interval > 0)\n\t\t\t\tinterval = hid_mousepoll_interval;\n\t\t\tbreak;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\tif (hid_jspoll_interval > 0)\n\t\t\t\tinterval = hid_jspoll_interval;\n\t\t\tbreak;\n\t\t}\n\t\tret = -ENOMEM;\n\t\tif (usb_endpoint_dir_in(endpoint)) {\n\t\t\tif (usbhid->urbin)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbin = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbin, dev, pipe, usbhid->inbuf, insize,\n\t\t\t\t\t hid_irq_in, hid, interval);\n\t\t\tusbhid->urbin->transfer_dma = usbhid->inbuf_dma;\n\t\t\tusbhid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t} else {\n\t\t\tif (usbhid->urbout)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbout = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbout, dev, pipe, usbhid->outbuf, 0,\n\t\t\t\t\t hid_irq_out, hid, interval);\n\t\t\tusbhid->urbout->transfer_dma = usbhid->outbuf_dma;\n\t\t\tusbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t}\n\t}\n\tusbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usbhid->urbctrl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tusb_fill_control_urb(usbhid->urbctrl, dev, 0, (void *) usbhid->cr,\n\t\t\t     usbhid->ctrlbuf, 1, hid_ctrl, hid);\n\tusbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;\n\tusbhid->urbctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tset_bit(HID_STARTED, &usbhid->iofl);\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tret = usb_autopm_get_interface(usbhid->intf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 1;\n\t\tret = hid_start_in(hid);\n\t\tif (ret) {\n\t\t\tdev_err(&hid->dev,\n\t\t\t\t\"failed to start in urb: %d\\n\", ret);\n\t\t}\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t}\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &&\n\t\t\tinterface->desc.bInterfaceProtocol ==\n\t\t\t\tUSB_INTERFACE_PROTOCOL_KEYBOARD) {\n\t\tusbhid_set_leds(hid);\n\t\tdevice_set_wakeup_enable(&dev->dev, 1);\n\t}\n\treturn 0;\nfail:\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbout);\n\tusb_free_urb(usbhid->urbctrl);\n\tusbhid->urbin = NULL;\n\tusbhid->urbout = NULL;\n\tusbhid->urbctrl = NULL;\n\thid_free_buffers(dev, hid);\n\treturn ret;\n}\nstruct hid_ll_driver usb_hid_driver = {\n\t.parse = usbhid_parse,\n\t.start = usbhid_start,\n\t.stop = usbhid_stop,\n\t.open = usbhid_open,\n\t.close = usbhid_close,\n\t.power = usbhid_power,\n\t.request = usbhid_request,\n\t.wait = usbhid_wait_io,\n\t.raw_request = usbhid_raw_request,\n\t.output_report = usbhid_output_report,\n\t.idle = usbhid_idle,\n};\nstatic int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid;\n\tstruct hid_device *hid;\n\tunsigned int n, has_in = 0;\n\tsize_t len;\n\tint ret;\n\tdbg_hid(\"HID probe called for ifnum %d\\n\",\n\t\t\tintf->altsetting->desc.bInterfaceNumber);\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++)\n\t\tif (usb_endpoint_is_int_in(&interface->endpoint[n].desc))\n\t\t\thas_in++;\n\tif (!has_in) {\n\t\thid_err(intf, \"couldn't find an input interrupt endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\tusb_set_intfdata(intf, hid);\n\thid->ll_driver = &usb_hid_driver;\n\thid->ff_init = hid_pidff_init;\n#ifdef CONFIG_USB_HIDDEV\n\thid->hiddev_connect = hiddev_connect;\n\thid->hiddev_disconnect = hiddev_disconnect;\n\thid->hiddev_hid_event = hiddev_hid_event;\n\thid->hiddev_report_event = hiddev_report_event;\n#endif\n\thid->dev.parent = &intf->dev;\n\thid->bus = BUS_USB;\n\thid->vendor = le16_to_cpu(dev->descriptor.idVendor);\n\thid->product = le16_to_cpu(dev->descriptor.idProduct);\n\thid->name[0] = 0;\n\thid->quirks = usbhid_lookup_quirk(hid->vendor, hid->product);\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol ==\n\t\t\tUSB_INTERFACE_PROTOCOL_MOUSE)\n\t\thid->type = HID_TYPE_USBMOUSE;\n\telse if (intf->cur_altsetting->desc.bInterfaceProtocol == 0)\n\t\thid->type = HID_TYPE_USBNONE;\n\tif (dev->manufacturer)\n\t\tstrlcpy(hid->name, dev->manufacturer, sizeof(hid->name));\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(hid->name, \" \", sizeof(hid->name));\n\t\tstrlcat(hid->name, dev->product, sizeof(hid->name));\n\t}\n\tif (!strlen(hid->name))\n\t\tsnprintf(hid->name, sizeof(hid->name), \"HID %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\tusb_make_path(dev, hid->phys, sizeof(hid->phys));\n\tstrlcat(hid->phys, \"/input\", sizeof(hid->phys));\n\tlen = strlen(hid->phys);\n\tif (len < sizeof(hid->phys) - 1)\n\t\tsnprintf(hid->phys + len, sizeof(hid->phys) - len,\n\t\t\t \"%d\", intf->altsetting[0].desc.bInterfaceNumber);\n\tif (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)\n\t\thid->uniq[0] = 0;\n\tusbhid = kzalloc(sizeof(*usbhid), GFP_KERNEL);\n\tif (usbhid == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\thid->driver_data = usbhid;\n\tusbhid->hid = hid;\n\tusbhid->intf = intf;\n\tusbhid->ifnum = interface->desc.bInterfaceNumber;\n\tinit_waitqueue_head(&usbhid->wait);\n\tINIT_WORK(&usbhid->reset_work, hid_reset);\n\tsetup_timer(&usbhid->io_retry, hid_retry_timeout, (unsigned long) hid);\n\tspin_lock_init(&usbhid->lock);\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(intf, \"can't add hid device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\treturn 0;\nerr_free:\n\tkfree(usbhid);\nerr:\n\thid_destroy_device(hid);\n\treturn ret;\n}\nstatic int hid_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint status;\n\tchar *rdesc;\n\trdesc = kmalloc(hid->dev_rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\tstatus = hid_get_class_descriptor(dev,\n\t\t\t\tinterface->desc.bInterfaceNumber,\n\t\t\t\tHID_DT_REPORT, rdesc, hid->dev_rsize);\n\tif (status < 0) {\n\t\tdbg_hid(\"reading report descriptor failed (post_reset)\\n\");\n\t\tkfree(rdesc);\n\t\treturn status;\n\t}\n\tstatus = memcmp(rdesc, hid->dev_rdesc, hid->dev_rsize);\n\tkfree(rdesc);\n\tif (status != 0) {\n\t\tdbg_hid(\"report descriptor changed\\n\");\n\t\treturn -EPERM;\n\t}\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);\n\thid_restart_io(hid);\n\treturn 0;\n}\n#ifdef CONFIG_PM\nstatic int hid_resume_common(struct hid_device *hid, bool driver_suspended)\n{\n\tint status = 0;\n\thid_restart_io(hid);\n\tif (driver_suspended && hid->driver && hid->driver->resume)\n\t\tstatus = hid->driver->resume(hid);\n\treturn status;\n}\nstatic int hid_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint status = 0;\n\tbool driver_suspended = false;\n\tunsigned int ledcount;\n\tif (PMSG_IS_AUTO(message)) {\n\t\tledcount = hidinput_count_leds(hid);\n\t\tspin_lock_irq(&usbhid->lock);\t\n\t\tif (!test_bit(HID_RESET_PENDING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CLEAR_HALT, &usbhid->iofl)\n\t\t    && !test_bit(HID_OUT_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CTRL_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_KEYS_PRESSED, &usbhid->iofl)\n\t\t    && (!ledcount || ignoreled))\n\t\t{\n\t\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\tif (hid->driver && hid->driver->suspend) {\n\t\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tdriver_suspended = true;\n\t\t} else {\n\t\t\tusbhid_mark_busy(usbhid);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tif (hid->driver && hid->driver->suspend)\n\t\t\tstatus = hid->driver->suspend(hid, message);\n\t\tdriver_suspended = true;\n\t\tspin_lock_irq(&usbhid->lock);\n\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\tspin_unlock_irq(&usbhid->lock);\n\t\tif (usbhid_wait_io(hid) < 0)\n\t\t\tstatus = -EIO;\n\t}\n\thid_cancel_delayed_stuff(usbhid);\n\thid_cease_io(usbhid);\n\tif (PMSG_IS_AUTO(message) && test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {\n\t\tstatus = -EBUSY;\n\t\tgoto failed;\n\t}\n\tdev_dbg(&intf->dev, \"suspend\\n\");\n\treturn status;\n failed:\n\thid_resume_common(hid, driver_suspended);\n\treturn status;\n}\nstatic int hid_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata (intf);\n\tint status;\n\tstatus = hid_resume_common(hid, true);\n\tdev_dbg(&intf->dev, \"resume status %d\\n\", status);\n\treturn 0;\n}\nstatic int hid_reset_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tint status;\n\tstatus = hid_post_reset(intf);\n\tif (status >= 0 && hid->driver && hid->driver->reset_resume) {\n\t\tint ret = hid->driver->reset_resume(hid);\n\t\tif (ret < 0)\n\t\t\tstatus = ret;\n\t}\n\treturn status;\n}\n#endif \nstatic const struct usb_device_id hid_usb_ids[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n\t\t.bInterfaceClass = USB_INTERFACE_CLASS_HID },\n\t{ }\t\t\t\t\t\t\n};\nstatic struct usb_driver hid_driver = {\n\t.name =\t\t\"usbhid\",\n\t.probe =\tusbhid_probe,\n\t.disconnect =\tusbhid_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\thid_suspend,\n\t.resume =\thid_resume,\n\t.reset_resume =\thid_reset_resume,\n#endif\n\t.pre_reset =\thid_pre_reset,\n\t.post_reset =\thid_post_reset,\n\t.id_table =\thid_usb_ids,\n\t.supports_autosuspend = 1,\n};\nstatic int __init hid_init(void)\n{\n\tint retval = -ENOMEM;\n\tretval = usbhid_quirks_init(quirks_param);\n\tif (retval)\n\t\tgoto usbhid_quirks_init_fail;\n\tretval = usb_register(&hid_driver);\n\tif (retval)\n\t\tgoto usb_register_fail;\n\tpr_info(KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\treturn 0;\nusb_register_fail:\n\tusbhid_quirks_exit();\nusbhid_quirks_init_fail:\n\treturn retval;\n}\nstatic void __exit hid_exit(void)\n{\n\tusb_deregister(&hid_driver);\n\tusbhid_quirks_exit();\n}\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_2564.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int usb_console_setup(struct console *co, char *options)\n\tstruct tty_struct *tty = NULL;\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n/*\n * USB Serial Console driver\n *\n * Copyright (C) 2001 - 2002 Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * Thanks to Randy Dunlap for the original version of this code.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\n\n/*\n * ------------------------------------------------------------\n * USB Serial console driver\n *\n * Much of the code here is copied from drivers/char/serial.c\n * and implements a phony serial console in the same way that\n * serial.c does so that in case some software queries it,\n * it will get the same results.\n *\n * Things that are different from the way the serial port code\n * does things, is that we call the lower level usb-serial\n * driver code to initialize the device, and we set the initial\n * console speeds based on the command line arguments.\n * ------------------------------------------------------------\n */\n\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\n\n/*\n * The parsing of the command line works exactly like the\n * serial.c code, except that the specifier is \"ttyUSB\" instead\n * of \"ttyS\".\n */\nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\n\tif (count == 0)\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\t/* search for LF so we can insert CR if necessary */\n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* pass on to the driver specific version of this function if\n\t\t   it is available */\n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\t/* append CR after LF */\n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\n\nstatic struct tty_driver *usb_console_device(struct console *co, int *index)\n{\n\tstruct tty_driver **p = (struct tty_driver **)co->data;\n\n\tif (!*p)\n\t\treturn NULL;\n\n\t*index = co->index;\n\treturn *p;\n}\n\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n\nvoid usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}\n\nvoid usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t/*\n\t\t * Call register_console() if this is the first device plugged\n\t\t * in.  If we call it earlier, then the callback to\n\t\t * console_setup() will fail, as there is not a device seen by\n\t\t * the USB subsystem yet.\n\t\t */\n\t\t/*\n\t\t * Register console.\n\t\t * NOTES:\n\t\t * console_setup() is called (back) immediately (from\n\t\t * register_console). console_write() is called immediately\n\t\t * from register_console iff CON_PRINTBUFFER is set in flags.\n\t\t */\n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}\n\nvoid usb_serial_console_exit(void)\n{\n\tif (usbcons_info.port) {\n\t\tunregister_console(&usbcons);\n\t\tusbcons_info.port->port.console = 0;\n\t\tusbcons_info.port = NULL;\n\t}\n}\n\n\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_2567.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\tif (length == 0)\n\t\treturn 0;\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\t\tmemcpy(dest, src, length);\n\t}\n\tWARN_ON(!mem->map);\n\terr = mem_check_range(mem, iova, length);\n\tlookup_iova(mem, iova, &m, &i, &offset);\n\tbuf\t= map[0]->buf + i;\n\twhile (length > 0) {\n\t\tva\t= (u8 *)(uintptr_t)buf->addr + offset;\n\t\tsrc  = (dir == to_mem_obj) ? addr : va;\n\t\tdest = (dir == to_mem_obj) ? va : addr;\n\t\tbytes\t= buf->size - offset;\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\t\tif (crcp)\n\t\t\tcrc = crc32_le(crc, src, bytes);\n\t\tmemcpy(dest, src, bytes);\n\t\tlength\t-= bytes;\n\t\taddr\t+= bytes;\n\t\toffset\t= 0;\n\t\tbuf++;\n\t\tif (i == RXE_BUF_PER_MAP) {\n\t\t\tbuf = map[0]->buf;\n\t\t}\n\t}\n\tif (crcp)\n\t\t*crcp = crc;\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tif (length == 0)\n\t\treturn 0;\n\tif (length > resid) {\n\t}\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t}\n\t}\n\twhile (length > 0) {\n\t\tbytes = length;\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t}\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t}\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\nint mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\tif (iova < mem->iova ||\n\t\t    length > mem->length ||\n\t\t    iova > mem->iova + mem->length - length)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\n#define IB_ACCESS_REMOTE\t(IB_ACCESS_REMOTE_READ\t\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_WRITE\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_ATOMIC)\nint rxe_mem_init_user(struct rxe_dev *rxe, struct rxe_pd *pd, u64 start,\n\t\t      u64 length, u64 iova, int access, struct ib_udata *udata,\n\t\t      struct rxe_mem *mem)\n{\n\tint\t\t\tentry;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf = NULL;\n\tstruct ib_umem\t\t*umem;\n\tstruct scatterlist\t*sg;\n\tint\t\t\tnum_buf;\n\tvoid\t\t\t*vaddr;\n\tint err;\n\tumem = ib_umem_get(pd->ibpd.uobject->context, start, length, access, 0);\n\tif (IS_ERR(umem)) {\n\t\tpr_warn(\"err %d from rxe_umem_get\\n\",\n\t\t\t(int)PTR_ERR(umem));\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\tmem->umem = umem;\n\tnum_buf = umem->nmap;\n\trxe_mem_init(access, mem);\n\terr = rxe_mem_alloc(rxe, mem, num_buf);\n\tif (err) {\n\t\tpr_warn(\"err %d from rxe_mem_alloc\\n\", err);\n\t\tib_umem_release(umem);\n\t\tgoto err1;\n\t}\n\tWARN_ON(!is_power_of_2(umem->page_size));\n\tmem->page_shift\t\t= ilog2(umem->page_size);\n\tmem->page_mask\t\t= umem->page_size - 1;\n\tnum_buf\t\t\t= 0;\n\tmap\t\t\t= mem->map;\n\tif (length > 0) {\n\t\tbuf = map[0]->buf;\n\t\tfor_each_sg(umem->sg_head.sgl, sg, umem->nmap, entry) {\n\t\t\tvaddr = page_address(sg_page(sg));\n\t\t\tif (!vaddr) {\n\t\t\t\tpr_warn(\"null vaddr\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err1;\n\t\t\t}\n\t\t\tbuf->addr = (uintptr_t)vaddr;\n\t\t\tbuf->size = umem->page_size;\n\t\t\tnum_buf++;\n\t\t\tbuf++;\n\t\t\tif (num_buf >= RXE_BUF_PER_MAP) {\n\t\t\t\tmap++;\n\t\t\t\tbuf = map[0]->buf;\n\t\t\t\tnum_buf = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmem->pd\t\t\t= pd;\n\tmem->umem\t\t= umem;\n\tmem->access\t\t= access;\n\tmem->length\t\t= length;\n\tmem->iova\t\t= iova;\n\tmem->va\t\t\t= start;\n\tmem->offset\t\t= ib_umem_offset(umem);\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\treturn 0;\nerr1:\n\treturn err;\n}\nint rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\t\t enum copy_direction dir, u32 *crcp)\n{\n\tint\t\t\terr;\n\tint\t\t\tbytes;\n\tu8\t\t\t*va;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf;\n\tint\t\t\tm;\n\tint\t\t\ti;\n\tsize_t\t\t\toffset;\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\tif (length == 0)\n\t\treturn 0;\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tu8 *src, *dest;\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\t\tmemcpy(dest, src, length);\n\t\treturn 0;\n\t}\n\tWARN_ON(!mem->map);\n\terr = mem_check_range(mem, iova, length);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto err1;\n\t}\n\tlookup_iova(mem, iova, &m, &i, &offset);\n\tmap\t= mem->map + m;\n\tbuf\t= map[0]->buf + i;\n\twhile (length > 0) {\n\t\tu8 *src, *dest;\n\t\tva\t= (u8 *)(uintptr_t)buf->addr + offset;\n\t\tsrc  = (dir == to_mem_obj) ? addr : va;\n\t\tdest = (dir == to_mem_obj) ? va : addr;\n\t\tbytes\t= buf->size - offset;\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\t\tif (crcp)\n\t\t\tcrc = crc32_le(crc, src, bytes);\n\t\tmemcpy(dest, src, bytes);\n\t\tlength\t-= bytes;\n\t\taddr\t+= bytes;\n\t\toffset\t= 0;\n\t\tbuf++;\n\t\ti++;\n\t\tif (i == RXE_BUF_PER_MAP) {\n\t\t\ti = 0;\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t}\n\t}\n\tif (crcp)\n\t\t*crcp = crc;\n\treturn 0;\nerr1:\n\treturn err;\n}\nint copy_data(\n\tstruct rxe_dev\t\t*rxe,\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum copy_direction\tdir,\n\tu32\t\t\t*crcp)\n{\n\tint\t\t\tbytes;\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tu64\t\t\tiova;\n\tint\t\t\terr;\n\tif (length == 0)\n\t\treturn 0;\n\tif (length > resid) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\twhile (length > 0) {\n\t\tbytes = length;\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\trxe_drop_ref(mem);\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\tif (err)\n\t\t\t\tgoto err2;\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\tif (mem)\n\t\trxe_drop_ref(mem);\n\treturn 0;\nerr2:\n\tif (mem)\n\t\trxe_drop_ref(mem);\nerr1:\n\treturn err;\n}\n",
        "cwe": "CWE-190",
        "file_name": "safe_respovul_idx_1554.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n\tif (!zgfx || !stream || (segmentSize < 2))\n\t\treturn FALSE;\n\tcbSegment = segmentSize - 1;\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\tStream_Read_UINT8(stream, flags); \n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tif (!Stream_SafeSeek(stream, cbSegment))\n\t\treturn FALSE;\n\tif (!(flags & PACKET_COMPRESSED))\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\treturn TRUE;\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\tif (!stream)\n\t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t\tsize_t used = 0;\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount);     \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = aligned_zgfx_malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\t\t\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\t\t\tgoto fail;\n\t\t\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\t\t\tgoto fail;\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t\tused += zgfx->OutputCount;\n\t\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/bitstream.h>\n#include <freerdp/log.h>\n#include <freerdp/codec/zgfx.h>\n#define TAG FREERDP_TAG(\"codec\")\nstruct _ZGFX_TOKEN\n{\n\tUINT32 prefixLength;\n\tUINT32 prefixCode;\n\tUINT32 valueBits;\n\tUINT32 tokenType;\n\tUINT32 valueBase;\n};\ntypedef struct _ZGFX_TOKEN ZGFX_TOKEN;\nstruct _ZGFX_CONTEXT\n{\n\tBOOL Compressor;\n\tconst BYTE* pbInputCurrent;\n\tconst BYTE* pbInputEnd;\n\tUINT32 bits;\n\tUINT32 cBitsRemaining;\n\tUINT32 BitsCurrent;\n\tUINT32 cBitsCurrent;\n\tBYTE OutputBuffer[65536];\n\tUINT32 OutputCount;\n\tBYTE HistoryBuffer[2500000];\n\tUINT32 HistoryIndex;\n\tUINT32 HistoryBufferSize;\n};\nstatic const ZGFX_TOKEN ZGFX_TOKEN_TABLE[] = {\n\t// len code vbits type  vbase\n\t{ 1, 0, 8, 0, 0 },           // 0\n\t{ 5, 17, 5, 1, 0 },          // 10001\n\t{ 5, 18, 7, 1, 32 },         // 10010\n\t{ 5, 19, 9, 1, 160 },        // 10011\n\t{ 5, 20, 10, 1, 672 },       // 10100\n\t{ 5, 21, 12, 1, 1696 },      // 10101\n\t{ 5, 24, 0, 0, 0x00 },       // 11000\n\t{ 5, 25, 0, 0, 0x01 },       // 11001\n\t{ 6, 44, 14, 1, 5792 },      // 101100\n\t{ 6, 45, 15, 1, 22176 },     // 101101\n\t{ 6, 52, 0, 0, 0x02 },       // 110100\n\t{ 6, 53, 0, 0, 0x03 },       // 110101\n\t{ 6, 54, 0, 0, 0xFF },       // 110110\n\t{ 7, 92, 18, 1, 54944 },     // 1011100\n\t{ 7, 93, 20, 1, 317088 },    // 1011101\n\t{ 7, 110, 0, 0, 0x04 },      // 1101110\n\t{ 7, 111, 0, 0, 0x05 },      // 1101111\n\t{ 7, 112, 0, 0, 0x06 },      // 1110000\n\t{ 7, 113, 0, 0, 0x07 },      // 1110001\n\t{ 7, 114, 0, 0, 0x08 },      // 1110010\n\t{ 7, 115, 0, 0, 0x09 },      // 1110011\n\t{ 7, 116, 0, 0, 0x0A },      // 1110100\n\t{ 7, 117, 0, 0, 0x0B },      // 1110101\n\t{ 7, 118, 0, 0, 0x3A },      // 1110110\n\t{ 7, 119, 0, 0, 0x3B },      // 1110111\n\t{ 7, 120, 0, 0, 0x3C },      // 1111000\n\t{ 7, 121, 0, 0, 0x3D },      // 1111001\n\t{ 7, 122, 0, 0, 0x3E },      // 1111010\n\t{ 7, 123, 0, 0, 0x3F },      // 1111011\n\t{ 7, 124, 0, 0, 0x40 },      // 1111100\n\t{ 7, 125, 0, 0, 0x80 },      // 1111101\n\t{ 8, 188, 20, 1, 1365664 },  // 10111100\n\t{ 8, 189, 21, 1, 2414240 },  // 10111101\n\t{ 8, 252, 0, 0, 0x0C },      // 11111100\n\t{ 8, 253, 0, 0, 0x38 },      // 11111101\n\t{ 8, 254, 0, 0, 0x39 },      // 11111110\n\t{ 8, 255, 0, 0, 0x66 },      // 11111111\n\t{ 9, 380, 22, 1, 4511392 },  // 101111100\n\t{ 9, 381, 23, 1, 8705696 },  // 101111101\n\t{ 9, 382, 24, 1, 17094304 }, // 101111110\n\t{ 0 }\n};\nstatic INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)\n{\n\tif (!_zgfx)\n\t\treturn FALSE;\n\twhile (_zgfx->cBitsCurrent < _nbits)\n\t{\n\t\t_zgfx->BitsCurrent <<= 8;\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;\n\t\t_zgfx->cBitsCurrent += 8;\n\t}\n\t_zgfx->cBitsRemaining -= _nbits;\n\t_zgfx->cBitsCurrent -= _nbits;\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n\treturn TRUE;\n}\nstatic void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n{\n\tUINT32 front;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}\nstatic void zgfx_history_buffer_ring_read(ZGFX_CONTEXT* zgfx, int offset, BYTE* dst, UINT32 count)\n{\n\tUINT32 front;\n\tUINT32 index;\n\tINT32 bytes;\n\tUINT32 valid;\n\tINT32 bytesLeft;\n\tBYTE* dptr = dst;\n\tBYTE* origDst = dst;\n\tif ((count <= 0) || (count > INT32_MAX))\n\t\treturn;\n\tbytesLeft = (INT32)count;\n\tindex = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;\n\tbytes = MIN(bytesLeft, offset);\n\tif ((index + bytes) <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), bytes);\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - index;\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), front);\n\t\tCopyMemory(&dptr[front], zgfx->HistoryBuffer, bytes - front);\n\t}\n\tif ((bytesLeft -= bytes) == 0)\n\t\treturn;\n\tdptr += bytes;\n\tvalid = bytes;\n\tdo\n\t{\n\t\tbytes = valid;\n\t\tif (bytes > bytesLeft)\n\t\t\tbytes = bytesLeft;\n\t\tCopyMemory(dptr, origDst, bytes);\n\t\tdptr += bytes;\n\t\tvalid <<= 1;\n\t} while ((bytesLeft -= bytes) > 0);\n}\nstatic BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tUINT32 haveBits;\n\tUINT32 inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment;\n\tif (!zgfx || !stream || (segmentSize < 2))\n\t\treturn FALSE;\n\tcbSegment = segmentSize - 1;\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\tStream_Read_UINT8(stream, flags); \n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tif (!Stream_SafeSeek(stream, cbSegment))\n\t\treturn FALSE;\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))\n\t\t\treturn FALSE;\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(\n\t\t\t\t\t\t    zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(\n\t\t\t\t\t\t    zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\tif (count > zgfx->cBitsRemaining / 8)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent,\n\t\t\t\t\t\t           count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor;\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\tif (!stream)\n\t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\t\t*ppDstData = NULL;\n\t\tif (zgfx->OutputCount > 0)\n\t\t\t*ppDstData = aligned_zgfx_malloc(zgfx->OutputCount);\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n\t\tUINT16 segmentCount;\n\t\tUINT32 uncompressedSize;\n\t\tBYTE* pConcatenated;\n\t\tsize_t used = 0;\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount);     \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = aligned_zgfx_malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\t\t\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\t\t\tgoto fail;\n\t\t\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\t\t\tgoto fail;\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t\tused += zgfx->OutputCount;\n\t\t}\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}\nint zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,\n                            UINT32 uncompressedSize, UINT32* pFlags)\n{\n\tint fragment;\n\tUINT16 maxLength;\n\tUINT32 totalLength;\n\tsize_t posSegmentCount = 0;\n\tconst BYTE* pSrcData;\n\tint status = 0;\n\tmaxLength = ZGFX_SEGMENTED_MAXSIZE;\n\ttotalLength = uncompressedSize;\n\tpSrcData = pUncompressed;\n\tfor (fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)\n\t{\n\t\tUINT32 SrcSize;\n\t\tsize_t posDstSize;\n\t\tsize_t posDataStart;\n\t\tUINT32 DstSize;\n\t\tSrcSize = (totalLength > maxLength) ? maxLength : totalLength;\n\t\tposDstSize = 0;\n\t\ttotalLength -= SrcSize;\n\t\tif (!Stream_EnsureRemainingCapacity(sDst, 12))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (fragment == 0)\n\t\t{\n\t\t\tStream_Write_UINT8(sDst, (totalLength == 0) ? ZGFX_SEGMENTED_SINGLE\n\t\t\t                                            : ZGFX_SEGMENTED_MULTIPART);\n\t\t\tif (totalLength > 0)\n\t\t\t{\n\t\t\t\tposSegmentCount = Stream_GetPosition(sDst); \n\t\t\t\tStream_Seek(sDst, 2);\n\t\t\t\tStream_Write_UINT32(sDst, uncompressedSize); \n\t\t\t}\n\t\t}\n\t\tif (fragment > 0 || totalLength > 0)\n\t\t{\n\t\t\tposDstSize = Stream_GetPosition(sDst); \n\t\t\tStream_Seek(sDst, 4);\n\t\t}\n\t\tposDataStart = Stream_GetPosition(sDst);\n\t\tif (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))\n\t\t\treturn -1;\n\t\tif (posDstSize)\n\t\t{\n\t\t\tDstSize = Stream_GetPosition(sDst) - posDataStart;\n\t\t\tStream_SetPosition(sDst, posDstSize);\n\t\t\tStream_Write_UINT32(sDst, DstSize);\n\t\t\tStream_SetPosition(sDst, posDataStart + DstSize);\n\t\t}\n\t\tpSrcData += SrcSize;\n\t}\n\tStream_SealLength(sDst);\n\tif (posSegmentCount)\n\t{\n\t\tStream_SetPosition(sDst, posSegmentCount);\n\t\tStream_Write_UINT16(sDst, fragment);\n\t\tStream_SetPosition(sDst, Stream_Length(sDst));\n\t}\n\treturn status;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_9670.c",
        "project": "freerdp/freerdp",
        "url": "https://github.com/FreeRDP/FreeRDP/commit/e865c24efc40ebc52e75979c94cdd4ee2c1495b0",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```const char *ldb_dn_get_casefold(struct ldb_dn *dn)\n\tif (dn->casefold) return dn->casefold;\n\tif (dn->special) {\n\t\tdn->casefold = talloc_strdup(dn, dn->linearized);\n\t\tif (!dn->casefold) return NULL;\n\t\tdn->valid_case = true;\n\t\treturn dn->casefold;\n\t}\n\tif ( ! ldb_dn_casefold_internal(dn)) {\n\t\treturn NULL;\n\t}\n\tif (dn->comp_num == 0) {\n\t\tdn->casefold = talloc_strdup(dn, \"\");\n\t\treturn dn->casefold;\n\t}\n\tif ( ! dn->casefold) return NULL;\n\td = dn->casefold;\n\treturn dn->casefold;\nbool ldb_dn_add_base(struct ldb_dn *dn, struct ldb_dn *base)\n\tif ( !base || base->invalid || !dn || dn->invalid) {\n\t}\n\tif (dn == base) {\n\t}\n\tif (dn->components) {\n\t\tif ( ! ldb_dn_validate(base)) {\n\t\t}\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(base))) {\n\t\t\t}\n\t\t}\n\t\tif ( ! dn->components) {\n\t\t}\n\t\tfor (i = 0; i < base->comp_num; dn->comp_num++, i++) {\n\t\t\tdn->components[dn->comp_num] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&base->components[i]);\n\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t}\n\t\t}\n\t\tif (dn->casefold && s) {\n\t\t\tif (*dn->casefold) {\n\t\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t\t    dn->casefold, s);\n\t\t\t} else {\n\t\t\t\tt = talloc_strdup(dn, s);\n\t\t\t}\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\ts = ldb_dn_get_linearized(base);\n\t\tif ( ! s) {\n\t\t}\n\t\tif (*dn->linearized) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t    dn->linearized, s);\n\t\t} else {\n\t}\nbool ldb_dn_add_child(struct ldb_dn *dn, struct ldb_dn *child)\n\tif ( !child || child->invalid || !dn || dn->invalid) {\n\t}\n\tif (dn->components) {\n\t\tif (dn->comp_num == 0) {\n\t\t}\n\t\tif ( ! ldb_dn_validate(child)) {\n\t\t}\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(child))) {\n\t\t\t}\n\t\t}\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"ldb_private.h\"\n#include <ctype.h>\n#define LDB_DN_NULL_FAILED(x) if (!(x)) goto failed\n#define LDB_FREE(x) do { talloc_free(x); x = NULL; } while(0)\nstruct ldb_dn_component {\n\tchar *name;\n\tstruct ldb_val value;\n\tchar *cf_name;\n\tstruct ldb_val cf_value;\n};\nstruct ldb_dn_ext_component {\n\tconst char *name;\n\tstruct ldb_val value;\n};\nstruct ldb_dn {\n\tstruct ldb_context *ldb;\n\tbool special;\n\tbool invalid;\n\tbool valid_case;\n\tchar *linearized;\n\tchar *ext_linearized;\n\tchar *casefold;\n\tunsigned int comp_num;\n\tstruct ldb_dn_component *components;\n\tunsigned int ext_comp_num;\n\tstruct ldb_dn_ext_component *ext_components;\n};\nstatic void ldb_dn_mark_invalid(struct ldb_dn *dn)\n{\n\tdn->invalid = true;\n}\nstruct ldb_dn *ldb_dn_from_ldb_val(TALLOC_CTX *mem_ctx,\n                                   struct ldb_context *ldb,\n                                   const struct ldb_val *strdn)\n{\n\tstruct ldb_dn *dn;\n\tif (ldb == NULL || strdn == NULL) {\n\t\treturn NULL;\n\t}\n\tif (strdn->data\n\t    && (strnlen((const char*)strdn->data, strdn->length) != strdn->length)) {\n\t\treturn NULL;\n\t}\n\tdn = talloc_zero(mem_ctx, struct ldb_dn);\n\tLDB_DN_NULL_FAILED(dn);\n\tdn->ldb = talloc_get_type(ldb, struct ldb_context);\n\tif (dn->ldb == NULL) {\n\t\ttalloc_free(dn);\n\t\treturn NULL;\n\t}\n\tif (strdn->data && strdn->length) {\n\t\tconst char *data = (const char *)strdn->data;\n\t\tsize_t length = strdn->length;\n\t\tif (data[0] == '@') {\n\t\t\tdn->special = true;\n\t\t}\n\t\tdn->ext_linearized = talloc_strndup(dn, data, length);\n\t\tLDB_DN_NULL_FAILED(dn->ext_linearized);\n\t\tif (data[0] == '<') {\n\t\t\tconst char *p_save, *p = dn->ext_linearized;\n\t\t\tdo {\n\t\t\t\tp_save = p;\n\t\t\t\tp = strstr(p, \">;\");\n\t\t\t\tif (p) {\n\t\t\t\t\tp = p + 2;\n\t\t\t\t}\n\t\t\t} while (p);\n\t\t\tif (p_save == dn->ext_linearized) {\n\t\t\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\t\t} else {\n\t\t\t\tdn->linearized = talloc_strdup(dn, p_save);\n\t\t\t}\n\t\t\tLDB_DN_NULL_FAILED(dn->linearized);\n\t\t} else {\n\t\t\tdn->linearized = dn->ext_linearized;\n\t\t\tdn->ext_linearized = NULL;\n\t\t}\n\t} else {\n\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\tLDB_DN_NULL_FAILED(dn->linearized);\n\t}\n\treturn dn;\nfailed:\n\ttalloc_free(dn);\n\treturn NULL;\n}\nstatic int ldb_dn_escape_internal(char *dst, const char *src, int len)\n{\n\tchar c;\n\tchar *d;\n\tint i;\n\td = dst;\n\tfor (i = 0; i < len; i++){\n\t\tc = src[i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tif (i == 0 || i == len - 1) {\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = c;\n\t\t\t} else {\n\t\t\t\t*d++ = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\tcase ',':\n\t\tcase '+':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase '?':\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = c;\n\t\t\tbreak;\n\t\tcase ';':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\tcase '=':\n\t\tcase '\\0': {\n\t\t\tunsigned char v;\n\t\t\tconst char *hexbytes = \"0123456789ABCDEF\";\n\t\t\tv = (const unsigned char)c;\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = hexbytes[v>>4];\n\t\t\t*d++ = hexbytes[v&0xF];\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t*d++ = c;\n\t\t}\n\t}\n\treturn (d - dst);\n}\nstatic bool ldb_dn_explode(struct ldb_dn *dn)\n{\n\tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;\n\tbool trim = true;\n\tbool in_extended = true;\n\tbool in_ex_name = false;\n\tbool in_ex_value = false;\n\tbool in_attr = false;\n\tbool in_value = false;\n\tbool in_quote = false;\n\tbool is_oid = false;\n\tbool escape = false;\n\tunsigned int x;\n\tsize_t l = 0;\n\tint ret;\n\tchar *parse_dn;\n\tbool is_index;\n\tif (dn == NULL || dn->invalid == true) {\n\t\treturn false;\n\t}\n\tif (dn->components != NULL) {\n\t\treturn true;\n\t}\n\tif (dn->ext_linearized != NULL) {\n\t\tparse_dn = dn->ext_linearized;\n\t} else {\n\t\tparse_dn = dn->linearized;\n\t}\n\tif (parse_dn == NULL) {\n\t\treturn false;\n\t}\n\tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);\n\tif (parse_dn[0] == '\\0') {\n\t\treturn true;\n\t}\n\tif (dn->special == true) {\n\t\treturn true;\n\t}\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\tdn->comp_num = 0;\n\tdn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);\n\tif (dn->components == NULL) {\n\t\treturn false;\n\t}\n\tdata = talloc_array(dn->components, char, strlen(parse_dn) + 1);\n\tif (data == NULL) {\n\t\tgoto failed;\n\t}\n\tp = parse_dn;\n\tt = NULL;\n\td = dt = data;\n\twhile (*p) {\n\t\tif (in_extended == true) {\n\t\t\tif (!in_ex_name && !in_ex_value) {\n\t\t\t\tif (p[0] == '<') {\n\t\t\t\t\tp++;\n\t\t\t\t\tex_name = d;\n\t\t\t\t\tin_ex_name = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tin_extended = false;\n\t\t\t\t\tin_attr = true;\n\t\t\t\t\tdt = d;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_ex_name && *p == '=') {\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tex_value = d;\n\t\t\t\tin_ex_name = false;\n\t\t\t\tin_ex_value = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_ex_value && *p == '>') {\n\t\t\t\tstruct ldb_dn_ext_component *ext_comp = NULL;\n\t\t\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\t\t\tstruct ldb_val ex_val = {\n\t\t\t\t\t.data = (uint8_t *)ex_value,\n\t\t\t\t\t.length = d - ex_value\n\t\t\t\t};\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tin_ex_value = false;\n\t\t\t\text_comp = talloc_realloc(\n\t\t\t\t\tdn,\n\t\t\t\t\tdn->ext_components,\n\t\t\t\t\tstruct ldb_dn_ext_component,\n\t\t\t\t\tdn->ext_comp_num + 1);\n\t\t\t\tif (ext_comp == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_components = ext_comp;\n\t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);\n\t\t\t\tif (ext_syntax == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_components[dn->ext_comp_num].name = ext_syntax->name;\n\t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,\n\t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_comp_num++;\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\ttalloc_free(data);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (*p == ';') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_attr == true) {\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrim = false;\n\t\t\t\tif (!isascii(*p)) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\tis_oid = true;\n\t\t\t\t} else\n\t\t\t\tif ( ! isalpha(*p)) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*p == ' ') {\n\t\t\t\tp++;\n\t\t\t\ttrim = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*p == '=') {\n\t\t\t\tin_attr = false;\n\t\t\t\tin_value = true;\n\t\t\t\ttrim = true;\n\t\t\t\tl = 0;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);\n\t\t\t\tif (dn->components[dn->comp_num].name == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdt = d;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isascii(*p)) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tif (is_oid == true && ( ! (isdigit(*p) || (*p == '.')))) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t} else\n\t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_value == true) {\n\t\t\tif (in_quote == true) {\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tif (p[-1] != '\\\\') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tin_quote = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrim = false;\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tin_quote = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (*p) {\n\t\t\tcase ',':\n\t\t\t\tif (escape == true) {\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tescape = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\td -= (p - t);\n\t\t\t\t\tl -= (p - t);\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tin_attr = true;\n\t\t\t\tin_value = false;\n\t\t\t\ttrim = true;\n\t\t\t\tp++;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].value.data = \\\n\t\t\t\t\t(uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n\t\t\t\tdn->components[dn->comp_num].value.length = l;\n\t\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\ttalloc_set_name_const(dn->components[dn->comp_num].value.data,\n\t\t\t\t\t\t      (const char *)dn->components[dn->comp_num].value.data);\n\t\t\t\tdt = d;\n\t\t\t\tdn->comp_num++;\n\t\t\t\tif (dn->comp_num > 2) {\n\t\t\t\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\t\t\t\tdn->comp_num + 1);\n\t\t\t\t\tif (dn->components == NULL) {\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase '+':\n\t\t\tcase '=':\n\t\t\t\tif (is_index == true) {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tFALL_THROUGH;\n\t\t\tcase '\\\"':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase ';':\n\t\t\t\tif (escape == false) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tif (escape == false) {\n\t\t\t\t\tescape = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (escape == true) {\n\t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {\n\t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {\n\t\t\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t*d++ = (unsigned char)x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\t}\n\t\t\t\t\tescape = false;\n\t\t\t\t\tl++;\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tif (t == NULL) {\n\t\t\t\t\t\tt = p;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (in_attr == true || in_quote == true) {\n\t\tldb_dn_mark_invalid(dn);\n\t\tgoto failed;\n\t}\n\tif (in_value == true) {\n\t\tif (t != NULL) {\n\t\t\td -= (p - t);\n\t\t\tl -= (p - t);\n\t\t}\n\t\t*d++ = '\\0';\n\t\tdn->components[dn->comp_num].value.length = l;\n\t\tdn->components[dn->comp_num].value.data =\n\t\t\t(uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\tgoto failed;\n\t\t}\n\t\ttalloc_set_name_const(dn->components[dn->comp_num].value.data,\n\t\t\t(const char *)dn->components[dn->comp_num].value.data);\n\t\tdn->comp_num++;\n\t}\n\ttalloc_free(data);\n\treturn true;\nfailed:\n\tLDB_FREE(dn->components); \n\tdn->comp_num = 0;\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn false;\n}\nconst char *ldb_dn_get_linearized(struct ldb_dn *dn)\n{\n\tunsigned int i;\n\tsize_t len;\n\tchar *d, *n;\n\tif ( ! dn || ( dn->invalid)) return NULL;\n\tif (dn->linearized) return dn->linearized;\n\tif ( ! dn->components) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn NULL;\n\t}\n\tif (dn->comp_num == 0) {\n\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\tif ( ! dn->linearized) return NULL;\n\t\treturn dn->linearized;\n\t}\n\tfor (len = 0, i = 0; i < dn->comp_num; i++) {\n\t\tlen += strlen(dn->components[i].name);\n\t\tlen += (dn->components[i].value.length * 3);\n\t\tlen += 2; \n\t}\n\tdn->linearized = talloc_array(dn, char, len);\n\tif ( ! dn->linearized) return NULL;\n\td = dn->linearized;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tn = dn->components[i].name;\n\t\twhile (*n) *d++ = *n++;\n\t\t*d++ = '=';\n\t\td += ldb_dn_escape_internal( d,\n\t\t\t\t(char *)dn->components[i].value.data,\n\t\t\t\tdn->components[i].value.length);\n\t\t*d++ = ',';\n\t}\n\t*(--d) = '\\0';\n\tdn->linearized = talloc_realloc(dn, dn->linearized,\n\t\t\t\t\tchar, (d - dn->linearized + 1));\n\treturn dn->linearized;\n}\nchar *ldb_dn_get_extended_linearized(TALLOC_CTX *mem_ctx, struct ldb_dn *dn, int mode)\n{\n\tconst char *linearized = ldb_dn_get_linearized(dn);\n\tchar *p = NULL;\n\tunsigned int i;\n\tif (!linearized) {\n\t\treturn NULL;\n\t}\n\tif (!ldb_dn_has_extended(dn)) {\n\t\treturn talloc_strdup(mem_ctx, linearized);\n\t}\n\tif (!ldb_dn_validate(dn)) {\n\t\treturn NULL;\n\t}\n\tTYPESAFE_QSORT(dn->ext_components, dn->ext_comp_num,\n\t\t       ldb_dn_extended_component_compare);\n\tfor (i = 0; i < dn->ext_comp_num; i++) {\n\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\tconst char *name = dn->ext_components[i].name;\n\t\tstruct ldb_val ec_val = dn->ext_components[i].value;\n\t\tstruct ldb_val val;\n\t\tint ret;\n\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, name);\n\t\tif (!ext_syntax) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (mode == 1) {\n\t\t\tret = ext_syntax->write_clear_fn(dn->ldb, mem_ctx,\n\t\t\t\t\t\t\t&ec_val, &val);\n\t\t} else if (mode == 0) {\n\t\t\tret = ext_syntax->write_hex_fn(dn->ldb, mem_ctx,\n\t\t\t\t\t\t\t&ec_val, &val);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (i == 0) {\n\t\t\tp = talloc_asprintf(mem_ctx, \"<%s=%.*s>\",\n\t\t\t\t\t    name,\n\t\t\t\t\t    (int)val.length,\n\t\t\t\t\t    val.data);\n\t\t} else {\n\t\t\tp = talloc_asprintf_append_buffer(p, \";<%s=%.*s>\",\n\t\t\t\t\t\t\t  name,\n\t\t\t\t\t\t\t  (int)val.length,\n\t\t\t\t\t\t\t  val.data);\n\t\t}\n\t\ttalloc_free(val.data);\n\t\tif (!p) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->ext_comp_num && *linearized) {\n\t\tp = talloc_asprintf_append_buffer(p, \";%s\", linearized);\n\t}\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\treturn p;\n}\nconst char *ldb_dn_get_casefold(struct ldb_dn *dn)\n{\n\tunsigned int i;\n\tsize_t len;\n\tchar *d, *n;\n\tif (dn->casefold) return dn->casefold;\n\tif (dn->special) {\n\t\tdn->casefold = talloc_strdup(dn, dn->linearized);\n\t\tif (!dn->casefold) return NULL;\n\t\tdn->valid_case = true;\n\t\treturn dn->casefold;\n\t}\n\tif ( ! ldb_dn_casefold_internal(dn)) {\n\t\treturn NULL;\n\t}\n\tif (dn->comp_num == 0) {\n\t\tdn->casefold = talloc_strdup(dn, \"\");\n\t\treturn dn->casefold;\n\t}\n\tfor (len = 0, i = 0; i < dn->comp_num; i++) {\n\t\tlen += strlen(dn->components[i].cf_name);\n\t\tlen += (dn->components[i].cf_value.length * 3);\n\t\tlen += 2; \n\t}\n\tdn->casefold = talloc_array(dn, char, len);\n\tif ( ! dn->casefold) return NULL;\n\td = dn->casefold;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tn = dn->components[i].cf_name;\n\t\twhile (*n) *d++ = *n++;\n\t\t*d++ = '=';\n\t\td += ldb_dn_escape_internal( d,\n\t\t\t\t(char *)dn->components[i].cf_value.data,\n\t\t\t\tdn->components[i].cf_value.length);\n\t\t*d++ = ',';\n\t}\n\t*(--d) = '\\0';\n\tdn->casefold = talloc_realloc(dn, dn->casefold,\n\t\t\t\t      char, strlen(dn->casefold) + 1);\n\treturn dn->casefold;\n}\nint ldb_dn_compare_base(struct ldb_dn *base, struct ldb_dn *dn)\n{\n\tint ret;\n\tunsigned int n_base, n_dn;\n\tif ( ! base || base->invalid) return 1;\n\tif ( ! dn || dn->invalid) return -1;\n\tif (( ! base->valid_case) || ( ! dn->valid_case)) {\n\t\tif (base->linearized && dn->linearized && dn->special == base->special) {\n\t\t\tint dif;\n\t\t\tdif = strlen(dn->linearized) - strlen(base->linearized);\n\t\t\tif (dif < 0) {\n\t\t\t\treturn dif;\n\t\t\t}\n\t\t\tif (strcmp(base->linearized,\n\t\t\t\t   &dn->linearized[dif]) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(base)) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (base->comp_num > dn->comp_num) {\n\t\treturn (dn->comp_num - base->comp_num);\n\t}\n\tif ((dn->comp_num == 0) || (base->comp_num == 0)) {\n\t\tif (dn->special && base->special) {\n\t\t\treturn strcmp(base->linearized, dn->linearized);\n\t\t} else if (dn->special) {\n\t\t\treturn -1;\n\t\t} else if (base->special) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn_base = base->comp_num - 1;\n\tn_dn = dn->comp_num - 1;\n\twhile (n_base != (unsigned int) -1) {\n\t\tchar *b_name = base->components[n_base].cf_name;\n\t\tchar *dn_name = dn->components[n_dn].cf_name;\n\t\tchar *b_vdata = (char *)base->components[n_base].cf_value.data;\n\t\tchar *dn_vdata = (char *)dn->components[n_dn].cf_value.data;\n\t\tsize_t b_vlen = base->components[n_base].cf_value.length;\n\t\tsize_t dn_vlen = dn->components[n_dn].cf_value.length;\n\t\tret = strcmp(b_name, dn_name);\n\t\tif (ret != 0) return ret;\n\t\tif (b_vlen != dn_vlen) {\n\t\t\treturn b_vlen - dn_vlen;\n\t\t}\n\t\tret = strncmp(b_vdata, dn_vdata, b_vlen);\n\t\tif (ret != 0) return ret;\n\t\tn_base--;\n\t\tn_dn--;\n\t}\n\treturn 0;\n}\nint ldb_dn_compare(struct ldb_dn *dn0, struct ldb_dn *dn1)\n{\n\tunsigned int i;\n\tint ret;\n\tif (( ! dn0) || dn0->invalid || ! dn1 || dn1->invalid) {\n\t\treturn -1;\n\t}\n\tif (( ! dn0->valid_case) || ( ! dn1->valid_case)) {\n\t\tif (dn0->linearized && dn1->linearized) {\n\t\t\tif (strcmp(dn0->linearized, dn1->linearized) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn0)) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn1)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (dn0->comp_num != dn1->comp_num) {\n\t\treturn (dn1->comp_num - dn0->comp_num);\n\t}\n\tif (dn0->comp_num == 0) {\n\t\tif (dn0->special && dn1->special) {\n\t\t\treturn strcmp(dn0->linearized, dn1->linearized);\n\t\t} else if (dn0->special) {\n\t\t\treturn 1;\n\t\t} else if (dn1->special) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (i = 0; i < dn0->comp_num; i++) {\n\t\tchar *dn0_name = dn0->components[i].cf_name;\n\t\tchar *dn1_name = dn1->components[i].cf_name;\n\t\tchar *dn0_vdata = (char *)dn0->components[i].cf_value.data;\n\t\tchar *dn1_vdata = (char *)dn1->components[i].cf_value.data;\n\t\tsize_t dn0_vlen = dn0->components[i].cf_value.length;\n\t\tsize_t dn1_vlen = dn1->components[i].cf_value.length;\n\t\tret = strcmp(dn0_name, dn1_name);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (dn0_vlen != dn1_vlen) {\n\t\t\treturn dn0_vlen - dn1_vlen;\n\t\t}\n\t\tret = strncmp(dn0_vdata, dn1_vdata, dn0_vlen);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nstruct ldb_dn *ldb_dn_copy(TALLOC_CTX *mem_ctx, struct ldb_dn *dn)\n{\n\tstruct ldb_dn *new_dn;\n\tif (!dn || dn->invalid) {\n\t\treturn NULL;\n\t}\n\tnew_dn = talloc_zero(mem_ctx, struct ldb_dn);\n\tif ( !new_dn) {\n\t\treturn NULL;\n\t}\n\t*new_dn = *dn;\n\tif (dn->components) {\n\t\tunsigned int i;\n\t\tnew_dn->components =\n\t\t\ttalloc_zero_array(new_dn,\n\t\t\t\t\t  struct ldb_dn_component,\n\t\t\t\t\t  dn->comp_num);\n\t\tif ( ! new_dn->components) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tnew_dn->components[i] =\n\t\t\t\tldb_dn_copy_component(new_dn->components,\n\t\t\t\t\t\t      &dn->components[i]);\n\t\t\tif ( ! new_dn->components[i].value.data) {\n\t\t\t\ttalloc_free(new_dn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn->ext_components) {\n\t\tunsigned int i;\n\t\tnew_dn->ext_components =\n\t\t\ttalloc_zero_array(new_dn,\n\t\t\t\t\t  struct ldb_dn_ext_component,\n\t\t\t\t\t  dn->ext_comp_num);\n\t\tif ( ! new_dn->ext_components) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < dn->ext_comp_num; i++) {\n\t\t\tnew_dn->ext_components[i] =\n\t\t\t\t ldb_dn_ext_copy_component(\n\t\t\t\t\t\tnew_dn->ext_components,\n\t\t\t\t\t\t&dn->ext_components[i]);\n\t\t\tif ( ! new_dn->ext_components[i].value.data) {\n\t\t\t\ttalloc_free(new_dn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn->casefold) {\n\t\tnew_dn->casefold = talloc_strdup(new_dn, dn->casefold);\n\t\tif ( ! new_dn->casefold) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\tnew_dn->linearized = talloc_strdup(new_dn, dn->linearized);\n\t\tif ( ! new_dn->linearized) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->ext_linearized) {\n\t\tnew_dn->ext_linearized = talloc_strdup(new_dn,\n\t\t\t\t\t\t\tdn->ext_linearized);\n\t\tif ( ! new_dn->ext_linearized) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn new_dn;\n}\nbool ldb_dn_add_base(struct ldb_dn *dn, struct ldb_dn *base)\n{\n\tconst char *s;\n\tchar *t;\n\tif ( !base || base->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\tif (dn == base) {\n\t\treturn false; \n\t}\n\tif (dn->components) {\n\t\tunsigned int i;\n\t\tif ( ! ldb_dn_validate(base)) {\n\t\t\treturn false;\n\t\t}\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(base))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tdn->comp_num + base->comp_num);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < base->comp_num; dn->comp_num++, i++) {\n\t\t\tdn->components[dn->comp_num] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&base->components[i]);\n\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (dn->casefold && s) {\n\t\t\tif (*dn->casefold) {\n\t\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t\t    dn->casefold, s);\n\t\t\t} else {\n\t\t\t\tt = talloc_strdup(dn, s);\n\t\t\t}\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\ts = ldb_dn_get_linearized(base);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\t\tif (*dn->linearized) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t    dn->linearized, s);\n\t\t} else {\n\t\t\tt = talloc_strdup(dn, s);\n\t\t}\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn true;\n}\nbool ldb_dn_add_child(struct ldb_dn *dn, struct ldb_dn *child)\n{\n\tconst char *s;\n\tchar *t;\n\tif ( !child || child->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\tif (dn->components) {\n\t\tunsigned int n;\n\t\tunsigned int i, j;\n\t\tif (dn->comp_num == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( ! ldb_dn_validate(child)) {\n\t\t\treturn false;\n\t\t}\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(child))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tn = dn->comp_num + child->comp_num;\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tn);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = dn->comp_num - 1, j = n - 1; i != (unsigned int) -1;\n\t\t     i--, j--) {\n\t\t\tdn->components[j] = dn->components[i];\n\t\t}\n\t\tfor (i = 0; i < child->comp_num; i++) {\n\t\t\tdn->components[i] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&child->components[i]);\n\t\t\tif (dn->components[i].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdn->comp_num = n;\n\t\tif (dn->casefold && s) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->casefold);\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\tif (dn->linearized[0] == '\\0') {\n\t\t\treturn false;\n\t\t}\n\t\ts = ldb_dn_get_linearized(child);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->linearized);\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn true;\n}\nbool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)\n{\n\tunsigned int i;\n\tif ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tLDB_FREE(dn->components[i].name);\n\t\tLDB_FREE(dn->components[i].value.data);\n\t\tLDB_FREE(dn->components[i].cf_name);\n\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t}\n\tdn->components = talloc_realloc(dn,\n\t\t\t\t\tdn->components,\n\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\tnew_dn->comp_num);\n\tif (dn->components == NULL) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn false;\n\t}\n\tdn->comp_num = new_dn->comp_num;\n\tdn->valid_case = new_dn->valid_case;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tdn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);\n\t\tif (dn->components[i].name == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (new_dn->linearized == NULL) {\n\t\tdn->linearized = NULL;\n\t} else {\n\t\tdn->linearized = talloc_strdup(dn, new_dn->linearized);\n\t\tif (dn->linearized == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nstatic char *ldb_dn_canonical(TALLOC_CTX *mem_ctx, struct ldb_dn *dn, int ex_format) {\n\tunsigned int i;\n\tTALLOC_CTX *tmpctx;\n\tchar *cracked = NULL;\n\tconst char *format = (ex_format ? \"\\n\" : \"/\" );\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn NULL;\n\t}\n\ttmpctx = talloc_new(mem_ctx);\n\tfor (i = dn->comp_num - 1; i != (unsigned int) -1; i--) {\n\t\tif (ldb_attr_cmp(dn->components[i].name, \"dc\") != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cracked) {\n\t\t\tcracked = talloc_asprintf(tmpctx, \"%s.%s\",\n\t\t\t\t\t\t  ldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value),\n\t\t\t\t\t\t  cracked);\n\t\t} else {\n\t\t\tcracked = ldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value);\n\t\t}\n\t\tif (!cracked) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (i == (unsigned int) -1) {\n\t\tcracked = talloc_strdup_append_buffer(cracked, format);\n\t\ttalloc_steal(mem_ctx, cracked);\n\t\tgoto done;\n\t}\n\tfor (; i > 0; i--) {\n\t\tcracked = talloc_asprintf_append_buffer(cracked, \"/%s\",\n\t\t\t\t\t\t\tldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value));\n\t\tif (!cracked) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\tcracked = talloc_asprintf_append_buffer(cracked, \"%s%s\", format,\n\t\t\t\t\t\tldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value));\n\ttalloc_steal(mem_ctx, cracked);\ndone:\n\ttalloc_free(tmpctx);\n\treturn cracked;\n}\nint ldb_dn_set_component(struct ldb_dn *dn, int num,\n\t\t\t const char *name, const struct ldb_val val)\n{\n\tchar *n;\n\tstruct ldb_val v;\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif (num < 0) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif ((unsigned)num >= dn->comp_num) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif (val.length > val.length + 1) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tn = talloc_strdup(dn, name);\n\tif ( ! n) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tv.length = val.length;\n\tv.data = (uint8_t *)talloc_size(dn, v.length+1);\n\tif ( ! v.data) {\n\t\ttalloc_free(n);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tmemcpy(v.data, val.data, val.length);\n\tv.data[v.length] = '\\0';\n\ttalloc_free(dn->components[num].name);\n\ttalloc_free(dn->components[num].value.data);\n\tdn->components[num].name = n;\n\tdn->components[num].value = v;\n\tif (dn->valid_case) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tLDB_FREE(dn->components[i].cf_name);\n\t\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t\t}\n\t\tdn->valid_case = false;\n\t}\n\tLDB_FREE(dn->casefold);\n\tLDB_FREE(dn->linearized);\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn LDB_SUCCESS;\n}\nint ldb_dn_set_extended_component(struct ldb_dn *dn,\n\t\t\t\t  const char *name, const struct ldb_val *val)\n{\n\tstruct ldb_dn_ext_component *p;\n\tunsigned int i;\n\tstruct ldb_val v2;\n\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, name);\n\tif (ext_syntax == NULL) {\n\t\treturn LDB_ERR_INVALID_DN_SYNTAX;\n\t}\n\tfor (i=0; i < dn->ext_comp_num; i++) {\n\t\tif (ldb_attr_cmp(dn->ext_components[i].name, name) == 0) {\n\t\t\tif (val) {\n\t\t\t\tdn->ext_components[i].value =\n\t\t\t\t\tldb_val_dup(dn->ext_components, val);\n\t\t\t\tdn->ext_components[i].name = ext_syntax->name;\n\t\t\t\tif (!dn->ext_components[i].value.data) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tARRAY_DEL_ELEMENT(\n\t\t\t\t\tdn->ext_components,\n\t\t\t\t\ti,\n\t\t\t\t\tdn->ext_comp_num);\n\t\t\t\tdn->ext_comp_num--;\n\t\t\t\tdn->ext_components = talloc_realloc(dn,\n\t\t\t\t\t\t   dn->ext_components,\n\t\t\t\t\t\t   struct ldb_dn_ext_component,\n\t\t\t\t\t\t   dn->ext_comp_num);\n\t\t\t\tif (!dn->ext_components) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDB_FREE(dn->ext_linearized);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t}\n\tif (val == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tv2 = *val;\n\tp = dn->ext_components\n\t\t= talloc_realloc(dn,\n\t\t\t\t dn->ext_components,\n\t\t\t\t struct ldb_dn_ext_component,\n\t\t\t\t dn->ext_comp_num + 1);\n\tif (!dn->ext_components) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tp[dn->ext_comp_num].value = ldb_val_dup(dn->ext_components, &v2);\n\tp[dn->ext_comp_num].name = talloc_strdup(p, name);\n\tif (!dn->ext_components[i].name || !dn->ext_components[i].value.data) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tdn->ext_components = p;\n\tdn->ext_comp_num++;\n\tLDB_FREE(dn->ext_linearized);\n\treturn LDB_SUCCESS;\n}\nFile number 2:\nsamba.tests.segfault.samba.tests.segfault.SegfaultTests.test_net_replicate_init__3\n\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_6029.c",
        "project": "samba-team/samba",
        "url": "https://github.com/samba-team/samba/commit/f89767bea7330ec1936d2312e2b1da7b435c04b7",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t    const struct sk_buff *skb,\n\tif (family == PF_INET) {\n\t} else {\n\t\tstruct flowi6 *fl6 = &fl.u.ip6;\n\t\tmemset(fl6, 0, sizeof(*fl6));\n\t\tfl6->daddr = ipv6_hdr(skb)->saddr;\n\t}\ntcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     unsigned int tcphoff,\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\tlen = skb->len - tcphoff;\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn -1;\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t} else\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <net/dst.h>\n#include <net/flow.h>\n#include <net/ipv6.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/xt_tcpudp.h>\n#include <linux/netfilter/xt_TCPMSS.h>\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marc Boucher <marc@mbsi.ca>\");\nMODULE_DESCRIPTION(\"Xtables: TCP Maximum Segment Size (MSS) adjustment\");\nMODULE_ALIAS(\"ipt_TCPMSS\");\nMODULE_ALIAS(\"ip6t_TCPMSS\");\nstatic inline unsigned int\noptlen(const u_int8_t *opt, unsigned int offset)\n{\n\tif (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)\n\t\treturn 1;\n\telse\n\t\treturn opt[offset+1];\n}\nstatic u_int32_t tcpmss_reverse_mtu(struct net *net,\n\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t    unsigned int family)\n{\n\tstruct flowi fl;\n\tconst struct nf_afinfo *ai;\n\tstruct rtable *rt = NULL;\n\tu_int32_t mtu     = ~0U;\n\tif (family == PF_INET) {\n\t\tstruct flowi4 *fl4 = &fl.u.ip4;\n\t\tmemset(fl4, 0, sizeof(*fl4));\n\t\tfl4->daddr = ip_hdr(skb)->saddr;\n\t} else {\n\t\tstruct flowi6 *fl6 = &fl.u.ip6;\n\t\tmemset(fl6, 0, sizeof(*fl6));\n\t\tfl6->daddr = ipv6_hdr(skb)->saddr;\n\t}\n\trcu_read_lock();\n\tai = nf_get_afinfo(family);\n\tif (ai != NULL)\n\t\tai->route(net, (struct dst_entry **)&rt, &fl, false);\n\trcu_read_unlock();\n\tif (rt != NULL) {\n\t\tmtu = dst_mtu(&rt->dst);\n\t\tdst_release(&rt->dst);\n\t}\n\treturn mtu;\n}\nstatic int\ntcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\ttcp_hdrlen = tcph->doff * 4;\n\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n\t\treturn -1;\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (len > tcp_hdrlen)\n\t\treturn 0;\n\tif (tcp_hdrlen >= 15 * 4)\n\t\treturn 0;\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\tskb_put(skb, TCPOLEN_MSS);\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic unsigned int\ntcpmss_tg6(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tu8 nexthdr;\n\t__be16 frag_off, oldlen, newlen;\n\tint tcphoff;\n\tint ret;\n\tnexthdr = ipv6h->nexthdr;\n\ttcphoff = ipv6_skip_exthdr(skb, sizeof(*ipv6h), &nexthdr, &frag_off);\n\tif (tcphoff < 0)\n\t\treturn NF_DROP;\n\tret = tcpmss_mangle_packet(skb, par,\n\t\t\t\t   PF_INET6,\n\t\t\t\t   tcphoff,\n\t\t\t\t   sizeof(*ipv6h) + sizeof(struct tcphdr));\n\tif (ret < 0)\n\t\treturn NF_DROP;\n\tif (ret > 0) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\toldlen = ipv6h->payload_len;\n\t\tnewlen = htons(ntohs(oldlen) + ret);\n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\t\tskb->csum = csum_add(csum_sub(skb->csum, oldlen),\n\t\t\t\t\t     newlen);\n\t\tipv6h->payload_len = newlen;\n\t}\n\treturn XT_CONTINUE;\n}\n#endif\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\nstatic int tcpmss_tg6_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tconst struct ip6t_entry *e = par->entryinfo;\n\tconst struct xt_entry_match *ematch;\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU &&\n\t    (par->hook_mask & ~((1 << NF_INET_FORWARD) |\n\t\t\t   (1 << NF_INET_LOCAL_OUT) |\n\t\t\t   (1 << NF_INET_POST_ROUTING))) != 0) {\n\t\tpr_info(\"path-MTU clamping only supported in \"\n\t\t\t\"FORWARD, OUTPUT and POSTROUTING hooks\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->nft_compat)\n\t\treturn 0;\n\txt_ematch_foreach(ematch, e)\n\t\tif (find_syn_match(ematch))\n\t\t\treturn 0;\n\tpr_info(\"Only works on TCP SYN packets\\n\");\n\treturn -EINVAL;\n}\n#endif\nstatic struct xt_target tcpmss_tg_reg[] __read_mostly = {\n\t{\n\t\t.family\t\t= NFPROTO_IPV4,\n\t\t.name\t\t= \"TCPMSS\",\n\t\t.checkentry\t= tcpmss_tg4_check,\n\t\t.target\t\t= tcpmss_tg4,\n\t\t.targetsize\t= sizeof(struct xt_tcpmss_info),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\n\t{\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.name\t\t= \"TCPMSS\",\n\t\t.checkentry\t= tcpmss_tg6_check,\n\t\t.target\t\t= tcpmss_tg6,\n\t\t.targetsize\t= sizeof(struct xt_tcpmss_info),\n\t\t.proto\t\t= IPPROTO_TCP,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n#endif\n};\nstatic int __init tcpmss_tg_init(void)\n{\n\treturn xt_register_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));\n}\nstatic void __exit tcpmss_tg_exit(void)\n{\n\txt_unregister_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_2670.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void oom_kill_process(struct oom_control *oc, const char *message)\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tbool can_oom_reap = true;\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t}\n\ttask_unlock(p);\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\tchild_points = oom_badness(child,\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tvictim = child;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tvictim = p;\n\t}\n\tmm = victim->mm;\n\tmmgrab(mm);\n\tcount_vm_event(OOM_KILL);\n\tcount_memcg_event_mm(mm, OOM_KILL);\n\tdo_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t}\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);\n\t}\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n}\nbool out_of_memory(struct oom_control *oc)\n\tif (oom_killer_disabled)\n\t\treturn false;\n\tif (!is_memcg_oom(oc)) {\n\t}\n\tif (task_will_free_mem(current)) {\n\t}\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\tselect_bad_process(oc);\n\tif (!oc->chosen && !is_sysrq_oom(oc) && !is_memcg_oom(oc)) {\n\t\tdump_header(oc, NULL);\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL) {\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/oom.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task.h>\n#include <linux/swap.h>\n#include <linux/timex.h>\n#include <linux/jiffies.h>\n#include <linux/cpuset.h>\n#include <linux/export.h>\n#include <linux/notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/ftrace.h>\n#include <linux/ratelimit.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/mmu_notifier.h>\n#include <asm/tlb.h>\n#include \"internal.h\"\n#include \"slab.h\"\n#define CREATE_TRACE_POINTS\n#include <trace/events/oom.h>\nint sysctl_panic_on_oom;\nint sysctl_oom_kill_allocating_task;\nint sysctl_oom_dump_tasks = 1;\n#ifdef CONFIG_NUMA\nstatic bool has_intersects_mems_allowed(struct task_struct *start,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct task_struct *tsk;\n\tbool ret = false;\n\trcu_read_lock();\n\tfor_each_thread(start, tsk) {\n\t\tif (mask) {\n\t\t\tret = mempolicy_nodemask_intersects(tsk, mask);\n\t\t} else {\n\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n#else\n#endif \nunsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= (points * 3) / 100;\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\treturn points > 0 ? points : 1;\n}\nenum oom_constraint {\n\tCONSTRAINT_NONE,\n\tCONSTRAINT_CPUSET,\n\tCONSTRAINT_MEMORY_POLICY,\n\tCONSTRAINT_MEMCG,\n};\nstatic enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type high_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_limit(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\toc->totalpages = totalram_pages + total_swap_pages;\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thigh_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}\nstatic int oom_evaluate_task(struct task_struct *task, void *arg)\n{\n\tstruct oom_control *oc = arg;\n\tunsigned long points;\n\tif (oom_unkillable_task(task, NULL, oc->nodemask))\n\t\tgoto next;\n\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {\n\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))\n\t\t\tgoto next;\n\t\tgoto abort;\n\t}\n\tif (oom_task_origin(task)) {\n\t\tpoints = ULONG_MAX;\n\t\tgoto select;\n\t}\n\tpoints = oom_badness(task, NULL, oc->nodemask, oc->totalpages);\n\tif (!points || points < oc->chosen_points)\n\t\tgoto next;\n\tif (points == oc->chosen_points && thread_group_leader(oc->chosen))\n\t\tgoto next;\nselect:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\tget_task_struct(task);\n\toc->chosen = task;\n\toc->chosen_points = points;\nnext:\n\treturn 0;\nabort:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\toc->chosen = (void *)-1UL;\n\treturn 1;\n}\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic bool oom_killer_disabled __read_mostly;\n#define K(x) ((x) << (PAGE_SHIFT-10))\n#ifdef CONFIG_MMU\nstatic struct task_struct *oom_reaper_th;\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_reaper_wait);\nstatic struct task_struct *oom_reaper_list;\nstatic DEFINE_SPINLOCK(oom_reaper_lock);\nstatic bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n\t\t}\n\t}\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}\n#define MAX_OOM_REAP_RETRIES 10\nstatic void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\tif (attempts <= MAX_OOM_REAP_RETRIES)\n\t\tgoto done;\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\ndone:\n\ttsk->oom_reaper_list = NULL;\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\tput_task_struct(tsk);\n}\nstatic int oom_reaper(void *unused)\n{\n\twhile (true) {\n\t\tstruct task_struct *tsk = NULL;\n\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);\n\t\tspin_lock(&oom_reaper_lock);\n\t\tif (oom_reaper_list != NULL) {\n\t\t\ttsk = oom_reaper_list;\n\t\t\toom_reaper_list = tsk->oom_reaper_list;\n\t\t}\n\t\tspin_unlock(&oom_reaper_lock);\n\t\tif (tsk)\n\t\t\toom_reap_task(tsk);\n\t}\n\treturn 0;\n}\nstatic void wake_oom_reaper(struct task_struct *tsk)\n{\n\tif (tsk == oom_reaper_list || tsk->oom_reaper_list)\n\t\treturn;\n\tget_task_struct(tsk);\n\tspin_lock(&oom_reaper_lock);\n\ttsk->oom_reaper_list = oom_reaper_list;\n\toom_reaper_list = tsk;\n\tspin_unlock(&oom_reaper_lock);\n\ttrace_wake_reaper(tsk->pid);\n\twake_up(&oom_reaper_wait);\n}\nstatic int __init oom_init(void)\n{\n\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");\n\treturn 0;\n}\nsubsys_initcall(oom_init)\n#else\n#endif \nstatic bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\tif (!mm)\n\t\treturn false;\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\nstatic void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tstruct task_struct *child;\n\tstruct task_struct *t;\n\tstruct mm_struct *mm;\n\tunsigned int victim_points = 0;\n\tbool can_oom_reap = true;\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t\tmark_oom_victim(p);\n\t\twake_oom_reaper(p);\n\t\ttask_unlock(p);\n\t\tput_task_struct(p);\n\t\treturn;\n\t}\n\ttask_unlock(p);\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\tread_lock(&tasklist_lock);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tunsigned int child_points;\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\tchild_points = oom_badness(child,\n\t\t\t\toc->memcg, oc->nodemask, oc->totalpages);\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tput_task_struct(victim);\n\t\t\t\tvictim = child;\n\t\t\t\tvictim_points = child_points;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\tmm = victim->mm;\n\tmmgrab(mm);\n\tcount_vm_event(OOM_KILL);\n\tcount_memcg_event_mm(mm, OOM_KILL);\n\tdo_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_FORCED, p, true);\n\t}\n\trcu_read_unlock();\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}\n#undef K\nEXPORT_SYMBOL_GPL(unregister_oom_notifier);\nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\tif (oom_killer_disabled)\n\t\treturn false;\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\treturn true;\n\t}\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\tselect_bad_process(oc);\n\tif (!oc->chosen && !is_sysrq_oom(oc) && !is_memcg_oom(oc)) {\n\t\tdump_header(oc, NULL);\n\t\tpanic(\"Out of memory and no killable processes...\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL) {\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\t\tschedule_timeout_killable(1);\n\t}\n\treturn !!oc->chosen;\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_2676.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```Sprintf(char *fmt, ...)\n    int len = 0;\n    int p = 0;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n\t    if (*f == '%') {\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\t    len += (p > 0) ? p : 10;\n\t\t    len += (p > 0) ? p : 15;\n\t\t    len += 1;\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    len += 10;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t    else if (*f == '%') {\n\t\tlen++;\n\t    }\n\t    if (IS_ALPHA(*f)) {\n\t    }\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdio.h>\n#include <stdlib.h>\n#include <gc.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef __EMX__\t\t\t\n#include <strings.h>\n#endif\n#include \"Str.h\"\n#include \"myctype.h\"\n#define INITIAL_STR_SIZE 32\n#ifdef STR_DEBUG\n#define STR_LENGTH_CHECK(x) if (((x)->ptr==0&&(x)->length!=0)||(strlen((x)->ptr)!=(x)->length))abort();\n#else\t\t\t\t\n#define STR_LENGTH_CHECK(x)\n#endif\t\t\t\t\nvoid\nStrgrow(Str x)\n{\n    char *old = x->ptr;\n    int newlen;\n    newlen = x->area_size * 6 / 5;\n    if (newlen == x->area_size)\n\tnewlen += 2;\n    x->ptr = GC_MALLOC_ATOMIC(newlen);\n    x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n#define SP_NORMAL 0\n#define SP_PREC   1\n#define SP_PREC2  2\nStr\nSprintf(char *fmt, ...)\n{\n    int len = 0;\n    int status = SP_NORMAL;\n    int p = 0;\n    char *f;\n    Str s;\n    va_list ap;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n      redo:\n\tswitch (status) {\n\tcase SP_NORMAL:\n\t    if (*f == '%') {\n\t\tstatus = SP_PREC;\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\tcase SP_PREC:\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\tint vi;\n\t\tchar *vs;\n\t\tvoid *vp;\n\t\tswitch (*f) {\n\t\tcase 'l':\n\t\tcase 'h':\n\t\tcase 'L':\n\t\tcase 'w':\n\t\t    continue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\tcase 'u':\n\t\t    vi = va_arg(ap, int);\n\t\t    len += (p > 0) ? p : 10;\n\t\t    break;\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'e':\n\t\tcase 'G':\n\t\tcase 'E':\n\t\t    vd = va_arg(ap, double);\n\t\t    len += (p > 0) ? p : 15;\n\t\t    break;\n\t\tcase 'c':\n\t\t    len += 1;\n\t\t    vi = va_arg(ap, int);\n\t\t    break;\n\t\tcase 's':\n\t\t    vs = va_arg(ap, char *);\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    break;\n\t\tcase 'p':\n\t\t    vp = va_arg(ap, void *);\n\t\t    len += 10;\n\t\t    break;\n\t\tcase 'n':\n\t\t    vp = va_arg(ap, void *);\n\t\t    break;\n\t\t}\n\t\tstatus = SP_NORMAL;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t\tstatus = SP_PREC2;\n\t    else if (*f == '%') {\n\t\tstatus = SP_NORMAL;\n\t\tlen++;\n\t    }\n\t    break;\n\tcase SP_PREC2:\n\t    if (IS_ALPHA(*f)) {\n\t\tstatus = SP_PREC;\n\t\tgoto redo;\n\t    }\n\t    break;\n\t}\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n    va_end(ap);\n    s->length = strlen(s->ptr);\n    if (s->length > len * 2) {\n\tfprintf(stderr, \"Sprintf: string too long\\n\");\n\texit(1);\n    }\n    return s;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1445.c",
        "project": "tats/w3m",
        "url": "https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static options_t *parse_arguments(int argc, char *argv[])\n    int i = 0;\n    options_t *options = (options_t *) malloc(sizeof(options_t));\n    memset(options, 0, sizeof(options_t));\n    for (i = 1; i < argc; i++)\n        if (!strcmp(argv[i], \"--infile\") || !strcmp(argv[i], \"-i\"))\n            if ((i + 1) == argc)\n                free(options);\n                return NULL;\n            options->in_file = argv[i + 1];\n            i++;\n            continue;\n        if (!strcmp(argv[i], \"--outfile\") || !strcmp(argv[i], \"-o\"))\n            if ((i + 1) == argc)\n                return NULL;\n            options->out_file = argv[i + 1];\n            i++;\n            continue;\n        if (!strcmp(argv[i], \"--debug\") || !strcmp(argv[i], \"-d\"))\n            options->debug = 1;\n        if (!strcmp(argv[i], \"--help\") || !strcmp(argv[i], \"-h\"))\n            return NULL;\n        }\n    if (!options->in_file)\n        return NULL;\n    return options;\nint main(int argc, char *argv[])\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    char *plist_entire = NULL;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n        return 0;\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n    }\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    else\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    if (plist_out)\n        if (options->out_file != NULL)\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        free(plist_out);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"plist/plist.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#ifdef _MSC_VER\n#pragma warning(disable:4996)\n#endif\ntypedef struct _options\n{\n    char *in_file, *out_file;\n    uint8_t debug, in_fmt, out_fmt;\n} options_t;\nstatic void print_usage(int argc, char *argv[])\n{\n    char *name = NULL;\n    name = strrchr(argv[0], '/');\n    printf(\"Usage: %s -i|--infile FILE [-o|--outfile FILE] [-d|--debug]\\n\", (name ? name + 1: argv[0]));\n    printf(\"Convert a plist FILE from binary to XML format or vice-versa.\\n\\n\");\n    printf(\"  -i, --infile FILE\\tThe FILE to convert from\\n\");\n    printf(\"  -o, --outfile FILE\\tOptional FILE to convert to or stdout if not used\\n\");\n    printf(\"  -d, --debug\\t\\tEnable extended debug output\\n\");\n    printf(\"\\n\");\n}\nstatic options_t *parse_arguments(int argc, char *argv[])\n{\n    int i = 0;\n    options_t *options = (options_t *) malloc(sizeof(options_t));\n    memset(options, 0, sizeof(options_t));\n    for (i = 1; i < argc; i++)\n    {\n        if (!strcmp(argv[i], \"--infile\") || !strcmp(argv[i], \"-i\"))\n        {\n            if ((i + 1) == argc)\n            {\n                free(options);\n                return NULL;\n            }\n            options->in_file = argv[i + 1];\n            i++;\n            continue;\n        }\n        if (!strcmp(argv[i], \"--outfile\") || !strcmp(argv[i], \"-o\"))\n        {\n            if ((i + 1) == argc)\n            {\n                free(options);\n                return NULL;\n            }\n            options->out_file = argv[i + 1];\n            i++;\n            continue;\n        }\n        if (!strcmp(argv[i], \"--debug\") || !strcmp(argv[i], \"-d\"))\n        {\n            options->debug = 1;\n        }\n        if (!strcmp(argv[i], \"--help\") || !strcmp(argv[i], \"-h\"))\n        {\n            free(options);\n            return NULL;\n        }\n    }\n    if (!options->in_file)\n    {\n        free(options);\n        return NULL;\n    }\n    return options;\n}\nint main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_1485.c",
        "project": "libimobiledevice/libplist",
        "url": "https://github.com/libimobiledevice/libplist/commit/7391a506352c009fe044dead7baad9e22dd279ee",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n\t\tcil_reset_level(node->data);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"cil_internal.h\"\n#include \"cil_log.h\"\n#include \"cil_list.h\"\n#include \"cil_reset_ast.h\"\n#include \"cil_symtab.h\"\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list);\nstatic inline void cil_reset_level(struct cil_level *level);\nstatic inline void cil_reset_levelrange(struct cil_levelrange *levelrange);\nstatic inline void cil_reset_context(struct cil_context *context);\nstatic void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n}\nint __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; \n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; \n\tdefault:\n\t\tbreak;\n\t}\n\treturn SEPOL_OK;\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_6060.c",
        "project": "selinuxproject/selinux",
        "url": "https://github.com/SELinuxProject/selinux/commit/f34d3d30c8325e4847a6b696fe7a3936a8a361f3",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int io_msg_send_fd(struct io_kiocb *req, unsigned int issue_flags)\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tif (target_ctx == ctx)\n\t\treturn -EINVAL;\n\tret = io_double_lock_ctx(ctx, target_ctx, issue_flags);\n\tif (unlikely(msg->src_fd >= ctx->nr_user_files))\n\t\tgoto out_unlock;\n\tmsg->src_fd = array_index_nospec(msg->src_fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, msg->src_fd)->file_ptr;\n\tsrc_file = (struct file *) (file_ptr & FFS_MASK);\n\tget_file(src_file);\n\tret = __io_fixed_fd_install(target_ctx, src_file, msg->dst_fd);\n\tif (ret < 0) {\n\t}\n\tif (msg->flags & IORING_MSG_RING_CQE_SKIP)\n\t\tgoto out_unlock;\n\tif (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\tret = -EOVERFLOW;\nint io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\t\tret = io_msg_send_fd(req, issue_flags);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/io_uring.h>\n#include <uapi/linux/io_uring.h>\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"filetable.h\"\n#include \"msg_ring.h\"\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tu64 user_data;\n\tu32 len;\n\tu32 cmd;\n\tu32 src_fd;\n\tu32 dst_fd;\n\tu32 flags;\n};\nstatic int io_msg_ring_data(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tif (msg->src_fd || msg->dst_fd || msg->flags)\n\t\treturn -EINVAL;\n\tif (io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\treturn 0;\n\treturn -EOVERFLOW;\n}\nstatic void io_double_unlock_ctx(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_ring_ctx *octx,\n\t\t\t\t unsigned int issue_flags)\n{\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n\tmutex_unlock(&octx->uring_lock);\n}\nstatic int io_double_lock_ctx(struct io_ring_ctx *ctx,\n\t\t\t      struct io_ring_ctx *octx,\n\t\t\t      unsigned int issue_flags)\n{\n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tif (!mutex_trylock(&octx->uring_lock))\n\t\t\treturn -EAGAIN;\n\t\treturn 0;\n\t}\n\tif (ctx < octx) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tmutex_lock(&octx->uring_lock);\n\t} else {\n\t\tmutex_lock(&octx->uring_lock);\n\t\tmutex_lock(&ctx->uring_lock);\n\t}\n\treturn 0;\n}\nstatic int io_msg_send_fd(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long file_ptr;\n\tstruct file *src_file;\n\tint ret;\n\tif (target_ctx == ctx)\n\t\treturn -EINVAL;\n\tret = io_double_lock_ctx(ctx, target_ctx, issue_flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = -EBADF;\n\tif (unlikely(msg->src_fd >= ctx->nr_user_files))\n\t\tgoto out_unlock;\n\tmsg->src_fd = array_index_nospec(msg->src_fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, msg->src_fd)->file_ptr;\n\tsrc_file = (struct file *) (file_ptr & FFS_MASK);\n\tget_file(src_file);\n\tret = __io_fixed_fd_install(target_ctx, src_file, msg->dst_fd);\n\tif (ret < 0) {\n\t\tfput(src_file);\n\t\tgoto out_unlock;\n\t}\n\tif (msg->flags & IORING_MSG_RING_CQE_SKIP)\n\t\tgoto out_unlock;\n\tif (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\tret = -EOVERFLOW;\nout_unlock:\n\tio_double_unlock_ctx(ctx, target_ctx, issue_flags);\n\treturn ret;\n}\nint io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tif (!(req->flags & REQ_F_FIXED_FILE))\n\t\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_9618.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\tbitmapData->compressed = TRUE;\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tbitmapUpdate->count = count;\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\nBOOL update_recv(rdpUpdate* update, wStream* s)\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, updateType); \n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n#define TAG FREERDP_TAG(\"core.update\")\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); \n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); \n\t\t}\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\tif (!pointer_color)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); \n\tStream_Read_UINT16(s, pointer_color->xPos);       \n\tStream_Read_UINT16(s, pointer_color->yPos);       \n\tStream_Read_UINT16(s, pointer_color->width);  \n\tStream_Read_UINT16(s, pointer_color->height); \n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); \n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); \n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); \n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\tif (!pointer)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); \n\tStream_Read_UINT16(s, pointer->hotSpotX);   \n\tStream_Read_UINT16(s, pointer->hotSpotY);   \n\tStream_Read_UINT16(s, pointer->width);  \n\tStream_Read_UINT16(s, pointer->height); \n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\tStream_Read_UINT16(s, pointer->lengthAndMask); \n\tStream_Read_UINT16(s, pointer->lengthXorMask); \n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); \n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, messageType); \n\tStream_Seek_UINT16(s);              \n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\treturn length;\n}\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, extraFlags);                      \n\tStream_Write_UINT8(s, orderType);                        \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, extraFlags);                      \n\tStream_Write_UINT8(s, orderType);                        \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, extraFlags);                      \n\tStream_Write_UINT8(s, orderType);                        \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, flags);                           \n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, flags);                           \n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, flags);                           \n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); \n\tStream_Write_UINT16(s, orderLength);                     \n\tStream_Write_UINT16(s, flags);                           \n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tbm = Stream_GetPosition(s);\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\tStream_Seek(s, headerLength);\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\treturn orderSize;\n}\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\tupdate_check_flush(context, orderSize);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, controlFlags);           \n\tStream_Write_UINT16(s, orderSize);             \n\tStream_Write_UINT32(s, orderInfo->fieldFlags); \n\tStream_Write_UINT32(s, orderInfo->windowId);   \n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\tupdate_check_flush(context, orderSize);\n\ts = update->us;\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, controlFlags);           \n\tStream_Write_UINT16(s, orderSize);             \n\tStream_Write_UINT32(s, orderInfo->fieldFlags); \n\tStream_Write_UINT32(s, orderInfo->windowId);   \n\tStream_Write_UINT16(s, iconInfo->cacheEntry); \n\tStream_Write_UINT8(s, iconInfo->cacheId);     \n\tStream_Write_UINT8(s, iconInfo->bpp);         \n\tStream_Write_UINT16(s, iconInfo->width);      \n\tStream_Write_UINT16(s, iconInfo->height);     \n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); \n\t}\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              \n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             \n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); \n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); \n\t}\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); \n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\tupdate_check_flush(context, orderSize);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, controlFlags);           \n\tStream_Write_UINT16(s, orderSize);             \n\tStream_Write_UINT32(s, orderInfo->fieldFlags); \n\tStream_Write_UINT32(s, orderInfo->windowId);   \n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); \n\tStream_Write_UINT8(s, cachedIcon.cacheId);     \n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\treturn orderSize;\n}\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\tupdate_check_flush(context, orderSize);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, controlFlags);             \n\tStream_Write_INT16(s, orderSize);                \n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   \n\tStream_Write_UINT32(s, orderInfo->windowId);     \n\tStream_Write_UINT32(s, orderInfo->notifyIconId); \n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\t\tStream_Write_UINT32(s, infoTip.timeout);     \n\t\tStream_Write_UINT32(s, infoTip.flags);       \n\t\tStream_Write_UINT16(s, infoTip.text.length); \n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); \n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); \n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     \n\t\tStream_Write_UINT8(s, iconInfo.bpp);         \n\t\tStream_Write_UINT16(s, iconInfo.width);      \n\t\tStream_Write_UINT16(s, iconInfo.height);     \n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); \n\t\t}\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             \n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            \n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); \n\t\torderSize += iconInfo.cbBitsMask;\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); \n\t\t}\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); \n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); \n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     \n\t}\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, controlFlags);           \n\tStream_Write_UINT16(s, orderSize);             \n\tStream_Write_UINT32(s, orderInfo->fieldFlags); \n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); \n\t}\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); \n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\tif (!update)\n\t\treturn NULL;\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\tif (!update->pointer)\n\t\tgoto fail;\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\tif (!update->primary)\n\t\tgoto fail;\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\tif (!update->secondary)\n\t\tgoto fail;\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\tif (!update->altsec)\n\t\tgoto fail;\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\tif (!update->window)\n\t\tgoto fail;\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\tif (!update->queue)\n\t\tgoto fail;\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_4643.c",
        "project": "freerdp/freerdp",
        "url": "https://github.com/FreeRDP/FreeRDP/commit/f8890a645c221823ac133dbf991f8a65ae50d637",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t   gpa_t addr, int len, void *data)\n\tif (s->status_latched) {\n\t} else if (s->count_latched) {\n\t} else {\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) \"pit: \" fmt\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"i8254.h\"\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\tif (!ps->pit_timer.period)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&ps->pit_timer.timer);\n\telapsed = ps->pit_timer.period - ktime_to_ns(remaining);\n\telapsed = mod_64(elapsed, ps->pit_timer.period);\n\treturn elapsed;\n}\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\nstatic struct kvm_timer_ops kpit_ops = {\n\t.is_periodic = kpit_is_periodic,\n};\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tmutex_lock(&pit_state->lock);\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tint ret;\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->pit_timer.timer,\n\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->pit_timer.reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\tkvm_pit_reset(pit);\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = __kvm_io_bus_register_dev(&kvm->pio_bus, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = __kvm_io_bus_register_dev(&kvm->pio_bus,\n\t\t\t\t\t\t&pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\treturn pit;\nfail_unregister:\n\t__kvm_io_bus_unregister_dev(&kvm->pio_bus, &pit->dev);\nfail:\n\tif (pit->irq_source_id >= 0)\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\tkfree(pit);\n\treturn NULL;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_914.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static bool isAddLiquidityEthCall(const EthereumSignTx *msg) {\n}\nstatic bool isRemoveLiquidityEthCall(const EthereumSignTx *msg) {\n}\nstatic bool confirmFromAccountMatch(const EthereumSignTx *msg, char *addremStr) {\n}\nbool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {\n    char constr1[40], constr2[40], *arStr = \"\";\n    if (isAddLiquidityEthCall(msg)) {\n        arStr = \"uniswap add liquidity\";\n    } else if (isRemoveLiquidityEthCall(msg)) {\n        arStr = \"uniswap remove liquidity\";\n    } else {\n    tokenAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20);\n    token = tokenByChainAddress(msg->chain_id, tokenAddress);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 32, 32, &tokenAmount);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 2*32, 32, &tokenMinAmount);\n    ethereumFormatAmount(&tokenAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, \"%s\", tokbuf);\n    ethereumFormatAmount(&tokenMinAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr2, 32, \"%s\", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"%s\\nMinimum %s\", constr1, constr2);\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"keepkey/firmware/ethereum_contracts/zxliquidtx.h\"\n#include \"keepkey/board/confirm_sm.h\"\n#include \"keepkey/board/util.h\"\n#include \"keepkey/firmware/app_confirm.h\"\n#include \"keepkey/firmware/coins.h\"\n#include \"keepkey/firmware/ethereum.h\"\n#include \"keepkey/firmware/ethereum_tokens.h\"\n#include \"keepkey/firmware/fsm.h\"\n#include \"keepkey/firmware/storage.h\"\n#include \"trezor/crypto/address.h\"\n#include \"trezor/crypto/bip32.h\"\n#include \"trezor/crypto/curves.h\"\n#include \"trezor/crypto/memzero.h\"\n#include \"trezor/crypto/sha3.h\"\n#include <time.h>\nstatic HDNode *zx_getDerivedNode(const char *curve, const uint32_t *address_n,\n                                  size_t address_n_count,\n                                  uint32_t *fingerprint) {\n    static HDNode CONFIDENTIAL node;\n    if (fingerprint) {\n        *fingerprint = 0;\n    }\n    if (!get_curve_by_name(curve)) {\n       return 0;\n    }\n    if (!storage_getRootNode(curve, true, &node)) {\n        return 0;\n    }\n    if (!address_n || address_n_count == 0) {\n        return &node;\n    }\n    if (hdnode_private_ckd_cached(&node, address_n, address_n_count,\n                                fingerprint) == 0) {\n        return 0;\n    }\n    return &node;\n}\nstatic bool isAddLiquidityEthCall(const EthereumSignTx *msg) {\n    if (memcmp(msg->data_initial_chunk.bytes, \"\\xf3\\x05\\xd7\\x19\", 4) == 0)\n        return true;\n    return false;\n}\nstatic bool isRemoveLiquidityEthCall(const EthereumSignTx *msg) {\n    if (memcmp(msg->data_initial_chunk.bytes, \"\\x02\\x75\\x1c\\xec\", 4) == 0)\n        return true;\n    return false;\n}\nstatic bool confirmFromAccountMatch(const EthereumSignTx *msg, char *addremStr) {\n    // Determine withdrawal address\n    char addressStr[43] = {'0', 'x', '\\0'};\n    char *fromSrc;\n    uint8_t *fromAddress;\n    uint8_t addressBytes[20];\n    HDNode *node = zx_getDerivedNode(SECP256K1_NAME, msg->address_n,\n                                    msg->address_n_count, NULL);\n    if (!node) return false;\n    if (!hdnode_get_ethereum_pubkeyhash(node, addressBytes)) {\n        memzero(node, sizeof(*node));\n    }\n    fromAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 5*32 - 20);\n    if (memcmp(fromAddress, addressBytes, 20) == 0) {\n        fromSrc = \"self\";\n    } else {\n        fromSrc = \"NOT this wallet\";\n    }\n    for (uint32_t ctr=0; ctr<20; ctr++) {\n        snprintf(&addressStr[2+ctr*2], 3, \"%02x\", fromAddress[ctr]);\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, addremStr,\n                  \"Confirming ETH address is %s: %s\", fromSrc, addressStr)) {\n       return false;\n    }\n    return true;\n}\nbool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {\n    (void)data_total;\n    const TokenType *token;\n    char constr1[40], constr2[40], *arStr = \"\";\n    uint8_t *tokenAddress, *deadlineBytes;\n    bignum256 tokenAmount, tokenMinAmount, ethMinAmount;\n    uint64_t deadline;\n    if (isAddLiquidityEthCall(msg)) {\n        arStr = \"uniswap add liquidity\";\n    } else if (isRemoveLiquidityEthCall(msg)) {\n        arStr = \"uniswap remove liquidity\";\n    } else {\n        return false;\n    }\n    tokenAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20);\n    token = tokenByChainAddress(msg->chain_id, tokenAddress);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 32, 32, &tokenAmount);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 2*32, 32, &tokenMinAmount);\n    bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 3*32, 32, &ethMinAmount);\n    deadlineBytes = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 6*32 - 8);\n    deadline = ((uint64_t)deadlineBytes[0] << 8*7) |\n               ((uint64_t)deadlineBytes[1] << 8*6) |\n               ((uint64_t)deadlineBytes[2] << 8*5) |\n               ((uint64_t)deadlineBytes[3] << 8*4) |\n               ((uint64_t)deadlineBytes[4] << 8*3) |\n               ((uint64_t)deadlineBytes[5] << 8*2) |\n               ((uint64_t)deadlineBytes[6] << 8*1) |\n               ((uint64_t)deadlineBytes[7]);\n    char tokbuf[32];\n    ethereumFormatAmount(&tokenAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, \"%s\", tokbuf);\n    ethereumFormatAmount(&tokenMinAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr2, 32, \"%s\", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"%s\\nMinimum %s\", constr1, constr2);\n    if (!confirmFromAccountMatch(msg, arStr)) {\n        return false;\n    }\n    ethereumFormatAmount(&ethMinAmount, NULL, msg->chain_id, tokbuf, sizeof(tokbuf));\n    snprintf(constr1, 32, \"%s\", tokbuf);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"Minimum %s\", constr1);\n    snprintf(constr1, 32, \"%lld\", deadline);\n    confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,\n                 \"Deadline %s\", ctime((const time_t *)&deadline));\n    return true;\n}\n",
        "cwe": "CWE-120",
        "file_name": "vul_respovul_idx_6047.c",
        "project": "keepkey/keepkey-firmware",
        "url": "https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_encoding) {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#ifndef GPAC_DISABLE_ISOM\n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \nGF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 item_count, extent_count, i, j;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->offset_size = gf_bs_read_int(bs, 4);\n\tptr->length_size = gf_bs_read_int(bs, 4);\n\tptr->base_offset_size = gf_bs_read_int(bs, 4);\n\tif (ptr->version == 1 || ptr->version == 2) {\n\t\tptr->index_size = gf_bs_read_int(bs, 4);\n\t} else {\n\t\tgf_bs_read_int(bs, 4);\n\t}\n\tif (ptr->version < 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\titem_count = gf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\titem_count = gf_bs_read_u32(bs);\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location_entry;\n\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n\t\tif (!location_entry) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->location_entries, location_entry);\n\t\tif (ptr->version < 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n\t\t}\n\t\telse {\n\t\t\tlocation_entry->construction_method = 0;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n\t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n\t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tlocation_entry->original_base_offset = location_entry->base_offset;\n#endif\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\textent_count = gf_bs_read_u16(bs);\n\t\tlocation_entry->extent_entries = gf_list_new();\n\t\tfor (j = 0; j < extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent_entry;\n\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n\t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n\t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n\t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\textent_entry->extent_index = 0;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n\t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n\t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n#endif\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iloc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->offset_size, 4);\n\tgf_bs_write_int(bs, ptr->length_size, 4);\n\tgf_bs_write_int(bs, ptr->base_offset_size, 4);\n\tgf_bs_write_int(bs, ptr->index_size, 4);\n\titem_count = gf_list_count(ptr->location_entries);\n\tif (ptr->version < 2) {\n\t\tgf_bs_write_u16(bs, item_count);\n\t}\n\telse {\n\t\tgf_bs_write_u32(bs, item_count);\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (ptr->version < 2) {\n\t\t\tgf_bs_write_u16(bs, location->item_ID);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_u32(bs, location->item_ID);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tgf_bs_write_u16(bs, location->construction_method);\n\t\t}\n\t\tgf_bs_write_u16(bs, location->data_reference_index);\n\t\tgf_bs_write_long_int(bs, location->base_offset, 8*ptr->base_offset_size);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tgf_bs_write_u16(bs, extent_count);\n\t\tfor (j=0; j<extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent = (GF_ItemExtentEntry *)gf_list_get(location->extent_entries, j);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tgf_bs_write_long_int(bs, extent->extent_index, 8 * ptr->index_size);\n\t\t\t}\n\t\t\tgf_bs_write_long_int(bs, extent->extent_offset, 8*ptr->offset_size);\n\t\t\tgf_bs_write_long_int(bs, extent->extent_length, 8*ptr->length_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err iloc_box_size(GF_Box *s)\n{\n\tu32 i, item_count, extent_count;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->index_size) {\n\t\tptr->version = 1;\n\t}\n\titem_count = gf_list_count(ptr->location_entries);\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\tif (location->construction_method) {\n\t\t\tptr->version = 1;\n\t\t}\n\t\tif (location->item_ID > 0xFFFF) {\n\t\t\tptr->version = 2;\n\t\t}\n\t}\n\tptr->size += 4;\n\tif (ptr->version == 2) {\n\t\tptr->size += 2; // 32 bits item count instead of 16 bits\n\t}\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location = (GF_ItemLocationEntry *)gf_list_get(ptr->location_entries, i);\n\t\textent_count = gf_list_count(location->extent_entries);\n\t\tptr->size += 6 + ptr->base_offset_size + extent_count*(ptr->offset_size + ptr->length_size);\n\t\tif (ptr->version == 2) {\n\t\t\tptr->size += 2; //32 bits item ID instead of 16 bits\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tptr->size += 2; // construction_method\n\t\t\tptr->size += extent_count*ptr->index_size;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \nGF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_encoding) {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\t//we could throw an error but we silently accept this infe\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err infe_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 3) {\n\t\tgf_bs_write_u32(bs, ptr->item_ID);\n\t}\n\telse {\n\t\tgf_bs_write_u16(bs, ptr->item_ID);\n\t}\n\tgf_bs_write_u16(bs, ptr->item_protection_index);\n\tif (ptr->version >= 2) {\n\t\tgf_bs_write_u32(bs, ptr->item_type);\n\t}\n\tif (ptr->item_name) {\n\t\tlen = (u32) strlen(ptr->item_name)+1;\n\t\tgf_bs_write_data(bs, ptr->item_name, len);\n\t} else {\n\t\tgf_bs_write_byte(bs, 0, 1);\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME || ptr->item_type == GF_META_ITEM_TYPE_URI) {\n\t\tif (ptr->content_type) {\n\t\t\tlen = (u32)strlen(ptr->content_type) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_type, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\tif (ptr->item_type == GF_META_ITEM_TYPE_MIME) {\n\t\tif (ptr->content_encoding) {\n\t\t\tlen = (u32)strlen(ptr->content_encoding) + 1;\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, len);\n\t\t}\n\t\telse {\n\t\t\tgf_bs_write_byte(bs, 0, 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#ifndef GPAC_DISABLE_ISOM_WRITE\n#endif \n#endif \n",
        "cwe": "CWE-415",
        "file_name": "safe_respovul_idx_7149.c",
        "project": "gpac/gpac",
        "url": "https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```R_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t}\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t}\n\tbank->last_used = NULL;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t} else {\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t} // else\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t}\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t} else {\n\t}\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <r_io.h>\n#include <r_util.h>\nR_API \nR_API \nR_API \nR_API \nR_API \nR_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}\nR_API \nR_API \nR_API \nstatic RIOMapRef *_mapref_from_map(RIOMap *map) {\n\tRIOMapRef *mapref = R_NEW (RIOMapRef);\n\tif (mapref) {\n\t\tmapref->id = map->id;\n\t\tmapref->ts = map->ts;\n\t}\n\treturn mapref;\n}\nstatic RRBNode *_find_entry_submap_node(RIOBank *bank, RIOSubMap *sm) {\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, sm, _find_lowest_intersection_sm_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRRBNode *prev = r_rbnode_prev (node);\n\twhile (prev && r_io_submap_overlap (((RIOSubMap *)prev->data), sm)) {\n\t\tnode = prev;\n\t\tprev = r_rbnode_prev (node);\n\t}\n\treturn node;\n}\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\nR_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}\nR_API bool r_io_bank_map_priorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->tail) {\t//tail is top\n\t\treturn r_io_map_get_by_ref (io, mapref) ? true : false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// if this happens, something is really fucked up\n\t\tfree (sm);\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_itv_eq (bd->itv, sm->itv)) {\n\t\t// no need to insert new sm, if boundaries match perfectly\n\t\t// instead override mapref of existing node/submap\n\t\tbd->mapref = *mapref;\n\t\tfree (sm);\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// bd completly overlaps sm on both ends,\n\t\t// therefor split bd into 2 maps => bd and bdsm\n\t\t// |---bd---||--sm--|-bdsm-|\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL) &\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t//delete all submaps that are completly included in sm\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tr_list_iter_to_top (bank->maprefs, iter);\n\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n}\nstatic void _delete_submaps_from_bank_tree(RIO *io, RIOBank *bank, RListIter *prio, RIOMap *map) {\n\tRIOSubMap fake_sm;\n\tfake_sm.itv = map->itv;\n\tfake_sm.mapref.id = map->id;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\treturn;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\twhile (bd && r_io_submap_overlap (bd, (&fake_sm))) {\n\t\t// this loop deletes all affected submaps from the rbtree\n\t\t// and also enqueues them in bank->todo\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\tif (bd->mapref.id == fake_sm.mapref.id) {\n\t\t\tr_queue_enqueue (bank->todo, R_NEWCOPY (RIOSubMap, bd));\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tentry = next;\n\t\tbd = entry ? (RIOSubMap *)entry->data : NULL;\n\t}\n\tRListIter *iter = prio;\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\t// now check for each deleted submap if a lower map intersects with it\n\t\t// and create new submaps accordingly, and fill the gaps\n\t\tRIOSubMap *sm = r_queue_dequeue (bank->todo);\n\t\tRListIter *ator = r_list_iter_get_prev (iter);\n\t\twhile (ator) {\n\t\t\tmap = r_io_map_get_by_ref (io, (RIOMapRef *)ator->data);\n\t\t\tator = r_list_iter_get_prev (ator);\n\t\t\tif (!map) {\n\t\t\t\t// if this happens, something is fucked up, and no submap should be inserted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if the map and sm intersect, the intersecting submap needs to be inserted in the tree\n\t\t\t// there are 5 cases to consider here\n\t\t\t// 1. no intersection: just continue to the next iteration\n\t\t\t// 2. map overlaps sm on both ends: insert submap for map with boundaries of sm\n\t\t\t// 3. map overlaps sm on the upper end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 4. map overlaps sm on the lower end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 5. sm overlaps sm on both ends: split sm into 2 submaps and enqueue new one in banks->todo; insert submap for map; adjust sm boundaries\n\t\t\tif (r_io_submap_to (sm) < r_io_map_from (map) || r_io_submap_from (sm) > r_io_map_to (map)) {\n\t\t\t\t// case 1\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRIOMapRef *mapref = _mapref_from_map (map);\n\t\t\tbd = r_io_submap_new (io, mapref);\n\t\t\tfree (mapref);\n\t\t\tif (!bd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_from (sm) >= r_io_map_from (map)) {\n\t\t\t\t// case 4 and 2\n\t\t\t\tr_io_submap_set_from (bd, r_io_submap_from (sm));\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t\t// case 2\n\t\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case 4\n\t\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t// case 3\n\t\t\t\t// adjust bd upper boundary to avoid overlap with existing submaps\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t// adjust sm upper boundary to avoid hitting again on sm in further iterations\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// case 5 because all other cases are already handled\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (bd) + 1);\n\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_queue_enqueue (bank->todo, bdsm);\n\t\t}\n\t\tfree (sm);\n\t}\n}\nR_API \nR_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this map\n\treturn false;\nfound:\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tif (!map) {\n\t\t// inconsistent mapref\n\t\t// mapref should be deleted from bank here\n\t\treturn false;\n\t}\n\tif (r_io_map_from (map) == ofrom && r_io_map_to (map) == oto) {\n\t\t// nothing todo here\n\t\treturn true;\n\t}\n\t// allocate sm here to avoid deleting things without ensuring\n\t// that this code could at least insert 1 submap\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\t// this problem can be divided in 2 steps:\n\t// 1. delete corresponding submaps and insert intersecting submaps with lower priority\n\t// 2. adjust addr and insert submaps at new addr respecting priority\n\tRIOMap fake_map;\n\tmemcpy (&fake_map, map, sizeof (RIOMap));\n\tfake_map.itv.addr = ofrom;\n\tfake_map.itv.size = oto - ofrom + 1;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection here, so just insert sm into the tree and we're done\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t// assumption here is that there is no need to check for return value of r_crbtree_insert,\n\t\t// since it only fails, if allocation fails and a delete was performed before, so it should just be fine\n\t\treturn true;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t// check if sm has higher priority than bd by comparing their maprefs\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t// sm has higher priority that bd => adjust bd\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t// bc of _find_entry_submap_node, we can be sure, that there is no\n\t\t\t\t// lower submap that intersects with sm\n\t\t\t\t//\n\t\t\t\t// instead of deleting and inserting, just replace the mapref,\n\t\t\t\t// similar to r_io_bank_map_priorize\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t\tfree (sm);\n\t\t\t} else {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\t\t// allocating bdsm here is fine, bc bd is already in the tree\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t// What do if this fails?\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t// bd has higher priority than sm => adjust sm\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\t// bd completly overlaps sm => nothing to do\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t} // else\n\t\t\t// adjust sm\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\t\tfree (sm);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tif (!bdsm) {\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\tfree (bdsm);\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\t// entry = r_rbnode_next (entry);\n\t// it is given that entry->data->from >= sm->from on every iteration\n\t// so only check for upper boundary of sm for intersection with entry->data\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t// iterate forwards starting at entry, while entry->data and sm overlap\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\t// check if sm has higher priority than bd by comparing their maprefs\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\t// delete bd\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t\t// bd has higher priority than sm => adjust sm\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t\t// in this case the size of sm would be 0,\n\t\t\t\t// but since empty maps are not allowed free sm and return\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t\t}\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// can this happen?\n\t\t\tfree (sm);\n\t\t}\n\t}\n\treturn true;\n}\nR_API bool r_io_bank_locate(RIO *io, const ut32 bankid, ut64 *addr, const ut64 size, ut64 load_align) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank && bank->submaps && addr && size, false);\n\tif (load_align == 0LL) {\n\t\tload_align = 1;\n\t}\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = *addr + (load_align - *addr % load_align) % load_align;\n\tfake_sm.itv.size = size;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\t// no submaps in this bank\n\t\t*addr = fake_sm.itv.addr;\n\t\treturn true;\n\t}\n\t// this is a bit meh: first iteration can never be successful,\n\t// bc entry->sm will always intersect with fake_sm, if\n\t// _find_entry_submap_node suceeded previously\n\tut64 next_location = fake_sm.itv.addr;\n\twhile (entry) {\n\t\tRIOSubMap *sm = (RIOSubMap *)entry->data;\n\t\tif (size <= r_io_submap_from (sm) - next_location) {\n\t\t\t*addr = next_location;\n\t\t\treturn true;\n\t\t}\n\t\tnext_location = (r_io_submap_to (sm) + 1) +\n\t\t\t(load_align - ((r_io_submap_to (sm) + 1) % load_align)) % load_align;\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tif (next_location == 0LL) {\n\t\t// overflow from last submap in the tree => no location\n\t\treturn false;\n\t}\n\tif (UT64_MAX - size + 1 < next_location) {\n\t\treturn false;\n\t}\n\t*addr = next_location;\n\treturn true;\n}\nR_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\nR_API bool r_io_bank_write_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof (RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_W)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int write_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_write_at (io, map->fd, paddr, &buf[buf_off], write_len) == write_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\nR_API \nR_API \nR_API \nR_API \nR_API \nR_API \nR_IPI \nFile number 2:\n#include <r_util.h>\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\nR_API \nR_API \nR_API \nR_API \nR_API \nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\treturn node;\n}\n#define IS_RED(n) ((n) != NULL && (n)->red == 1)\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\troot->red = 1;\n\tsave->red = 0;\n\treturn save;\n}\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\t_set_link (q, tree->root, 1);\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0) {\n\t\t\tfound = q;\n\t\t}\n\t\tdir = (bool)(dir > 0);\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid *ret = NULL;\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\nR_API \nR_API \nR_API \nR_API \nR_API \n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_7365.c",
        "project": "radareorg/radare2",
        "url": "https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t   struct keyring_search_context *ctx)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#define KEYRING_SEARCH_MAX_DEPTH 6\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n#define KEYRING_PTR_SUBTYPE\t0x2UL\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\ttype = (unsigned long)index_key->type;\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\nsame:\n\treturn -1;\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tqty;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\tctx.qty = nr_keys * sizeof(key_serial_t);\n\tif (!buffer || !buflen)\n\t\treturn ctx.qty;\n\tif (buflen > ctx.qty)\n\t\tctx.qty = buflen;\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\nEXPORT_SYMBOL(keyring_alloc);\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\tkenter(\"{%d}\", key->serial);\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->type_data.reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\nskipped:\n\treturn ctx->skipped_ret;\n}\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tctx->skipped_ret = 0;\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\tptr = ACCESS_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\ndescend_to_node:\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\t\tkey = keyring_ptr_to_key(ptr);\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\tptr = ACCESS_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\nEXPORT_SYMBOL(keyring_search);\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!atomic_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\tBUG_ON(index_key->desc_len == 0);\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\tdown_write(&keyring->sem);\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\nEXPORT_SYMBOL(key_link);\nEXPORT_SYMBOL(key_unlink);\nEXPORT_SYMBOL(keyring_clear);\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_919.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```repodata_set_location(Repodata *data, Id solvid, int medianr, const char *dir, const char *file)\n  Pool *pool = data->repo->pool;\n  int l = 0;\n  if (medianr)\n    repodata_set_constant(data, solvid, SOLVABLE_MEDIANR, medianr);\n  if (!dir)\n      if ((dir = strrchr(file, '/')) != 0)\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n      dir += 2;\n      l -= 2;\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  s = pool->solvables + solvid;\n  if (dir && l)\n      str = pool_id2str(pool, s->arch);\n      if (!strncmp(dir, str, l) && !str[l])\n      else\n\trepodata_set_strn(data, solvid, SOLVABLE_MEDIADIR, dir, l);\n      if ((!l || !strncmp(fp, str, l)) && fp[l] == '.')\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define _GNU_SOURCE\n#include <string.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <assert.h>\n#include <regex.h>\n#include \"repo.h\"\n#include \"pool.h\"\n#include \"poolid_private.h\"\n#include \"util.h\"\n#include \"hash.h\"\n#include \"chksum.h\"\n#include \"repopack.h\"\n#include \"repopage.h\"\n#ifdef _WIN32\n  #include \"strfncs.h\"\n#endif\n#define REPODATA_BLOCK 255\nstatic unsigned char *data_skip_key(Repodata *data, unsigned char *dp, Repokey *key);\n#define SCHEMATA_BLOCK 31\n#define SCHEMATADATA_BLOCK 255\nId\nrepodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}\n#ifndef HAVE_STRCHRNUL\n#endif\n#define DIRCACHE_SIZE 41\t\n#ifdef DIRCACHE_SIZE\nstruct dircache {\n  Id ids[DIRCACHE_SIZE];\n  char str[(DIRCACHE_SIZE * (DIRCACHE_SIZE - 1)) / 2];\n};\n#endif\nId\nrepodata_str2dir(Repodata *data, const char *dir, int create)\n{\n  Id id, parent;\n#ifdef DIRCACHE_SIZE\n  const char *dirs;\n#endif\n  const char *dire;\n  if (!*dir)\n    return data->dirpool.ndirs ? 0 : dirpool_add_dir(&data->dirpool, 0, 0, create);\n  while (*dir == '/' && dir[1] == '/')\n    dir++;\n  if (*dir == '/' && !dir[1])\n    return data->dirpool.ndirs ? 1 : dirpool_add_dir(&data->dirpool, 0, 1, create);\n  parent = 0;\n#ifdef DIRCACHE_SIZE\n  dirs = dir;\n  if (data->dircache)\n    {\n      int l;\n      struct dircache *dircache = data->dircache;\n      l = strlen(dir);\n      while (l > 0)\n\t{\n\t  if (l < DIRCACHE_SIZE && dircache->ids[l] && !memcmp(dircache->str + l * (l - 1) / 2, dir, l))\n\t    {\n\t      parent = dircache->ids[l];\n\t      dir += l;\n\t      if (!*dir)\n\t\treturn parent;\n\t      while (*dir == '/')\n\t\tdir++;\n\t      break;\n\t    }\n\t  while (--l)\n\t    if (dir[l] == '/')\n\t      break;\n\t}\n    }\n#endif\n  while (*dir)\n    {\n      dire = strchrnul(dir, '/');\n      if (data->localpool)\n        id = stringpool_strn2id(&data->spool, dir, dire - dir, create);\n      else\n\tid = pool_strn2id(data->repo->pool, dir, dire - dir, create);\n      if (!id)\n\treturn 0;\n      parent = dirpool_add_dir(&data->dirpool, parent, id, create);\n      if (!parent)\n\treturn 0;\n#ifdef DIRCACHE_SIZE\n      if (!data->dircache)\n\tdata->dircache = solv_calloc(1, sizeof(struct dircache));\n      if (data->dircache)\n\t{\n\t  int l = dire - dirs;\n\t  if (l < DIRCACHE_SIZE)\n\t    {\n\t      data->dircache->ids[l] = parent;\n\t      memcpy(data->dircache->str + l * (l - 1) / 2, dirs, l);\n\t    }\n\t}\n#endif\n      if (!*dire)\n\tbreak;\n      dir = dire + 1;\n      while (*dir == '/')\n\tdir++;\n    }\n  return parent;\n}\nconst char *\nrepodata_dir2str(Repodata *data, Id did, const char *suf)\n{\n  Pool *pool = data->repo->pool;\n  int l = 0;\n  Id parent, comp;\n  const char *comps;\n  char *p;\n  if (!did)\n    return suf ? suf : \"\";\n  if (did == 1 && !suf)\n    return \"/\";\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l += strlen(comps);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n\tl++;\n    }\n  if (suf)\n    l += strlen(suf) + 1;\n  p = pool_alloctmpspace(pool, l + 1) + l;\n  *p = 0;\n  if (suf)\n    {\n      p -= strlen(suf);\n      strcpy(p, suf);\n      *--p = '/';\n    }\n  parent = did;\n  while (parent)\n    {\n      comp = dirpool_compid(&data->dirpool, parent);\n      comps = stringpool_id2str(data->localpool ? &data->spool : &pool->ss, comp);\n      l = strlen(comps);\n      p -= l;\n      strncpy(p, comps, l);\n      parent = dirpool_parent(&data->dirpool, parent);\n      if (parent)\n        *--p = '/';\n    }\n  return p;\n}\nstatic void\ndata_fetch_uninternalized(Repodata *data, Repokey *key, Id value, KeyValue *kv)\n{\n  Id *array;\n  kv->eof = 1;\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_STR:\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_CONSTANT:\n      kv->num2 = 0;\n      kv->num = key->size;\n      return;\n    case REPOKEY_TYPE_CONSTANTID:\n      kv->id = key->size;\n      return;\n    case REPOKEY_TYPE_NUM:\n      kv->num2 = 0;\n      kv->num = value;\n      if (value & 0x80000000)\n\t{\n\t  kv->num = (unsigned int)data->attrnum64data[value ^ 0x80000000];\n\t  kv->num2 = (unsigned int)(data->attrnum64data[value ^ 0x80000000] >> 32);\n\t}\n      return;\n    case_CHKSUM_TYPES:\n      kv->num = 0;\t\n      kv->str = (const char *)data->attrdata + value;\n      return;\n    case REPOKEY_TYPE_BINARY:\n      kv->str = (const char *)data_read_id(data->attrdata + value, (Id *)&kv->num);\n      return;\n    case REPOKEY_TYPE_IDARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      kv->num = 0;\t\n      array = data->attriddata + (value + kv->entry * 2);\n      kv->id = array[0];\n      kv->str = (const char *)data->attrdata + array[1];\n      kv->eof = array[2] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      array = data->attriddata + (value + kv->entry * 3);\n      kv->id = array[0];\n      kv->num = array[1];\n      kv->num2 = array[2];\n      kv->eof = array[3] ? 0 : 1;\n      return;\n    case REPOKEY_TYPE_FIXARRAY:\n    case REPOKEY_TYPE_FLEXARRAY:\n      array = data->attriddata + (value + kv->entry);\n      kv->id = array[0];\t\t\n      kv->eof = array[1] ? 0 : 1;\n      return;\n    default:\n      kv->id = value;\n      return;\n    }\n}\nconst char *\nrepodata_stringify(Pool *pool, Repodata *data, Repokey *key, KeyValue *kv, int flags)\n{\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_IDARRAY:\n      if (data && data->localpool)\n\tkv->str = stringpool_id2str(&data->spool, kv->id);\n      else\n\tkv->str = pool_id2str(pool, kv->id);\n      if ((flags & SEARCH_SKIP_KIND) != 0 && key->storage == KEY_STORAGE_SOLVABLE && (key->name == SOLVABLE_NAME || key->type == REPOKEY_TYPE_IDARRAY))\n\t{\n\t  const char *s;\n\t  for (s = kv->str; *s >= 'a' && *s <= 'z'; s++)\n\t    ;\n\t  if (*s == ':' && s > kv->str)\n\t    kv->str = s + 1;\n\t}\n      return kv->str;\n    case REPOKEY_TYPE_STR:\n      return kv->str;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      if (!(flags & SEARCH_FILES))\n\treturn kv->str;\t\n      if (kv->num)\n\treturn kv->str;\t\n      kv->str = repodata_dir2str(data, kv->id, kv->str);\n      kv->num = 1;\t\n      return kv->str;\n    case_CHKSUM_TYPES:\n      if (!(flags & SEARCH_CHECKSUMS))\n\treturn 0;\t\n      if (kv->num)\n\treturn kv->str;\t\n      kv->str = repodata_chk2str(data, key->type, (const unsigned char *)kv->str);\n      kv->num = 1;\t\n      return kv->str;\n    default:\n      return 0;\n    }\n}\nstruct subschema_data {\n  void *cbdata;\n  Id solvid;\n  KeyValue *parent;\n};\nstatic int\nrepodata_search_array(Repodata *data, Id solvid, Id keyname, int flags, Repokey *key, KeyValue *kv, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Solvable *s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  unsigned char *dp = (unsigned char *)kv->str;\n  int stop;\n  Id schema = 0;\n  if (!dp || kv->entry != -1)\n    return 0;\n  while (++kv->entry < (int)kv->num)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      if (kv->entry == 0 || key->type == REPOKEY_TYPE_FLEXARRAY)\n\tdp = data_read_id(dp, &schema);\n      kv->id = schema;\n      kv->str = (const char *)dp;\n      kv->eof = kv->entry == kv->num - 1 ? 1 : 0;\n      stop = callback(cbdata, s, data, key, kv);\n      if (stop && stop != SEARCH_ENTERSUB)\n\treturn stop;\n      if ((flags & SEARCH_SUB) != 0 || stop == SEARCH_ENTERSUB)\n        repodata_search_keyskip(data, solvid, keyname, flags | SEARCH_SUBSCHEMA, (Id *)kv, callback, cbdata);\n    }\n  if ((flags & SEARCH_ARRAYSENTINEL) != 0)\n    {\n      if (kv->entry)\n\tdp = data_skip_schema(data, dp, schema);\n      kv->id = 0;\n      kv->str = (const char *)dp;\n      kv->eof = 2;\n      return callback(cbdata, s, data, key, kv);\n    }\n  return 0;\n}\nvoid\nrepodata_search_keyskip(Repodata *data, Id solvid, Id keyname, int flags, Id *keyskip, int (*callback)(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *kv), void *cbdata)\n{\n  Id schema;\n  Repokey *key;\n  Id keyid, *kp, *keyp;\n  unsigned char *dp, *ddp;\n  int onekey = 0;\n  int stop;\n  KeyValue kv;\n  Solvable *s;\n  if (!maybe_load_repodata(data, keyname))\n    return;\n  if ((flags & SEARCH_SUBSCHEMA) != 0)\n    {\n      flags ^= SEARCH_SUBSCHEMA;\n      kv.parent = (KeyValue *)keyskip;\n      keyskip = 0;\n      schema = kv.parent->id;\n      dp = (unsigned char *)kv.parent->str;\n    }\n  else\n    {\n      schema = 0;\n      dp = solvid2data(data, solvid, &schema);\n      if (!dp)\n\treturn;\n      kv.parent = 0;\n    }\n  s = solvid > 0 ? data->repo->pool->solvables + solvid : 0;\n  keyp = data->schemadata + data->schemata[schema];\n  if (keyname)\n    {\n      for (kp = keyp; *kp; kp++)\n\tif (data->keys[*kp].name == keyname)\n\t  break;\n      if (!*kp)\n\treturn;\n      dp = forward_to_key(data, *kp, keyp, dp);\n      if (!dp)\n\treturn;\n      keyp = kp;\n      onekey = 1;\n    }\n  while ((keyid = *keyp++) != 0)\n    {\n      stop = 0;\n      key = data->keys + keyid;\n      ddp = get_data(data, key, &dp, *keyp && !onekey ? 1 : 0);\n      if (keyskip && (key->name >= keyskip[0] || keyskip[3 + key->name] != keyskip[1] + data->repodataid))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_DELETED && !(flags & SEARCH_KEEP_TYPE_DELETED))\n\t{\n\t  if (onekey)\n\t    return;\n\t  continue;\n\t}\n      if (key->type == REPOKEY_TYPE_FLEXARRAY || key->type == REPOKEY_TYPE_FIXARRAY)\n\t{\n\t  kv.entry = -1;\n\t  ddp = data_read_id(ddp, (Id *)&kv.num);\n\t  kv.str = (const char *)ddp;\n\t  stop = repodata_search_array(data, solvid, 0, flags, key, &kv, callback, cbdata);\n\t  if (onekey || stop > SEARCH_NEXT_KEY)\n\t    return;\n\t  continue;\n\t}\n      kv.entry = 0;\n      do\n\t{\n\t  ddp = data_fetch(ddp, &kv, key);\n\t  if (!ddp)\n\t    break;\n\t  stop = callback(cbdata, s, data, key, &kv);\n\t  kv.entry++;\n\t}\n      while (!kv.eof && !stop);\n      if (onekey || stop > SEARCH_NEXT_KEY)\n\treturn;\n    }\n}\nstatic inline Id *\nsolvabledata_fetch(Solvable *s, KeyValue *kv, Id keyname)\n{\n  kv->id = keyname;\n  switch (keyname)\n    {\n    case SOLVABLE_NAME:\n      kv->eof = 1;\n      return &s->name;\n    case SOLVABLE_ARCH:\n      kv->eof = 1;\n      return &s->arch;\n    case SOLVABLE_EVR:\n      kv->eof = 1;\n      return &s->evr;\n    case SOLVABLE_VENDOR:\n      kv->eof = 1;\n      return &s->vendor;\n    case SOLVABLE_PROVIDES:\n      kv->eof = 0;\n      return s->provides ? s->repo->idarraydata + s->provides : 0;\n    case SOLVABLE_OBSOLETES:\n      kv->eof = 0;\n      return s->obsoletes ? s->repo->idarraydata + s->obsoletes : 0;\n    case SOLVABLE_CONFLICTS:\n      kv->eof = 0;\n      return s->conflicts ? s->repo->idarraydata + s->conflicts : 0;\n    case SOLVABLE_REQUIRES:\n      kv->eof = 0;\n      return s->requires ? s->repo->idarraydata + s->requires : 0;\n    case SOLVABLE_RECOMMENDS:\n      kv->eof = 0;\n      return s->recommends ? s->repo->idarraydata + s->recommends : 0;\n    case SOLVABLE_SUPPLEMENTS:\n      kv->eof = 0;\n      return s->supplements ? s->repo->idarraydata + s->supplements : 0;\n    case SOLVABLE_SUGGESTS:\n      kv->eof = 0;\n      return s->suggests ? s->repo->idarraydata + s->suggests : 0;\n    case SOLVABLE_ENHANCES:\n      kv->eof = 0;\n      return s->enhances ? s->repo->idarraydata + s->enhances : 0;\n    case RPM_RPMDBID:\n      kv->eof = 1;\n      return s->repo->rpmdbid ? s->repo->rpmdbid + (s - s->repo->pool->solvables - s->repo->start) : 0;\n    default:\n      return 0;\n    }\n}\nint\ndatamatcher_init(Datamatcher *ma, const char *match, int flags)\n{\n  match = match ? solv_strdup(match) : 0;\n  ma->match = match;\n  ma->flags = flags;\n  ma->error = 0;\n  ma->matchdata = 0;\n  if ((flags & SEARCH_STRINGMASK) == SEARCH_REGEX)\n    {\n      ma->matchdata = solv_calloc(1, sizeof(regex_t));\n      ma->error = regcomp((regex_t *)ma->matchdata, match, REG_EXTENDED | REG_NOSUB | REG_NEWLINE | ((flags & SEARCH_NOCASE) ? REG_ICASE : 0));\n      if (ma->error)\n\t{\n\t  solv_free(ma->matchdata);\n\t  ma->flags = (flags & ~SEARCH_STRINGMASK) | SEARCH_ERROR;\n\t}\n    }\n  if ((flags & SEARCH_FILES) != 0 && match)\n    {\n      if ((flags & SEARCH_STRINGMASK) == SEARCH_STRING || (flags & SEARCH_STRINGMASK) == SEARCH_STRINGEND)\n\t{\n\t  const char *p = strrchr(match, '/');\n\t  ma->matchdata = (void *)(p ? p + 1 : match);\n\t}\n      else if ((flags & SEARCH_STRINGMASK) == SEARCH_GLOB)\n\t{\n\t  const char *p;\n\t  for (p = match + strlen(match) - 1; p >= match; p--)\n\t    if (*p == '[' || *p == ']' || *p == '*' || *p == '?' || *p == '/')\n\t      break;\n\t  ma->matchdata = (void *)(p + 1);\n\t}\n    }\n  return ma->error;\n}\nint\ndatamatcher_match(Datamatcher *ma, const char *str)\n{\n  int l;\n  switch ((ma->flags & SEARCH_STRINGMASK))\n    {\n    case SEARCH_SUBSTRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn strcasestr(str, ma->match) != 0;\n      else\n\treturn strstr(str, ma->match) != 0;\n    case SEARCH_STRING:\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str);\n      else\n\treturn !strcmp(ma->match, str);\n    case SEARCH_STRINGSTART:\n      if (ma->flags & SEARCH_NOCASE)\n        return !strncasecmp(ma->match, str, strlen(ma->match));\n      else\n        return !strncmp(ma->match, str, strlen(ma->match));\n    case SEARCH_STRINGEND:\n      l = strlen(str) - strlen(ma->match);\n      if (l < 0)\n\treturn 0;\n      if (ma->flags & SEARCH_NOCASE)\n\treturn !strcasecmp(ma->match, str + l);\n      else\n\treturn !strcmp(ma->match, str + l);\n    case SEARCH_GLOB:\n      return !fnmatch(ma->match, str, (ma->flags & SEARCH_NOCASE) ? FNM_CASEFOLD : 0);\n    case SEARCH_REGEX:\n      return !regexec((const regex_t *)ma->matchdata, str, 0, NULL, 0);\n    default:\n      return 0;\n    }\n}\nenum {\n  di_bye,\n  di_enterrepo,\n  di_entersolvable,\n  di_enterrepodata,\n  di_enterschema,\n  di_enterkey,\n  di_nextattr,\n  di_nextkey,\n  di_nextrepodata,\n  di_nextsolvable,\n  di_nextrepo,\n  di_enterarray,\n  di_nextarrayelement,\n  di_entersub,\n  di_leavesub,\n  di_nextsolvablekey,\n  di_entersolvablekey,\n  di_nextsolvableattr\n};\nint\ndataiterator_step(Dataiterator *di)\n{\n  Id schema;\n  if (di->state == di_nextattr && di->key->storage == KEY_STORAGE_VERTICAL_OFFSET && di->vert_ddp && di->vert_storestate != di->data->storestate)\n    {\n      unsigned int ddpoff = di->ddp - di->vert_ddp;\n      di->vert_off += ddpoff;\n      di->vert_len -= ddpoff;\n      di->ddp = di->vert_ddp = get_vertical_data(di->data, di->key, di->vert_off, di->vert_len);\n      di->vert_storestate = di->data->storestate;\n      if (!di->ddp)\n\tdi->state = di_nextkey;\n    }\n  for (;;)\n    {\n      switch (di->state)\n\t{\n\tcase di_enterrepo: di_enterrepo:\n\t  if (!di->repo || (di->repo->disabled && !(di->flags & SEARCH_DISABLED_REPOS)))\n\t    goto di_nextrepo;\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      di->solvid = di->repo->start - 1;\t\n\t      goto di_nextsolvable;\n\t    }\n\tcase di_entersolvable: di_entersolvable:\n\t  if (!di->repodataid)\n\t    goto di_enterrepodata;\t\n\t  if (di->solvid > 0 && !(di->flags & SEARCH_NO_STORAGE_SOLVABLE) && (!di->keyname || (di->keyname >= SOLVABLE_NAME && di->keyname <= RPM_RPMDBID)) && di->nparents - di->rootlevel == di->nkeynames)\n\t    {\n\t      extern Repokey repo_solvablekeys[RPM_RPMDBID - SOLVABLE_NAME + 1];\n\t      di->key = repo_solvablekeys + (di->keyname ? di->keyname - SOLVABLE_NAME : 0);\n\t      di->data = 0;\n\t      goto di_entersolvablekey;\n\t    }\n\t  if (di->keyname)\n\t    {\n\t      di->data = di->keyname == SOLVABLE_FILELIST ? repo_lookup_filelist_repodata(di->repo, di->solvid, &di->matcher) : repo_lookup_repodata_opt(di->repo, di->solvid, di->keyname);\n\t      if (!di->data)\n\t\tgoto di_nextsolvable;\n\t      di->repodataid = di->data - di->repo->repodata;\n\t      di->keyskip = 0;\n\t      goto di_enterrepodata;\n\t    }\n\tdi_leavesolvablekey:\n\t  di->repodataid = 1;\t\n\t  di->keyskip = repo_create_keyskip(di->repo, di->solvid, &di->oldkeyskip);\n\tcase di_enterrepodata: di_enterrepodata:\n\t  if (di->repodataid)\n\t    {\n\t      if (di->repodataid >= di->repo->nrepodata)\n\t\tgoto di_nextsolvable;\n\t      di->data = di->repo->repodata + di->repodataid;\n\t    }\n\t  if (!maybe_load_repodata(di->data, di->keyname))\n\t    goto di_nextrepodata;\n\t  di->dp = solvid2data(di->data, di->solvid, &schema);\n\t  if (!di->dp)\n\t    goto di_nextrepodata;\n\t  if (di->solvid == SOLVID_POS)\n\t    di->solvid = di->pool->pos.solvid;\n\t  di->keyp = di->data->schemadata + di->data->schemata[schema];\n\tcase di_enterschema: di_enterschema:\n\t  if (di->keyname)\n\t    di->dp = dataiterator_find_keyname(di, di->keyname);\n\t  if (!di->dp || !*di->keyp)\n\t    {\n\t      if (di->kv.parent)\n\t\tgoto di_leavesub;\n\t      goto di_nextrepodata;\n\t    }\n\tcase di_enterkey: di_enterkey:\n\t  di->kv.entry = -1;\n\t  di->key = di->data->keys + *di->keyp;\n\t  if (!di->dp)\n\t    goto di_nextkey;\n\t  if (di->key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t    {\n\t      Id off, len;\n\t      di->dp = data_read_id(di->dp, &off);\n\t      di->dp = data_read_id(di->dp, &len);\n\t      di->vert_ddp = di->ddp = get_vertical_data(di->data, di->key, off, len);\n\t      di->vert_off = off;\n\t      di->vert_len = len;\n\t      di->vert_storestate = di->data->storestate;\n\t    }\n\t  else if (di->key->storage == KEY_STORAGE_INCORE)\n\t    {\n\t      di->ddp = di->dp;\t\t\n\t      if (di->keyp[1] && (!di->keyname || (di->flags & SEARCH_SUB) != 0))\n\t\tdi->dp = data_skip_key(di->data, di->dp, di->key);\t\n\t    }\n\t  else\n\t    di->ddp = 0;\n\t  if (!di->ddp)\n\t    goto di_nextkey;\n\t  if (di->keyskip && (di->key->name >= di->keyskip[0] || di->keyskip[3 + di->key->name] != di->keyskip[1] + di->data->repodataid))\n\t    goto di_nextkey;\n          if (di->key->type == REPOKEY_TYPE_DELETED && !(di->flags & SEARCH_KEEP_TYPE_DELETED))\n\t    goto di_nextkey;\n\t  if (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY)\n\t    goto di_enterarray;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_nextkey;\n\tcase di_nextattr:\n          di->kv.entry++;\n\t  di->ddp = data_fetch(di->ddp, &di->kv, di->key);\n\t  di->state = di->kv.eof ? di_nextkey : di_nextattr;\n\t  break;\n\tcase di_nextkey: di_nextkey:\n\t  if (!di->keyname && *++di->keyp)\n\t    goto di_enterkey;\n\t  if (di->kv.parent)\n\t    goto di_leavesub;\n\tcase di_nextrepodata: di_nextrepodata:\n\t  if (!di->keyname && di->repodataid && ++di->repodataid < di->repo->nrepodata)\n\t      goto di_enterrepodata;\n\tcase di_nextsolvable: di_nextsolvable:\n\t  if (!(di->flags & SEARCH_THISSOLVID))\n\t    {\n\t      if (di->solvid < 0)\n\t\tdi->solvid = di->repo->start;\n\t      else\n\t        di->solvid++;\n\t      for (; di->solvid < di->repo->end; di->solvid++)\n\t\t{\n\t\t  if (di->pool->solvables[di->solvid].repo == di->repo)\n\t\t    goto di_entersolvable;\n\t\t}\n\t    }\n\tcase di_nextrepo: di_nextrepo:\n\t  if (di->repoid > 0)\n\t    {\n\t      di->repoid++;\n\t      di->repodataid = 1;\n\t      if (di->repoid < di->pool->nrepos)\n\t\t{\n\t\t  di->repo = di->pool->repos[di->repoid];\n\t          goto di_enterrepo;\n\t\t}\n\t    }\n\tcase di_bye: di_bye:\n\t  di->state = di_bye;\n\t  return 0;\n\tcase di_enterarray: di_enterarray:\n\t  if (di->key->name == REPOSITORY_SOLVABLES)\n\t    goto di_nextkey;\n\t  di->ddp = data_read_id(di->ddp, (Id *)&di->kv.num);\n\t  di->kv.eof = 0;\n\t  di->kv.entry = -1;\n\tcase di_nextarrayelement: di_nextarrayelement:\n\t  di->kv.entry++;\n\t  if (di->kv.entry)\n\t    di->ddp = data_skip_schema(di->data, di->ddp, di->kv.id);\n\t  if (di->kv.entry == di->kv.num)\n\t    {\n\t      if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t\tgoto di_nextkey;\n\t      if (!(di->flags & SEARCH_ARRAYSENTINEL))\n\t\tgoto di_nextkey;\n\t      di->kv.str = (char *)di->ddp;\n\t      di->kv.eof = 2;\n\t      di->state = di_nextkey;\n\t      break;\n\t    }\n\t  if (di->kv.entry == di->kv.num - 1)\n\t    di->kv.eof = 1;\n\t  if (di->key->type == REPOKEY_TYPE_FLEXARRAY || !di->kv.entry)\n\t    di->ddp = data_read_id(di->ddp, &di->kv.id);\n\t  di->kv.str = (char *)di->ddp;\n\t  if (di->nkeynames && di->nparents - di->rootlevel < di->nkeynames)\n\t    goto di_entersub;\n\t  if ((di->flags & SEARCH_SUB) != 0)\n\t    di->state = di_entersub;\n\t  else\n\t    di->state = di_nextarrayelement;\n\t  break;\n\tcase di_entersub: di_entersub:\n\t  if (di->nparents == sizeof(di->parents)/sizeof(*di->parents) - 1)\n\t    goto di_nextarrayelement;\t\n\t  di->parents[di->nparents].kv = di->kv;\n\t  di->parents[di->nparents].dp = di->dp;\n\t  di->parents[di->nparents].keyp = di->keyp;\n\t  di->dp = (unsigned char *)di->kv.str;\n\t  di->keyp = di->data->schemadata + di->data->schemata[di->kv.id];\n\t  memset(&di->kv, 0, sizeof(di->kv));\n\t  di->kv.parent = &di->parents[di->nparents].kv;\n\t  di->nparents++;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_enterschema;\n\tcase di_leavesub: di_leavesub:\n\t  if (di->nparents - 1 < di->rootlevel)\n\t    goto di_bye;\n\t  di->nparents--;\n\t  di->dp = di->parents[di->nparents].dp;\n\t  di->kv = di->parents[di->nparents].kv;\n\t  di->keyp = di->parents[di->nparents].keyp;\n\t  di->key = di->data->keys + *di->keyp;\n\t  di->ddp = (unsigned char *)di->kv.str;\n\t  di->keyname = di->keynames[di->nparents - di->rootlevel];\n\t  goto di_nextarrayelement;\n\tcase di_nextsolvablekey: di_nextsolvablekey:\n\t  if (di->keyname)\n\t    goto di_nextsolvable;\n\t  if (di->key->name == RPM_RPMDBID)\t\n\t    goto di_leavesolvablekey;\n\t  di->key++;\n\tcase di_entersolvablekey: di_entersolvablekey:\n\t  di->idp = solvabledata_fetch(di->pool->solvables + di->solvid, &di->kv, di->key->name);\n\t  if (!di->idp || !*di->idp)\n\t    goto di_nextsolvablekey;\n\t  if (di->kv.eof)\n\t    {\n\t      di->kv.id = *di->idp;\n\t      di->kv.num = *di->idp;\t\n\t      di->kv.num2 = 0;\t\t\n\t      di->kv.entry = 0;\n\t      di->state = di_nextsolvablekey;\n\t      break;\n\t    }\n\t  di->kv.entry = -1;\n\tcase di_nextsolvableattr:\n\t  di->state = di_nextsolvableattr;\n\t  di->kv.id = *di->idp++;\n\t  di->kv.entry++;\n\t  if (!*di->idp)\n\t    {\n\t      di->kv.eof = 1;\n\t      di->state = di_nextsolvablekey;\n\t    }\n\t  break;\n\t}\n      if (di->matcher.match)\n\t{\n\t  const char *str;\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->matcher.flags & SEARCH_FILES) != 0)\n\t    if (!datamatcher_checkbasename(&di->matcher, di->kv.str))\n\t      continue;\n\t  if (!(str = repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags)))\n\t    {\n\t      if (di->keyname && (di->key->type == REPOKEY_TYPE_FIXARRAY || di->key->type == REPOKEY_TYPE_FLEXARRAY))\n\t\treturn 1;\n\t      continue;\n\t    }\n\t  if (!datamatcher_match(&di->matcher, str))\n\t    continue;\n\t}\n      else\n\t{\n\t  if (di->keyname == SOLVABLE_FILELIST && di->key->type == REPOKEY_TYPE_DIRSTRARRAY && (di->flags & SEARCH_FILES) != 0)\n\t    repodata_stringify(di->pool, di->data, di->key, &di->kv, di->flags);\n\t}\n      return 1;\n    }\n}\nvoid\ndataiterator_seek(Dataiterator *di, int whence)\n{\n  if ((whence & DI_SEEK_STAY) != 0)\n    di->rootlevel = di->nparents;\n  switch (whence & ~DI_SEEK_STAY)\n    {\n    case DI_SEEK_CHILD:\n      if (di->state != di_nextarrayelement)\n\tbreak;\n      if ((whence & DI_SEEK_STAY) != 0)\n\tdi->rootlevel = di->nparents + 1;\t\n      di->state = di_entersub;\n      break;\n    case DI_SEEK_PARENT:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->nparents--;\n      if (di->rootlevel > di->nparents)\n\tdi->rootlevel = di->nparents;\n      di->dp = di->parents[di->nparents].dp;\n      di->kv = di->parents[di->nparents].kv;\n      di->keyp = di->parents[di->nparents].keyp;\n      di->key = di->data->keys + *di->keyp;\n      di->ddp = (unsigned char *)di->kv.str;\n      di->keyname = di->keynames[di->nparents - di->rootlevel];\n      di->state = di_nextarrayelement;\n      break;\n    case DI_SEEK_REWIND:\n      if (!di->nparents)\n\t{\n\t  di->state = di_bye;\n\t  break;\n\t}\n      di->dp = (unsigned char *)di->kv.parent->str;\n      di->keyp = di->data->schemadata + di->data->schemata[di->kv.parent->id];\n      di->state = di_enterschema;\n      break;\n    default:\n      break;\n    }\n}\nvoid\nrepodata_extend(Repodata *data, Id p)\n{\n  if (data->start == data->end)\n    data->start = data->end = p;\n  if (p >= data->end)\n    {\n      int old = data->end - data->start;\n      int new = p - data->end + 1;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend(data->attrs, old, new, sizeof(Id *), REPODATA_BLOCK);\n\t  memset(data->attrs + old, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend(data->incoreoffset, old, new, sizeof(Id), REPODATA_BLOCK);\n      memset(data->incoreoffset + old, 0, new * sizeof(Id));\n      data->end = p + 1;\n    }\n  if (p < data->start)\n    {\n      int old = data->end - data->start;\n      int new = data->start - p;\n      if (data->attrs)\n\t{\n\t  data->attrs = solv_extend_resize(data->attrs, old + new, sizeof(Id *), REPODATA_BLOCK);\n\t  memmove(data->attrs + new, data->attrs, old * sizeof(Id *));\n\t  memset(data->attrs, 0, new * sizeof(Id *));\n\t}\n      data->incoreoffset = solv_extend_resize(data->incoreoffset, old + new, sizeof(Id), REPODATA_BLOCK);\n      memmove(data->incoreoffset + new, data->incoreoffset, old * sizeof(Id));\n      memset(data->incoreoffset, 0, new * sizeof(Id));\n      data->start = p;\n    }\n}\n#define REPODATA_ATTRS_BLOCK 31\n#define REPODATA_ATTRDATA_BLOCK 1023\n#define REPODATA_ATTRIDDATA_BLOCK 63\n#define REPODATA_ATTRNUM64DATA_BLOCK 15\nstatic void\nrepodata_add_array(Repodata *data, Id handle, Id keyname, Id keytype, int entrysize)\n{\n  int oldsize;\n  Id *ida, *pp, **ppp;\n  if (handle == data->lasthandle && data->keys[data->lastkey].name == keyname && data->keys[data->lastkey].type == keytype && data->attriddatalen == data->lastdatalen)\n    {\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t\n      data->lastdatalen += entrysize;\n      return;\n    }\n  ppp = repodata_get_attrp(data, handle);\n  pp = *ppp;\n  if (pp)\n    {\n      for (; *pp; pp += 2)\n        if (data->keys[*pp].name == keyname)\n          break;\n    }\n  if (!pp || !*pp || data->keys[*pp].type != keytype)\n    {\n      Repokey key;\n      Id keyid;\n      key.name = keyname;\n      key.type = keytype;\n      key.size = 0;\n      key.storage = KEY_STORAGE_INCORE;\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      keyid = repodata_key2id(data, &key, 1);\n      repodata_insert_keyid(data, handle, keyid, data->attriddatalen, 1);\n      data->lasthandle = handle;\n      data->lastkey = keyid;\n      data->lastdatalen = data->attriddatalen + entrysize + 1;\n      return;\n    }\n  oldsize = 0;\n  for (ida = data->attriddata + pp[1]; *ida; ida += entrysize)\n    oldsize += entrysize;\n  if (ida + 1 == data->attriddata + data->attriddatalen)\n    {\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen, entrysize, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      data->attriddatalen--;\t\n    }\n  else\n    {\n      data->attriddata = solv_extend(data->attriddata, data->attriddatalen,  oldsize + entrysize + 1, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n      memcpy(data->attriddata + data->attriddatalen, data->attriddata + pp[1], oldsize * sizeof(Id));\n      pp[1] = data->attriddatalen;\n      data->attriddatalen += oldsize;\n    }\n  data->lasthandle = handle;\n  data->lastkey = *pp;\n  data->lastdatalen = data->attriddatalen + entrysize + 1;\n}\nvoid\nrepodata_set_location(Repodata *data, Id solvid, int medianr, const char *dir, const char *file)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s;\n  const char *str, *fp;\n  int l = 0;\n  if (medianr)\n    repodata_set_constant(data, solvid, SOLVABLE_MEDIANR, medianr);\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  s = pool->solvables + solvid;\n  if (dir && l)\n    {\n      str = pool_id2str(pool, s->arch);\n      if (!strncmp(dir, str, l) && !str[l])\n\trepodata_set_void(data, solvid, SOLVABLE_MEDIADIR);\n      else\n\trepodata_set_strn(data, solvid, SOLVABLE_MEDIADIR, dir, l);\n    }\n  fp = file;\n  str = pool_id2str(pool, s->name);\n  l = strlen(str);\n  if ((!l || !strncmp(fp, str, l)) && fp[l] == '-')\n    {\n      fp += l + 1;\n      str = evrid2vrstr(pool, s->evr);\n      l = strlen(str);\n      if ((!l || !strncmp(fp, str, l)) && fp[l] == '.')\n\t{\n\t  fp += l + 1;\n\t  str = pool_id2str(pool, s->arch);\n\t  l = strlen(str);\n\t  if ((!l || !strncmp(fp, str, l)) && !strcmp(fp + l, \".rpm\"))\n\t    {\n\t      repodata_set_void(data, solvid, SOLVABLE_MEDIAFILE);\n\t      return;\n\t    }\n\t}\n    }\n  repodata_set_str(data, solvid, SOLVABLE_MEDIAFILE, file);\n}\nvoid\nrepodata_set_deltalocation(Repodata *data, Id handle, int medianr, const char *dir, const char *file)\n{\n  int l = 0;\n  const char *evr, *suf, *s;\n  if (!dir)\n    {\n      if ((dir = strrchr(file, '/')) != 0)\n\t{\n          l = dir - file;\n\t  dir = file;\n\t  file = dir + l + 1;\n\t  if (!l)\n\t    l++;\n\t}\n    }\n  else\n    l = strlen(dir);\n  if (l >= 2 && dir[0] == '.' && dir[1] == '/' && (l == 2 || dir[2] != '/'))\n    {\n      dir += 2;\n      l -= 2;\n    }\n  if (l == 1 && dir[0] == '.')\n    l = 0;\n  if (dir && l)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_DIR, dir, l);\n  evr = strchr(file, '-');\n  if (evr)\n    {\n      for (s = evr - 1; s > file; s--)\n\tif (*s == '-')\n\t  {\n\t    evr = s;\n\t    break;\n\t  }\n    }\n  suf = strrchr(file, '.');\n  if (suf)\n    {\n      for (s = suf - 1; s > file; s--)\n\tif (*s == '.')\n\t  {\n\t    suf = s;\n\t    break;\n\t  }\n      if (!strcmp(suf, \".delta.rpm\") || !strcmp(suf, \".patch.rpm\"))\n\t{\n\t  for (s = suf - 1; s > file; s--)\n\t    if (*s == '.')\n\t      {\n\t\tsuf = s;\n\t        break;\n\t      }\n\t}\n    }\n  if (!evr)\n    suf = 0;\n  if (suf && evr && suf < evr)\n    suf = 0;\n  repodata_set_poolstrn(data, handle, DELTA_LOCATION_NAME, file, evr ? evr - file : strlen(file));\n  if (evr)\n    repodata_set_poolstrn(data, handle, DELTA_LOCATION_EVR, evr + 1, suf ? suf - evr - 1: strlen(evr + 1));\n  if (suf)\n    repodata_set_poolstr(data, handle, DELTA_LOCATION_SUFFIX, suf + 1);\n}\nvoid\nrepodata_set_sourcepkg(Repodata *data, Id solvid, const char *sourcepkg)\n{\n  Pool *pool = data->repo->pool;\n  Solvable *s = pool->solvables + solvid;\n  const char *p, *sevr, *sarch, *name, *evr;\n  p = strrchr(sourcepkg, '.');\n  if (!p || strcmp(p, \".rpm\") != 0)\n    {\n      if (*sourcepkg)\n        repodata_set_str(data, solvid, SOLVABLE_SOURCENAME, sourcepkg);\n      return;\n    }\n  p--;\n  while (p > sourcepkg && *p != '.')\n    p--;\n  if (*p != '.' || p == sourcepkg)\n    return;\n  sarch = p-- + 1;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  p--;\n  while (p > sourcepkg && *p != '-')\n    p--;\n  if (*p != '-' || p == sourcepkg)\n    return;\n  sevr = p + 1;\n  pool = s->repo->pool;\n  name = pool_id2str(pool, s->name);\n  if (name && !strncmp(sourcepkg, name, sevr - sourcepkg - 1) && name[sevr - sourcepkg - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCENAME);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCENAME, pool_strn2id(pool, sourcepkg, sevr - sourcepkg - 1, 1));\n  evr = evrid2vrstr(pool, s->evr);\n  if (evr && !strncmp(sevr, evr, sarch - sevr - 1) && evr[sarch - sevr - 1] == 0)\n    repodata_set_void(data, solvid, SOLVABLE_SOURCEEVR);\n  else\n    repodata_set_id(data, solvid, SOLVABLE_SOURCEEVR, pool_strn2id(pool, sevr, sarch - sevr - 1, 1));\n  if (!strcmp(sarch, \"src.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_SRC);\n  else if (!strcmp(sarch, \"nosrc.rpm\"))\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, ARCH_NOSRC);\n  else\n    repodata_set_constantid(data, solvid, SOLVABLE_SOURCEARCH, pool_strn2id(pool, sarch, strlen(sarch) - 4, 1));\n}\nvoid\nrepodata_set_kv(Repodata *data, Id solvid, Id keyname, Id keytype, KeyValue *kv)\n{\n  switch (keytype)\n    {\n    case REPOKEY_TYPE_ID:\n      repodata_set_id(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_CONSTANTID:\n      repodata_set_constantid(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      repodata_add_idarray(data, solvid, keyname, kv->id);\n      break;\n    case REPOKEY_TYPE_STR:\n      repodata_set_str(data, solvid, keyname, kv->str);\n      break;\n    case REPOKEY_TYPE_VOID:\n      repodata_set_void(data, solvid, keyname);\n      break;\n    case REPOKEY_TYPE_NUM:\n      repodata_set_num(data, solvid, keyname, SOLV_KV_NUM64(kv));\n      break;\n    case REPOKEY_TYPE_CONSTANT:\n      repodata_set_constant(data, solvid, keyname, kv->num);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      if (kv->id)\n        repodata_add_dirnumnum(data, solvid, keyname, kv->id, kv->num, kv->num2);\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      repodata_add_dirstr(data, solvid, keyname, kv->id, kv->str);\n      break;\n    case_CHKSUM_TYPES:\n      repodata_set_bin_checksum(data, solvid, keyname, keytype, (const unsigned char *)kv->str);\n      break;\n    default:\n      break;\n    }\n}\n#define EXTDATA_BLOCK 1023\nstruct extdata {\n  unsigned char *buf;\n  int len;\n};\nstatic void\ncompact_attrdata(Repodata *data, int entry, int nentry)\n{\n  int i;\n  unsigned int attrdatastart = data->attrdatalen;\n  unsigned int attriddatastart = data->attriddatalen;\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      if ((unsigned int)attrs[1] < attrdatastart)\n\t\t attrdatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tif ((unsigned int)data->attriddata[v + 1] < attrdatastart)\n\t\t  attrdatastart = data->attriddata[v + 1];\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      if ((unsigned int)attrs[1] < attriddatastart)\n\t\tattriddatastart = attrs[1];\n\t      break;\n\t    case REPOKEY_TYPE_FIXARRAY:\n\t    case REPOKEY_TYPE_FLEXARRAY:\n\t      return;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n#if 0\n  printf(\"compact_attrdata %d %d\\n\", entry, nentry);\n  printf(\"attrdatastart: %d\\n\", attrdatastart);\n  printf(\"attriddatastart: %d\\n\", attriddatastart);\n#endif\n  if (attrdatastart < 1024 * 1024 * 4 && attriddatastart < 1024 * 1024)\n    return;\n  for (i = entry; i < nentry; i++)\n    {\n      Id v, *attrs = data->attrs[i];\n      if (!attrs)\n\tcontinue;\n      for (; *attrs; attrs += 2)\n\t{\n\t  switch (data->keys[*attrs].type)\n\t    {\n\t    case REPOKEY_TYPE_STR:\n\t    case REPOKEY_TYPE_BINARY:\n\t    case_CHKSUM_TYPES:\n\t      attrs[1] -= attrdatastart;\n\t      break;\n\t    case REPOKEY_TYPE_DIRSTRARRAY:\n\t      for (v = attrs[1]; data->attriddata[v] ; v += 2)\n\t\tdata->attriddata[v + 1] -= attrdatastart;\n\t    case REPOKEY_TYPE_IDARRAY:\n\t    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n\t      attrs[1] -= attriddatastart;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  if (attrdatastart)\n    {\n      data->attrdatalen -= attrdatastart;\n      memmove(data->attrdata, data->attrdata + attrdatastart, data->attrdatalen);\n      data->attrdata = solv_extend_resize(data->attrdata, data->attrdatalen, 1, REPODATA_ATTRDATA_BLOCK);\n    }\n  if (attriddatastart)\n    {\n      data->attriddatalen -= attriddatastart;\n      memmove(data->attriddata, data->attriddata + attriddatastart, data->attriddatalen * sizeof(Id));\n      data->attriddata = solv_extend_resize(data->attriddata, data->attriddatalen, sizeof(Id), REPODATA_ATTRIDDATA_BLOCK);\n    }\n}\nstatic void\nrepodata_serialize_key(Repodata *data, struct extdata *newincore,\n\t\t       struct extdata *newvincore,\n\t\t       Id *schema,\n\t\t       Repokey *key, Id val)\n{\n  Id *ida;\n  struct extdata *xd;\n  unsigned int oldvincorelen = 0;\n  Id schemaid, *sp;\n  xd = newincore;\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      xd = newvincore;\n      oldvincorelen = xd->len;\n    }\n  switch (key->type)\n    {\n    case REPOKEY_TYPE_VOID:\n    case REPOKEY_TYPE_CONSTANT:\n    case REPOKEY_TYPE_CONSTANTID:\n    case REPOKEY_TYPE_DELETED:\n      break;\n    case REPOKEY_TYPE_STR:\n      data_addblob(xd, data->attrdata + val, strlen((char *)(data->attrdata + val)) + 1);\n      break;\n    case REPOKEY_TYPE_MD5:\n      data_addblob(xd, data->attrdata + val, SIZEOF_MD5);\n      break;\n    case REPOKEY_TYPE_SHA1:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA1);\n      break;\n    case REPOKEY_TYPE_SHA224:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA224);\n      break;\n    case REPOKEY_TYPE_SHA256:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA256);\n      break;\n    case REPOKEY_TYPE_SHA384:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA384);\n      break;\n    case REPOKEY_TYPE_SHA512:\n      data_addblob(xd, data->attrdata + val, SIZEOF_SHA512);\n      break;\n    case REPOKEY_TYPE_NUM:\n      if (val & 0x80000000)\n\t{\n\t  data_addid64(xd, data->attrnum64data[val ^ 0x80000000]);\n\t  break;\n\t}\n    case REPOKEY_TYPE_ID:\n    case REPOKEY_TYPE_DIR:\n      data_addid(xd, val);\n      break;\n    case REPOKEY_TYPE_BINARY:\n      {\n\tId len;\n\tunsigned char *dp = data_read_id(data->attrdata + val, &len);\n\tdp += (unsigned int)len;\n\tdata_addblob(xd, data->attrdata + val, dp - (data->attrdata + val));\n      }\n      break;\n    case REPOKEY_TYPE_IDARRAY:\n      for (ida = data->attriddata + val; *ida; ida++)\n\tdata_addideof(xd, ida[0], ida[1] ? 0 : 1);\n      break;\n    case REPOKEY_TYPE_DIRNUMNUMARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 3)\n\t{\n\t  data_addid(xd, ida[0]);\n\t  data_addid(xd, ida[1]);\n\t  data_addideof(xd, ida[2], ida[3] ? 0 : 1);\n\t}\n      break;\n    case REPOKEY_TYPE_DIRSTRARRAY:\n      for (ida = data->attriddata + val; *ida; ida += 2)\n\t{\n\t  data_addideof(xd, ida[0], ida[2] ? 0 : 1);\n\t  data_addblob(xd, data->attrdata + ida[1], strlen((char *)(data->attrdata + ida[1])) + 1);\n\t}\n      break;\n    case REPOKEY_TYPE_FIXARRAY:\n      {\n\tint num = 0;\n\tschemaid = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp;\n\t    sp = schema;\n\t    kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\t\t\n\t    num++;\n\t    for (; *kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    if (!schemaid)\n\t      schemaid = repodata_schema2id(data, schema, 1);\n\t    else if (schemaid != repodata_schema2id(data, schema, 0))\n\t      {\n\t \tpool_debug(data->repo->pool, SOLV_ERROR, \"repodata_serialize_key: fixarray substructs with different schemas\\n\");\n\t\tnum = 0;\n\t\tbreak;\n\t      }\n\t  }\n\tdata_addid(xd, num);\n\tif (!num)\n\t  break;\n\tdata_addid(xd, schemaid);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      continue;\n\t    for (; *kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    case REPOKEY_TYPE_FLEXARRAY:\n      {\n\tint num = 0;\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  num++;\n\tdata_addid(xd, num);\n\tfor (ida = data->attriddata + val; *ida; ida++)\n\t  {\n\t    Id *kp = data->xattrs[-*ida];\n\t    if (!kp)\n\t      {\n\t        data_addid(xd, 0);\t\n\t        continue;\n\t      }\n\t    sp = schema;\n\t    for (;*kp; kp += 2)\n\t      *sp++ = *kp;\n\t    *sp = 0;\n\t    schemaid = repodata_schema2id(data, schema, 1);\n\t    data_addid(xd, schemaid);\n\t    kp = data->xattrs[-*ida];\n\t    for (;*kp; kp += 2)\n\t      repodata_serialize_key(data, newincore, newvincore, schema, data->keys + *kp, kp[1]);\n\t  }\n\tbreak;\n      }\n    default:\n      pool_debug(data->repo->pool, SOLV_FATAL, \"repodata_serialize_key: don't know how to handle type %d\\n\", key->type);\n      exit(1);\n    }\n  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n    {\n      data_addid(newincore, data->lastverticaloffset + oldvincorelen);\n      oldvincorelen = xd->len - oldvincorelen;\n      data_addid(newincore, oldvincorelen);\n    }\n}\nvoid\nrepodata_internalize(Repodata *data)\n{\n  Repokey *key, solvkey;\n  Id entry, nentry;\n  Id schemaid, keyid, *schema, *sp, oldschemaid, *keyp, *seen;\n  Offset *oldincoreoffs = 0;\n  int schemaidx;\n  unsigned char *dp, *ndp;\n  int neednewschema;\n  struct extdata newincore;\n  struct extdata newvincore;\n  Id solvkeyid;\n  Id *keylink;\n  int haveoldkl;\n  if (!data->attrs && !data->xattrs)\n    return;\n#if 0\n  printf(\"repodata_internalize %d\\n\", data->repodataid);\n  printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n  printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n#endif\n  newvincore.buf = data->vincore;\n  newvincore.len = data->vincorelen;\n  memset(&solvkey, 0, sizeof(solvkey));\n  solvkey.name = REPOSITORY_SOLVABLES;\n  solvkey.type = REPOKEY_TYPE_FLEXARRAY;\n  solvkey.size = 0;\n  solvkey.storage = KEY_STORAGE_INCORE;\n  solvkeyid = repodata_key2id(data, &solvkey, data->end != data->start ? 1 : 0);\n  schema = solv_malloc2(data->nkeys, sizeof(Id));\n  seen = solv_malloc2(data->nkeys, sizeof(Id));\n  nentry = data->end - data->start;\n  memset(&newincore, 0, sizeof(newincore));\n  data_addid(&newincore, 0);\t\n  data->mainschema = 0;\n  data->mainschemaoffsets = solv_free(data->mainschemaoffsets);\n  keylink = calculate_keylink(data);\n  for (entry = -1; entry < nentry; entry++)\n    {\n      oldschemaid = 0;\n      dp = data->incoredata;\n      if (dp)\n\t{\n\t  dp += entry >= 0 ? data->incoreoffset[entry] : 1;\n          dp = data_read_id(dp, &oldschemaid);\n\t}\n      memset(seen, 0, data->nkeys * sizeof(Id));\n#if 0\nfprintf(stderr, \"oldschemaid %d\\n\", oldschemaid);\nfprintf(stderr, \"schemata %d\\n\", data->schemata[oldschemaid]);\nfprintf(stderr, \"schemadata %p\\n\", data->schemadata);\n#endif\n      neednewschema = 0;\n      sp = schema;\n      haveoldkl = 0;\n      for (keyp = data->schemadata + data->schemata[oldschemaid]; *keyp; keyp++)\n\t{\n\t  if (seen[*keyp])\n\t    {\n\t      neednewschema = 1;\n\t      continue;\n\t    }\n\t  seen[*keyp] = -1;\t\n\t  *sp++ = *keyp;\n\t  if (keylink[*keyp])\n\t    haveoldkl = 1;\t\n\t}\n      if (entry < 0 && solvkeyid && seen[solvkeyid])\n\t{\n\t  *sp = 0;\n\t  for (sp = keyp = schema; *sp; sp++)\n\t    if (*sp != solvkeyid)\n\t      *keyp++ = *sp;\n\t  sp = keyp;\n\t  seen[solvkeyid] = 0;\n\t  neednewschema = 1;\n\t}\n      if (entry >= 0)\n\tkeyp = data->attrs ? data->attrs[entry] : 0;\n      else\n        keyp = data->xattrs ? data->xattrs[1] : 0;\n      if (keyp)\n        for (; *keyp; keyp += 2)\n\t  {\n\t    if (!seen[*keyp])\n\t      {\n\t        neednewschema = 1;\n\t        *sp++ = *keyp;\n\t\tif (haveoldkl && keylink[*keyp])\t\t\n\t\t  {\n\t\t    Id kl;\n\t\t    for (kl = keylink[*keyp]; kl != *keyp; kl = keylink[kl])\n\t\t      if (seen[kl] == -1)\n\t\t        {\n\t\t\t  Id *osp;\n\t\t\t  for (osp = schema; osp < sp; osp++)\n\t\t\t    if (*osp == kl)\n\t\t\t      {\n\t\t\t        memmove(osp, osp + 1, (sp - osp) * sizeof(Id));\n\t\t\t        sp--;\n\t\t\t        seen[kl] = 0;\n\t\t\t\tbreak;\n\t\t\t      }\n\t\t        }\n\t\t  }\n\t      }\n\t    seen[*keyp] = keyp[1] + 1;\n\t  }\n      if (entry < 0 && data->end != data->start)\n\t{\n\t  *sp++ = solvkeyid;\t\n\t  neednewschema = 1;\n\t}\n      *sp = 0;\n      if (neednewschema)\n\tschemaid = repodata_schema2id(data, schema, 1);\n      else\n\tschemaid = oldschemaid;\n      if (entry < 0)\n\t{\n\t  data->mainschemaoffsets = solv_calloc(sp - schema, sizeof(Id));\n\t  data->mainschema = schemaid;\n\t}\n      if (oldschemaid)\n\t{\n\t  Id *lastneeded = 0;\n\t  for (sp = data->schemadata + data->schemata[oldschemaid]; *sp; sp++)\n\t    if (seen[*sp] == -1)\n\t      lastneeded = sp + 1;\n\t  if (lastneeded)\n\t    {\n\t      if (!oldincoreoffs)\n\t        oldincoreoffs = solv_malloc2(data->nkeys, 2 * sizeof(Offset));\n\t      for (sp = data->schemadata + data->schemata[oldschemaid]; sp != lastneeded; sp++)\n\t\t{\n\t\t  key = data->keys + *sp;\n\t\t  ndp = dp;\n\t\t  if (key->storage == KEY_STORAGE_VERTICAL_OFFSET)\n\t\t    {\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t      ndp = data_skip(ndp, REPOKEY_TYPE_ID);\n\t\t    }\n\t\t  else if (key->storage == KEY_STORAGE_INCORE)\n\t\t    ndp = data_skip_key(data, ndp, key);\n\t\t  oldincoreoffs[*sp * 2] = dp - data->incoredata;\n\t\t  oldincoreoffs[*sp * 2 + 1] = ndp - dp;\n\t\t  dp = ndp;\n\t\t}\n\t    }\n\t}\n      if (entry >= 0 && !neednewschema && oldschemaid && (!data->attrs || !data->attrs[entry]) && dp)\n\t{\n\t  ndp = data->incoredata + data->incoreoffset[entry];\n\t  data->incoreoffset[entry] = newincore.len;\n\t  data_addblob(&newincore, ndp, dp - ndp);\n\t  goto entrydone;\n\t}\n      if (entry >= 0)\n        data->incoreoffset[entry] = newincore.len;\n      data_addid(&newincore, schemaid);\n      for (schemaidx = data->schemata[schemaid]; (keyid = data->schemadata[schemaidx]) != 0; schemaidx++)\n\t{\n\t  if (entry < 0)\n\t    {\n\t      data->mainschemaoffsets[schemaidx - data->schemata[schemaid]] = newincore.len;\n\t      if (keyid == solvkeyid)\n\t\t{\n\t\t  data_addid(&newincore, data->end - data->start);\n\t\t  break;\t\n\t\t}\n\t    }\n\t  if (seen[keyid] == -1)\n\t    {\n\t      if (oldincoreoffs[keyid * 2 + 1])\n\t\tdata_addblob(&newincore, data->incoredata + oldincoreoffs[keyid * 2], oldincoreoffs[keyid * 2 + 1]);\n\t    }\n\t  else if (seen[keyid])\n\t    repodata_serialize_key(data, &newincore, &newvincore, schema, data->keys + keyid, seen[keyid] - 1);\n\t}\nentrydone:\n      if (entry >= 0 && data->attrs)\n\t{\n\t  if (data->attrs[entry])\n\t    data->attrs[entry] = solv_free(data->attrs[entry]);\n\t  if (entry && entry % 4096 == 0 && data->nxattrs <= 2 && entry + 64 < nentry)\n\t    {\n\t      compact_attrdata(data, entry + 1, nentry);\t\n#if 0\n\t      printf(\"  attr data: %d K\\n\", data->attrdatalen / 1024);\n\t      printf(\"  attrid data: %d K\\n\", data->attriddatalen / (1024 / 4));\n\t      printf(\"  incore data: %d K\\n\", newincore.len / 1024);\n\t      printf(\"  sum: %d K\\n\", (newincore.len + data->attrdatalen + data->attriddatalen * 4) / 1024);\n#endif\n\t    }\n\t}\n    }\n  for (entry = 0; entry < data->nxattrs; entry++)\n    if (data->xattrs[entry])\n      solv_free(data->xattrs[entry]);\n  data->xattrs = solv_free(data->xattrs);\n  data->nxattrs = 0;\n  data->lasthandle = 0;\n  data->lastkey = 0;\n  data->lastdatalen = 0;\n  solv_free(schema);\n  solv_free(seen);\n  solv_free(keylink);\n  solv_free(oldincoreoffs);\n  repodata_free_schemahash(data);\n  solv_free(data->incoredata);\n  data->incoredata = newincore.buf;\n  data->incoredatalen = newincore.len;\n  data->incoredatafree = 0;\n  data->vincore = newvincore.buf;\n  data->vincorelen = newvincore.len;\n  data->attrs = solv_free(data->attrs);\n  data->attrdata = solv_free(data->attrdata);\n  data->attriddata = solv_free(data->attriddata);\n  data->attrnum64data = solv_free(data->attrnum64data);\n  data->attrdatalen = 0;\n  data->attriddatalen = 0;\n  data->attrnum64datalen = 0;\n#if 0\n  printf(\"repodata_internalize %d done\\n\", data->repodataid);\n  printf(\"  incore data: %d K\\n\", data->incoredatalen / 1024);\n#endif\n}\nRepodata *\nrepodata_create_stubs(Repodata *data)\n{\n  Repo *repo = data->repo;\n  Pool *pool = repo->pool;\n  Repodata *sdata;\n  int *stubdataids;\n  Dataiterator di;\n  Id xkeyname = 0;\n  int i, cnt = 0;\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  while (dataiterator_step(&di))\n    if (di.data == data)\n      cnt++;\n  dataiterator_free(&di);\n  if (!cnt)\n    return data;\n  stubdataids = solv_calloc(cnt, sizeof(*stubdataids));\n  for (i = 0; i < cnt; i++)\n    {\n      sdata = repodata_add_stub(&data);\n      stubdataids[i] = sdata - repo->repodata;\n    }\n  i = 0;\n  dataiterator_init(&di, pool, repo, SOLVID_META, REPOSITORY_EXTERNAL, 0, 0);\n  sdata = 0;\n  while (dataiterator_step(&di))\n    {\n      if (di.data != data)\n\tcontinue;\n      if (di.key->name == REPOSITORY_EXTERNAL && !di.nparents)\n\t{\n\t  dataiterator_entersub(&di);\n\t  sdata = repo->repodata + stubdataids[i++];\n\t  xkeyname = 0;\n\t  continue;\n\t}\n      repodata_set_kv(sdata, SOLVID_META, di.key->name, di.key->type, &di.kv);\n      if (di.key->name == REPOSITORY_KEYS && di.key->type == REPOKEY_TYPE_IDARRAY)\n\t{\n\t  if (!xkeyname)\n\t    {\n\t      if (!di.kv.eof)\n\t\txkeyname = di.kv.id;\n\t    }\n\t  else\n\t    {\n\t      repodata_add_stubkey(sdata, xkeyname, di.kv.id);\n\t      if (xkeyname == SOLVABLE_FILELIST)\n\t        repodata_set_filelisttype(sdata, REPODATA_FILELIST_EXTENSION);\n\t      xkeyname = 0;\n\t    }\n\t}\n    }\n  dataiterator_free(&di);\n  for (i = 0; i < cnt; i++)\n    repodata_internalize(repo->repodata + stubdataids[i]);\n  solv_free(stubdataids);\n  return data;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_4291.c",
        "project": "opensuse/libsolv",
        "url": "https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static bool is_good_protocol(const char *protocol_list, const char *protocol)\n    char *tmp = strdup(protocol_list);\n    char *pch = strtok(tmp, \", \");\n    free(tmp);\nstatic int on_http_message_complete(http_parser* parser)\n    struct clt_info *info = parser->data;\n    info->request->version_major = parser->http_major;\n    info->request->version_minor = parser->http_minor;\n    info->request->method = parser->method;\n    dict_iterator *iter = dict_get_iterator(info->request->headers);\n    if (info->request->method != HTTP_GET)\n        goto error;\n    if (http_request_get_header(info->request, \"Host\") == NULL)\n        goto error;\n    double version = info->request->version_major + info->request->version_minor * 0.1;\n    const char *upgrade = http_request_get_header(info->request, \"Upgrade\");\n    const char *connection = http_request_get_header(info->request, \"Connection\");\n    const char *ws_version = http_request_get_header(info->request, \"Sec-WebSocket-Version\");\n    const char *ws_key = http_request_get_header(info->request, \"Sec-WebSocket-Key\");\n    const char *protocol_list = http_request_get_header(info->request, \"Sec-WebSocket-Protocol\");\n    if (protocol_list && !is_good_protocol(protocol_list, svr->protocol))\n        goto error;\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n# include <errno.h>\n# include <string.h>\n# include \"nw_buf.h\"\n# define NW_BUF_POOL_INIT_SIZE 64\n# define NW_BUF_POOL_MAX_SIZE  65535\n# define NW_CACHE_INIT_SIZE    64\n# define NW_CACHE_MAX_SIZE     65535\nvoid nw_buf_free(nw_buf_pool *pool, nw_buf *buf)\n{\n    if (pool->free < pool->free_total) {\n        pool->free_arr[pool->free++] = buf;\n    } else if (pool->free_total < NW_BUF_POOL_MAX_SIZE) {\n        uint32_t new_free_total = pool->free_total * 2;\n        void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));\n        if (new_arr) {\n            pool->free_total = new_free_total;\n            pool->free_arr = new_arr;\n            pool->free_arr[pool->free++] = buf;\n        } else {\n            free(buf);\n        }\n    } else {\n        free(buf);\n    }\n}\nvoid nw_cache_free(nw_cache *cache, void *obj)\n{\n    if (cache->free < cache->free_total) {\n        cache->free_arr[cache->free++] = obj;\n    } else if (cache->free_total < NW_CACHE_MAX_SIZE) {\n        uint32_t new_free_total = cache->free_total * 2;\n        void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));\n        if (new_arr) {\n            cache->free_total = new_free_total;\n            cache->free_arr = new_arr;\n            cache->free_arr[cache->free++] = obj;\n        } else {\n            free(obj);\n        }\n    } else {\n        free(obj);\n    }\n}\nFile number 2:\n# include <stdlib.h>\n# include <assert.h>\n# include \"ut_rpc.h\"\n# include \"ut_crc32.h\"\n# include \"ut_misc.h\"\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size)\n{\n    static void *send_buf;\n    static size_t send_buf_size;\n    uint32_t pkg_size;\n    if (pkg->body_size > RPC_PKG_MAX_BODY_SIZE) {\n        return -1;\n    }\n    pkg_size = RPC_PKG_HEAD_SIZE + pkg->ext_size + pkg->body_size;\n    if (send_buf_size < pkg_size) {\n        if (send_buf)\n            free(send_buf);\n        send_buf_size = pkg_size * 2;\n        send_buf = malloc(send_buf_size);\n        if (send_buf == NULL) {\n            return -1;\n        }\n    }\n    memcpy(send_buf, pkg, RPC_PKG_HEAD_SIZE);\n    if (pkg->ext_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE, pkg->ext, pkg->ext_size);\n    if (pkg->body_size)\n        memcpy(send_buf + RPC_PKG_HEAD_SIZE + pkg->ext_size, pkg->body, pkg->body_size);\n    pkg = send_buf;\n    pkg->magic     = htole32(RPC_PKG_MAGIC);\n    pkg->command   = htole32(pkg->command);\n    pkg->pkg_type  = htole16(pkg->pkg_type);\n    pkg->result    = htole32(pkg->result);\n    pkg->sequence  = htole32(pkg->sequence);\n    pkg->req_id    = htole64(pkg->req_id);\n    pkg->body_size = htole32(pkg->body_size);\n    pkg->ext_size  = htole16(pkg->ext_size);\n    pkg->crc32 = 0;\n    pkg->crc32 = htole32(generate_crc32c(send_buf, pkg_size));\n    *data = send_buf;\n    *size = pkg_size;\n    return 0;\n}\nFile number 3:\n/*\n * Description: \n *     History: yang@haipo.me, 2016/03/29, create\n */\n\n# ifndef _UT_RPC_H_\n# define _UT_RPC_H_\n\n# include <stdint.h>\n# include \"nw_ses.h\"\n\n# define RPC_PKG_MAGIC 0x70656562\n\n# define RPC_PKG_TYPE_REQUEST 0\n# define RPC_PKG_TYPE_REPLY   1\n# define RPC_PKG_TYPE_PUSH    2\n\n# pragma pack(1)\ntypedef struct rpc_pkg {\n    uint32_t magic;\n    uint32_t command;\n    uint16_t pkg_type;\n    uint32_t result;\n    uint32_t crc32;\n    uint32_t sequence;\n    uint64_t req_id;\n    uint32_t body_size;\n    uint16_t ext_size;\n    void   * ext;\n    void   * body;\n} rpc_pkg;\n# pragma pack()\n\n# define RPC_PKG_HEAD_SIZE (sizeof(rpc_pkg) - sizeof(void *) * 2)\n# define RPC_PKG_MAX_BODY_SIZE ((UINT32_MAX / 2) - UINT16_MAX - sizeof(rpc_pkg))\n\nint rpc_decode(nw_ses *ses, void *data, size_t max);\nint rpc_pack(rpc_pkg *pkg, void **data, uint32_t *size);\nint rpc_send(nw_ses *ses, rpc_pkg *pkg);\n\n# define RPC_CMD_HEARTBEAT 0\n\n# define RPC_HEARTBEAT_INTERVAL         1.0\n# define RPC_HEARTBEAT_TIMEOUT_DEFAULT  3.0\n# define RPC_HEARTBEAT_TIMEOUT_MIN      2.0\n# define RPC_HEARTBEAT_TIMEOUT_MAX      600\n\n# define RPC_HEARTBEAT_TYPE_TIMEOUT     1\n\n# endif\n\n\nFile number 4:\n# include <stdbool.h>\n# include <openssl/sha.h>  \n# include \"ut_log.h\"\n# include \"ut_misc.h\"\n# include \"ut_base64.h\"\n# include \"ut_ws_svr.h\"\nstruct ws_frame {\n    uint8_t     fin;\n    uint8_t     opcode;\n    uint64_t    payload_len;\n    void        *payload;\n};\nstruct clt_info {\n    nw_ses      *ses;\n    void        *privdata;\n    double      last_activity;\n    struct      http_parser parser;\n    sds         field;\n    bool        field_set;\n    sds         value;\n    bool        value_set;\n    bool        upgrade;\n    sds         remote;\n    sds         url;\n    sds         message;\n    http_request_t *request;\n    struct ws_frame frame;\n};\nstatic int send_hand_shake_reply(nw_ses *ses, char *protocol, const char *key)\n{\n    unsigned char hash[20];\n    sds data = sdsnew(key);\n    data = sdscat(data, \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    SHA1((const unsigned char *)data, sdslen(data), hash);\n    sdsfree(data);\n    sds b4message;\n    base64_encode(hash, sizeof(hash), &b4message);\n    http_response_t *response = http_response_new();\n    http_response_set_header(response, \"Upgrade\", \"websocket\");\n    http_response_set_header(response, \"Connection\", \"Upgrade\");\n    http_response_set_header(response, \"Sec-WebSocket-Accept\", b4message);\n    if (protocol) {\n        http_response_set_header(response, \"Sec-WebSocket-Protocol\", protocol);\n    }\n    response->status = 101;\n    sds message = http_response_encode(response);\n    nw_ses_send(ses, message, sdslen(message));\n    sdsfree(message);\n    sdsfree(b4message);\n    return 0;\n}\nstatic bool is_good_protocol(const char *protocol_list, const char *protocol)\n{\n    char *tmp = strdup(protocol_list);\n    char *pch = strtok(tmp, \", \");\n    while (pch != NULL) {\n        if (strcmp(pch, protocol) == 0) {\n            free(tmp);\n            return true;\n        }\n        pch = strtok(NULL, \", \");\n    }\n    free(tmp);\n    return false;\n}\nstatic bool is_good_origin(const char *origin, const char *require)\n{\n    size_t origin_len  = strlen(origin);\n    size_t require_len = strlen(require);\n    if (origin_len < require_len)\n        return false;\n    if (memcmp(origin + (origin_len - require_len), require, require_len) != 0)\n        return false;\n    return true;\n}\nstatic int on_http_message_complete(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    ws_svr *svr = ws_svr_from_ses(info->ses);\n    info->request->version_major = parser->http_major;\n    info->request->version_minor = parser->http_minor;\n    info->request->method = parser->method;\n    dict_entry *entry;\n    dict_iterator *iter = dict_get_iterator(info->request->headers);\n    while ((entry = dict_next(iter)) != NULL) {\n        log_trace(\"Header: %s: %s\", (char *)entry->key, (char *)entry->val);\n    }\n    dict_release_iterator(iter);\n    if (info->request->method != HTTP_GET)\n        goto error;\n    if (http_request_get_header(info->request, \"Host\") == NULL)\n        goto error;\n    double version = info->request->version_major + info->request->version_minor * 0.1;\n    if (version < 1.1)\n        goto error;\n    const char *upgrade = http_request_get_header(info->request, \"Upgrade\");\n    if (upgrade == NULL || strcasecmp(upgrade, \"websocket\") != 0)\n        goto error;\n    const char *connection = http_request_get_header(info->request, \"Connection\");\n    if (connection == NULL || strlen(connection) > UT_WS_SVR_MAX_HEADER_SIZE)\n        goto error;\n    else {\n        bool found_upgrade = false;\n        int count;\n        sds *tokens = sdssplitlen(connection, strlen(connection), \",\", 1, &count); \n        if (tokens == NULL)\n            goto error;\n        for (int i = 0; i < count; i++) {\n            sds token = tokens[i];\n            sdstrim(token, \" \");\n            if (strcasecmp(token, \"Upgrade\") == 0) {\n                found_upgrade = true;\n                break;\n            }\n        }\n        sdsfreesplitres(tokens, count);\n        if (!found_upgrade)\n            goto error;\n    }\n    const char *ws_version = http_request_get_header(info->request, \"Sec-WebSocket-Version\");\n    if (ws_version == NULL || strcmp(ws_version, \"13\") != 0)\n        goto error;\n    const char *ws_key = http_request_get_header(info->request, \"Sec-WebSocket-Key\");\n    if (ws_key == NULL)\n        goto error;\n    const char *protocol_list = http_request_get_header(info->request, \"Sec-WebSocket-Protocol\");\n    if (protocol_list && !is_good_protocol(protocol_list, svr->protocol))\n        goto error;\n    if (strlen(svr->origin) > 0) {\n        const char *origin = http_request_get_header(info->request, \"Origin\");\n        if (origin == NULL || !is_good_origin(origin, svr->origin))\n            goto error;\n    }\n    if (svr->type.on_privdata_alloc) {\n        info->privdata = svr->type.on_privdata_alloc(svr);\n        if (info->privdata == NULL)\n            goto error;\n    }\n    info->upgrade = true;\n    info->remote = sdsnew(http_get_remote_ip(info->ses, info->request));\n    info->url = sdsnew(info->request->url);\n    if (svr->type.on_upgrade) {\n        svr->type.on_upgrade(info->ses, info->remote);\n    }\n    if (protocol_list) {\n        send_hand_shake_reply(info->ses, svr->protocol, ws_key);\n    } else {\n        send_hand_shake_reply(info->ses, NULL, ws_key);\n    }\n    return 0;\nerror:\n    ws_svr_close_clt(ws_svr_from_ses(info->ses), info->ses);\n    return -1;\n}\nstatic int decode_pkg(nw_ses *ses, void *data, size_t max)\n{\n    struct clt_info *info = ses->privdata;\n    if (!info->upgrade) {\n        return max;\n    }\n    if (max < 2)\n        return 0;\n    uint8_t *p = data;\n    size_t pkg_size = 0;\n    memset(&info->frame, 0, sizeof(info->frame));\n    info->frame.fin = p[0] & 0x80;\n    info->frame.opcode = p[0] & 0x0f;\n    if (!is_good_opcode(info->frame.opcode))\n        return -1;\n    uint8_t mask = p[1] & 0x80;\n    if (mask == 0)\n        return -1;\n    uint8_t len = p[1] & 0x7f;\n    if (len < 126) {\n        pkg_size = 2;\n        info->frame.payload_len = len;\n    } else if (len == 126) {\n        pkg_size = 2 + 2;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be16toh(*(uint16_t *)(p + 2));\n    } else if (len == 127) {\n        pkg_size = 2 + 8;\n        if (max < pkg_size)\n            return 0;\n        info->frame.payload_len = be64toh(*(uint64_t *)(p + 2));\n    }\n    uint8_t masks[4];\n    memcpy(masks, p + pkg_size, sizeof(masks));\n    pkg_size += sizeof(masks);\n    info->frame.payload = p + pkg_size;\n    pkg_size += info->frame.payload_len;\n    if (max < pkg_size)\n        return 0;\n    p = info->frame.payload;\n    for (size_t i = 0; i < info->frame.payload_len; ++i) {\n        p[i] = p[i] ^ masks[i & 3];\n    }\n    return pkg_size;\n}\nstatic int send_reply(nw_ses *ses, uint8_t opcode, void *payload, size_t payload_len)\n{\n    if (payload == NULL)\n        payload_len = 0;\n    static void *buf;\n    static size_t buf_size = 1024;\n    if (buf == NULL) {\n        buf = malloc(1024);\n        if (buf == NULL)\n            return -1;\n    }\n    size_t require_len = 10 + payload_len;\n    if (buf_size < require_len) {\n        void *new = realloc(buf, require_len);\n        if (new == NULL)\n            return -1;\n        buf = new;\n        buf_size = require_len;\n    }\n    size_t pkg_len = 0;\n    uint8_t *p = buf;\n    p[0] = 0;\n    p[0] |= 0x1 << 7;\n    p[0] |= opcode;\n    p[1] = 0;\n    if (payload_len < 126) {\n        uint8_t len = payload_len;\n        p[1] |= len;\n        pkg_len = 2;\n    } else if (payload_len <= 0xffff) {\n        p[1] |= 126;\n        uint16_t len = htobe16((uint16_t)payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    } else {\n        p[1] |= 127;\n        uint64_t len = htobe64(payload_len);\n        memcpy(p + 2, &len, sizeof(len));\n        pkg_len = 2 + sizeof(len);\n    }\n    if (payload) {\n        memcpy(p + pkg_len, payload, payload_len);\n        pkg_len += payload_len;\n    }\n    return nw_ses_send(ses, buf, pkg_len);\n}\nstatic void on_recv_pkg(nw_ses *ses, void *data, size_t size)\n{\n    struct clt_info *info = ses->privdata;\n    ws_svr *svr = ws_svr_from_ses(ses);\n    info->last_activity = current_timestamp();\n    if (!info->upgrade) {\n        size_t nparsed = http_parser_execute(&info->parser, &svr->settings, data, size);\n        if (!info->parser.upgrade && nparsed != size) {\n            log_error(\"peer: %s http parse error: %s (%s)\", nw_sock_human_addr(&ses->peer_addr),\n                    http_errno_description(HTTP_PARSER_ERRNO(&info->parser)),\n                    http_errno_name(HTTP_PARSER_ERRNO(&info->parser)));\n            nw_svr_close_clt(svr->raw_svr, ses);\n        }\n        return;\n    }\n    switch (info->frame.opcode) {\n    case 0x8:\n        nw_svr_close_clt(svr->raw_svr, ses);\n        return;\n    case 0x9:\n        send_pong_message(ses);\n        return;\n    case 0xa:\n        return;\n    }\n    if (info->message == NULL)\n        info->message = sdsempty();\n    info->message = sdscatlen(info->message, info->frame.payload, info->frame.payload_len);\n    if (info->frame.fin) {\n        int ret = svr->type.on_message(ses, info->remote, info->url, info->message, sdslen(info->message));\n        if (ses->id != 0) {\n            if (ret < 0) {\n                nw_svr_close_clt(svr->raw_svr, ses);\n            } else {\n                sdsfree(info->message);\n                info->message = NULL;\n            }\n        }\n    }\n}\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type)\n{\n    if (type->on_message == NULL)\n        return NULL;\n    if (type->on_privdata_alloc && !type->on_privdata_free)\n        return NULL;\n    ws_svr *svr = malloc(sizeof(ws_svr));\n    memset(svr, 0, sizeof(ws_svr));\n    nw_svr_cfg raw_cfg;\n    memset(&raw_cfg, 0, sizeof(raw_cfg));\n    raw_cfg.bind_count = cfg->bind_count;\n    raw_cfg.bind_arr = cfg->bind_arr;\n    raw_cfg.max_pkg_size = cfg->max_pkg_size;\n    raw_cfg.buf_limit = cfg->buf_limit;\n    raw_cfg.read_mem = cfg->read_mem;\n    raw_cfg.write_mem = cfg->write_mem;\n    nw_svr_type st;\n    memset(&st, 0, sizeof(st));\n    st.decode_pkg = decode_pkg;\n    st.on_error_msg = on_error_msg;\n    st.on_new_connection = on_new_connection;\n    st.on_connection_close = on_connection_close;\n    st.on_recv_pkg = on_recv_pkg;\n    st.on_privdata_alloc = on_privdata_alloc;\n    st.on_privdata_free = on_privdata_free;\n    svr->raw_svr = nw_svr_create(&raw_cfg, &st, svr);\n    if (svr->raw_svr == NULL) {\n        free(svr);\n        return NULL;\n    }\n    memset(&svr->settings, 0, sizeof(http_parser_settings));\n    svr->settings.on_message_begin = on_http_message_begin;\n    svr->settings.on_url = on_http_url;\n    svr->settings.on_header_field = on_http_header_field;\n    svr->settings.on_header_value = on_http_header_value;\n    svr->settings.on_body = on_http_body;\n    svr->settings.on_message_complete = on_http_message_complete;\n    svr->keep_alive = cfg->keep_alive;\n    svr->protocol = strdup(cfg->protocol);\n    svr->origin   = strdup(cfg->origin);\n    svr->privdata_cache = nw_cache_create(sizeof(struct clt_info));\n    memcpy(&svr->type, type, sizeof(ws_svr_type));\n    if (cfg->keep_alive > 0) {\n        nw_timer_set(&svr->timer, 60, true, on_timer, svr);\n        nw_timer_start(&svr->timer);\n    }\n    return svr;\n}\nws_svr *ws_svr_from_ses(nw_ses *ses)\n{\n    return ((nw_svr *)ses->svr)->privdata;\n}\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses)\n{\n    nw_svr_close_clt(svr->raw_svr, ses);\n}\nFile number 5:\n/*\n * Description: Websocket server\n *              https://tools.ietf.org/html/rfc6455\n *     History: yang@haipo.me, 2017/04/26, create\n */\n\n# ifndef _UT_WS_SVR_H_\n# define _UT_WS_SVR_H_\n\n# include \"ut_http.h\"\n# include \"nw_svr.h\"\n# include \"nw_buf.h\"\n# include \"nw_timer.h\"\n\n# define UT_WS_SVR_MAX_HEADER_SIZE 1024\n\ntypedef struct ws_svr_cfg {\n    uint32_t bind_count;\n    nw_svr_bind *bind_arr;\n    uint32_t max_pkg_size;\n    uint32_t buf_limit;\n    uint32_t read_mem;\n    uint32_t write_mem;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n} ws_svr_cfg;\n\ntypedef struct ws_svr_type {\n    void (*on_upgrade)(nw_ses *ses, const char *remote);\n    void (*on_close)(nw_ses *ses, const char *remote);\n    int (*on_message)(nw_ses *ses, const char *remote, const char *url, void *message, size_t size);\n    void *(*on_privdata_alloc)(void *svr);\n    void (*on_privdata_free)(void *svr, void *privdata);\n} ws_svr_type;\n\ntypedef struct ws_svr {\n    nw_svr *raw_svr;\n    nw_timer timer;\n    nw_cache *privdata_cache;\n    int keep_alive;\n    char *protocol;\n    char *origin;\n    http_parser_settings settings;\n    ws_svr_type type;\n} ws_svr;\n\nws_svr *ws_svr_create(ws_svr_cfg *cfg, ws_svr_type *type);\nint ws_svr_start(ws_svr *svr);\nint ws_svr_stop(ws_svr *svr);\nws_svr *ws_svr_from_ses(nw_ses *ses);\nvoid *ws_ses_privdata(nw_ses *ses);\nint ws_send_text(nw_ses *ses, char *message);\nint ws_send_binary(nw_ses *ses, void *data, size_t size);\nint ws_svr_broadcast_text(ws_svr *svr, char *message);\nint ws_svr_broadcast_binary(ws_svr *svr, void *data, size_t size);\nvoid ws_svr_release(ws_svr *svr);\nvoid ws_svr_close_clt(ws_svr *svr, nw_ses *ses);\n\n# endif\n\n\n",
        "cwe": "CWE-190",
        "file_name": "vul_respovul_idx_9405.c",
        "project": "viabtc/viabtc_exchange_server",
        "url": "https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int init_frame_decoder(APEContext *ctx)\n    if ((ret = init_entropy_decoder(ctx)) < 0)\n        return ret;\nstatic void ape_unpack_mono(APEContext *ctx, int count)\n    if (ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) {\n    }\n    ctx->entropy_decode_mono(ctx, count);\n    ctx->predictor_decode_mono(ctx, count);\n    if (ctx->channels == 2) {\n        memcpy(ctx->decoded[1], ctx->decoded[0], count * sizeof(*ctx->decoded[1]));\n    }\nstatic int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n    APEContext *s = avctx->priv_data;\n    av_assert0(s->samples >= 0);\n    if(!s->samples){\n        if (!avpkt->size) {\n        }\n        if (avpkt->size < 8) {\n        }\n        buf_size = avpkt->size & ~3;\n        if (buf_size != avpkt->size) {\n        }\n        if (s->fileversion < 3950) // previous versions overread two bytes\n            buf_size += 2;\n        av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n        if (!s->data)\n            return AVERROR(ENOMEM);\n        s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\n                          buf_size >> 2);\n        memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n        s->ptr = s->data;\n        s->data_end = s->data + buf_size;\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (s->fileversion >= 3900) {\n            if (offset > 3) {\n            }\n            if (s->data_end - s->ptr < offset) {\n            }\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\n        }\n        if (init_frame_decoder(s) < 0) {\n        }\n        s->samples = nblocks;\n    if (!s->data) {\n    }\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n    av_assert0(decoded_buffer_size <= INT_MAX);\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n    frame->nb_samples = blockstodecode;\n    s->error=0;\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <inttypes.h>\n#include \"libavutil/avassert.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/opt.h\"\n#include \"lossless_audiodsp.h\"\n#include \"avcodec.h\"\n#include \"bswapdsp.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"get_bits.h\"\n#include \"unary.h\"\n#define MAX_CHANNELS        2\n#define MAX_BYTESPERSAMPLE  3\n#define APE_FRAMECODE_MONO_SILENCE    1\n#define APE_FRAMECODE_STEREO_SILENCE  3\n#define APE_FRAMECODE_PSEUDO_STEREO   4\n#define HISTORY_SIZE 512\n#define PREDICTOR_ORDER 8\n#define PREDICTOR_SIZE 50\n#define YDELAYA (18 + PREDICTOR_ORDER*4)\n#define YDELAYB (18 + PREDICTOR_ORDER*3)\n#define XDELAYA (18 + PREDICTOR_ORDER*2)\n#define XDELAYB (18 + PREDICTOR_ORDER)\n#define YADAPTCOEFFSA 18\n#define XADAPTCOEFFSA 14\n#define YADAPTCOEFFSB 10\n#define XADAPTCOEFFSB 5\nenum APECompressionLevel {\n    COMPRESSION_LEVEL_FAST       = 1000,\n    COMPRESSION_LEVEL_NORMAL     = 2000,\n    COMPRESSION_LEVEL_HIGH       = 3000,\n    COMPRESSION_LEVEL_EXTRA_HIGH = 4000,\n    COMPRESSION_LEVEL_INSANE     = 5000\n};\n#define APE_FILTER_LEVELS 3\nstatic const uint16_t ape_filter_orders[5][APE_FILTER_LEVELS] = {\n    {  0,   0,    0 },\n    { 16,   0,    0 },\n    { 64,   0,    0 },\n    { 32, 256,    0 },\n    { 16, 256, 1280 }\n};\nstatic const uint8_t ape_filter_fracbits[5][APE_FILTER_LEVELS] = {\n    {  0,  0,  0 },\n    { 11,  0,  0 },\n    { 11,  0,  0 },\n    { 10, 13,  0 },\n    { 11, 13, 15 }\n};\ntypedef struct APEFilter {\n    int16_t *coeffs;        ///< actual coefficients used in filtering\n    int16_t *adaptcoeffs;   ///< adaptive filter coefficients used for correcting of actual filter coefficients\n    int16_t *historybuffer; ///< filter memory\n    int16_t *delay;         ///< filtered values\n    int avg;\n} APEFilter;\ntypedef struct APERice {\n    uint32_t k;\n    uint32_t ksum;\n} APERice;\ntypedef struct APERangecoder {\n    uint32_t low;           ///< low end of interval\n    uint32_t range;         ///< length of interval\n    uint32_t help;          ///< bytes_to_follow resp. intermediate value\n    unsigned int buffer;    ///< buffer for input/output\n} APERangecoder;\ntypedef struct APEPredictor {\n    int32_t *buf;\n    int32_t lastA[2];\n    int32_t filterA[2];\n    int32_t filterB[2];\n    int32_t coeffsA[2][4];  ///< adaption coefficients\n    int32_t coeffsB[2][5];  ///< adaption coefficients\n    int32_t historybuffer[HISTORY_SIZE + PREDICTOR_SIZE];\n    unsigned int sample_pos;\n} APEPredictor;\ntypedef struct APEContext {\n    AVClass *class;                          ///< class for AVOptions\n    AVCodecContext *avctx;\n    BswapDSPContext bdsp;\n    LLAudDSPContext adsp;\n    int channels;\n    int samples;                             ///< samples left to decode in current frame\n    int bps;\n    int fileversion;                         ///< codec version, very important in decoding process\n    int compression_level;                   ///< compression levels\n    int fset;                                ///< which filter set to use (calculated from compression level)\n    int flags;                               ///< global decoder flags\n    uint32_t CRC;                            ///< frame CRC\n    int frameflags;                          ///< frame flags\n    APEPredictor predictor;                  ///< predictor used for final reconstruction\n    int32_t *decoded_buffer;\n    int decoded_size;\n    int32_t *decoded[MAX_CHANNELS];          ///< decoded data for each channel\n    int blocks_per_loop;                     ///< maximum number of samples to decode for each call\n    int16_t* filterbuf[APE_FILTER_LEVELS];   ///< filter memory\n    APERangecoder rc;                        ///< rangecoder used to decode actual values\n    APERice riceX;                           ///< rice code parameters for the second channel\n    APERice riceY;                           ///< rice code parameters for the first channel\n    APEFilter filters[APE_FILTER_LEVELS][2]; ///< filters used for reconstruction\n    GetBitContext gb;\n    uint8_t *data;                           ///< current frame data\n    uint8_t *data_end;                       ///< frame data end\n    int data_size;                           ///< frame data allocated size\n    const uint8_t *ptr;                      ///< current position in frame data\n    int error;\n    void (*entropy_decode_mono)(struct APEContext *ctx, int blockstodecode);\n    void (*entropy_decode_stereo)(struct APEContext *ctx, int blockstodecode);\n    void (*predictor_decode_mono)(struct APEContext *ctx, int count);\n    void (*predictor_decode_stereo)(struct APEContext *ctx, int count);\n} APEContext;\nstatic void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count);\nstatic void entropy_decode_mono_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_0000(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3860(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3900(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3930(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_mono_3990(APEContext *ctx, int blockstodecode);\nstatic void entropy_decode_stereo_3990(APEContext *ctx, int blockstodecode);\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3930(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3930(APEContext *ctx, int count);\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count);\nstatic void predictor_decode_stereo_3950(APEContext *ctx, int count);\nstatic av_cold int ape_decode_close(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n    for (i = 0; i < APE_FILTER_LEVELS; i++)\n        av_freep(&s->filterbuf[i]);\n    av_freep(&s->decoded_buffer);\n    av_freep(&s->data);\n    s->decoded_size = s->data_size = 0;\n    return 0;\n}\nstatic av_cold int ape_decode_init(AVCodecContext *avctx)\n{\n    APEContext *s = avctx->priv_data;\n    int i;\n    if (avctx->extradata_size != 6) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect extradata\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (avctx->channels > 2) {\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo is supported\\n\");\n        return AVERROR(EINVAL);\n    }\n    s->bps = avctx->bits_per_coded_sample;\n    switch (s->bps) {\n    case 8:\n        avctx->sample_fmt = AV_SAMPLE_FMT_U8P;\n        break;\n    case 16:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;\n        break;\n    case 24:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n        break;\n    default:\n        avpriv_request_sample(avctx,\n                              \"%d bits per coded sample\", s->bps);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->avctx             = avctx;\n    s->channels          = avctx->channels;\n    s->fileversion       = AV_RL16(avctx->extradata);\n    s->compression_level = AV_RL16(avctx->extradata + 2);\n    s->flags             = AV_RL16(avctx->extradata + 4);\n    av_log(avctx, AV_LOG_DEBUG, \"Compression Level: %d - Flags: %d\\n\",\n           s->compression_level, s->flags);\n    if (s->compression_level % 1000 || s->compression_level > COMPRESSION_LEVEL_INSANE ||\n        !s->compression_level ||\n        (s->fileversion < 3930 && s->compression_level == COMPRESSION_LEVEL_INSANE)) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect compression level %d\\n\",\n               s->compression_level);\n        return AVERROR_INVALIDDATA;\n    }\n    s->fset = s->compression_level / 1000 - 1;\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[s->fset][i])\n            break;\n        FF_ALLOC_OR_GOTO(avctx, s->filterbuf[i],\n                         (ape_filter_orders[s->fset][i] * 3 + HISTORY_SIZE) * 4,\n                         filter_alloc_fail);\n    }\n    if (s->fileversion < 3860) {\n        s->entropy_decode_mono   = entropy_decode_mono_0000;\n        s->entropy_decode_stereo = entropy_decode_stereo_0000;\n    } else if (s->fileversion < 3900) {\n        s->entropy_decode_mono   = entropy_decode_mono_3860;\n        s->entropy_decode_stereo = entropy_decode_stereo_3860;\n    } else if (s->fileversion < 3930) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3900;\n    } else if (s->fileversion < 3990) {\n        s->entropy_decode_mono   = entropy_decode_mono_3900;\n        s->entropy_decode_stereo = entropy_decode_stereo_3930;\n    } else {\n        s->entropy_decode_mono   = entropy_decode_mono_3990;\n        s->entropy_decode_stereo = entropy_decode_stereo_3990;\n    }\n    if (s->fileversion < 3930) {\n        s->predictor_decode_mono   = predictor_decode_mono_3800;\n        s->predictor_decode_stereo = predictor_decode_stereo_3800;\n    } else if (s->fileversion < 3950) {\n        s->predictor_decode_mono   = predictor_decode_mono_3930;\n        s->predictor_decode_stereo = predictor_decode_stereo_3930;\n    } else {\n        s->predictor_decode_mono   = predictor_decode_mono_3950;\n        s->predictor_decode_stereo = predictor_decode_stereo_3950;\n    }\n    ff_bswapdsp_init(&s->bdsp);\n    ff_llauddsp_init(&s->adsp);\n    avctx->channel_layout = (avctx->channels==2) ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO;\n    return 0;\nfilter_alloc_fail:\n    ape_decode_close(avctx);\n    return AVERROR(ENOMEM);\n}\n#define CODE_BITS    32\n#define TOP_VALUE    ((unsigned int)1 << (CODE_BITS-1))\n#define SHIFT_BITS   (CODE_BITS - 9)\n#define EXTRA_BITS   ((CODE_BITS-2) % 8 + 1)\n#define BOTTOM_VALUE (TOP_VALUE >> 8)\nstatic inline void range_start_decoding(APEContext *ctx)\n{\n    ctx->rc.buffer = bytestream_get_byte(&ctx->ptr);\n    ctx->rc.low    = ctx->rc.buffer >> (8 - EXTRA_BITS);\n    ctx->rc.range  = (uint32_t) 1 << EXTRA_BITS;\n}\n#define MODEL_ELEMENTS 64\nstatic const uint16_t counts_3970[22] = {\n        0, 14824, 28224, 39348, 47855, 53994, 58171, 60926,\n    62682, 63786, 64463, 64878, 65126, 65276, 65365, 65419,\n    65450, 65469, 65480, 65487, 65491, 65493,\n};\nstatic const uint16_t counts_diff_3970[21] = {\n    14824, 13400, 11124, 8507, 6139, 4177, 2755, 1756,\n    1104, 677, 415, 248, 150, 89, 54, 31,\n    19, 11, 7, 4, 2,\n};\nstatic const uint16_t counts_3980[22] = {\n        0, 19578, 36160, 48417, 56323, 60899, 63265, 64435,\n    64971, 65232, 65351, 65416, 65447, 65466, 65476, 65482,\n    65485, 65488, 65490, 65491, 65492, 65493,\n};\nstatic const uint16_t counts_diff_3980[21] = {\n    19578, 16582, 12257, 7906, 4576, 2366, 1170, 536,\n    261, 119, 65, 31, 19, 10, 6, 3,\n    3, 2, 1, 1, 1,\n};\n // group rangecoder\nstatic inline int ape_decode_value_3900(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int tmpk;\n    overflow = range_get_symbol(ctx, counts_3970, counts_diff_3970);\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        tmpk = range_decode_bits(ctx, 5);\n        overflow = 0;\n    } else\n        tmpk = (rice->k < 1) ? 0 : rice->k - 1;\n    if (tmpk <= 16 || ctx->fileversion < 3910) {\n        if (tmpk > 23) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n            return AVERROR_INVALIDDATA;\n        }\n        x = range_decode_bits(ctx, tmpk);\n    } else if (tmpk <= 31) {\n        x = range_decode_bits(ctx, 16);\n        x |= (range_decode_bits(ctx, tmpk - 16) << 16);\n    } else {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Too many bits: %d\\n\", tmpk);\n        return AVERROR_INVALIDDATA;\n    }\n    x += overflow << tmpk;\n    update_rice(rice, x);\n    if (x & 1)\n        return (x >> 1) + 1;\n    else\n        return -(x >> 1);\n}\nstatic inline int ape_decode_value_3990(APEContext *ctx, APERice *rice)\n{\n    unsigned int x, overflow;\n    int base, pivot;\n    pivot = rice->ksum >> 5;\n    if (pivot == 0)\n        pivot = 1;\n    overflow = range_get_symbol(ctx, counts_3980, counts_diff_3980);\n    if (overflow == (MODEL_ELEMENTS - 1)) {\n        overflow  = range_decode_bits(ctx, 16) << 16;\n        overflow |= range_decode_bits(ctx, 16);\n    }\n    if (pivot < 0x10000) {\n        base = range_decode_culfreq(ctx, pivot);\n        range_decode_update(ctx, 1, base);\n    } else {\n        int base_hi = pivot, base_lo;\n        int bbits = 0;\n        while (base_hi & ~0xFFFF) {\n            base_hi >>= 1;\n            bbits++;\n        }\n        base_hi = range_decode_culfreq(ctx, base_hi + 1);\n        range_decode_update(ctx, 1, base_hi);\n        base_lo = range_decode_culfreq(ctx, 1 << bbits);\n        range_decode_update(ctx, 1, base_lo);\n        base = (base_hi << bbits) + base_lo;\n    }\n    x = base + overflow * pivot;\n    update_rice(rice, x);\n    if (x & 1)\n        return (x >> 1) + 1;\n    else\n        return -(x >> 1);\n}\nstatic void decode_array_0000(APEContext *ctx, GetBitContext *gb,\n                              int32_t *out, APERice *rice, int blockstodecode)\n{\n    int i;\n    int ksummax, ksummin;\n    rice->ksum = 0;\n    for (i = 0; i < FFMIN(blockstodecode, 5); i++) {\n        out[i] = get_rice_ook(&ctx->gb, 10);\n        rice->ksum += out[i];\n    }\n    rice->k = av_log2(rice->ksum / 10) + 1;\n    if (rice->k >= 24)\n        return;\n    for (; i < FFMIN(blockstodecode, 64); i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i];\n        rice->k = av_log2(rice->ksum / ((i + 1) * 2)) + 1;\n        if (rice->k >= 24)\n            return;\n    }\n    ksummax = 1 << rice->k + 7;\n    ksummin = rice->k ? (1 << rice->k + 6) : 0;\n    for (; i < blockstodecode; i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i] - out[i - 64];\n        while (rice->ksum < ksummin) {\n            rice->k--;\n            ksummin = rice->k ? ksummin >> 1 : 0;\n            ksummax >>= 1;\n        }\n        while (rice->ksum >= ksummax) {\n            rice->k++;\n            if (rice->k > 24)\n                return;\n            ksummax <<= 1;\n            ksummin = ksummin ? ksummin << 1 : 128;\n        }\n    }\n    for (i = 0; i < blockstodecode; i++) {\n        if (out[i] & 1)\n            out[i] = (out[i] >> 1) + 1;\n        else\n            out[i] = -(out[i] >> 1);\n    }\n}\nstatic int init_entropy_decoder(APEContext *ctx)\n{\n    if (ctx->fileversion >= 3900) {\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->CRC = bytestream_get_be32(&ctx->ptr);\n    } else {\n        ctx->CRC = get_bits_long(&ctx->gb, 32);\n    }\n    ctx->frameflags = 0;\n    if ((ctx->fileversion > 3820) && (ctx->CRC & 0x80000000)) {\n        ctx->CRC &= ~0x80000000;\n        if (ctx->data_end - ctx->ptr < 6)\n            return AVERROR_INVALIDDATA;\n        ctx->frameflags = bytestream_get_be32(&ctx->ptr);\n    }\n    ctx->riceX.k = 10;\n    ctx->riceX.ksum = (1 << ctx->riceX.k) * 16;\n    ctx->riceY.k = 10;\n    ctx->riceY.ksum = (1 << ctx->riceY.k) * 16;\n    if (ctx->fileversion >= 3900) {\n        ctx->ptr++;\n        range_start_decoding(ctx);\n    }\n    return 0;\n}\nstatic const int32_t initial_coeffs_fast_3320[1] = {\n    375,\n};\nstatic const int32_t initial_coeffs_a_3800[3] = {\n    64, 115, 64,\n};\nstatic const int32_t initial_coeffs_b_3800[2] = {\n    740, 0\n};\nstatic const int32_t initial_coeffs_3930[4] = {\n    360, 317, -109, 98\n};\nstatic void init_predictor_decoder(APEContext *ctx)\n{\n    APEPredictor *p = &ctx->predictor;\n    memset(p->historybuffer, 0, PREDICTOR_SIZE * sizeof(*p->historybuffer));\n    p->buf = p->historybuffer;\n    if (ctx->fileversion < 3930) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            memcpy(p->coeffsA[0], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n            memcpy(p->coeffsA[1], initial_coeffs_fast_3320,\n                   sizeof(initial_coeffs_fast_3320));\n        } else {\n            memcpy(p->coeffsA[0], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n            memcpy(p->coeffsA[1], initial_coeffs_a_3800,\n                   sizeof(initial_coeffs_a_3800));\n        }\n    } else {\n        memcpy(p->coeffsA[0], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n        memcpy(p->coeffsA[1], initial_coeffs_3930, sizeof(initial_coeffs_3930));\n    }\n    memset(p->coeffsB, 0, sizeof(p->coeffsB));\n    if (ctx->fileversion < 3930) {\n        memcpy(p->coeffsB[0], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n        memcpy(p->coeffsB[1], initial_coeffs_b_3800,\n               sizeof(initial_coeffs_b_3800));\n    }\n    p->filterA[0] = p->filterA[1] = 0;\n    p->filterB[0] = p->filterB[1] = 0;\n    p->lastA[0]   = p->lastA[1]   = 0;\n    p->sample_pos = 0;\n}\nstatic av_always_inline int filter_fast_3320(APEPredictor *p,\n                                             const int decoded, const int filter,\n                                             const int delayA)\n{\n    int32_t predictionA;\n    p->buf[delayA] = p->lastA[filter];\n    if (p->sample_pos < 3) {\n        p->lastA[filter]   = decoded;\n        p->filterA[filter] = decoded;\n        return decoded;\n    }\n    predictionA = p->buf[delayA] * 2 - p->buf[delayA - 1];\n    p->lastA[filter] = decoded + (predictionA  * p->coeffsA[filter][0] >> 9);\n    if ((decoded ^ predictionA) > 0)\n        p->coeffsA[filter][0]++;\n    else\n        p->coeffsA[filter][0]--;\n    p->filterA[filter] += p->lastA[filter];\n    return p->filterA[filter];\n}\nstatic av_always_inline int filter_3800(APEPredictor *p,\n                                        const int decoded, const int filter,\n                                        const int delayA,  const int delayB,\n                                        const int start,   const int shift)\n{\n    int32_t predictionA, predictionB, sign;\n    int32_t d0, d1, d2, d3, d4;\n    p->buf[delayA] = p->lastA[filter];\n    p->buf[delayB] = p->filterB[filter];\n    if (p->sample_pos < start) {\n        predictionA = decoded + p->filterA[filter];\n        p->lastA[filter]   = decoded;\n        p->filterB[filter] = decoded;\n        p->filterA[filter] = predictionA;\n        return predictionA;\n    }\n    d2 =  p->buf[delayA];\n    d1 = (p->buf[delayA] - p->buf[delayA - 1]) << 1;\n    d0 =  p->buf[delayA] + ((p->buf[delayA - 2] - p->buf[delayA - 1]) << 3);\n    d3 =  p->buf[delayB] * 2 - p->buf[delayB - 1];\n    d4 =  p->buf[delayB];\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2];\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += (((d0 >> 30) & 2) - 1) * sign;\n    p->coeffsA[filter][1] += (((d1 >> 28) & 8) - 4) * sign;\n    p->coeffsA[filter][2] += (((d2 >> 28) & 8) - 4) * sign;\n    predictionB = d3 * p->coeffsB[filter][0] -\n                  d4 * p->coeffsB[filter][1];\n    p->lastA[filter] = decoded + (predictionA >> 11);\n    sign = APESIGN(p->lastA[filter]);\n    p->coeffsB[filter][0] += (((d3 >> 29) & 4) - 2) * sign;\n    p->coeffsB[filter][1] -= (((d4 >> 30) & 2) - 1) * sign;\n    p->filterB[filter] = p->lastA[filter] + (predictionB >> shift);\n    p->filterA[filter] = p->filterB[filter] + ((p->filterA[filter] * 31) >> 5);\n    return p->filterA[filter];\n}\nstatic void predictor_decode_stereo_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    int32_t coeffs[256], delay[256];\n    int start = 4, shift = 10;\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, coeffs, delay, count);\n        long_filter_high_3800(decoded1, 16, 9, coeffs, delay, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n            long_filter_ehigh_3830(decoded1 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, coeffs, delay, count);\n        long_filter_high_3800(decoded1, order, shift2, coeffs, delay, count);\n    }\n    while (count--) {\n        int X = *decoded0, Y = *decoded1;\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, Y, 0, YDELAYA);\n            decoded0++;\n            *decoded1 = filter_fast_3320(p, X, 1, XDELAYA);\n            decoded1++;\n        } else {\n            *decoded0 = filter_3800(p, Y, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n            *decoded1 = filter_3800(p, X, 1, XDELAYA, XDELAYB,\n                                    start, shift);\n            decoded1++;\n        }\n        p->buf++;\n        p->sample_pos++;\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\nstatic void predictor_decode_mono_3800(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t coeffs[256], delay[256];\n    int start = 4, shift = 10;\n    if (ctx->compression_level == COMPRESSION_LEVEL_HIGH) {\n        start = 16;\n        long_filter_high_3800(decoded0, 16, 9, coeffs, delay, count);\n    } else if (ctx->compression_level == COMPRESSION_LEVEL_EXTRA_HIGH) {\n        int order = 128, shift2 = 11;\n        if (ctx->fileversion >= 3830) {\n            order <<= 1;\n            shift++;\n            shift2++;\n            long_filter_ehigh_3830(decoded0 + order, count - order);\n        }\n        start = order;\n        long_filter_high_3800(decoded0, order, shift2, coeffs, delay, count);\n    }\n    while (count--) {\n        if (ctx->compression_level == COMPRESSION_LEVEL_FAST) {\n            *decoded0 = filter_fast_3320(p, *decoded0, 0, YDELAYA);\n            decoded0++;\n        } else {\n            *decoded0 = filter_3800(p, *decoded0, 0, YDELAYA, YDELAYB,\n                                    start, shift);\n            decoded0++;\n        }\n        p->buf++;\n        p->sample_pos++;\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n    }\n}\nstatic av_always_inline int predictor_update_3930(APEPredictor *p,\n                                                  const int decoded, const int filter,\n                                                  const int delayA)\n{\n    int32_t predictionA, sign;\n    int32_t d0, d1, d2, d3;\n    p->buf[delayA]     = p->lastA[filter];\n    d0 = p->buf[delayA    ];\n    d1 = p->buf[delayA    ] - p->buf[delayA - 1];\n    d2 = p->buf[delayA - 1] - p->buf[delayA - 2];\n    d3 = p->buf[delayA - 2] - p->buf[delayA - 3];\n    predictionA = d0 * p->coeffsA[filter][0] +\n                  d1 * p->coeffsA[filter][1] +\n                  d2 * p->coeffsA[filter][2] +\n                  d3 * p->coeffsA[filter][3];\n    p->lastA[filter] = decoded + (predictionA >> 9);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += ((d0 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][1] += ((d1 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][2] += ((d2 < 0) * 2 - 1) * sign;\n    p->coeffsA[filter][3] += ((d3 < 0) * 2 - 1) * sign;\n    return p->filterA[filter];\n}\nstatic av_always_inline int predictor_update_filter(APEPredictor *p,\n                                                    const int decoded, const int filter,\n                                                    const int delayA,  const int delayB,\n                                                    const int adaptA,  const int adaptB)\n{\n    int32_t predictionA, predictionB, sign;\n    p->buf[delayA]     = p->lastA[filter];\n    p->buf[adaptA]     = APESIGN(p->buf[delayA]);\n    p->buf[delayA - 1] = p->buf[delayA] - p->buf[delayA - 1];\n    p->buf[adaptA - 1] = APESIGN(p->buf[delayA - 1]);\n    predictionA = p->buf[delayA    ] * p->coeffsA[filter][0] +\n                  p->buf[delayA - 1] * p->coeffsA[filter][1] +\n                  p->buf[delayA - 2] * p->coeffsA[filter][2] +\n                  p->buf[delayA - 3] * p->coeffsA[filter][3];\n    p->buf[delayB]     = p->filterA[filter ^ 1] - ((p->filterB[filter] * 31) >> 5);\n    p->buf[adaptB]     = APESIGN(p->buf[delayB]);\n    p->buf[delayB - 1] = p->buf[delayB] - p->buf[delayB - 1];\n    p->buf[adaptB - 1] = APESIGN(p->buf[delayB - 1]);\n    p->filterB[filter] = p->filterA[filter ^ 1];\n    predictionB = p->buf[delayB    ] * p->coeffsB[filter][0] +\n                  p->buf[delayB - 1] * p->coeffsB[filter][1] +\n                  p->buf[delayB - 2] * p->coeffsB[filter][2] +\n                  p->buf[delayB - 3] * p->coeffsB[filter][3] +\n                  p->buf[delayB - 4] * p->coeffsB[filter][4];\n    p->lastA[filter] = decoded + ((predictionA + (predictionB >> 1)) >> 10);\n    p->filterA[filter] = p->lastA[filter] + ((p->filterA[filter] * 31) >> 5);\n    sign = APESIGN(decoded);\n    p->coeffsA[filter][0] += p->buf[adaptA    ] * sign;\n    p->coeffsA[filter][1] += p->buf[adaptA - 1] * sign;\n    p->coeffsA[filter][2] += p->buf[adaptA - 2] * sign;\n    p->coeffsA[filter][3] += p->buf[adaptA - 3] * sign;\n    p->coeffsB[filter][0] += p->buf[adaptB    ] * sign;\n    p->coeffsB[filter][1] += p->buf[adaptB - 1] * sign;\n    p->coeffsB[filter][2] += p->buf[adaptB - 2] * sign;\n    p->coeffsB[filter][3] += p->buf[adaptB - 3] * sign;\n    p->coeffsB[filter][4] += p->buf[adaptB - 4] * sign;\n    return p->filterA[filter];\n}\nstatic void predictor_decode_mono_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t predictionA, currentA, A, sign;\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n    currentA = p->lastA[0];\n    while (count--) {\n        A = *decoded0;\n        p->buf[YDELAYA] = currentA;\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n        currentA = A + (predictionA >> 10);\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n        sign = APESIGN(A);\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n        p->buf++;\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n        *(decoded0++) = p->filterA[0];\n    }\n    p->lastA[0] = currentA;\n}\nstatic void do_init_filter(APEFilter *f, int16_t *buf, int order)\n{\n    f->coeffs = buf;\n    f->historybuffer = buf + order;\n    f->delay       = f->historybuffer + order * 2;\n    f->adaptcoeffs = f->historybuffer + order;\n    memset(f->historybuffer, 0, (order * 2) * sizeof(*f->historybuffer));\n    memset(f->coeffs, 0, order * sizeof(*f->coeffs));\n    f->avg = 0;\n}\nstatic void init_filter(APEContext *ctx, APEFilter *f, int16_t *buf, int order)\n{\n    do_init_filter(&f[0], buf, order);\n    do_init_filter(&f[1], buf + order * 3 + HISTORY_SIZE, order);\n}\nstatic void do_apply_filter(APEContext *ctx, int version, APEFilter *f,\n                            int32_t *data, int count, int order, int fracbits)\n{\n    int res;\n    int absres;\n    while (count--) {\n        res = ctx->adsp.scalarproduct_and_madd_int16(f->coeffs,\n                                                     f->delay - order,\n                                                     f->adaptcoeffs - order,\n                                                     order, APESIGN(*data));\n        res = (res + (1 << (fracbits - 1))) >> fracbits;\n        res += *data;\n        *data++ = res;\n        *f->delay++ = av_clip_int16(res);\n        if (version < 3980) {\n            f->adaptcoeffs[0]  = (res == 0) ? 0 : ((res >> 28) & 8) - 4;\n            f->adaptcoeffs[-4] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        } else {\n            absres = FFABS(res);\n            if (absres)\n                *f->adaptcoeffs = ((res & (-1<<31)) ^ (-1<<30)) >>\n                                  (25 + (absres <= f->avg*3) + (absres <= f->avg*4/3));\n            else\n                *f->adaptcoeffs = 0;\n            f->avg += (absres - f->avg) / 16;\n            f->adaptcoeffs[-1] >>= 1;\n            f->adaptcoeffs[-2] >>= 1;\n            f->adaptcoeffs[-8] >>= 1;\n        }\n        f->adaptcoeffs++;\n        if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {\n            memmove(f->historybuffer, f->delay - (order * 2),\n                    (order * 2) * sizeof(*f->historybuffer));\n            f->delay = f->historybuffer + order * 2;\n            f->adaptcoeffs = f->historybuffer + order;\n        }\n    }\n}\nstatic int init_frame_decoder(APEContext *ctx)\n{\n    int i, ret;\n    if ((ret = init_entropy_decoder(ctx)) < 0)\n        return ret;\n    init_predictor_decoder(ctx);\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        init_filter(ctx, ctx->filters[i], ctx->filterbuf[i],\n                    ape_filter_orders[ctx->fset][i]);\n    }\n    return 0;\n}\nstatic void ape_unpack_mono(APEContext *ctx, int count)\n{\n    if (ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) {\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence mono\\n\");\n        return;\n    }\n    ctx->entropy_decode_mono(ctx, count);\n    ctx->predictor_decode_mono(ctx, count);\n    if (ctx->channels == 2) {\n        memcpy(ctx->decoded[1], ctx->decoded[0], count * sizeof(*ctx->decoded[1]));\n    }\n}\nstatic void ape_unpack_stereo(APEContext *ctx, int count)\n{\n    int32_t left, right;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t *decoded1 = ctx->decoded[1];\n    if ((ctx->frameflags & APE_FRAMECODE_STEREO_SILENCE) == APE_FRAMECODE_STEREO_SILENCE) {\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"pure silence stereo\\n\");\n        return;\n    }\n    ctx->entropy_decode_stereo(ctx, count);\n    ctx->predictor_decode_stereo(ctx, count);\n    while (count--) {\n        left = *decoded1 - (*decoded0 / 2);\n        right = left + *decoded0;\n        *(decoded0++) = left;\n        *(decoded1++) = right;\n    }\n}\nstatic int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n    uint64_t decoded_buffer_size;\n    av_assert0(s->samples >= 0);\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n        if (!avpkt->size) {\n            *got_frame_ptr = 0;\n            return 0;\n        }\n        if (avpkt->size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        buf_size = avpkt->size & ~3;\n        if (buf_size != avpkt->size) {\n            av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n                   \"extra bytes at the end will be skipped.\\n\");\n        }\n        if (s->fileversion < 3950) // previous versions overread two bytes\n            buf_size += 2;\n        av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n        if (!s->data)\n            return AVERROR(ENOMEM);\n        s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf,\n                          buf_size >> 2);\n        memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n        s->ptr = s->data;\n        s->data_end = s->data + buf_size;\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (s->fileversion >= 3900) {\n            if (offset > 3) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n                s->data = NULL;\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->data_end - s->ptr < offset) {\n                av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->samples = nblocks;\n    }\n    if (!s->data) {\n        *got_frame_ptr = 0;\n        return avpkt->size;\n    }\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n    av_assert0(decoded_buffer_size <= INT_MAX);\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    s->error=0;\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n    if (s->error) {\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    switch (s->bps) {\n    case 8:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample8 = (uint8_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n        }\n        break;\n    case 16:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample16 = (int16_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample16++ = s->decoded[ch][i];\n        }\n        break;\n    case 24:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample24 = (int32_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample24++ = s->decoded[ch][i] << 8;\n        }\n        break;\n    }\n    s->samples -= blockstodecode;\n    *got_frame_ptr = 1;\n    return !s->samples ? avpkt->size : 0;\n}\n#define OFFSET(x) offsetof(APEContext, x)\n#define PAR (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM)\nstatic const AVOption options[] = {\n    { \"max_samples\", \"maximum number of samples decoded per call\",             OFFSET(blocks_per_loop), AV_OPT_TYPE_INT,   { .i64 = 4608 },    1,       INT_MAX, PAR, \"max_samples\" },\n    { \"all\",         \"no maximum. decode all samples for each packet at once\", 0,                       AV_OPT_TYPE_CONST, { .i64 = INT_MAX }, INT_MIN, INT_MAX, PAR, \"max_samples\" },\n    { NULL},\n};\nstatic const AVClass ape_decoder_class = {\n    .class_name = \"APE decoder\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\nAVCodec ff_ape_decoder = {\n    .name           = \"ape\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Monkey's Audio\"),\n    .type           = AVMEDIA_TYPE_AUDIO,\n    .id             = AV_CODEC_ID_APE,\n    .priv_data_size = sizeof(APEContext),\n    .init           = ape_decode_init,\n    .close          = ape_decode_close,\n    .decode         = ape_decode_frame,\n    .capabilities   = CODEC_CAP_SUBFRAMES | CODEC_CAP_DELAY | CODEC_CAP_DR1,\n    .flush          = ape_flush,\n    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                      AV_SAMPLE_FMT_S16P,\n                                                      AV_SAMPLE_FMT_S32P,\n                                                      AV_SAMPLE_FMT_NONE },\n    .priv_class     = &ape_decoder_class,\n};\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_2145.c",
        "project": "ffmpeg/ffmpeg",
        "url": "https://github.com/FFmpeg/FFmpeg/commit/96349da5ec8eda9f0368446e557fe0c8ba0e66b7",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static struct blkcg_gq *blkg_alloc(struct blkcg *blkcg, struct request_queue *q,\n\t\t\t\t   gfp_t gfp_mask)\n\tblkg = kzalloc_node(sizeof(*blkg), gfp_mask, q->node);\n\tif (!blkg)\n\t\treturn NULL;\n\tif (blkg_rwstat_init(&blkg->stat_bytes, gfp_mask) ||\n\t    blkg_rwstat_init(&blkg->stat_ios, gfp_mask))\nstatic struct blkcg_gq *blkg_create(struct blkcg *blkcg,\n\t\t\t\t    struct request_queue *q,\n\tlockdep_assert_held(q->queue_lock);\n\tif (!css_tryget_online(&blkcg->css)) {\n\t}\n\twb_congested = wb_congested_get_create(q->backing_dev_info,\n\t\t\t\t\t       blkcg->css.id,\n\t\t\t\t\t       GFP_NOWAIT | __GFP_NOWARN);\n\tif (!wb_congested) {\n\t}\n\tif (!new_blkg) {\n\t\tnew_blkg = blkg_alloc(blkcg, q, GFP_NOWAIT | __GFP_NOWARN);\n\t}\nint blkcg_init_queue(struct request_queue *q)\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/ioprio.h>\n#include <linux/kdev_t.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/delay.h>\n#include <linux/atomic.h>\n#include <linux/ctype.h>\n#include <linux/blk-cgroup.h>\n#include \"blk.h\"\n#define MAX_KEY_LEN 100\nstatic DEFINE_MUTEX(blkcg_pol_mutex);\nstruct blkcg blkcg_root;\nstruct cgroup_subsys_state * const blkcg_root_css = &blkcg_root.css;\nstatic struct blkcg_policy *blkcg_policy[BLKCG_MAX_POLS];\nstatic bool blkcg_policy_enabled(struct request_queue *q,\n\t\t\t\t const struct blkcg_policy *pol)\n{\n\treturn pol && test_bit(pol->plid, q->blkcg_pols);\n}\nstatic void blkg_free(struct blkcg_gq *blkg)\n{\n\tint i;\n\tif (!blkg)\n\t\treturn;\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++)\n\t\tif (blkg->pd[i])\n\t\t\tblkcg_policy[i]->pd_free_fn(blkg->pd[i]);\n\tif (blkg->blkcg != &blkcg_root)\n\t\tblk_exit_rl(&blkg->rl);\n\tblkg_rwstat_exit(&blkg->stat_ios);\n\tblkg_rwstat_exit(&blkg->stat_bytes);\n\tkfree(blkg);\n}\nstatic struct blkcg_gq *blkg_alloc(struct blkcg *blkcg, struct request_queue *q,\n\t\t\t\t   gfp_t gfp_mask)\n{\n\tstruct blkcg_gq *blkg;\n\tint i;\n\tblkg = kzalloc_node(sizeof(*blkg), gfp_mask, q->node);\n\tif (!blkg)\n\t\treturn NULL;\n\tif (blkg_rwstat_init(&blkg->stat_bytes, gfp_mask) ||\n\t    blkg_rwstat_init(&blkg->stat_ios, gfp_mask))\n\t\tgoto err_free;\n\tblkg->q = q;\n\tINIT_LIST_HEAD(&blkg->q_node);\n\tblkg->blkcg = blkcg;\n\tatomic_set(&blkg->refcnt, 1);\n\tif (blkcg != &blkcg_root) {\n\t\tif (blk_init_rl(&blkg->rl, q, gfp_mask))\n\t\t\tgoto err_free;\n\t\tblkg->rl.blkg = blkg;\n\t}\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++) {\n\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\tstruct blkg_policy_data *pd;\n\t\tif (!blkcg_policy_enabled(q, pol))\n\t\t\tcontinue;\n\t\tpd = pol->pd_alloc_fn(gfp_mask, q->node);\n\t\tif (!pd)\n\t\t\tgoto err_free;\n\t\tblkg->pd[i] = pd;\n\t\tpd->blkg = blkg;\n\t\tpd->plid = i;\n\t}\n\treturn blkg;\nerr_free:\n\tblkg_free(blkg);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(blkg_lookup_slowpath);\nstatic struct blkcg_gq *blkg_create(struct blkcg *blkcg,\n\t\t\t\t    struct request_queue *q,\n\t\t\t\t    struct blkcg_gq *new_blkg)\n{\n\tstruct blkcg_gq *blkg;\n\tstruct bdi_writeback_congested *wb_congested;\n\tint i, ret;\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\tlockdep_assert_held(q->queue_lock);\n\tif (!css_tryget_online(&blkcg->css)) {\n\t\tret = -ENODEV;\n\t\tgoto err_free_blkg;\n\t}\n\twb_congested = wb_congested_get_create(q->backing_dev_info,\n\t\t\t\t\t       blkcg->css.id,\n\t\t\t\t\t       GFP_NOWAIT | __GFP_NOWARN);\n\tif (!wb_congested) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_css;\n\t}\n\tif (!new_blkg) {\n\t\tnew_blkg = blkg_alloc(blkcg, q, GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!new_blkg)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_congested;\n\t\t}\n\t}\n\tblkg = new_blkg;\n\tblkg->wb_congested = wb_congested;\n\tif (blkcg_parent(blkcg)) {\n\t\tblkg->parent = __blkg_lookup(blkcg_parent(blkcg), q, false);\n\t\tif (WARN_ON_ONCE(!blkg->parent)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_put_congested;\n\t\t}\n\t\tblkg_get(blkg->parent);\n\t}\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++) {\n\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\tif (blkg->pd[i] && pol->pd_init_fn)\n\t\t\tpol->pd_init_fn(blkg->pd[i]);\n\t}\n\tspin_lock(&blkcg->lock);\n\tret = radix_tree_insert(&blkcg->blkg_tree, q->id, blkg);\n\tif (likely(!ret)) {\n\t\thlist_add_head_rcu(&blkg->blkcg_node, &blkcg->blkg_list);\n\t\tlist_add(&blkg->q_node, &q->blkg_list);\n\t\tfor (i = 0; i < BLKCG_MAX_POLS; i++) {\n\t\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\t\tif (blkg->pd[i] && pol->pd_online_fn)\n\t\t\t\tpol->pd_online_fn(blkg->pd[i]);\n\t\t}\n\t}\n\tblkg->online = true;\n\tspin_unlock(&blkcg->lock);\n\tif (!ret)\n\t\treturn blkg;\n\tblkg_put(blkg);\n\treturn ERR_PTR(ret);\nerr_put_congested:\n\twb_congested_put(wb_congested);\nerr_put_css:\n\tcss_put(&blkcg->css);\nerr_free_blkg:\n\tblkg_free(new_blkg);\n\treturn ERR_PTR(ret);\n}\nstatic void blkg_destroy(struct blkcg_gq *blkg)\n{\n\tstruct blkcg *blkcg = blkg->blkcg;\n\tstruct blkcg_gq *parent = blkg->parent;\n\tint i;\n\tlockdep_assert_held(blkg->q->queue_lock);\n\tlockdep_assert_held(&blkcg->lock);\n\tWARN_ON_ONCE(list_empty(&blkg->q_node));\n\tWARN_ON_ONCE(hlist_unhashed(&blkg->blkcg_node));\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++) {\n\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\tif (blkg->pd[i] && pol->pd_offline_fn)\n\t\t\tpol->pd_offline_fn(blkg->pd[i]);\n\t}\n\tif (parent) {\n\t\tblkg_rwstat_add_aux(&parent->stat_bytes, &blkg->stat_bytes);\n\t\tblkg_rwstat_add_aux(&parent->stat_ios, &blkg->stat_ios);\n\t}\n\tblkg->online = false;\n\tradix_tree_delete(&blkcg->blkg_tree, blkg->q->id);\n\tlist_del_init(&blkg->q_node);\n\thlist_del_init_rcu(&blkg->blkcg_node);\n\tif (rcu_access_pointer(blkcg->blkg_hint) == blkg)\n\t\trcu_assign_pointer(blkcg->blkg_hint, NULL);\n\tblkg_put(blkg);\n}\nstatic void blkg_destroy_all(struct request_queue *q)\n{\n\tstruct blkcg_gq *blkg, *n;\n\tlockdep_assert_held(q->queue_lock);\n\tlist_for_each_entry_safe(blkg, n, &q->blkg_list, q_node) {\n\t\tstruct blkcg *blkcg = blkg->blkcg;\n\t\tspin_lock(&blkcg->lock);\n\t\tblkg_destroy(blkg);\n\t\tspin_unlock(&blkcg->lock);\n\t}\n\tq->root_blkg = NULL;\n\tq->root_rl.blkg = NULL;\n}\nEXPORT_SYMBOL_GPL(__blkg_release_rcu);\nEXPORT_SYMBOL_GPL(blkg_dev_name);\nEXPORT_SYMBOL_GPL(blkcg_print_blkgs);\nEXPORT_SYMBOL_GPL(__blkg_prfill_u64);\nEXPORT_SYMBOL_GPL(__blkg_prfill_rwstat);\nEXPORT_SYMBOL_GPL(blkg_prfill_stat);\nEXPORT_SYMBOL_GPL(blkg_prfill_rwstat);\nEXPORT_SYMBOL_GPL(blkg_print_stat_bytes);\nEXPORT_SYMBOL_GPL(blkg_print_stat_ios);\nEXPORT_SYMBOL_GPL(blkg_print_stat_bytes_recursive);\nEXPORT_SYMBOL_GPL(blkg_print_stat_ios_recursive);\nEXPORT_SYMBOL_GPL(blkg_stat_recursive_sum);\nEXPORT_SYMBOL_GPL(blkg_rwstat_recursive_sum);\n\t__acquires(rcu) __acquires(disk->queue->queue_lock)\n{\n\tstruct gendisk *disk;\n\tstruct blkcg_gq *blkg;\n\tstruct module *owner;\n\tunsigned int major, minor;\n\tint key_len, part, ret;\n\tchar *body;\n\tif (sscanf(input, \"%u:%u%n\", &major, &minor, &key_len) != 2)\n\t\treturn -EINVAL;\n\tbody = input + key_len;\n\tif (!isspace(*body))\n\t\treturn -EINVAL;\n\tbody = skip_spaces(body);\n\tdisk = get_gendisk(MKDEV(major, minor), &part);\n\tif (!disk)\n\t\treturn -ENODEV;\n\tif (part) {\n\t\towner = disk->fops->owner;\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t\treturn -ENODEV;\n\t}\n\trcu_read_lock();\n\tspin_lock_irq(disk->queue->queue_lock);\n\tif (blkcg_policy_enabled(disk->queue, pol))\n\t\tblkg = blkg_lookup_create(blkcg, disk->queue);\n\telse\n\t\tblkg = ERR_PTR(-EOPNOTSUPP);\n\tif (IS_ERR(blkg)) {\n\t\tret = PTR_ERR(blkg);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irq(disk->queue->queue_lock);\n\t\towner = disk->fops->owner;\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t\tif (ret == -EBUSY) {\n\t\t\tmsleep(10);\n\t\t\tret = restart_syscall();\n\t\t}\n\t\treturn ret;\n\t}\n\tctx->disk = disk;\n\tctx->blkg = blkg;\n\tctx->body = body;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(blkg_conf_prep);\n\t__releases(ctx->disk->queue->queue_lock) __releases(rcu)\n{\n\tstruct module *owner;\n\tspin_unlock_irq(ctx->disk->queue->queue_lock);\n\trcu_read_unlock();\n\towner = ctx->disk->fops->owner;\n\tput_disk(ctx->disk);\n\tmodule_put(owner);\n}\nEXPORT_SYMBOL_GPL(blkg_conf_finish);\nstatic int blkcg_print_stat(struct seq_file *sf, void *v)\n{\n\tstruct blkcg *blkcg = css_to_blkcg(seq_css(sf));\n\tstruct blkcg_gq *blkg;\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(blkg, &blkcg->blkg_list, blkcg_node) {\n\t\tconst char *dname;\n\t\tstruct blkg_rwstat rwstat;\n\t\tu64 rbytes, wbytes, rios, wios;\n\t\tdname = blkg_dev_name(blkg);\n\t\tif (!dname)\n\t\t\tcontinue;\n\t\tspin_lock_irq(blkg->q->queue_lock);\n\t\trwstat = blkg_rwstat_recursive_sum(blkg, NULL,\n\t\t\t\t\toffsetof(struct blkcg_gq, stat_bytes));\n\t\trbytes = atomic64_read(&rwstat.aux_cnt[BLKG_RWSTAT_READ]);\n\t\twbytes = atomic64_read(&rwstat.aux_cnt[BLKG_RWSTAT_WRITE]);\n\t\trwstat = blkg_rwstat_recursive_sum(blkg, NULL,\n\t\t\t\t\toffsetof(struct blkcg_gq, stat_ios));\n\t\trios = atomic64_read(&rwstat.aux_cnt[BLKG_RWSTAT_READ]);\n\t\twios = atomic64_read(&rwstat.aux_cnt[BLKG_RWSTAT_WRITE]);\n\t\tspin_unlock_irq(blkg->q->queue_lock);\n\t\tif (rbytes || wbytes || rios || wios)\n\t\t\tseq_printf(sf, \"%s rbytes=%llu wbytes=%llu rios=%llu wios=%llu\\n\",\n\t\t\t\t   dname, rbytes, wbytes, rios, wios);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\nstatic struct cftype blkcg_files[] = {\n\t{\n\t\t.name = \"stat\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = blkcg_print_stat,\n\t},\n\t{ }\t\n};\nstatic struct cftype blkcg_legacy_files[] = {\n\t{\n\t\t.name = \"reset_stats\",\n\t\t.write_u64 = blkcg_reset_stats,\n\t},\n\t{ }\t\n};\nstatic struct cgroup_subsys_state *\nblkcg_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct blkcg *blkcg;\n\tstruct cgroup_subsys_state *ret;\n\tint i;\n\tmutex_lock(&blkcg_pol_mutex);\n\tif (!parent_css) {\n\t\tblkcg = &blkcg_root;\n\t} else {\n\t\tblkcg = kzalloc(sizeof(*blkcg), GFP_KERNEL);\n\t\tif (!blkcg) {\n\t\t\tret = ERR_PTR(-ENOMEM);\n\t\t\tgoto free_blkcg;\n\t\t}\n\t}\n\tfor (i = 0; i < BLKCG_MAX_POLS ; i++) {\n\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\tstruct blkcg_policy_data *cpd;\n\t\tif (!pol || !pol->cpd_alloc_fn)\n\t\t\tcontinue;\n\t\tcpd = pol->cpd_alloc_fn(GFP_KERNEL);\n\t\tif (!cpd) {\n\t\t\tret = ERR_PTR(-ENOMEM);\n\t\t\tgoto free_pd_blkcg;\n\t\t}\n\t\tblkcg->cpd[i] = cpd;\n\t\tcpd->blkcg = blkcg;\n\t\tcpd->plid = i;\n\t\tif (pol->cpd_init_fn)\n\t\t\tpol->cpd_init_fn(cpd);\n\t}\n\tspin_lock_init(&blkcg->lock);\n\tINIT_RADIX_TREE(&blkcg->blkg_tree, GFP_NOWAIT | __GFP_NOWARN);\n\tINIT_HLIST_HEAD(&blkcg->blkg_list);\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tINIT_LIST_HEAD(&blkcg->cgwb_list);\n#endif\n\tlist_add_tail(&blkcg->all_blkcgs_node, &all_blkcgs);\n\tmutex_unlock(&blkcg_pol_mutex);\n\treturn &blkcg->css;\nfree_pd_blkcg:\n\tfor (i--; i >= 0; i--)\n\t\tif (blkcg->cpd[i])\n\t\t\tblkcg_policy[i]->cpd_free_fn(blkcg->cpd[i]);\nfree_blkcg:\n\tkfree(blkcg);\n\tmutex_unlock(&blkcg_pol_mutex);\n\treturn ret;\n}\nint blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}\nstruct cgroup_subsys io_cgrp_subsys = {\n\t.css_alloc = blkcg_css_alloc,\n\t.css_offline = blkcg_css_offline,\n\t.css_free = blkcg_css_free,\n\t.can_attach = blkcg_can_attach,\n\t.bind = blkcg_bind,\n\t.dfl_cftypes = blkcg_files,\n\t.legacy_cftypes = blkcg_legacy_files,\n\t.legacy_name = \"blkio\",\n#ifdef CONFIG_MEMCG\n\t.depends_on = 1 << memory_cgrp_id,\n#endif\n};\nEXPORT_SYMBOL_GPL(io_cgrp_subsys);\nint blkcg_activate_policy(struct request_queue *q,\n\t\t\t  const struct blkcg_policy *pol)\n{\n\tstruct blkg_policy_data *pd_prealloc = NULL;\n\tstruct blkcg_gq *blkg;\n\tint ret;\n\tif (blkcg_policy_enabled(q, pol))\n\t\treturn 0;\n\tif (q->mq_ops)\n\t\tblk_mq_freeze_queue(q);\n\telse\n\t\tblk_queue_bypass_start(q);\npd_prealloc:\n\tif (!pd_prealloc) {\n\t\tpd_prealloc = pol->pd_alloc_fn(GFP_KERNEL, q->node);\n\t\tif (!pd_prealloc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_bypass_end;\n\t\t}\n\t}\n\tspin_lock_irq(q->queue_lock);\n\tlist_for_each_entry(blkg, &q->blkg_list, q_node) {\n\t\tstruct blkg_policy_data *pd;\n\t\tif (blkg->pd[pol->plid])\n\t\t\tcontinue;\n\t\tpd = pol->pd_alloc_fn(GFP_NOWAIT | __GFP_NOWARN, q->node);\n\t\tif (!pd)\n\t\t\tswap(pd, pd_prealloc);\n\t\tif (!pd) {\n\t\t\tspin_unlock_irq(q->queue_lock);\n\t\t\tgoto pd_prealloc;\n\t\t}\n\t\tblkg->pd[pol->plid] = pd;\n\t\tpd->blkg = blkg;\n\t\tpd->plid = pol->plid;\n\t\tif (pol->pd_init_fn)\n\t\t\tpol->pd_init_fn(pd);\n\t}\n\t__set_bit(pol->plid, q->blkcg_pols);\n\tret = 0;\n\tspin_unlock_irq(q->queue_lock);\nout_bypass_end:\n\tif (q->mq_ops)\n\t\tblk_mq_unfreeze_queue(q);\n\telse\n\t\tblk_queue_bypass_end(q);\n\tif (pd_prealloc)\n\t\tpol->pd_free_fn(pd_prealloc);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(blkcg_activate_policy);\nEXPORT_SYMBOL_GPL(blkcg_deactivate_policy);\nint blkcg_policy_register(struct blkcg_policy *pol)\n{\n\tstruct blkcg *blkcg;\n\tint i, ret;\n\tmutex_lock(&blkcg_pol_register_mutex);\n\tmutex_lock(&blkcg_pol_mutex);\n\tret = -ENOSPC;\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++)\n\t\tif (!blkcg_policy[i])\n\t\t\tbreak;\n\tif (i >= BLKCG_MAX_POLS)\n\t\tgoto err_unlock;\n\tpol->plid = i;\n\tblkcg_policy[pol->plid] = pol;\n\tif (pol->cpd_alloc_fn) {\n\t\tlist_for_each_entry(blkcg, &all_blkcgs, all_blkcgs_node) {\n\t\t\tstruct blkcg_policy_data *cpd;\n\t\t\tcpd = pol->cpd_alloc_fn(GFP_KERNEL);\n\t\t\tif (!cpd)\n\t\t\t\tgoto err_free_cpds;\n\t\t\tblkcg->cpd[pol->plid] = cpd;\n\t\t\tcpd->blkcg = blkcg;\n\t\t\tcpd->plid = pol->plid;\n\t\t\tpol->cpd_init_fn(cpd);\n\t\t}\n\t}\n\tmutex_unlock(&blkcg_pol_mutex);\n\tif (pol->dfl_cftypes)\n\t\tWARN_ON(cgroup_add_dfl_cftypes(&io_cgrp_subsys,\n\t\t\t\t\t       pol->dfl_cftypes));\n\tif (pol->legacy_cftypes)\n\t\tWARN_ON(cgroup_add_legacy_cftypes(&io_cgrp_subsys,\n\t\t\t\t\t\t  pol->legacy_cftypes));\n\tmutex_unlock(&blkcg_pol_register_mutex);\n\treturn 0;\nerr_free_cpds:\n\tif (pol->cpd_alloc_fn) {\n\t\tlist_for_each_entry(blkcg, &all_blkcgs, all_blkcgs_node) {\n\t\t\tif (blkcg->cpd[pol->plid]) {\n\t\t\t\tpol->cpd_free_fn(blkcg->cpd[pol->plid]);\n\t\t\t\tblkcg->cpd[pol->plid] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tblkcg_policy[pol->plid] = NULL;\nerr_unlock:\n\tmutex_unlock(&blkcg_pol_mutex);\n\tmutex_unlock(&blkcg_pol_register_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(blkcg_policy_register);\nEXPORT_SYMBOL_GPL(blkcg_policy_unregister);\n",
        "cwe": "CWE-415",
        "file_name": "vul_respovul_idx_2681.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```void dsi_writeflush(DSI *dsi)\n  while (dsi->datasize > 0) { \n    length = dsi_stream_read(dsi, dsi->data,\n\t\t\t     MIN(sizeof(dsi->data), dsi->datasize));\n  }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n/*\n *\n * Copyright (c) 1997 Adrian Sun (asun@zoology.washington.edu)\n * All rights reserved. See COPYRIGHT.\n *\n * 7 Oct 1997 added checks for 0 data.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n/* this streams writes */\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <fcntl.h>\n#include <string.h>\n\n#include <atalk/dsi.h>\n#include <atalk/util.h>\n#include <atalk/logger.h>\n\nsize_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)\n{\n    size_t bytes = 0;\n    dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;\n\n    if (dsi->eof > dsi->start) {\n        /* We have data in the buffer */\n        bytes = MIN(dsi->eof - dsi->start, dsi->datasize);\n        memmove(buf, dsi->start, bytes);\n        dsi->start += bytes;\n        dsi->datasize -= bytes;\n        if (dsi->start >= dsi->eof)\n            dsi->start = dsi->eof = dsi->buffer;\n    }\n\n    LOG(log_maxdebug, logtype_dsi, \"dsi_writeinit: remaining DSI datasize: %jd\", (intmax_t)dsi->datasize);\n\n    return bytes;\n}\n\n\n/* fill up buf and then return. this should be called repeatedly\n * until all the data has been read. i block alarm processing \n * during the transfer to avoid sending unnecessary tickles. */\nsize_t dsi_write(DSI *dsi, void *buf, const size_t buflen)\n{\n  size_t length;\n\n  LOG(log_maxdebug, logtype_dsi, \"dsi_write: remaining DSI datasize: %jd\", (intmax_t)dsi->datasize);\n\n  if ((length = MIN(buflen, dsi->datasize)) > 0) {\n      if ((length = dsi_stream_read(dsi, buf, length)) > 0) {\n          LOG(log_maxdebug, logtype_dsi, \"dsi_write: received: %ju\", (intmax_t)length);\n          dsi->datasize -= length;\n          return length;\n      }\n  }\n  return 0;\n}\n\n/* flush any unread buffers. */\nvoid dsi_writeflush(DSI *dsi)\n{\n  size_t length;\n\n  while (dsi->datasize > 0) { \n    length = dsi_stream_read(dsi, dsi->data,\n\t\t\t     MIN(sizeof(dsi->data), dsi->datasize));\n    if (length > 0)\n      dsi->datasize -= length;\n    else\n      break;\n  }\n}\n\n",
        "cwe": "CWE-122",
        "file_name": "vul_respovul_idx_10828.c",
        "project": "netatalk/netatalk",
        "url": "https://github.com/Netatalk/netatalk/commit/5fcb4ab02aced14484310165b3d754bb2f0820ca",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int x25_rx_call_request(struct sk_buff *skb, struct x25_neigh *nb,\n\t\t\tunsigned int lci)\n\tskb_pull(skb, X25_STD_MIN_LEN);\n\taddr_len = x25_parse_address_block(skb, &source_addr, &dest_addr);\n\tif (addr_len <= 0)\n\t\tgoto out_clear_request;\n\tskb_pull(skb, addr_len);\n\tif (!pskb_may_pull(skb, 1))\n\t\tgoto out_clear_request;\n\tlen = skb->data[0] + 1;\n\tif (!pskb_may_pull(skb, len))\n\t\tgoto out_clear_request;\n\tskb_pull(skb,len);\n\tif (skb->len > X25_MAX_CUD_LEN)\n\t\tgoto out_clear_request;\n\tif (!pskb_may_pull(skb, skb->len))\n\t\tgoto out_clear_request;\n\tsk = x25_find_listener(&source_addr,skb);\n\tskb_push(skb,len);\n\tif (sk != NULL && sk_acceptq_is_full(sk)) {\n\t}\n\tif (sk == NULL) {\n\t}\n\tlen = x25_negotiate_facilities(skb, sk, &facilities, &dte_facilities);\n\tif (len == -1)\n\t\tgoto out_sock_put;\n\tx25_limit_facilities(&facilities, nb);\n\tmake = x25_make_new(sk);\n\tif (!make)\n\t\tgoto out_sock_put;\n\tskb_pull(skb, len);\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmakex25 = x25_sk(make);\n\tmakex25->lci           = lci;\n\tmakex25->dest_addr     = dest_addr;\n\tmakex25->source_addr   = source_addr;\n\tx25_neigh_hold(nb);\n\tmakex25->neighbour     = nb;\n\tmakex25->facilities    = facilities;\n\tmakex25->dte_facilities= dte_facilities;\n\tmakex25->vc_facil_mask = x25_sk(sk)->vc_facil_mask;\n\tmakex25->vc_facil_mask &= ~X25_MASK_REVERSE;\n\tmakex25->vc_facil_mask &= ~X25_MASK_CALLING_AE;\n\tmakex25->cudmatchlength = x25_sk(sk)->cudmatchlength;\n\tif (test_bit(X25_ACCPT_APPRV_FLAG, &makex25->flags)) {\n\t\tmakex25->state = X25_STATE_3;\n\t} else {\n\t\tmakex25->state = X25_STATE_5;\n\t}\n\tskb_copy_from_linear_data(skb, makex25->calluserdata.cuddata, skb->len);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) \"X25: \" fmt\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/ctype.h>\n#include <net/x25.h>\n#include <net/compat.h>\nint sysctl_x25_restart_request_timeout = X25_DEFAULT_T20;\nint sysctl_x25_call_request_timeout    = X25_DEFAULT_T21;\nint sysctl_x25_reset_request_timeout   = X25_DEFAULT_T22;\nint sysctl_x25_clear_request_timeout   = X25_DEFAULT_T23;\nint sysctl_x25_ack_holdback_timeout    = X25_DEFAULT_T2;\nint sysctl_x25_forward                 = 0;\nstatic const struct proto_ops x25_proto_ops;\nstatic const struct x25_address null_x25_address = {\"               \"};\n#ifdef CONFIG_COMPAT\nstruct compat_x25_subscrip_struct {\n\tchar device[200-sizeof(compat_ulong_t)];\n\tcompat_ulong_t global_facil_mask;\n\tcompat_uint_t extended;\n};\n#endif\nstatic void x25_insert_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_add_node(sk, &x25_list);\n\twrite_unlock_bh(&x25_list_lock);\n}\nstatic struct sock *__x25_find_socket(unsigned int lci, struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->lci == lci && x25_sk(s)->neighbour == nb) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\ts = NULL;\nfound:\n\treturn s;\n}\nstruct sock *x25_find_socket(unsigned int lci, struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\tread_lock_bh(&x25_list_lock);\n\ts = __x25_find_socket(lci, nb);\n\tread_unlock_bh(&x25_list_lock);\n\treturn s;\n}\nstatic unsigned int x25_new_lci(struct x25_neigh *nb)\n{\n\tunsigned int lci = 1;\n\tstruct sock *sk;\n\twhile ((sk = x25_find_socket(lci, nb)) != NULL) {\n\t\tsock_put(sk);\n\t\tif (++lci == 4096) {\n\t\t\tlci = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\treturn lci;\n}\nstatic void __x25_destroy_socket(struct sock *);\nstatic int x25_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val, len, rc = -ENOPROTOOPT;\n\tif (level != SOL_X25 || optname != X25_QBITINCL)\n\t\tgoto out;\n\trc = -EFAULT;\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\trc = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\trc = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\tval = test_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\n\trc = copy_to_user(optval, &val, len) ? -EFAULT : 0;\nout:\n\treturn rc;\n}\nstatic struct proto x25_proto = {\n\t.name\t  = \"X25\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct x25_sock),\n};\nstatic int x25_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tstruct x25_sock *x25;\n\tint rc = -EAFNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\tgoto out;\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (protocol)\n\t\tgoto out;\n\trc = -ENOBUFS;\n\tif ((sk = x25_alloc_socket(net, kern)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsock_init_data(sock, sk);\n\tx25_init_timers(sk);\n\tsock->ops    = &x25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tsk->sk_backlog_rcv = x25_backlog_rcv;\n\tx25->t21   = sysctl_x25_call_request_timeout;\n\tx25->t22   = sysctl_x25_reset_request_timeout;\n\tx25->t23   = sysctl_x25_clear_request_timeout;\n\tx25->t2    = sysctl_x25_ack_holdback_timeout;\n\tx25->state = X25_STATE_0;\n\tx25->cudmatchlength = 0;\n\tset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\t\n\tx25->facilities.winsize_in  = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.pacsize_in  = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.throughput  = 0;\t\n\tx25->facilities.reverse     = X25_DEFAULT_REVERSE;\n\tx25->dte_facilities.calling_len = 0;\n\tx25->dte_facilities.called_len = 0;\n\tmemset(x25->dte_facilities.called_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.called_ae));\n\tmemset(x25->dte_facilities.calling_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.calling_ae));\n\trc = 0;\nout:\n\treturn rc;\n}\nstatic int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}\nstatic int x25_wait_for_connection_establishment(struct sock *sk)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint rc;\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = sock_error(sk);\n\t\tif (rc) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tbreak;\n\t\t}\n\t\trc = 0;\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; \n\t}\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\trc = -EISCONN;\t\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\trc = -EALREADY;\t\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) \n\t\tgoto out_put_neigh;\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\tx25->dest_addr = addr->sx25_addr;\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\tx25->state = X25_STATE_1;\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\nint x25_rx_call_request(struct sk_buff *skb, struct x25_neigh *nb,\n\t\t\tunsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct x25_sock *makex25;\n\tstruct x25_address source_addr, dest_addr;\n\tstruct x25_facilities facilities;\n\tstruct x25_dte_facilities dte_facilities;\n\tint len, addr_len, rc;\n\tskb_pull(skb, X25_STD_MIN_LEN);\n\taddr_len = x25_parse_address_block(skb, &source_addr, &dest_addr);\n\tif (addr_len <= 0)\n\t\tgoto out_clear_request;\n\tskb_pull(skb, addr_len);\n\tif (!pskb_may_pull(skb, 1))\n\t\tgoto out_clear_request;\n\tlen = skb->data[0] + 1;\n\tif (!pskb_may_pull(skb, len))\n\t\tgoto out_clear_request;\n\tskb_pull(skb,len);\n\tif (skb->len > X25_MAX_CUD_LEN)\n\t\tgoto out_clear_request;\n\tif (!pskb_may_pull(skb, skb->len))\n\t\tgoto out_clear_request;\n\tsk = x25_find_listener(&source_addr,skb);\n\tskb_push(skb,len);\n\tif (sk != NULL && sk_acceptq_is_full(sk)) {\n\t\tgoto out_sock_put;\n\t}\n\tif (sk == NULL) {\n\t\tskb_push(skb, addr_len + X25_STD_MIN_LEN);\n\t\tif (sysctl_x25_forward &&\n\t\t\t\tx25_forward_call(&dest_addr, nb, skb, lci) > 0)\n\t\t{\n\t\t\tkfree_skb(skb);\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto out_clear_request;\n\t\t}\n\t}\n\tlen = x25_negotiate_facilities(skb, sk, &facilities, &dte_facilities);\n\tif (len == -1)\n\t\tgoto out_sock_put;\n\tx25_limit_facilities(&facilities, nb);\n\tmake = x25_make_new(sk);\n\tif (!make)\n\t\tgoto out_sock_put;\n\tskb_pull(skb, len);\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmakex25 = x25_sk(make);\n\tmakex25->lci           = lci;\n\tmakex25->dest_addr     = dest_addr;\n\tmakex25->source_addr   = source_addr;\n\tx25_neigh_hold(nb);\n\tmakex25->neighbour     = nb;\n\tmakex25->facilities    = facilities;\n\tmakex25->dte_facilities= dte_facilities;\n\tmakex25->vc_facil_mask = x25_sk(sk)->vc_facil_mask;\n\tmakex25->vc_facil_mask &= ~X25_MASK_REVERSE;\n\tmakex25->vc_facil_mask &= ~X25_MASK_CALLING_AE;\n\tmakex25->cudmatchlength = x25_sk(sk)->cudmatchlength;\n\tif (test_bit(X25_ACCPT_APPRV_FLAG, &makex25->flags)) {\n\t\tx25_write_internal(make, X25_CALL_ACCEPTED);\n\t\tmakex25->state = X25_STATE_3;\n\t} else {\n\t\tmakex25->state = X25_STATE_5;\n\t}\n\tskb_copy_from_linear_data(skb, makex25->calluserdata.cuddata, skb->len);\n\tmakex25->calluserdata.cudlength = skb->len;\n\tsk_acceptq_added(sk);\n\tx25_insert_socket(make);\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\tx25_start_heartbeat(make);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\trc = 1;\n\tsock_put(sk);\nout:\n\treturn rc;\nout_sock_put:\n\tsock_put(sk);\nout_clear_request:\n\trc = 0;\n\tx25_transmit_clear_request(nb, lci, 0x01);\n\tgoto out;\n}\nstatic int x25_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_x25 *, usx25, msg->msg_name);\n\tstruct sockaddr_x25 sx25;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint noblock = msg->msg_flags & MSG_DONTWAIT;\n\tsize_t size;\n\tint qbit = 0, rc = -EINVAL;\n\tlock_sock(sk);\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_OOB|MSG_EOR|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tif (!(msg->msg_flags & (MSG_EOR|MSG_OOB)))\n\t\tgoto out;\n\trc = -EADDRNOTAVAIL;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\trc = -EPIPE;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tgoto out;\n\t}\n\trc = -ENETUNREACH;\n\tif (!x25->neighbour)\n\t\tgoto out;\n\tif (usx25) {\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(sx25))\n\t\t\tgoto out;\n\t\tmemcpy(&sx25, usx25, sizeof(sx25));\n\t\trc = -EISCONN;\n\t\tif (strcmp(x25->dest_addr.x25_addr, sx25.sx25_addr.x25_addr))\n\t\t\tgoto out;\n\t\trc = -EINVAL;\n\t\tif (sx25.sx25_family != AF_X25)\n\t\t\tgoto out;\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tsx25.sx25_family = AF_X25;\n\t\tsx25.sx25_addr   = x25->dest_addr;\n\t}\n\tif (len > 65535) {\n\t\trc = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: building packet.\\n\");\n\tif ((msg->msg_flags & MSG_OOB) && len > 32)\n\t\tlen = 32;\n\tsize = len + X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tX25_SKB_CB(skb)->flags = msg->msg_flags;\n\tskb_reserve(skb, X25_MAX_L2_LEN + X25_EXT_MIN_LEN);\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Copying user data\\n\");\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\trc = memcpy_from_msg(skb_transport_header(skb), msg, len);\n\tif (rc)\n\t\tgoto out_kfree_skb;\n\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\tif (!pskb_may_pull(skb, 1))\n\t\t\tgoto out_kfree_skb;\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Building X.25 Header.\\n\");\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tif (x25->neighbour->extended) {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t} else {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t}\n\t} else {\n\t\tif (x25->neighbour->extended) {\n\t\t\tasmptr    = skb_push(skb, X25_EXT_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t} else {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t}\n\t\tif (qbit)\n\t\t\tskb->data[0] |= X25_Q_BIT;\n\t}\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Built header.\\n\");\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Transmitting buffer\\n\");\n\trc = -ENOTCONN;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out_kfree_skb;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tskb_queue_tail(&x25->interrupt_out_queue, skb);\n\telse {\n\t\trc = x25_output(sk, skb);\n\t\tlen = rc;\n\t\tif (rc < 0)\n\t\t\tkfree_skb(skb);\n\t\telse if (test_bit(X25_Q_BIT_FLAG, &x25->flags))\n\t\t\tlen++;\n\t}\n\tx25_kick(sk);\n\trc = len;\nout:\n\trelease_sock(sk);\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\nstatic int x25_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_x25 *, sx25, msg->msg_name);\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\tlock_sock(sk);\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\t\tskb_pull(skb, header_len);\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tmsg->msg_flags |= MSG_EOR;\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\tif (sx25) {\n\t\tsx25->sx25_family = AF_X25;\n\t\tsx25->sx25_addr   = x25->dest_addr;\n\t\tmsg->msg_namelen = sizeof(*sx25);\n\t}\n\tx25_check_rbuf(sk);\n\trc = copied;\nout_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\nstatic int x25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tvoid __user *argp = (void __user *)arg;\n\tint rc;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tint amount;\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (unsigned int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\t\tlock_sock(sk);\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\trelease_sock(sk);\n\t\trc = put_user(amount, (unsigned int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_route_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GSUBSCRIP:\n\t\trc = x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25SSUBSCRIP:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GFACILITIES: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->facilities,\n\t\t\t\t  sizeof(x25->facilities))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25SFACILITIES: {\n\t\tstruct x25_facilities facilities;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&facilities, argp, sizeof(facilities)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_LISTEN &&\n\t\t    sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.pacsize_in < X25_PS16 ||\n\t\t    facilities.pacsize_in > X25_PS4096)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.pacsize_out < X25_PS16 ||\n\t\t    facilities.pacsize_out > X25_PS4096)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.winsize_in < 1 ||\n\t\t    facilities.winsize_in > 127)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.throughput) {\n\t\t\tint out = facilities.throughput & 0xf0;\n\t\t\tint in  = facilities.throughput & 0x0f;\n\t\t\tif (!out)\n\t\t\t\tfacilities.throughput |=\n\t\t\t\t\tX25_DEFAULT_THROUGHPUT << 4;\n\t\t\telse if (out < 0x30 || out > 0xD0)\n\t\t\t\tgoto out_fac_release;\n\t\t\tif (!in)\n\t\t\t\tfacilities.throughput |=\n\t\t\t\t\tX25_DEFAULT_THROUGHPUT;\n\t\t\telse if (in < 0x03 || in > 0x0D)\n\t\t\t\tgoto out_fac_release;\n\t\t}\n\t\tif (facilities.reverse &&\n\t\t    (facilities.reverse & 0x81) != 0x81)\n\t\t\tgoto out_fac_release;\n\t\tx25->facilities = facilities;\n\t\trc = 0;\nout_fac_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25GDTEFACILITIES: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->dte_facilities,\n\t\t\t\t  sizeof(x25->dte_facilities));\n\t\trelease_sock(sk);\n\t\tif (rc)\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase SIOCX25SDTEFACILITIES: {\n\t\tstruct x25_dte_facilities dtefacs;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&dtefacs, argp, sizeof(dtefacs)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_LISTEN &&\n\t\t    sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_dtefac_release;\n\t\tif (dtefacs.calling_len > X25_MAX_AE_LEN)\n\t\t\tgoto out_dtefac_release;\n\t\tif (dtefacs.called_len > X25_MAX_AE_LEN)\n\t\t\tgoto out_dtefac_release;\n\t\tx25->dte_facilities = dtefacs;\n\t\trc = 0;\nout_dtefac_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25GCALLUSERDATA: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->calluserdata,\n\t\t\t\t  sizeof(x25->calluserdata))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25SCALLUSERDATA: {\n\t\tstruct x25_calluserdata calluserdata;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&calluserdata, argp, sizeof(calluserdata)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tif (calluserdata.cudlength > X25_MAX_CUD_LEN)\n\t\t\tbreak;\n\t\tlock_sock(sk);\n\t\tx25->calluserdata = calluserdata;\n\t\trelease_sock(sk);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCX25GCAUSEDIAG: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->causediag, sizeof(x25->causediag))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25SCAUSEDIAG: {\n\t\tstruct x25_causediag causediag;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&causediag, argp, sizeof(causediag)))\n\t\t\tbreak;\n\t\tlock_sock(sk);\n\t\tx25->causediag = causediag;\n\t\trelease_sock(sk);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCX25SCUDMATCHLEN: {\n\t\tstruct x25_subaddr sub_addr;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif(sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_cud_release;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&sub_addr, argp,\n\t\t\t\t   sizeof(sub_addr)))\n\t\t\tgoto out_cud_release;\n\t\trc = -EINVAL;\n\t\tif (sub_addr.cudmatchlength > X25_MAX_CUD_LEN)\n\t\t\tgoto out_cud_release;\n\t\tx25->cudmatchlength = sub_addr.cudmatchlength;\n\t\trc = 0;\nout_cud_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25CALLACCPTAPPRV: {\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\tclear_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\n\t\t\trc = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tcase SIOCX25SENDCALLACCPT:  {\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out_sendcallaccpt_release;\n\t\tif (test_bit(X25_ACCPT_APPRV_FLAG, &x25->flags))\n\t\t\tgoto out_sendcallaccpt_release;\n\t\tx25_write_internal(sk, X25_CALL_ACCEPTED);\n\t\tx25->state = X25_STATE_3;\n\t\trc = 0;\nout_sendcallaccpt_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn rc;\n}\nstatic const struct net_proto_family x25_family_ops = {\n\t.family =\tAF_X25,\n\t.create =\tx25_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n#ifdef CONFIG_COMPAT\nstatic int compat_x25_subscr_ioctl(unsigned int cmd,\n\t\tstruct compat_x25_subscrip_struct __user *x25_subscr32)\n{\n\tstruct compat_x25_subscrip_struct x25_subscr;\n\tstruct x25_neigh *nb;\n\tstruct net_device *dev;\n\tint rc = -EINVAL;\n\trc = -EFAULT;\n\tif (copy_from_user(&x25_subscr, x25_subscr32, sizeof(*x25_subscr32)))\n\t\tgoto out;\n\trc = -EINVAL;\n\tdev = x25_dev_get(x25_subscr.device);\n\tif (dev == NULL)\n\t\tgoto out;\n\tnb = x25_get_neigh(dev);\n\tif (nb == NULL)\n\t\tgoto out_dev_put;\n\tdev_put(dev);\n\tif (cmd == SIOCX25GSUBSCRIP) {\n\t\tread_lock_bh(&x25_neigh_list_lock);\n\t\tx25_subscr.extended = nb->extended;\n\t\tx25_subscr.global_facil_mask = nb->global_facil_mask;\n\t\tread_unlock_bh(&x25_neigh_list_lock);\n\t\trc = copy_to_user(x25_subscr32, &x25_subscr,\n\t\t\t\tsizeof(*x25_subscr32)) ? -EFAULT : 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (x25_subscr.extended == 0 || x25_subscr.extended == 1) {\n\t\t\trc = 0;\n\t\t\twrite_lock_bh(&x25_neigh_list_lock);\n\t\t\tnb->extended = x25_subscr.extended;\n\t\t\tnb->global_facil_mask = x25_subscr.global_facil_mask;\n\t\t\twrite_unlock_bh(&x25_neigh_list_lock);\n\t\t}\n\t}\n\tx25_neigh_put(nb);\nout:\n\treturn rc;\nout_dev_put:\n\tdev_put(dev);\n\tgoto out;\n}\nstatic int compat_x25_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tint rc = -ENOIOCTLCMD;\n\tswitch(cmd) {\n\tcase TIOCOUTQ:\n\tcase TIOCINQ:\n\t\trc = x25_ioctl(sock, cmd, (unsigned long)argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_route_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GSUBSCRIP:\n\t\trc = compat_x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25SSUBSCRIP:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = compat_x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GFACILITIES:\n\tcase SIOCX25SFACILITIES:\n\tcase SIOCX25GDTEFACILITIES:\n\tcase SIOCX25SDTEFACILITIES:\n\tcase SIOCX25GCALLUSERDATA:\n\tcase SIOCX25SCALLUSERDATA:\n\tcase SIOCX25GCAUSEDIAG:\n\tcase SIOCX25SCAUSEDIAG:\n\tcase SIOCX25SCUDMATCHLEN:\n\tcase SIOCX25CALLACCPTAPPRV:\n\tcase SIOCX25SENDCALLACCPT:\n\t\trc = x25_ioctl(sock, cmd, (unsigned long)argp);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n#endif\nstatic const struct proto_ops x25_proto_ops = {\n\t.family =\tAF_X25,\n\t.owner =\tTHIS_MODULE,\n\t.release =\tx25_release,\n\t.bind =\t\tx25_bind,\n\t.connect =\tx25_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tx25_accept,\n\t.getname =\tx25_getname,\n\t.poll =\t\tdatagram_poll,\n\t.ioctl =\tx25_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_x25_ioctl,\n#endif\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tx25_listen,\n\t.shutdown =\tsock_no_shutdown,\n\t.setsockopt =\tx25_setsockopt,\n\t.getsockopt =\tx25_getsockopt,\n\t.sendmsg =\tx25_sendmsg,\n\t.recvmsg =\tx25_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n\t.sendpage =\tsock_no_sendpage,\n};\nstatic struct packet_type x25_packet_type __read_mostly = {\n\t.type =\tcpu_to_be16(ETH_P_X25),\n\t.func =\tx25_lapb_receive_frame,\n};\nstatic struct notifier_block x25_dev_notifier = {\n\t.notifier_call = x25_device_event,\n};\nstatic int __init x25_init(void)\n{\n\tint rc;\n\trc = proto_register(&x25_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&x25_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tdev_add_pack(&x25_packet_type);\n\trc = register_netdevice_notifier(&x25_dev_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\trc = x25_register_sysctl();\n\tif (rc)\n\t\tgoto out_dev;\n\trc = x25_proc_init();\n\tif (rc)\n\t\tgoto out_sysctl;\n\tpr_info(\"Linux Version 0.2\\n\");\nout:\n\treturn rc;\nout_sysctl:\n\tx25_unregister_sysctl();\nout_dev:\n\tunregister_netdevice_notifier(&x25_dev_notifier);\nout_sock:\n\tdev_remove_pack(&x25_packet_type);\n\tsock_unregister(AF_X25);\nout_proto:\n\tproto_unregister(&x25_proto);\n\tgoto out;\n}\nstatic void __exit x25_exit(void)\n{\n\tx25_proc_exit();\n\tx25_link_free();\n\tx25_route_free();\n\tx25_unregister_sysctl();\n\tunregister_netdevice_notifier(&x25_dev_notifier);\n\tdev_remove_pack(&x25_packet_type);\n\tsock_unregister(AF_X25);\n\tproto_unregister(&x25_proto);\n}\nMODULE_AUTHOR(\"Jonathan Naylor <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The X.25 Packet Layer network layer protocol\");\nMODULE_LICENSE(\"GPL\");\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_6043.c",
        "project": "gregkh/linux",
        "url": "https://github.com/gregkh/linux/commit/6ee50c8e262a0f0693dad264c3c99e30e6442a56",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```    unsigned int start_bits, unsigned int nb_bits,\n    unsigned int start_input_bits, unsigned int nb_input_bits,\n    mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));\n    if (mb_mapping == NULL) {\n    }\n    mb_mapping->nb_bits = nb_bits;\n    mb_mapping->start_bits = start_bits;\n    if (nb_bits == 0) {\n        mb_mapping->tab_bits = NULL;\n    } else {\n        mb_mapping->tab_bits =\n            (uint8_t *) malloc(nb_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_bits == NULL) {\n        }\n        memset(mb_mapping->tab_bits, 0, nb_bits * sizeof(uint8_t));\n    }\n    mb_mapping->nb_input_bits = nb_input_bits;\n    mb_mapping->start_input_bits = start_input_bits;\n    if (nb_input_bits == 0) {\n    } else {\n        mb_mapping->tab_input_bits =\n            (uint8_t *) malloc(nb_input_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_input_bits == NULL) {\n        }\n        memset(mb_mapping->tab_input_bits, 0, nb_input_bits * sizeof(uint8_t));\n    }\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <limits.h>\n#include <time.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#endif\n#include <config.h>\n#include \"modbus.h\"\n#include \"modbus-private.h\"\n#define MSG_LENGTH_UNDEFINED -1\nconst unsigned int libmodbus_version_major = LIBMODBUS_VERSION_MAJOR;\nconst unsigned int libmodbus_version_minor = LIBMODBUS_VERSION_MINOR;\nconst unsigned int libmodbus_version_micro = LIBMODBUS_VERSION_MICRO;\n#define MAX_MESSAGE_LENGTH 260\ntypedef enum {\n    _STEP_FUNCTION,\n    _STEP_META,\n    _STEP_DATA\n} _step_t;\nconst char *modbus_strerror(int errnum) {\n    switch (errnum) {\n    case EMBXILFUN:\n        return \"Illegal function\";\n    case EMBXILADD:\n        return \"Illegal data address\";\n    case EMBXILVAL:\n        return \"Illegal data value\";\n    case EMBXSFAIL:\n        return \"Slave device or server failure\";\n    case EMBXACK:\n        return \"Acknowledge\";\n    case EMBXSBUSY:\n        return \"Slave device or server is busy\";\n    case EMBXNACK:\n        return \"Negative acknowledge\";\n    case EMBXMEMPAR:\n        return \"Memory parity error\";\n    case EMBXGPATH:\n        return \"Gateway path unavailable\";\n    case EMBXGTAR:\n        return \"Target device failed to respond\";\n    case EMBBADCRC:\n        return \"Invalid CRC\";\n    case EMBBADDATA:\n        return \"Invalid data\";\n    case EMBBADEXC:\n        return \"Invalid exception code\";\n    case EMBMDATA:\n        return \"Too many data\";\n    case EMBBADSLAVE:\n        return \"Response not from requested slave\";\n    default:\n        return strerror(errnum);\n    }\n}\nvoid _error_print(modbus_t *ctx, const char *context)\n{\n    if (ctx->debug) {\n        fprintf(stderr, \"ERROR %s\", modbus_strerror(errno));\n        if (context != NULL) {\n            fprintf(stderr, \": %s\\n\", context);\n        } else {\n            fprintf(stderr, \"\\n\");\n        }\n    }\n}\nstatic void _sleep_response_timeout(modbus_t *ctx)\n{\n#ifdef _WIN32\n    Sleep((ctx->response_timeout.tv_sec * 1000) +\n          (ctx->response_timeout.tv_usec / 1000));\n#else\n    struct timespec request, remaining;\n    request.tv_sec = ctx->response_timeout.tv_sec;\n    request.tv_nsec = ((long int)ctx->response_timeout.tv_usec) * 1000;\n    while (nanosleep(&request, &remaining) == -1 && errno == EINTR) {\n        request = remaining;\n    }\n#endif\n}\nint modbus_flush(modbus_t *ctx)\n{\n    int rc;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    rc = ctx->backend->flush(ctx);\n    if (rc != -1 && ctx->debug) {\n        printf(\"Bytes flushed (%d)\\n\", rc);\n    }\n    return rc;\n}\nstatic unsigned int compute_response_length_from_request(modbus_t *ctx, uint8_t *req)\n{\n    int length;\n    const int offset = ctx->backend->header_length;\n    switch (req[offset]) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        int nb = (req[offset + 3] << 8) | req[offset + 4];\n        length = 2 + (nb / 8) + ((nb % 8) ? 1 : 0);\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS:\n        length = 2 + 2 * (req[offset + 3] << 8 | req[offset + 4]);\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        length = 3;\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID:\n        return MSG_LENGTH_UNDEFINED;\n    case MODBUS_FC_MASK_WRITE_REGISTER:\n        length = 7;\n        break;\n    default:\n        length = 5;\n    }\n    return offset + length + ctx->backend->checksum_length;\n}\nstatic int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)\n{\n    int rc;\n    int i;\n    msg_length = ctx->backend->send_msg_pre(msg, msg_length);\n    if (ctx->debug) {\n        for (i = 0; i < msg_length; i++)\n            printf(\"[%.2X]\", msg[i]);\n        printf(\"\\n\");\n    }\n    do {\n        rc = ctx->backend->send(ctx, msg, msg_length);\n        if (rc == -1) {\n            _error_print(ctx, NULL);\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n                if ((errno == EBADF || errno == ECONNRESET || errno == EPIPE)) {\n                    modbus_close(ctx);\n                    _sleep_response_timeout(ctx);\n                    modbus_connect(ctx);\n                } else {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                }\n                errno = saved_errno;\n            }\n        }\n    } while ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n             rc == -1);\n    if (rc > 0 && rc != msg_length) {\n        errno = EMBBADDATA;\n        return -1;\n    }\n    return rc;\n}\nint modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req, int raw_req_length)\n{\n    sft_t sft;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    int req_length;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (raw_req_length < 2 || raw_req_length > (MODBUS_MAX_PDU_LENGTH + 1)) {\n        errno = EINVAL;\n        return -1;\n    }\n    sft.slave = raw_req[0];\n    sft.function = raw_req[1];\n    sft.t_id = 0;\n    req_length = ctx->backend->build_response_basis(&sft, req);\n    if (raw_req_length > 2) {\n        memcpy(req + req_length, raw_req + 2, raw_req_length - 2);\n        req_length += raw_req_length - 2;\n    }\n    return send_msg(ctx, req, req_length);\n}\nstatic uint8_t compute_meta_length_after_function(int function,\n                                                  msg_type_t msg_type)\n{\n    int length;\n    if (msg_type == MSG_INDICATION) {\n        if (function <= MODBUS_FC_WRITE_SINGLE_REGISTER) {\n            length = 4;\n        } else if (function == MODBUS_FC_WRITE_MULTIPLE_COILS ||\n                   function == MODBUS_FC_WRITE_MULTIPLE_REGISTERS) {\n            length = 5;\n        } else if (function == MODBUS_FC_MASK_WRITE_REGISTER) {\n            length = 6;\n        } else if (function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = 9;\n        } else {\n            length = 0;\n        }\n    } else {\n        switch (function) {\n        case MODBUS_FC_WRITE_SINGLE_COIL:\n        case MODBUS_FC_WRITE_SINGLE_REGISTER:\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = 4;\n            break;\n        case MODBUS_FC_MASK_WRITE_REGISTER:\n            length = 6;\n            break;\n        default:\n            length = 1;\n        }\n    }\n    return length;\n}\nstatic int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg,\n                                          msg_type_t msg_type)\n{\n    int function = msg[ctx->backend->header_length];\n    int length;\n    if (msg_type == MSG_INDICATION) {\n        switch (function) {\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = msg[ctx->backend->header_length + 5];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n            length = msg[ctx->backend->header_length + 9];\n            break;\n        default:\n            length = 0;\n        }\n    } else {\n        if (function <= MODBUS_FC_READ_INPUT_REGISTERS ||\n            function == MODBUS_FC_REPORT_SLAVE_ID ||\n            function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = msg[ctx->backend->header_length + 1];\n        } else {\n            length = 0;\n        }\n    }\n    length += ctx->backend->checksum_length;\n    return length;\n}\nint _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)\n{\n    int rc;\n    fd_set rset;\n    struct timeval tv;\n    struct timeval *p_tv;\n    int length_to_read;\n    int msg_length = 0;\n    _step_t step;\n    if (ctx->debug) {\n        if (msg_type == MSG_INDICATION) {\n            printf(\"Waiting for an indication...\\n\");\n        } else {\n            printf(\"Waiting for a confirmation...\\n\");\n        }\n    }\n    FD_ZERO(&rset);\n    FD_SET(ctx->s, &rset);\n    step = _STEP_FUNCTION;\n    length_to_read = ctx->backend->header_length + 1;\n    if (msg_type == MSG_INDICATION) {\n        if (ctx->indication_timeout.tv_sec == 0 && ctx->indication_timeout.tv_usec == 0) {\n            p_tv = NULL;\n        } else {\n            tv.tv_sec = ctx->indication_timeout.tv_sec;\n            tv.tv_usec = ctx->indication_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    } else {\n        tv.tv_sec = ctx->response_timeout.tv_sec;\n        tv.tv_usec = ctx->response_timeout.tv_usec;\n        p_tv = &tv;\n    }\n    while (length_to_read != 0) {\n        rc = ctx->backend->select(ctx, &rset, p_tv, length_to_read);\n        if (rc == -1) {\n            _error_print(ctx, \"select\");\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n                if (errno == ETIMEDOUT) {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                } else if (errno == EBADF) {\n                    modbus_close(ctx);\n                    modbus_connect(ctx);\n                }\n                errno = saved_errno;\n            }\n            return -1;\n        }\n        rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);\n        if (rc == 0) {\n            errno = ECONNRESET;\n            rc = -1;\n        }\n        if (rc == -1) {\n            _error_print(ctx, \"read\");\n            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n                (errno == ECONNRESET || errno == ECONNREFUSED ||\n                 errno == EBADF)) {\n                int saved_errno = errno;\n                modbus_close(ctx);\n                modbus_connect(ctx);\n                errno = saved_errno;\n            }\n            return -1;\n        }\n        if (ctx->debug) {\n            int i;\n            for (i=0; i < rc; i++)\n                printf(\"<%.2X>\", msg[msg_length + i]);\n        }\n        msg_length += rc;\n        length_to_read -= rc;\n        if (length_to_read == 0) {\n            switch (step) {\n            case _STEP_FUNCTION:\n                length_to_read = compute_meta_length_after_function(\n                    msg[ctx->backend->header_length],\n                    msg_type);\n                if (length_to_read != 0) {\n                    step = _STEP_META;\n                    break;\n                } \n            case _STEP_META:\n                length_to_read = compute_data_length_after_meta(\n                    ctx, msg, msg_type);\n                if ((msg_length + length_to_read) > (int)ctx->backend->max_adu_length) {\n                    errno = EMBBADDATA;\n                    _error_print(ctx, \"too many data\");\n                    return -1;\n                }\n                step = _STEP_DATA;\n                break;\n            default:\n                break;\n            }\n        }\n        if (length_to_read > 0 &&\n            (ctx->byte_timeout.tv_sec > 0 || ctx->byte_timeout.tv_usec > 0)) {\n            tv.tv_sec = ctx->byte_timeout.tv_sec;\n            tv.tv_usec = ctx->byte_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    }\n    if (ctx->debug)\n        printf(\"\\n\");\n    return ctx->backend->check_integrity(ctx, msg, msg_length);\n}\nstatic int check_confirmation(modbus_t *ctx, uint8_t *req,\n                              uint8_t *rsp, int rsp_length)\n{\n    int rc;\n    int rsp_length_computed;\n    const int offset = ctx->backend->header_length;\n    const int function = rsp[offset];\n    if (ctx->backend->pre_check_confirmation) {\n        rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);\n        if (rc == -1) {\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            return -1;\n        }\n    }\n    rsp_length_computed = compute_response_length_from_request(ctx, req);\n    if (function >= 0x80) {\n        if (rsp_length == (offset + 2 + (int)ctx->backend->checksum_length) &&\n            req[offset] == (rsp[offset] - 0x80)) {\n            int exception_code = rsp[offset + 1];\n            if (exception_code < MODBUS_EXCEPTION_MAX) {\n                errno = MODBUS_ENOBASE + exception_code;\n            } else {\n                errno = EMBBADEXC;\n            }\n            _error_print(ctx, NULL);\n            return -1;\n        } else {\n            errno = EMBBADEXC;\n            _error_print(ctx, NULL);\n            return -1;\n        }\n    }\n    if ((rsp_length == rsp_length_computed ||\n         rsp_length_computed == MSG_LENGTH_UNDEFINED) &&\n        function < 0x80) {\n        int req_nb_value;\n        int rsp_nb_value;\n        if (function != req[offset]) {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Received function not corresponding to the request (0x%X != 0x%X)\\n\",\n                        function, req[offset]);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            return -1;\n        }\n        switch (function) {\n        case MODBUS_FC_READ_COILS:\n        case MODBUS_FC_READ_DISCRETE_INPUTS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            req_nb_value = (req_nb_value / 8) + ((req_nb_value % 8) ? 1 : 0);\n            rsp_nb_value = rsp[offset + 1];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n        case MODBUS_FC_READ_HOLDING_REGISTERS:\n        case MODBUS_FC_READ_INPUT_REGISTERS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 1] / 2);\n            break;\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];\n            break;\n        case MODBUS_FC_REPORT_SLAVE_ID:\n            req_nb_value = rsp_nb_value = rsp[offset + 1];\n            break;\n        default:\n            req_nb_value = rsp_nb_value = 1;\n        }\n        if (req_nb_value == rsp_nb_value) {\n            rc = rsp_nb_value;\n        } else {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Quantity not corresponding to the request (%d != %d)\\n\",\n                        rsp_nb_value, req_nb_value);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            rc = -1;\n        }\n    } else {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"Message length not corresponding to the computed length (%d != %d)\\n\",\n                    rsp_length, rsp_length_computed);\n        }\n        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n            _sleep_response_timeout(ctx);\n            modbus_flush(ctx);\n        }\n        errno = EMBBADDATA;\n        rc = -1;\n    }\n    return rc;\n}\nstatic int response_io_status(uint8_t *tab_io_status,\n                              int address, int nb,\n                              uint8_t *rsp, int offset)\n{\n    int shift = 0;\n    int one_byte = 0;\n    int i;\n    for (i = address; i < address + nb; i++) {\n        one_byte |= tab_io_status[i] << shift;\n        if (shift == 7) {\n            rsp[offset++] = one_byte;\n            one_byte = shift = 0;\n        } else {\n            shift++;\n        }\n    }\n    if (shift != 0)\n        rsp[offset++] = one_byte;\n    return offset;\n}\nstatic int response_exception(modbus_t *ctx, sft_t *sft,\n                              int exception_code, uint8_t *rsp,\n                              unsigned int to_flush,\n                              const char* template, ...)\n{\n    int rsp_length;\n    if (ctx->debug) {\n        va_list ap;\n        va_start(ap, template);\n        vfprintf(stderr, template, ap);\n        va_end(ap);\n    }\n    if (to_flush) {\n        _sleep_response_timeout(ctx);\n        modbus_flush(ctx);\n    }\n    sft->function = sft->function + 0x80;\n    rsp_length = ctx->backend->build_response_basis(sft, rsp);\n    rsp[rsp_length++] = exception_code;\n    return rsp_length;\n}\nint modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - start_bits;\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - start_registers;\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        rsp[rsp_length++] = 0xFF;\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}\nstatic int read_io_status(modbus_t *ctx, int function,\n                          int addr, int nb, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i, temp, bit;\n        int pos = 0;\n        int offset;\n        int offset_end;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length + 2;\n        offset_end = offset + rc;\n        for (i = offset; i < offset_end; i++) {\n            temp = rsp[i];\n            for (bit = 0x01; (bit & 0xff) && (pos < nb);) {\n                dest[pos++] = (temp & bit) ? TRUE : FALSE;\n                bit = bit << 1;\n            }\n        }\n    }\n    return rc;\n}\nstatic int read_registers(modbus_t *ctx, int function, int addr, int nb,\n                          uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        int i;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n    return rc;\n}\nint modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)\n{\n    int rc;\n    int i;\n    int byte_count;\n    int req_length;\n    int bit_check = 0;\n    int pos = 0;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (nb > MODBUS_MAX_WRITE_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr, \"ERROR Writing too many bits (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_COILS,\n                                                   addr, nb, req);\n    byte_count = (nb / 8) + ((nb % 8) ? 1 : 0);\n    req[req_length++] = byte_count;\n    for (i = 0; i < byte_count; i++) {\n        int bit;\n        bit = 0x01;\n        req[req_length] = 0;\n        while ((bit & 0xFF) && (bit_check++ < nb)) {\n            if (src[pos++])\n                req[req_length] |= bit;\n            else\n                req[req_length] &=~ bit;\n            bit = bit << 1;\n        }\n        req_length++;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)\n{\n    int rc;\n    int i;\n    int req_length;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (nb > MODBUS_MAX_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Trying to write to too many registers (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_REGISTERS,\n                                                   addr, nb, req);\n    byte_count = nb * 2;\n    req[req_length++] = byte_count;\n    for (i = 0; i < nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH + 2];\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_MASK_WRITE_REGISTER,\n                                                   addr, 0, req);\n    req_length -= 2;\n    req[req_length++] = and_mask >> 8;\n    req[req_length++] = and_mask & 0x00ff;\n    req[req_length++] = or_mask >> 8;\n    req[req_length++] = or_mask & 0x00ff;\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_write_and_read_registers(modbus_t *ctx,\n                                    int write_addr, int write_nb,\n                                    const uint16_t *src,\n                                    int read_addr, int read_nb,\n                                    uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    int i;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (write_nb > MODBUS_MAX_WR_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers to write (%d > %d)\\n\",\n                    write_nb, MODBUS_MAX_WR_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    if (read_nb > MODBUS_MAX_WR_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    read_nb, MODBUS_MAX_WR_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_AND_READ_REGISTERS,\n                                                   read_addr, read_nb, req);\n    req[req_length++] = write_addr >> 8;\n    req[req_length++] = write_addr & 0x00ff;\n    req[req_length++] = write_nb >> 8;\n    req[req_length++] = write_nb & 0x00ff;\n    byte_count = write_nb * 2;\n    req[req_length++] = byte_count;\n    for (i = 0; i < write_nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n    return rc;\n}\nint modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    if (ctx == NULL || max_dest <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx, MODBUS_FC_REPORT_SLAVE_ID,\n                                                   0, 0, req);\n    req_length -= 4;\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i;\n        int offset;\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length + 2;\n        for (i=0; i < rc && i < max_dest; i++) {\n            dest[i] = rsp[offset + i];\n        }\n    }\n    return rc;\n}\nint modbus_connect(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    return ctx->backend->connect(ctx);\n}\nvoid modbus_close(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n    ctx->backend->close(ctx);\n}\nmodbus_mapping_t* modbus_mapping_new_start_address(\n    unsigned int start_bits, unsigned int nb_bits,\n    unsigned int start_input_bits, unsigned int nb_input_bits,\n    unsigned int start_registers, unsigned int nb_registers,\n    unsigned int start_input_registers, unsigned int nb_input_registers)\n{\n    modbus_mapping_t *mb_mapping;\n    mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));\n    if (mb_mapping == NULL) {\n        return NULL;\n    }\n    mb_mapping->nb_bits = nb_bits;\n    mb_mapping->start_bits = start_bits;\n    if (nb_bits == 0) {\n        mb_mapping->tab_bits = NULL;\n    } else {\n        mb_mapping->tab_bits =\n            (uint8_t *) malloc(nb_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_bits == NULL) {\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_bits, 0, nb_bits * sizeof(uint8_t));\n    }\n    mb_mapping->nb_input_bits = nb_input_bits;\n    mb_mapping->start_input_bits = start_input_bits;\n    if (nb_input_bits == 0) {\n        mb_mapping->tab_input_bits = NULL;\n    } else {\n        mb_mapping->tab_input_bits =\n            (uint8_t *) malloc(nb_input_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_input_bits == NULL) {\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_bits, 0, nb_input_bits * sizeof(uint8_t));\n    }\n    mb_mapping->nb_registers = nb_registers;\n    mb_mapping->start_registers = start_registers;\n    if (nb_registers == 0) {\n        mb_mapping->tab_registers = NULL;\n    } else {\n        mb_mapping->tab_registers =\n            (uint16_t *) malloc(nb_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_registers == NULL) {\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_registers, 0, nb_registers * sizeof(uint16_t));\n    }\n    mb_mapping->nb_input_registers = nb_input_registers;\n    mb_mapping->start_input_registers = start_input_registers;\n    if (nb_input_registers == 0) {\n        mb_mapping->tab_input_registers = NULL;\n    } else {\n        mb_mapping->tab_input_registers =\n            (uint16_t *) malloc(nb_input_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_input_registers == NULL) {\n            free(mb_mapping->tab_registers);\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_registers, 0,\n               nb_input_registers * sizeof(uint16_t));\n    }\n    return mb_mapping;\n}\n#ifndef HAVE_STRLCPY\n#endif\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_3614.c",
        "project": "stephane/libmodbus",
        "url": "https://github.com/stephane/libmodbus/commit/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```Sprintf(char *fmt, ...)\n    int len = 0;\n    int p = 0;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n\t    if (*f == '%') {\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\t    len += (p > 0) ? p : 10;\n\t\t    len += (p > 0) ? p : 15;\n\t\t    len += 1;\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    len += 10;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t    else if (*f == '%') {\n\t\tlen++;\n\t    }\n\t    if (IS_ALPHA(*f)) {\n\t    }\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdio.h>\n#include <stdlib.h>\n#include <gc.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef __EMX__\t\t\t\n#include <strings.h>\n#endif\n#include \"Str.h\"\n#include \"myctype.h\"\n#define INITIAL_STR_SIZE 32\n#ifdef STR_DEBUG\n#define STR_LENGTH_CHECK(x) if (((x)->ptr==0&&(x)->length!=0)||(strlen((x)->ptr)!=(x)->length))abort();\n#else\t\t\t\t\n#define STR_LENGTH_CHECK(x)\n#endif\t\t\t\t\nvoid\nStrgrow(Str x)\n{\n    char *old = x->ptr;\n    int newlen;\n    newlen = x->area_size * 6 / 5;\n    if (newlen == x->area_size)\n\tnewlen += 2;\n    x->ptr = GC_MALLOC_ATOMIC(newlen);\n    x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n#define SP_NORMAL 0\n#define SP_PREC   1\n#define SP_PREC2  2\nStr\nSprintf(char *fmt, ...)\n{\n    int len = 0;\n    int status = SP_NORMAL;\n    int p = 0;\n    char *f;\n    Str s;\n    va_list ap;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n      redo:\n\tswitch (status) {\n\tcase SP_NORMAL:\n\t    if (*f == '%') {\n\t\tstatus = SP_PREC;\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\tcase SP_PREC:\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\tint vi;\n\t\tchar *vs;\n\t\tvoid *vp;\n\t\tswitch (*f) {\n\t\tcase 'l':\n\t\tcase 'h':\n\t\tcase 'L':\n\t\tcase 'w':\n\t\t    continue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\tcase 'u':\n\t\t    vi = va_arg(ap, int);\n\t\t    len += (p > 0) ? p : 10;\n\t\t    break;\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'e':\n\t\tcase 'G':\n\t\tcase 'E':\n\t\t    vd = va_arg(ap, double);\n\t\t    len += (p > 0) ? p : 15;\n\t\t    break;\n\t\tcase 'c':\n\t\t    len += 1;\n\t\t    vi = va_arg(ap, int);\n\t\t    break;\n\t\tcase 's':\n\t\t    vs = va_arg(ap, char *);\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    break;\n\t\tcase 'p':\n\t\t    vp = va_arg(ap, void *);\n\t\t    len += 10;\n\t\t    break;\n\t\tcase 'n':\n\t\t    vp = va_arg(ap, void *);\n\t\t    break;\n\t\t}\n\t\tstatus = SP_NORMAL;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t\tstatus = SP_PREC2;\n\t    else if (*f == '%') {\n\t\tstatus = SP_NORMAL;\n\t\tlen++;\n\t    }\n\t    break;\n\tcase SP_PREC2:\n\t    if (IS_ALPHA(*f)) {\n\t\tstatus = SP_PREC;\n\t\tgoto redo;\n\t    }\n\t    break;\n\t}\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n    va_end(ap);\n    s->length = strlen(s->ptr);\n    if (s->length > len * 2) {\n\tfprintf(stderr, \"Sprintf: string too long\\n\");\n\texit(1);\n    }\n    return s;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1446.c",
        "project": "tats/w3m",
        "url": "https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int main(int argc, char *argv[])\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n        return 0;\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    else\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    if (plist_out)\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"plist/plist.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#ifdef _MSC_VER\n#pragma warning(disable:4996)\n#endif\ntypedef struct _options\n{\n    char *in_file, *out_file;\n    uint8_t debug, in_fmt, out_fmt;\n} options_t;\nstatic void print_usage(int argc, char *argv[])\n{\n    char *name = NULL;\n    name = strrchr(argv[0], '/');\n    printf(\"Usage: %s -i|--infile FILE [-o|--outfile FILE] [-d|--debug]\\n\", (name ? name + 1: argv[0]));\n    printf(\"Convert a plist FILE from binary to XML format or vice-versa.\\n\\n\");\n    printf(\"  -i, --infile FILE\\tThe FILE to convert from\\n\");\n    printf(\"  -o, --outfile FILE\\tOptional FILE to convert to or stdout if not used\\n\");\n    printf(\"  -d, --debug\\t\\tEnable extended debug output\\n\");\n    printf(\"\\n\");\n}\nstatic options_t *parse_arguments(int argc, char *argv[])\n{\n    int i = 0;\n    options_t *options = (options_t *) malloc(sizeof(options_t));\n    memset(options, 0, sizeof(options_t));\n    for (i = 1; i < argc; i++)\n    {\n        if (!strcmp(argv[i], \"--infile\") || !strcmp(argv[i], \"-i\"))\n        {\n            if ((i + 1) == argc)\n            {\n                free(options);\n                return NULL;\n            }\n            options->in_file = argv[i + 1];\n            i++;\n            continue;\n        }\n        if (!strcmp(argv[i], \"--outfile\") || !strcmp(argv[i], \"-o\"))\n        {\n            if ((i + 1) == argc)\n            {\n                free(options);\n                return NULL;\n            }\n            options->out_file = argv[i + 1];\n            i++;\n            continue;\n        }\n        if (!strcmp(argv[i], \"--debug\") || !strcmp(argv[i], \"-d\"))\n        {\n            options->debug = 1;\n        }\n        if (!strcmp(argv[i], \"--help\") || !strcmp(argv[i], \"-h\"))\n        {\n            free(options);\n            return NULL;\n        }\n    }\n    if (!options->in_file)\n    {\n        free(options);\n        return NULL;\n    }\n    return options;\n}\nint main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_1485.c",
        "project": "libimobiledevice/libplist",
        "url": "https://github.com/libimobiledevice/libplist/commit/7391a506352c009fe044dead7baad9e22dd279ee",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ttusbdecfe_dvbs_set_frontend(struct dvb_frontend *fe)\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tu8 b[] = { 0x00, 0x00, 0x00, 0x01,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x01,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00 };\n\tfreq = htonl(p->frequency +\n\t       (state->hi_band ? LOF_HI : LOF_LO));\n\tmemcpy(&b[4], &freq, sizeof(u32));\n\tsym_rate = htonl(p->symbol_rate);\n\tmemcpy(&b[12], &sym_rate, sizeof(u32));\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"dvb_frontend.h\"\n#include \"ttusbdecfe.h\"\n#define LOF_HI\t\t\t10600000\n#define LOF_LO\t\t\t9750000\nstruct ttusbdecfe_state {\n\tconst struct ttusbdecfe_config* config;\n\tstruct dvb_frontend frontend;\n\tu8 hi_band;\n\tu8 voltage;\n};\nstatic int ttusbdecfe_dvbs_set_frontend(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0x00, 0x00, 0x01,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x01,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00 };\n\t__be32 freq;\n\t__be32 sym_rate;\n\t__be32 band;\n\t__be32 lnb_voltage;\n\tfreq = htonl(p->frequency +\n\t       (state->hi_band ? LOF_HI : LOF_LO));\n\tmemcpy(&b[4], &freq, sizeof(u32));\n\tsym_rate = htonl(p->symbol_rate);\n\tmemcpy(&b[12], &sym_rate, sizeof(u32));\n\tband = htonl(state->hi_band ? LOF_HI : LOF_LO);\n\tmemcpy(&b[24], &band, sizeof(u32));\n\tlnb_voltage = htonl(state->voltage);\n\tmemcpy(&b[28], &lnb_voltage, sizeof(u32));\n\tstate->config->send_command(fe, 0x71, sizeof(b), b, NULL, NULL);\n\treturn 0;\n}\nstatic int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}\nstatic struct dvb_frontend_ops ttusbdecfe_dvbt_ops;\nstatic struct dvb_frontend_ops ttusbdecfe_dvbs_ops;\nstatic struct dvb_frontend_ops ttusbdecfe_dvbt_ops = {\n\t.delsys = { SYS_DVBT },\n\t.info = {\n\t\t.name\t\t\t= \"TechnoTrend/Hauppauge DEC2000-t Frontend\",\n\t\t.frequency_min\t\t= 51000000,\n\t\t.frequency_max\t\t= 858000000,\n\t\t.frequency_stepsize\t= 62500,\n\t\t.caps =\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |\n\t\t\tFE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |\n\t\t\tFE_CAN_HIERARCHY_AUTO,\n\t},\n\t.release = ttusbdecfe_release,\n\t.set_frontend = ttusbdecfe_dvbt_set_frontend,\n\t.get_tune_settings = ttusbdecfe_dvbt_get_tune_settings,\n\t.read_status = ttusbdecfe_dvbt_read_status,\n};\nstatic struct dvb_frontend_ops ttusbdecfe_dvbs_ops = {\n\t.delsys = { SYS_DVBS },\n\t.info = {\n\t\t.name\t\t\t= \"TechnoTrend/Hauppauge DEC3000-s Frontend\",\n\t\t.frequency_min\t\t= 950000,\n\t\t.frequency_max\t\t= 2150000,\n\t\t.frequency_stepsize\t= 125,\n\t\t.symbol_rate_min        = 1000000,  \n\t\t.symbol_rate_max        = 45000000, \n\t\t.caps =\tFE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |\n\t\t\tFE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |\n\t\t\tFE_CAN_QPSK\n\t},\n\t.release = ttusbdecfe_release,\n\t.set_frontend = ttusbdecfe_dvbs_set_frontend,\n\t.read_status = ttusbdecfe_dvbs_read_status,\n\t.diseqc_send_master_cmd = ttusbdecfe_dvbs_diseqc_send_master_cmd,\n\t.set_voltage = ttusbdecfe_dvbs_set_voltage,\n\t.set_tone = ttusbdecfe_dvbs_set_tone,\n};\nMODULE_DESCRIPTION(\"TTUSB DEC DVB-T/S Demodulator driver\");\nMODULE_AUTHOR(\"Alex Woods/Andrew de Quincey\");\nMODULE_LICENSE(\"GPL\");\nEXPORT_SYMBOL(ttusbdecfe_dvbs_attach);\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_739.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n}\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n}\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n}\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n}\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n    }\n    if (buf->offset + entry_length >= buf_maxlen) {\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n    }\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n        }\n        uint32_t ptagx_count = 0;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                i++;\n            }\n            if (value != 0) {\n                if (value == tagx->tags[i].bitmask) {\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                } else {\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            } else {\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            i++;\n        }\n    }\n}\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); \n    const uint32_t header_length = mobi_buffer_get32(buf); \n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n    mobi_buffer_seek(buf, 4); \n    const uint32_t type = mobi_buffer_get32(buf); \n    mobi_buffer_seek(buf, 4); \n    const uint32_t idxt_offset = mobi_buffer_get32(buf); \n    const uint32_t entries_count = mobi_buffer_get32(buf); \n    if (entries_count > INDX_RECORD_MAXCNT) {\n    }\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n    } else {\n        if (idxt_offset == 0) {\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n        }\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n            }\n        }\n    }\n}\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n    }\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n    }\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n    }\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit\nFile number 2:\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD \n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"index.h\"\n#include \"util.h\"\n#include \"memory.h\"\n#include \"debug.h\"\n#include \"buffer.h\"\nsize_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {\n    if (!output) {\n        buf->error = MOBI_PARAM_ERR;\n        return 0;\n    }\n    if (buf->offset + length > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    const unsigned char replacement = 0x3f;\n    size_t output_length = 0;\n    size_t i = 0;\n    while (i < length && output_length < INDX_LABEL_SIZEMAX) {\n        unsigned char c = mobi_buffer_get8(buf);\n        i++;\n        if (c == 0) {\n            debug_print(\"Invalid character: %u\\n\", c);\n            c = replacement;\n        }\n        if (c <= 5 && has_ligatures) {\n            unsigned char c2 = mobi_buffer_get8(buf);\n            c = mobi_ligature_to_cp1252(c, c2);\n            if (c == 0) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, -1);\n                c = replacement;\n            } else {\n                i++;\n            }\n        }\n        *output++ = c;\n        output_length++;\n    }\n    *output = '\\0';\n    return output_length;\n}\nstatic MOBI_RET mobi_parse_ordt(MOBIBuffer *buf, MOBIOrdt *ordt) {\n    mobi_buffer_setpos(buf, ordt->ordt1_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT1 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT1 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt1 = malloc(ordt->offsets_count * sizeof(*ordt->ordt1));\n        if (ordt->ordt1 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT1 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt1[i++] = mobi_buffer_get8(buf);\n        }\n        debug_print(\"ORDT1: read %zu entries\\n\", ordt->offsets_count);\n    }\n    mobi_buffer_setpos(buf, ordt->ordt2_pos);\n    if (mobi_buffer_match_magic(buf, ORDT_MAGIC)) {\n        debug_print(\"%s\\n\", \"ORDT2 section found\");\n        mobi_buffer_seek(buf, 4);\n        if (ordt->offsets_count * 2 + buf->offset > buf->maxlen) {\n            debug_print(\"ORDT2 section too long (%zu)\", ordt->offsets_count);\n            return MOBI_DATA_CORRUPT;\n        }\n        ordt->ordt2 = malloc(ordt->offsets_count * sizeof(*ordt->ordt2));\n        if (ordt->ordt2 == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed for ORDT2 offsets\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        size_t i = 0;\n        while (i < ordt->offsets_count) {\n            ordt->ordt2[i++] = mobi_buffer_get16(buf);\n        }\n        debug_print(\"ORDT2: read %zu entries\\n\", ordt->offsets_count);\n    }\n    return MOBI_SUCCESS;\n}\nstatic MOBI_RET mobi_parse_tagx(MOBIBuffer *buf, MOBITagx *tagx) {\n    tagx->control_byte_count = 0;\n    tagx->tags_count = 0;\n    tagx->tags = NULL;\n    mobi_buffer_seek(buf, 4); \n    uint32_t tagx_record_length = mobi_buffer_get32(buf);\n    if (tagx_record_length < 12) {\n        debug_print(\"INDX record too short: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->control_byte_count = mobi_buffer_get32(buf);\n    tagx_record_length -= 12;\n    if (tagx_record_length + buf->offset > buf->maxlen) {\n        debug_print(\"INDX record too long: %u\\n\", tagx_record_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags = malloc(tagx_record_length * sizeof(TAGXTags));\n    if (tagx->tags == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed for TAGX tags\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    const size_t tagx_data_length = tagx_record_length / 4;\n    size_t control_byte_count = 0;\n    while (i < tagx_data_length) {\n        tagx->tags[i].tag = mobi_buffer_get8(buf);\n        tagx->tags[i].values_count = mobi_buffer_get8(buf);\n        tagx->tags[i].bitmask = mobi_buffer_get8(buf);\n        const uint8_t control_byte = mobi_buffer_get8(buf);\n        if (control_byte) { control_byte_count++; }\n        tagx->tags[i].control_byte = control_byte;\n        debug_print(\"tagx[%zu]:\\t%i\\t%i\\t%i\\t%i\\n\", i, tagx->tags[i].tag, tagx->tags[i].values_count, tagx->tags[i].bitmask, control_byte);\n        i++;\n    }\n    if (tagx->control_byte_count != control_byte_count) {\n        debug_print(\"Wrong count of control bytes: %zu != %zu\\n\", tagx->control_byte_count, control_byte_count);\n        free(tagx->tags);\n        tagx->tags = NULL;\n        tagx->control_byte_count = 0;\n        return MOBI_DATA_CORRUPT;\n    }\n    tagx->tags_count = i;\n    return MOBI_SUCCESS;\n}\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n    size_t i = 0;\n    size_t output_length = 0;\n    const uint32_t bytemask = 0xbf;\n    const uint32_t bytemark = 0x80;\n    const uint32_t uni_replacement = 0xfffd;\n    const uint32_t surrogate_offset = 0x35fdc00;\n    static const uint8_t init_byte[7] = { 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc };\n    while (i < length) {\n        uint16_t offset;\n        i += mobi_ordt_getbuffer(ordt, buf, &offset);\n        uint32_t codepoint = mobi_ordt_lookup(ordt, offset);\n        if (codepoint <= 5) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            codepoint = mobi_ligature_to_utf16(codepoint, codepoint2);\n            if (codepoint == uni_replacement) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, - (int) k);\n            } else {\n                i += k;\n            }\n        }\n        if (codepoint >= 0xd800 && codepoint <= 0xdbff) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            if (codepoint2 >= 0xdc00 && codepoint2 <= 0xdfff) {\n                i += k;\n                codepoint = (codepoint << 10) + codepoint2 - surrogate_offset;\n            } else {\n                debug_print(\"Invalid code point: %u\\n\", codepoint);\n                mobi_buffer_seek(buf, - (int) k);\n                codepoint = uni_replacement;\n            }\n        }\n        if ((codepoint >= 0xdc00 && codepoint <= 0xdfff) \n            || (codepoint >= 0xfdd0 && codepoint <= 0xfdef) \n            || (codepoint & 0xfffe) == 0xfffe \n            || codepoint == 0 ) {\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        size_t bytes;\n        if (codepoint < 0x80) { bytes = 1; }\n        else if (codepoint < 0x800) { bytes = 2; }\n        else if (codepoint < 0x10000) { bytes = 3; }\n        else if (codepoint < 0x110000) { bytes = 4; }\n        else {\n            bytes = 3;\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        if (output_length + bytes >= INDX_LABEL_SIZEMAX) {\n            debug_print(\"%s\\n\", \"INDX label too long\");\n            break;\n        }\n        output += bytes;\n        switch (bytes) {\n            case 4: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 3: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 2: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; \n            case 1: *--output = (uint8_t)(codepoint | init_byte[bytes]);\n        }\n        output += bytes;\n        output_length += bytes;\n    }\n    *output = '\\0';\n    return output_length;\n}\nstatic MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                if (value == tagx->tags[i].bitmask) {\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            } else {\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_parse_indx(const MOBIPdbRecord *indx_record, MOBIIndx *indx, MOBITagx *tagx, MOBIOrdt *ordt) {\n    if (indx_record == NULL || indx == NULL || tagx == NULL || ordt == NULL) {\n        debug_print(\"%s\", \"index structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null(indx_record->data, indx_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char indx_magic[5];\n    mobi_buffer_getstring(indx_magic, buf, 4); \n    const uint32_t header_length = mobi_buffer_get32(buf); \n    if (strncmp(indx_magic, INDX_MAGIC, 4) != 0 ||\n        header_length == 0 || header_length > indx_record->size) {\n        debug_print(\"INDX wrong magic: %s or header length: %u\\n\", indx_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_seek(buf, 4); \n    const uint32_t type = mobi_buffer_get32(buf); \n    mobi_buffer_seek(buf, 4); \n    const uint32_t idxt_offset = mobi_buffer_get32(buf); \n    const uint32_t entries_count = mobi_buffer_get32(buf); \n    if (entries_count > INDX_RECORD_MAXCNT) {\n        debug_print(\"Too many index entries (%u)\\n\", entries_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (mobi_buffer_match_magic_offset(buf, TAGX_MAGIC, header_length) && indx->total_entries_count == 0) {\n        buf->maxlen = header_length;\n        uint32_t encoding = mobi_buffer_get32(buf); \n        if (encoding == MOBI_NOTSET) { encoding = MOBI_CP1252; }\n        mobi_buffer_seek(buf, 4); \n        const uint32_t total_entries_count = mobi_buffer_get32(buf); \n        if (total_entries_count > INDX_TOTAL_MAXCNT) {\n            debug_print(\"Too many total index entries (%u)\\n\", total_entries_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_offset = mobi_buffer_get32(buf); \n        if (ordt_offset + ORDT_RECORD_MAXCNT + 4 > indx_record->size) {\n            ordt_offset = 0;\n        }\n        uint32_t ligt_offset = mobi_buffer_get32(buf); \n        uint32_t ligt_entries_count = mobi_buffer_get32(buf); \n        if (ligt_offset + 4 * ligt_entries_count + 4 > indx_record->size) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        const uint32_t cncx_records_count = mobi_buffer_get32(buf); \n        if (cncx_records_count > CNCX_RECORD_MAXCNT) {\n            debug_print(\"Too many CNCX records (%u)\\n\", cncx_records_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t ordt_type = 0;\n        uint32_t ordt_entries_count = 0;\n        uint32_t ordt1_offset = 0;\n        uint32_t ordt2_offset = 0;\n        uint32_t index_name_offset = 0;\n        uint32_t index_name_length = 0;\n        if (header_length >= 180) {\n            mobi_buffer_setpos(buf, 164);\n            ordt_type = mobi_buffer_get32(buf); \n            ordt_entries_count = mobi_buffer_get32(buf); \n            ordt1_offset = mobi_buffer_get32(buf); \n            ordt2_offset = mobi_buffer_get32(buf); \n            const size_t entry_size = (ordt_type == 0) ? 1 : 2;\n            if (ordt1_offset + entry_size * ordt_entries_count > indx_record->size\n                || ordt2_offset + 2 * ordt_entries_count > indx_record->size) {\n                ordt1_offset = 0;\n                ordt2_offset = 0;\n                ordt_entries_count = 0;\n            }\n            index_name_offset = mobi_buffer_get32(buf); \n            index_name_length = mobi_buffer_get32(buf); \n        }\n        buf->maxlen = indx_record->size;\n        mobi_buffer_setpos(buf, header_length);\n        ret = mobi_parse_tagx(buf, tagx);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (ordt_entries_count > 0) {\n            ordt->offsets_count = ordt_entries_count;\n            ordt->type = ordt_type;\n            ordt->ordt1_pos = ordt1_offset;\n            ordt->ordt2_pos = ordt2_offset;\n            ret = mobi_parse_ordt(buf, ordt);\n            debug_print(\"ORDT: %u, %u, %u, %u\\n\", ordt_type, ordt_entries_count, ordt1_offset, ordt2_offset);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                return ret;\n            }\n        }\n        if (index_name_offset > 0 && index_name_length > 0) {\n            if (index_name_length <= header_length - index_name_offset && index_name_length < INDX_NAME_SIZEMAX) {\n                mobi_buffer_setpos(buf, index_name_offset);\n                char *name = malloc(index_name_length + 1);\n                if (name == NULL) {\n                    debug_print(\"%s\", \"Memory allocation failed\\n\");\n                    mobi_buffer_free_null(buf);\n                    return MOBI_MALLOC_FAILED;\n                }\n                mobi_buffer_getstring(name, buf, index_name_length);\n                indx->orth_index_name = name;\n                debug_print(\"Orth index name: %s\\n\", name);\n            }\n        }\n        indx->encoding = encoding;\n        indx->type = type;\n        indx->entries_count = entries_count;\n        indx->total_entries_count = total_entries_count;\n        if (ligt_entries_count != 0 && !mobi_buffer_match_magic_offset(buf, LIGT_MAGIC, ligt_offset)) {\n            ligt_offset = 0;\n            ligt_entries_count = 0;\n        }\n        indx->ligt_offset = ligt_offset;\n        indx->ligt_entries_count = ligt_entries_count;\n        indx->ordt_offset = ordt_offset;\n        indx->cncx_records_count = cncx_records_count;\n    } else {\n        if (idxt_offset == 0) {\n            debug_print(\"%s\", \"Missing IDXT offset\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (idxt_offset + 2 * entries_count + 4 > indx_record->size ) {\n            debug_print(\"IDXT entries beyond record end%s\", \"\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, idxt_offset);\n        MOBIIdxt idxt;\n        uint32_t *offsets = malloc((entries_count + 1) * sizeof(uint32_t));\n        if (offsets == NULL) {\n            mobi_buffer_free_null(buf);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        idxt.offsets = offsets;\n        ret = mobi_parse_idxt(buf, &idxt, entries_count);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"IDXT parsing failed\\n\");\n            mobi_buffer_free_null(buf);\n            free(offsets);\n            return ret;\n        }\n        if (entries_count > 0) {\n            if (indx->entries == NULL) {\n                indx->entries = malloc(indx->total_entries_count * sizeof(MOBIIndexEntry));\n                if (indx->entries == NULL) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            size_t i = 0;\n            while (i < entries_count) {\n                ret = mobi_parse_index_entry(indx, idxt, tagx, ordt, buf, i++);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_buffer_free_null(buf);\n                    free(offsets);\n                    return ret;\n                }\n            }\n            indx->entries_count += entries_count;\n        }\n        free(offsets);\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_parse_index(const MOBIData *m, MOBIIndx *indx, const size_t indx_record_number) {\n    MOBI_RET ret;\n    MOBITagx *tagx = calloc(1, sizeof(MOBITagx));\n    if (tagx == NULL) {\n        mobi_free_indx(indx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIOrdt *ordt = calloc(1, sizeof(MOBIOrdt));\n    if (ordt == NULL) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, indx_record_number);\n    ret = mobi_parse_indx(record, indx, tagx, ordt);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return ret;\n    }\n    size_t count = indx->entries_count;\n    indx->entries_count = 0;\n    while (count--) {\n        record = record->next;\n        ret = mobi_parse_indx(record, indx, tagx, ordt);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_indx(indx);\n            mobi_free_tagx(tagx);\n            mobi_free_ordt(ordt);\n            return ret;\n        }\n    }\n    if (indx->entries_count != indx->total_entries_count) {\n        debug_print(\"Entries count %zu != total entries count %zu\\n\", indx->entries_count, indx->total_entries_count);\n        mobi_free_indx(indx);\n        mobi_free_tagx(tagx);\n        mobi_free_ordt(ordt);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (indx->cncx_records_count) {\n        indx->cncx_record = record->next;\n    }\n    mobi_free_tagx(tagx);\n    mobi_free_ordt(ordt);\n    return MOBI_SUCCESS;\n}\nMOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\nsize_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {\n    if (root == NULL) {\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 0;\n    size_t length = strlen(string);\n    MOBITrie *node = root;\n    while (node && length > 0) {\n        char **values = NULL;\n        size_t values_count = 0;\n        node = mobi_trie_get_next(&values, &values_count, node, string[length - 1]);\n        length--;\n        for (size_t j = 0; j < values_count; j++) {\n            if (count == INDX_INFLSTRINGS_MAX) {\n                debug_print(\"Inflection strings array too small (%d)\\n\", INDX_INFLSTRINGS_MAX);\n                break;\n            }\n            char infl_string[INDX_LABEL_SIZEMAX + 1];\n            const size_t suffix_length = strlen(values[j]);\n            if (length + suffix_length > INDX_LABEL_SIZEMAX) {\n                debug_print(\"Label too long (%zu + %zu)\\n\", length, suffix_length);\n                continue;\n            }\n            memcpy(infl_string, string, length);\n            memcpy(infl_string + length, values[j], suffix_length);\n            infl_string[length + suffix_length] = '\\0';\n            infl_strings[count++] = strdup(infl_string);\n        }\n    }\n    return count;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_7847.c",
        "project": "bfabiszewski/libmobi",
        "url": "https://github.com/bfabiszewski/libmobi/commit/eafc415bc6067e72577f70d6dd5acbf057ce6e6f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\twhile (leftover) {\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t}\n\tif (leftover) {\n\t}\n\tif (mc_saved_count == 0) {\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/earlycpio.h>\n#include <linux/initrd.h>\n#include <linux/cpu.h>\n#include <asm/msr.h>\n#include <asm/microcode_intel.h>\n#include <asm/processor.h>\n#include <asm/tlbflush.h>\n#include <asm/setup.h>\nstatic unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];\nstatic struct mc_saved_data {\n\tunsigned int mc_saved_count;\n\tstruct microcode_intel **mc_saved;\n} mc_saved_data;\n#ifdef CONFIG_X86_32\nstatic void\nmicrocode_phys(struct microcode_intel **mc_saved_tmp,\n\t       struct mc_saved_data *mc_saved_data)\n{\n\tint i;\n\tstruct microcode_intel ***mc_saved;\n\tmc_saved = (struct microcode_intel ***)\n\t\t   __pa_nodebug(&mc_saved_data->mc_saved);\n\tfor (i = 0; i < mc_saved_data->mc_saved_count; i++) {\n\t\tstruct microcode_intel *p;\n\t\tp = *(struct microcode_intel **)\n\t\t\t__pa_nodebug(mc_saved_data->mc_saved + i);\n\t\tmc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);\n\t}\n}\n#endif\nstatic u8 get_x86_family(unsigned long sig)\n{\n\tu8 x86;\n\tx86 = (sig >> 8) & 0xf;\n\tif (x86 == 0xf)\n\t\tx86 += (sig >> 20) & 0xff;\n\treturn x86;\n}\nstatic u8 get_x86_model(unsigned long sig)\n{\n\tu8 x86, x86_model;\n\tx86 = get_x86_family(sig);\n\tx86_model = (sig >> 4) & 0xf;\n\tif (x86 == 0x6 || x86 == 0xf)\n\t\tx86_model += ((sig >> 16) & 0xf) << 4;\n\treturn x86_model;\n}\nstatic enum ucode_state\nmatching_model_microcode(struct microcode_header_intel *mc_header,\n\t\t\tunsigned long sig)\n{\n\tu8 x86, x86_model;\n\tu8 x86_ucode, x86_model_ucode;\n\tstruct extended_sigtable *ext_header;\n\tunsigned long total_size = get_totalsize(mc_header);\n\tunsigned long data_size = get_datasize(mc_header);\n\tint ext_sigcount, i;\n\tstruct extended_signature *ext_sig;\n\tx86 = get_x86_family(sig);\n\tx86_model = get_x86_model(sig);\n\tx86_ucode = get_x86_family(mc_header->sig);\n\tx86_model_ucode = get_x86_model(mc_header->sig);\n\tif (x86 == x86_ucode && x86_model == x86_model_ucode)\n\t\treturn UCODE_OK;\n\tif (total_size <= data_size + MC_HEADER_SIZE)\n\t\treturn UCODE_NFOUND;\n\text_header = (struct extended_sigtable *)\n\t\t     mc_header + data_size + MC_HEADER_SIZE;\n\text_sigcount = ext_header->count;\n\text_sig = (void *)ext_header + EXT_HEADER_SIZE;\n\tfor (i = 0; i < ext_sigcount; i++) {\n\t\tx86_ucode = get_x86_family(ext_sig->sig);\n\t\tx86_model_ucode = get_x86_model(ext_sig->sig);\n\t\tif (x86 == x86_ucode && x86_model == x86_model_ucode)\n\t\t\treturn UCODE_OK;\n\t\text_sig++;\n\t}\n\treturn UCODE_NFOUND;\n}\nstatic int\nsave_microcode(struct mc_saved_data *mc_saved_data,\n\t       struct microcode_intel **mc_saved_src,\n\t       unsigned int mc_saved_count)\n{\n\tint i, j;\n\tstruct microcode_intel **mc_saved_p;\n\tint ret;\n\tif (!mc_saved_count)\n\t\treturn -EINVAL;\n\tmc_saved_p = kmalloc(mc_saved_count*sizeof(struct microcode_intel *),\n\t\t\t     GFP_KERNEL);\n\tif (!mc_saved_p)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < mc_saved_count; i++) {\n\t\tstruct microcode_intel *mc = mc_saved_src[i];\n\t\tstruct microcode_header_intel *mc_header = &mc->hdr;\n\t\tunsigned long mc_size = get_totalsize(mc_header);\n\t\tmc_saved_p[i] = kmalloc(mc_size, GFP_KERNEL);\n\t\tif (!mc_saved_p[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!mc_saved_src[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(mc_saved_p[i], mc, mc_size);\n\t}\n\tmc_saved_data->mc_saved = mc_saved_p;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\n\treturn 0;\nerr:\n\tfor (j = 0; j <= i; j++)\n\t\tkfree(mc_saved_p[j]);\n\tkfree(mc_saved_p);\n\treturn ret;\n}\nstatic void _save_mc(struct microcode_intel **mc_saved, u8 *ucode_ptr,\n\t\t     unsigned int *mc_saved_count_p)\n{\n\tint i;\n\tint found = 0;\n\tunsigned int mc_saved_count = *mc_saved_count_p;\n\tstruct microcode_header_intel *mc_header;\n\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\tfor (i = 0; i < mc_saved_count; i++) {\n\t\tunsigned int sig, pf;\n\t\tunsigned int new_rev;\n\t\tstruct microcode_header_intel *mc_saved_header =\n\t\t\t     (struct microcode_header_intel *)mc_saved[i];\n\t\tsig = mc_saved_header->sig;\n\t\tpf = mc_saved_header->pf;\n\t\tnew_rev = mc_header->rev;\n\t\tif (get_matching_sig(sig, pf, ucode_ptr, new_rev)) {\n\t\t\tfound = 1;\n\t\t\tif (update_match_revision(mc_header, new_rev)) {\n\t\t\t\tmc_saved[i] =\n\t\t\t\t\t(struct microcode_intel *)ucode_ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i >= mc_saved_count && !found)\n\t\tmc_saved[mc_saved_count++] =\n\t\t\t\t (struct microcode_intel *)ucode_ptr;\n\t*mc_saved_count_p = mc_saved_count;\n}\nstatic enum ucode_state __init\nget_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}\n#ifdef DEBUG\nstatic void __ref show_saved_mc(void)\n{\n\tint i, j;\n\tunsigned int sig, pf, rev, total_size, data_size, date;\n\tstruct ucode_cpu_info uci;\n\tif (mc_saved_data.mc_saved_count == 0) {\n\t\tpr_debug(\"no microcode data saved.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"Total microcode saved: %d\\n\", mc_saved_data.mc_saved_count);\n\tcollect_cpu_info_early(&uci);\n\tsig = uci.cpu_sig.sig;\n\tpf = uci.cpu_sig.pf;\n\trev = uci.cpu_sig.rev;\n\tpr_debug(\"CPU%d: sig=0x%x, pf=0x%x, rev=0x%x\\n\",\n\t\t smp_processor_id(), sig, pf, rev);\n\tfor (i = 0; i < mc_saved_data.mc_saved_count; i++) {\n\t\tstruct microcode_header_intel *mc_saved_header;\n\t\tstruct extended_sigtable *ext_header;\n\t\tint ext_sigcount;\n\t\tstruct extended_signature *ext_sig;\n\t\tmc_saved_header = (struct microcode_header_intel *)\n\t\t\t\t  mc_saved_data.mc_saved[i];\n\t\tsig = mc_saved_header->sig;\n\t\tpf = mc_saved_header->pf;\n\t\trev = mc_saved_header->rev;\n\t\ttotal_size = get_totalsize(mc_saved_header);\n\t\tdata_size = get_datasize(mc_saved_header);\n\t\tdate = mc_saved_header->date;\n\t\tpr_debug(\"mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\\n\",\n\t\t\t i, sig, pf, rev, total_size,\n\t\t\t date & 0xffff,\n\t\t\t date >> 24,\n\t\t\t (date >> 16) & 0xff);\n\t\tif (total_size <= data_size + MC_HEADER_SIZE)\n\t\t\tcontinue;\n\t\text_header = (struct extended_sigtable *)\n\t\t\t     mc_saved_header + data_size + MC_HEADER_SIZE;\n\t\text_sigcount = ext_header->count;\n\t\text_sig = (void *)ext_header + EXT_HEADER_SIZE;\n\t\tfor (j = 0; j < ext_sigcount; j++) {\n\t\t\tsig = ext_sig->sig;\n\t\t\tpf = ext_sig->pf;\n\t\t\tpr_debug(\"\\tExtended[%d]: sig=0x%x, pf=0x%x\\n\",\n\t\t\t\t j, sig, pf);\n\t\t\text_sig++;\n\t\t}\n\t}\n}\n#else\n#endif\n#if defined(CONFIG_MICROCODE_INTEL_EARLY) && defined(CONFIG_HOTPLUG_CPU)\nstatic DEFINE_MUTEX(x86_cpu_microcode_mutex);\nint save_mc_for_early(u8 *mc)\n{\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count_init;\n\tunsigned int mc_saved_count;\n\tstruct microcode_intel **mc_saved;\n\tint ret = 0;\n\tint i;\n\tmutex_lock(&x86_cpu_microcode_mutex);\n\tmc_saved_count_init = mc_saved_data.mc_saved_count;\n\tmc_saved_count = mc_saved_data.mc_saved_count;\n\tmc_saved = mc_saved_data.mc_saved;\n\tif (mc_saved && mc_saved_count)\n\t\tmemcpy(mc_saved_tmp, mc_saved,\n\t\t       mc_saved_count * sizeof(struct microcode_intel *));\n\t_save_mc(mc_saved_tmp, mc, &mc_saved_count);\n\tret = save_microcode(&mc_saved_data, mc_saved_tmp, mc_saved_count);\n\tif (ret) {\n\t\tpr_err(\"Cannot save microcode patch.\\n\");\n\t\tgoto out;\n\t}\n\tshow_saved_mc();\n\tif (mc_saved) {\n\t\tfor (i = 0; i < mc_saved_count_init; i++)\n\t\t\tkfree(mc_saved[i]);\n\t\tkfree(mc_saved);\n\t}\nout:\n\tmutex_unlock(&x86_cpu_microcode_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(save_mc_for_early);\n#endif\nstatic __initdata char ucode_name[] = \"kernel/x86/microcode/GenuineIntel.bin\";\nstatic __init enum ucode_state\nscan_microcode(unsigned long start, unsigned long end,\n\t\tstruct mc_saved_data *mc_saved_data,\n\t\tunsigned long *mc_saved_in_initrd,\n\t\tstruct ucode_cpu_info *uci)\n{\n\tunsigned int size = end - start + 1;\n\tstruct cpio_data cd;\n\tlong offset = 0;\n#ifdef CONFIG_X86_32\n\tchar *p = (char *)__pa_nodebug(ucode_name);\n#else\n\tchar *p = ucode_name;\n#endif\n\tcd.data = NULL;\n\tcd.size = 0;\n\tcd = find_cpio_data(p, (void *)start, size, &offset);\n\tif (!cd.data)\n\t\treturn UCODE_ERROR;\n\treturn get_matching_model_microcode(0, start, cd.data, cd.size,\n\t\t\t\t\t    mc_saved_data, mc_saved_in_initrd,\n\t\t\t\t\t    uci);\n}\n#ifdef CONFIG_X86_32\nstatic int delay_ucode_info;\nstatic int current_mc_date;\nvoid show_ucode_info_early(void)\n{\n\tstruct ucode_cpu_info uci;\n\tif (delay_ucode_info) {\n\t\tcollect_cpu_info_early(&uci);\n\t\tprint_ucode_info(&uci, current_mc_date);\n\t\tdelay_ucode_info = 0;\n\t}\n}\nstatic void print_ucode(struct ucode_cpu_info *uci)\n{\n\tstruct microcode_intel *mc_intel;\n\tint *delay_ucode_info_p;\n\tint *current_mc_date_p;\n\tmc_intel = uci->mc;\n\tif (mc_intel == NULL)\n\t\treturn;\n\tdelay_ucode_info_p = (int *)__pa_nodebug(&delay_ucode_info);\n\tcurrent_mc_date_p = (int *)__pa_nodebug(&current_mc_date);\n\t*delay_ucode_info_p = 1;\n\t*current_mc_date_p = mc_intel->hdr.date;\n}\n#else\n#endif\nint __init save_microcode_in_initrd_intel(void)\n{\n\tunsigned int count = mc_saved_data.mc_saved_count;\n\tstruct microcode_intel *mc_saved[MAX_UCODE_COUNT];\n\tint ret = 0;\n\tif (count == 0)\n\t\treturn ret;\n\tmicrocode_pointer(mc_saved, mc_saved_in_initrd, initrd_start, count);\n\tret = save_microcode(&mc_saved_data, mc_saved, count);\n\tif (ret)\n\t\tpr_err(\"Cannot save microcode patches from initrd.\\n\");\n\tshow_saved_mc();\n\treturn ret;\n}\nstatic void __init\nvoid __init\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_864.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/f84598bd7c851f8b0bf8cd0d7c3be0d73c432ff4",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int phar_wrapper_mkdir(php_stream_wrapper *wrapper, const char *url_from, int mode, int options, php_stream_context *context) \n\tphar_archive_data *phar = NULL;\n\tphp_url *resource = NULL;\n\tif (FAILURE == phar_split_fname(url_from, strlen(url_from), &arch, &arch_len, &entry2, &entry_len, 2, 2)) {\n\t}\n\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL)) {\n\t\tphar = NULL;\n\t}\n\tif (PHAR_G(readonly) && (!phar || !phar->is_data)) {\n\t}\n\tif ((resource = phar_parse_url(wrapper, url_from, \"w\", options)) == NULL) {\n\t}\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t}\n\tif (!zend_string_equals_literal_ci(resource->scheme, \"phar\")) {\n\t}\n\thost_len = ZSTR_LEN(resource->host);\n\tif (FAILURE == phar_get_archive(&phar, ZSTR_VAL(resource->host), host_len, NULL, 0, &error)) {\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define PHAR_DIRSTREAM 1\n#include \"phar_internal.h\"\n#include \"dirstream.h\"\nconst php_stream_ops phar_dir_ops = {\n\tphar_dir_write, \n\tphar_dir_read,  \n\tphar_dir_close, \n\tphar_dir_flush, \n\t\"phar dir\",\n\tphar_dir_seek,  \n\tNULL,           \n\tNULL,           \n\tNULL, \n};\nstatic int phar_dir_seek(php_stream *stream, zend_off_t offset, int whence, zend_off_t *newoffset) \n{\n\tHashTable *data = (HashTable *)stream->abstract;\n\tif (!data) {\n\t\treturn -1;\n\t}\n\tif (whence == SEEK_END) {\n\t\twhence = SEEK_SET;\n\t\toffset = zend_hash_num_elements(data) + offset;\n\t}\n\tif (whence == SEEK_SET) {\n\t\tzend_hash_internal_pointer_reset(data);\n\t}\n\tif (offset < 0) {\n\t\treturn -1;\n\t} else {\n\t\t*newoffset = 0;\n\t\twhile (*newoffset < offset && zend_hash_move_forward(data) == SUCCESS) {\n\t\t\t++(*newoffset);\n\t\t}\n\t\treturn 0;\n\t}\n}\nstatic php_stream *phar_make_dirstream(char *dir, HashTable *manifest) \n{\n\tHashTable *data;\n\tsize_t dirlen = strlen(dir);\n\tchar *entry, *found, *save;\n\tzend_string *str_key;\n\tsize_t keylen;\n\tzend_ulong unused;\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, NULL, NULL, 0);\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\tzend_hash_internal_pointer_reset(manifest);\n\twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key(manifest, &str_key, &unused)) {\n\t\t\tbreak;\n\t\t}\n\t\tkeylen = ZSTR_LEN(str_key);\n\t\tif (keylen <= dirlen) {\n\t\t\tif (keylen == 0 || keylen < dirlen || !strncmp(ZSTR_VAL(str_key), dir, dirlen)) {\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*dir == '/') {\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(ZSTR_VAL(str_key), \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (NULL != (found = (char *) memchr(ZSTR_VAL(str_key), '/', keylen))) {\n\t\t\t\tentry = (char *) safe_emalloc(found - ZSTR_VAL(str_key), 1, 1);\n\t\t\t\tmemcpy(entry, ZSTR_VAL(str_key), found - ZSTR_VAL(str_key));\n\t\t\t\tkeylen = found - ZSTR_VAL(str_key);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, ZSTR_VAL(str_key), keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(ZSTR_VAL(str_key), dir, dirlen)) {\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (ZSTR_VAL(str_key)[dirlen] != '/') {\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsave = ZSTR_VAL(str_key);\n\t\tsave += dirlen + 1; \n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\t\tefree(entry);\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tzend_hash_sort(data, phar_compare_dir_name, 0);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}\nphp_stream *phar_wrapper_open_dir(php_stream_wrapper *wrapper, const char *path, const char *mode, int options, zend_string **opened_path, php_stream_context *context STREAMS_DC) \n{\n\tphp_url *resource = NULL;\n\tphp_stream *ret;\n\tchar *internal_file, *error;\n\tzend_string *str_key;\n\tzend_ulong unused;\n\tphar_archive_data *phar;\n\tphar_entry_info *entry = NULL;\n\tuint32_t host_len;\n\tif ((resource = phar_parse_url(wrapper, path, mode, options)) == NULL) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar url \\\"%s\\\" is unknown\", path);\n\t\treturn NULL;\n\t}\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tif (resource->host && !resource->path) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: no directory in \\\"%s\\\", must have at least phar://%s/ for root directory (always use full path to a new phar)\", path, ZSTR_VAL(resource->host));\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: invalid url \\\"%s\\\", must have at least phar://%s/\", path, path);\n\t\treturn NULL;\n\t}\n\tif (!zend_string_equals_literal_ci(resource->scheme, \"phar\")) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: not a phar url \\\"%s\\\"\", path);\n\t\treturn NULL;\n\t}\n\thost_len = ZSTR_LEN(resource->host);\n\tphar_request_initialize();\n\tinternal_file = ZSTR_VAL(resource->path) + 1; \n\tif (FAILURE == phar_get_archive(&phar, ZSTR_VAL(resource->host), host_len, NULL, 0, &error)) {\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"%s\", error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar file \\\"%s\\\" is unknown\", ZSTR_VAL(resource->host));\n\t\t}\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\tefree(error);\n\t}\n\tif (*internal_file == '\\0') {\n\t\tinternal_file = estrndup(internal_file - 1, 1);\n\t\tret = phar_make_dirstream(internal_file, &phar->manifest);\n\t\tphp_url_free(resource);\n\t\treturn ret;\n\t}\n\tif (!HT_IS_INITIALIZED(&phar->manifest)) {\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t}\n\tif (NULL != (entry = zend_hash_str_find_ptr(&phar->manifest, internal_file, strlen(internal_file))) && !entry->is_dir) {\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t} else if (entry && entry->is_dir) {\n\t\tif (entry->is_mounted) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_opendir(entry->tmp, options, context);\n\t\t}\n\t\tinternal_file = estrdup(internal_file);\n\t\tphp_url_free(resource);\n\t\treturn phar_make_dirstream(internal_file, &phar->manifest);\n\t} else {\n\t\tsize_t i_len = strlen(internal_file);\n\t\tzend_hash_internal_pointer_reset(&phar->manifest);\n\t\twhile (FAILURE != zend_hash_has_more_elements(&phar->manifest)) {\n\t\t\tif (HASH_KEY_NON_EXISTENT !=\n\t\t\t\t\tzend_hash_get_current_key(&phar->manifest, &str_key, &unused)) {\n\t\t\t\tif (ZSTR_LEN(str_key) > i_len && 0 == memcmp(ZSTR_VAL(str_key), internal_file, i_len)) {\n\t\t\t\t\tinternal_file = estrndup(internal_file,\n\t\t\t\t\t\t\ti_len);\n\t\t\t\t\tphp_url_free(resource);\n\t\t\t\t\treturn phar_make_dirstream(internal_file, &phar->manifest);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (SUCCESS != zend_hash_move_forward(&phar->manifest)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tphp_url_free(resource);\n\treturn NULL;\n}\nint phar_wrapper_mkdir(php_stream_wrapper *wrapper, const char *url_from, int mode, int options, php_stream_context *context) \n{\n\tphar_entry_info entry, *e;\n\tphar_archive_data *phar = NULL;\n\tchar *error, *arch, *entry2;\n\tsize_t arch_len, entry_len;\n\tphp_url *resource = NULL;\n\tuint32_t host_len;\n\tif (FAILURE == phar_split_fname(url_from, strlen(url_from), &arch, &arch_len, &entry2, &entry_len, 2, 2)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\", no phar archive specified\", url_from);\n\t\treturn 0;\n\t}\n\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL)) {\n\t\tphar = NULL;\n\t}\n\tefree(arch);\n\tefree(entry2);\n\tif (PHAR_G(readonly) && (!phar || !phar->is_data)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\", write operations disabled\", url_from);\n\t\treturn 0;\n\t}\n\tif ((resource = phar_parse_url(wrapper, url_from, \"w\", options)) == NULL) {\n\t\treturn 0;\n\t}\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: invalid url \\\"%s\\\"\", url_from);\n\t\treturn 0;\n\t}\n\tif (!zend_string_equals_literal_ci(resource->scheme, \"phar\")) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: not a phar stream url \\\"%s\\\"\", url_from);\n\t\treturn 0;\n\t}\n\thost_len = ZSTR_LEN(resource->host);\n\tif (FAILURE == phar_get_archive(&phar, ZSTR_VAL(resource->host), host_len, NULL, 0, &error)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", error retrieving phar information: %s\", ZSTR_VAL(resource->path) + 1, ZSTR_VAL(resource->host), error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tif ((e = phar_get_entry_info_dir(phar, ZSTR_VAL(resource->path) + 1, ZSTR_LEN(resource->path) - 1, 2, &error, 1))) {\n\t\tif (e->is_temp_dir) {\n\t\t\tefree(e->filename);\n\t\t\tefree(e);\n\t\t}\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", directory already exists\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host));\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host), error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tif (phar_get_entry_info_dir(phar, ZSTR_VAL(resource->path) + 1, ZSTR_LEN(resource->path) - 1, 0, &error, 1)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", file already exists\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host));\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host), error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tmemset((void *) &entry, 0, sizeof(phar_entry_info));\n\tif (phar->is_zip) {\n\t\tentry.is_zip = 1;\n\t}\n\tentry.filename = estrdup(ZSTR_VAL(resource->path) + 1);\n\tif (phar->is_tar) {\n\t\tentry.is_tar = 1;\n\t\tentry.tar_type = TAR_DIR;\n\t}\n\tentry.filename_len = ZSTR_LEN(resource->path) - 1;\n\tphp_url_free(resource);\n\tentry.is_dir = 1;\n\tentry.phar = phar;\n\tentry.is_modified = 1;\n\tentry.is_crc_checked = 1;\n\tentry.flags = PHAR_ENT_PERM_DEF_DIR;\n\tentry.old_flags = PHAR_ENT_PERM_DEF_DIR;\n\tif (NULL == zend_hash_str_add_mem(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info))) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", adding to manifest failed\", entry.filename, phar->fname);\n\t\tefree(error);\n\t\tefree(entry.filename);\n\t\treturn 0;\n\t}\n\tphar_flush(phar, 0, 0, 0, &error);\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", entry.filename, phar->fname, error);\n\t\tzend_hash_str_del(&phar->manifest, entry.filename, entry.filename_len);\n\t\tefree(error);\n\t\treturn 0;\n\t}\n\tphar_add_virtual_dirs(phar, entry.filename, entry.filename_len);\n\treturn 1;\n}\nint phar_wrapper_rmdir(php_stream_wrapper *wrapper, const char *url, int options, php_stream_context *context) \n{\n\tphar_entry_info *entry;\n\tphar_archive_data *phar = NULL;\n\tchar *error, *arch, *entry2;\n\tsize_t arch_len, entry_len;\n\tphp_url *resource = NULL;\n\tuint32_t host_len;\n\tzend_string *str_key;\n\tzend_ulong unused;\n\tuint32_t path_len;\n\tif (FAILURE == phar_split_fname(url, strlen(url), &arch, &arch_len, &entry2, &entry_len, 2, 2)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot remove directory \\\"%s\\\", no phar archive specified, or phar archive does not exist\", url);\n\t\treturn 0;\n\t}\n\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL)) {\n\t\tphar = NULL;\n\t}\n\tefree(arch);\n\tefree(entry2);\n\tif (PHAR_G(readonly) && (!phar || !phar->is_data)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot rmdir directory \\\"%s\\\", write operations disabled\", url);\n\t\treturn 0;\n\t}\n\tif ((resource = phar_parse_url(wrapper, url, \"w\", options)) == NULL) {\n\t\treturn 0;\n\t}\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: invalid url \\\"%s\\\"\", url);\n\t\treturn 0;\n\t}\n\tif (!zend_string_equals_literal_ci(resource->scheme, \"phar\")) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: not a phar stream url \\\"%s\\\"\", url);\n\t\treturn 0;\n\t}\n\thost_len = ZSTR_LEN(resource->host);\n\tif (FAILURE == phar_get_archive(&phar, ZSTR_VAL(resource->host), host_len, NULL, 0, &error)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", error retrieving phar information: %s\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host), error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tpath_len = ZSTR_LEN(resource->path) - 1;\n\tif (!(entry = phar_get_entry_info_dir(phar, ZSTR_VAL(resource->path) + 1, path_len, 2, &error, 1))) {\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", %s\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host), error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", directory does not exist\", ZSTR_VAL(resource->path)+1, ZSTR_VAL(resource->host));\n\t\t}\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\tif (!entry->is_deleted) {\n\t\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key(&phar->manifest, &str_key, &unused);\n\t\t\tzend_hash_move_forward(&phar->manifest)\n\t\t) {\n\t\t\tif (ZSTR_LEN(str_key) > path_len &&\n\t\t\t\tmemcmp(ZSTR_VAL(str_key), ZSTR_VAL(resource->path)+1, path_len) == 0 &&\n\t\t\t\tIS_SLASH(ZSTR_VAL(str_key)[path_len])) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: Directory not empty\");\n\t\t\t\tif (entry->is_temp_dir) {\n\t\t\t\t\tefree(entry->filename);\n\t\t\t\t\tefree(entry);\n\t\t\t\t}\n\t\t\t\tphp_url_free(resource);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor (zend_hash_internal_pointer_reset(&phar->virtual_dirs);\n\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key(&phar->virtual_dirs, &str_key, &unused);\n\t\t\tzend_hash_move_forward(&phar->virtual_dirs)) {\n\t\t\tif (ZSTR_LEN(str_key) > path_len &&\n\t\t\t\tmemcmp(ZSTR_VAL(str_key), ZSTR_VAL(resource->path)+1, path_len) == 0 &&\n\t\t\t\tIS_SLASH(ZSTR_VAL(str_key)[path_len])) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: Directory not empty\");\n\t\t\t\tif (entry->is_temp_dir) {\n\t\t\t\t\tefree(entry->filename);\n\t\t\t\t\tefree(entry);\n\t\t\t\t}\n\t\t\t\tphp_url_free(resource);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (entry->is_temp_dir) {\n\t\tzend_hash_str_del(&phar->virtual_dirs, ZSTR_VAL(resource->path)+1, path_len);\n\t\tefree(entry->filename);\n\t\tefree(entry);\n\t} else {\n\t\tentry->is_deleted = 1;\n\t\tentry->is_modified = 1;\n\t\tphar_flush(phar, 0, 0, 0, &error);\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", %s\", entry->filename, phar->fname, error);\n\t\t\tphp_url_free(resource);\n\t\t\tefree(error);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tphp_url_free(resource);\n\treturn 1;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_12157.c",
        "project": "php/php-src",
        "url": "https://github.com/php/php-src/commit/80316123f3e9dcce8ac419bd9dd43546e2ccb5ef",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int usb_set_configuration(struct usb_device *dev, int configuration)\n\tstruct usb_host_config *cp = NULL;\n\tstruct usb_interface **new_interfaces = NULL;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tif (dev->authorized == 0 || configuration == -1)\n\t\tconfiguration = 0;\n\telse {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\t\tif (dev->config[i].desc.bConfigurationValue ==\n\t\t\t\t\tconfiguration) {\n\t\t\t\tcp = &dev->config[i];\n\t\t}\n\t}\n\tif ((!cp && configuration != 0))\n\t\treturn -EINVAL;\n\tif (cp && configuration == 0)\n\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");\n\tif (cp) {\n\t\tnintf = cp->desc.bNumInterfaces;\n\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (!new_interfaces)\n\t\t\treturn -ENOMEM;\n\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);\n\t\tif (i < 0)\n\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"\n\t\t\t\t\tconfiguration, -i);\n\t}\n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto free_interfaces;\n\tif (dev->state != USB_STATE_ADDRESS)\n\t\tusb_disable_device(dev, 1);\t\n\tcancel_async_set_config(dev);\n\tmutex_lock(hcd->bandwidth_mutex);\n\tif (dev->actconfig && usb_disable_lpm(dev)) {\n\t}\n\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\n\tif (ret < 0) {\n\t}\n\tfor (i = 0; i < nintf; ++i) {\n\t\tcp->interface[i] = intf = new_interfaces[i];\n\t\tintfc = cp->intf_cache[i];\n\t\tintf->altsetting = intfc->altsetting;\n\t\tintf->num_altsetting = intfc->num_altsetting;\n\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tifnum = alt->desc.bInterfaceNumber;\n\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tintf->dev.parent = &dev->dev;\n\t\tif (usb_of_has_combined_node(dev)) {\n\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);\n\t\t} else {\n\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,\n\t\t\t\t\tconfiguration, ifnum);\n\t\t}\n\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));\n\t\tintf->dev.driver = NULL;\n\t\tintf->dev.bus = &usb_bus_type;\n\t\tintf->dev.type = &usb_if_device_type;\n\t\tintf->dev.groups = usb_interface_groups;\n\t\tintf->dev.dma_mask = dev->dev.dma_mask;\n\t\tintf->dev.dma_pfn_offset = dev->dev.dma_pfn_offset;\n\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\n\t\tintf->minor = -1;\n\t\tdevice_initialize(&intf->dev);\n\t\tpm_runtime_no_callbacks(&intf->dev);\n\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,\n\t\t\t\tdev->devpath, configuration, ifnum);\n\t\tusb_get_dev(dev);\n\t}\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/acpi.h>\n#include <linux/pci.h>\t\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/quirks.h>\n#include <linux/usb/hcd.h>\t\n#include <linux/usb/of.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\nstatic void cancel_async_set_config(struct usb_device *udev);\nstruct api_context {\n\tstruct completion\tdone;\n\tint\t\t\tstatus;\n};\nEXPORT_SYMBOL_GPL(usb_interrupt_msg);\nEXPORT_SYMBOL_GPL(usb_bulk_msg);\nstatic void sg_complete(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_sg_request *io = urb->context;\n\tint status = urb->status;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status\n\t\t\t&& (io->status != -ECONNRESET\n\t\t\t\t|| status != -ECONNRESET)\n\t\t\t&& urb->actual_length) {\n\t\tdev_err(io->dev->bus->controller,\n\t\t\t\"dev %s ep%d%s scatterlist error %d/%d\\n\",\n\t\t\tio->dev->devpath,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\tstatus, io->status);\n\t}\n\tif (io->status == 0 && status && status != -ECONNRESET) {\n\t\tint i, found, retval;\n\t\tio->status = status;\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\tfor (i = 0, found = 0; i < io->entries; i++) {\n\t\t\tif (!io->urbs[i])\n\t\t\t\tcontinue;\n\t\t\tif (found) {\n\t\t\t\tusb_block_urb(io->urbs[i]);\n\t\t\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\t\t\tif (retval != -EINPROGRESS &&\n\t\t\t\t    retval != -ENODEV &&\n\t\t\t\t    retval != -EBUSY &&\n\t\t\t\t    retval != -EIDRM)\n\t\t\t\t\tdev_err(&io->dev->dev,\n\t\t\t\t\t\t\"%s, unlink --> %d\\n\",\n\t\t\t\t\t\t__func__, retval);\n\t\t\t} else if (urb == io->urbs[i])\n\t\t\t\tfound = 1;\n\t\t}\n\t\tspin_lock_irqsave(&io->lock, flags);\n\t}\n\tio->bytes += urb->actual_length;\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\nint usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,\n\t\tunsigned pipe, unsigned\tperiod, struct scatterlist *sg,\n\t\tint nents, size_t length, gfp_t mem_flags)\n{\n\tint i;\n\tint urb_flags;\n\tint use_sg;\n\tif (!io || !dev || !sg\n\t\t\t|| usb_pipecontrol(pipe)\n\t\t\t|| usb_pipeisoc(pipe)\n\t\t\t|| nents <= 0)\n\t\treturn -EINVAL;\n\tspin_lock_init(&io->lock);\n\tio->dev = dev;\n\tio->pipe = pipe;\n\tif (dev->bus->sg_tablesize > 0) {\n\t\tuse_sg = true;\n\t\tio->entries = 1;\n\t} else {\n\t\tuse_sg = false;\n\t\tio->entries = nents;\n\t}\n\tio->urbs = kmalloc_array(io->entries, sizeof(*io->urbs), mem_flags);\n\tif (!io->urbs)\n\t\tgoto nomem;\n\turb_flags = URB_NO_INTERRUPT;\n\tif (usb_pipein(pipe))\n\t\turb_flags |= URB_SHORT_NOT_OK;\n\tfor_each_sg(sg, sg, io->entries, i) {\n\t\tstruct urb *urb;\n\t\tunsigned len;\n\t\turb = usb_alloc_urb(0, mem_flags);\n\t\tif (!urb) {\n\t\t\tio->entries = i;\n\t\t\tgoto nomem;\n\t\t}\n\t\tio->urbs[i] = urb;\n\t\turb->dev = NULL;\n\t\turb->pipe = pipe;\n\t\turb->interval = period;\n\t\turb->transfer_flags = urb_flags;\n\t\turb->complete = sg_complete;\n\t\turb->context = io;\n\t\turb->sg = sg;\n\t\tif (use_sg) {\n\t\t\turb->transfer_buffer = NULL;\n\t\t\turb->num_sgs = nents;\n\t\t\tlen = length;\n\t\t\tif (len == 0) {\n\t\t\t\tstruct scatterlist\t*sg2;\n\t\t\t\tint\t\t\tj;\n\t\t\t\tfor_each_sg(sg, sg2, nents, j)\n\t\t\t\t\tlen += sg2->length;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!PageHighMem(sg_page(sg)))\n\t\t\t\turb->transfer_buffer = sg_virt(sg);\n\t\t\telse\n\t\t\t\turb->transfer_buffer = NULL;\n\t\t\tlen = sg->length;\n\t\t\tif (length) {\n\t\t\t\tlen = min_t(size_t, len, length);\n\t\t\t\tlength -= len;\n\t\t\t\tif (length == 0)\n\t\t\t\t\tio->entries = i + 1;\n\t\t\t}\n\t\t}\n\t\turb->transfer_buffer_length = len;\n\t}\n\tio->urbs[--i]->transfer_flags &= ~URB_NO_INTERRUPT;\n\tio->count = io->entries;\n\tio->status = 0;\n\tio->bytes = 0;\n\tinit_completion(&io->complete);\n\treturn 0;\nnomem:\n\tsg_clean(io);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_sg_init);\nvoid usb_sg_wait(struct usb_sg_request *io)\n{\n\tint i;\n\tint entries = io->entries;\n\tspin_lock_irq(&io->lock);\n\ti = 0;\n\twhile (i < entries && !io->status) {\n\t\tint retval;\n\t\tio->urbs[i]->dev = io->dev;\n\t\tspin_unlock_irq(&io->lock);\n\t\tretval = usb_submit_urb(io->urbs[i], GFP_NOIO);\n\t\tswitch (retval) {\n\t\tcase -ENXIO:\t\n\t\tcase -EAGAIN:\n\t\tcase -ENOMEM:\n\t\t\tretval = 0;\n\t\t\tyield();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t++i;\n\t\t\tcpu_relax();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tio->urbs[i]->status = retval;\n\t\t\tdev_dbg(&io->dev->dev, \"%s, submit --> %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tusb_sg_cancel(io);\n\t\t}\n\t\tspin_lock_irq(&io->lock);\n\t\tif (retval && (io->status == 0 || io->status == -ECONNRESET))\n\t\t\tio->status = retval;\n\t}\n\tio->count -= entries - i;\n\tif (io->count == 0)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irq(&io->lock);\n\twait_for_completion(&io->complete);\n\tsg_clean(io);\n}\nEXPORT_SYMBOL_GPL(usb_sg_wait);\nvoid usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_sg_cancel);\nEXPORT_SYMBOL_GPL(usb_get_descriptor);\nstatic int usb_get_langid(struct usb_device *dev, unsigned char *tbuf)\n{\n\tint err;\n\tif (dev->have_langid)\n\t\treturn 0;\n\tif (dev->string_langid < 0)\n\t\treturn -EPIPE;\n\terr = usb_string_sub(dev, 0, 0, tbuf);\n\tif (err == -ENODATA || (err > 0 && err < 4)) {\n\t\tdev->string_langid = 0x0409;\n\t\tdev->have_langid = 1;\n\t\tdev_err(&dev->dev,\n\t\t\t\"language id specifier not provided by device, defaulting to English\\n\");\n\t\treturn 0;\n\t}\n\tif (err < 0) {\n\t\tdev_info(&dev->dev, \"string descriptor 0 read error: %d\\n\",\n\t\t\t\t\terr);\n\t\tdev->string_langid = -1;\n\t\treturn -EPIPE;\n\t}\n\tdev->string_langid = tbuf[2] | (tbuf[3] << 8);\n\tdev->have_langid = 1;\n\tdev_dbg(&dev->dev, \"default language 0x%04x\\n\",\n\t\t\t\tdev->string_langid);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_string);\n#define MAX_USB_STRING_SIZE (127 * 3 + 1)\nEXPORT_SYMBOL_GPL(usb_get_status);\nEXPORT_SYMBOL_GPL(usb_clear_halt);\nEXPORT_SYMBOL_GPL(usb_reset_endpoint);\nvoid usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tif (dev->actconfig) {\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\t\tusb_disable_usb2_hardware_lpm(dev);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\tif (hcd->driver->check_bandwidth) {\n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t}\n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}\nint usb_set_interface(struct usb_device *dev, int interface, int alternate)\n{\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alt;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint i, ret, manual = 0;\n\tunsigned int epaddr;\n\tunsigned int pipe;\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tiface = usb_ifnum_to_if(dev, interface);\n\tif (!iface) {\n\t\tdev_dbg(&dev->dev, \"selecting invalid interface %d\\n\",\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\tif (iface->unregistering)\n\t\treturn -ENODEV;\n\talt = usb_altnum_to_altsetting(iface, alternate);\n\tif (!alt) {\n\t\tdev_warn(&dev->dev, \"selecting invalid altsetting %d\\n\",\n\t\t\t alternate);\n\t\treturn -EINVAL;\n\t}\n\tusb_disable_interface(dev, iface, false);\n\tmutex_lock(hcd->bandwidth_mutex);\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&iface->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < iface->cur_altsetting->desc.bNumEndpoints; i++)\n\t\tiface->cur_altsetting->endpoint[i].streams = 0;\n\tret = usb_hcd_alloc_bandwidth(dev, NULL, iface->cur_altsetting, alt);\n\tif (ret < 0) {\n\t\tdev_info(&dev->dev, \"Not enough bandwidth for altsetting %d\\n\",\n\t\t\t\talternate);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\tif (dev->quirks & USB_QUIRK_NO_SET_INTF)\n\t\tret = -EPIPE;\n\telse\n\t\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t   USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,\n\t\t\t\t   alternate, interface, NULL, 0, 5000);\n\tif (ret == -EPIPE && iface->num_altsetting == 1) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"manual set_interface for iface %d, alt %d\\n\",\n\t\t\tinterface, alternate);\n\t\tmanual = 1;\n\t} else if (ret < 0) {\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, alt, iface->cur_altsetting);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tif (iface->cur_altsetting != alt) {\n\t\tremove_intf_ep_devs(iface);\n\t\tusb_remove_sysfs_intf_files(iface);\n\t}\n\tusb_disable_interface(dev, iface, true);\n\tiface->cur_altsetting = alt;\n\tusb_unlocked_enable_lpm(dev);\n\tif (manual) {\n\t\tfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\n\t\t\tepaddr = alt->endpoint[i].desc.bEndpointAddress;\n\t\t\tpipe = __create_pipe(dev,\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK & epaddr) |\n\t\t\t\t\t(usb_endpoint_out(epaddr) ?\n\t\t\t\t\tUSB_DIR_OUT : USB_DIR_IN);\n\t\t\tusb_clear_halt(dev, pipe);\n\t\t}\n\t}\n\tusb_enable_interface(dev, iface, true);\n\tif (device_is_registered(&iface->dev)) {\n\t\tusb_create_sysfs_intf_files(iface);\n\t\tcreate_intf_ep_devs(iface);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_interface);\nint usb_reset_configuration(struct usb_device *dev)\n{\n\tint\t\t\ti, retval;\n\tstruct usb_host_config\t*config;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tfor (i = 1; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n\tconfig = dev->actconfig;\n\tretval = 0;\n\tmutex_lock(hcd->bandwidth_mutex);\n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tif (alt != intf->cur_altsetting)\n\t\t\tretval = usb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\tintf->cur_altsetting, alt);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\tif (retval < 0) {\nreset_old_alts:\n\t\tfor (i--; i >= 0; i--) {\n\t\t\tstruct usb_interface *intf = config->interface[i];\n\t\t\tstruct usb_host_interface *alt;\n\t\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\t\tif (!alt)\n\t\t\t\talt = &intf->altsetting[0];\n\t\t\tif (alt != intf->cur_altsetting)\n\t\t\t\tusb_hcd_alloc_bandwidth(dev, NULL,\n\t\t\t\t\t\talt, intf->cur_altsetting);\n\t\t}\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0)\n\t\tgoto reset_old_alts;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tif (alt != intf->cur_altsetting) {\n\t\t\tremove_intf_ep_devs(intf);\n\t\t\tusb_remove_sysfs_intf_files(intf);\n\t\t}\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tif (device_is_registered(&intf->dev)) {\n\t\t\tusb_create_sysfs_intf_files(intf);\n\t\t\tcreate_intf_ep_devs(intf);\n\t\t}\n\t}\n\tusb_unlocked_enable_lpm(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_reset_configuration);\nstruct device_type usb_if_device_type = {\n\t.name =\t\t\"usb_interface\",\n\t.release =\tusb_release_interface,\n\t.uevent =\tusb_if_uevent,\n};\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\tint i, ret;\n\tstruct usb_host_config *cp = NULL;\n\tstruct usb_interface **new_interfaces = NULL;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint n, nintf;\n\tif (dev->authorized == 0 || configuration == -1)\n\t\tconfiguration = 0;\n\telse {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\t\tif (dev->config[i].desc.bConfigurationValue ==\n\t\t\t\t\tconfiguration) {\n\t\t\t\tcp = &dev->config[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!cp && configuration != 0))\n\t\treturn -EINVAL;\n\tif (cp && configuration == 0)\n\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");\n\tn = nintf = 0;\n\tif (cp) {\n\t\tnintf = cp->desc.bNumInterfaces;\n\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (!new_interfaces)\n\t\t\treturn -ENOMEM;\n\t\tfor (; n < nintf; ++n) {\n\t\t\tnew_interfaces[n] = kzalloc(\n\t\t\t\t\tsizeof(struct usb_interface),\n\t\t\t\t\tGFP_NOIO);\n\t\t\tif (!new_interfaces[n]) {\n\t\t\t\tret = -ENOMEM;\nfree_interfaces:\n\t\t\t\twhile (--n >= 0)\n\t\t\t\t\tkfree(new_interfaces[n]);\n\t\t\t\tkfree(new_interfaces);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);\n\t\tif (i < 0)\n\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"\n\t\t\t\t\t\"limit by %dmA\\n\",\n\t\t\t\t\tconfiguration, -i);\n\t}\n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto free_interfaces;\n\tif (dev->state != USB_STATE_ADDRESS)\n\t\tusb_disable_device(dev, 1);\t\n\tcancel_async_set_config(dev);\n\tmutex_lock(hcd->bandwidth_mutex);\n\tif (dev->actconfig && usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto free_interfaces;\n\t}\n\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (dev->actconfig)\n\t\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tusb_autosuspend_device(dev);\n\t\tgoto free_interfaces;\n\t}\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface_cache *intfc;\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_host_interface *alt;\n\t\tu8 ifnum;\n\t\tcp->interface[i] = intf = new_interfaces[i];\n\t\tintfc = cp->intf_cache[i];\n\t\tintf->altsetting = intfc->altsetting;\n\t\tintf->num_altsetting = intfc->num_altsetting;\n\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);\n\t\tkref_get(&intfc->ref);\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\t\tifnum = alt->desc.bInterfaceNumber;\n\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tintf->dev.parent = &dev->dev;\n\t\tif (usb_of_has_combined_node(dev)) {\n\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);\n\t\t} else {\n\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,\n\t\t\t\t\tconfiguration, ifnum);\n\t\t}\n\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));\n\t\tintf->dev.driver = NULL;\n\t\tintf->dev.bus = &usb_bus_type;\n\t\tintf->dev.type = &usb_if_device_type;\n\t\tintf->dev.groups = usb_interface_groups;\n\t\tintf->dev.dma_mask = dev->dev.dma_mask;\n\t\tintf->dev.dma_pfn_offset = dev->dev.dma_pfn_offset;\n\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\n\t\tintf->minor = -1;\n\t\tdevice_initialize(&intf->dev);\n\t\tpm_runtime_no_callbacks(&intf->dev);\n\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,\n\t\t\t\tdev->devpath, configuration, ifnum);\n\t\tusb_get_dev(dev);\n\t}\n\tkfree(new_interfaces);\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0 && cp) {\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tfor (i = 0; i < nintf; ++i) {\n\t\t\tusb_disable_interface(dev, cp->interface[i], true);\n\t\t\tput_device(&cp->interface[i]->dev);\n\t\t\tcp->interface[i] = NULL;\n\t\t}\n\t\tcp = NULL;\n\t}\n\tdev->actconfig = cp;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tif (!cp) {\n\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t\tusb_autosuspend_device(dev);\n\t\treturn ret;\n\t}\n\tusb_set_device_state(dev, USB_STATE_CONFIGURED);\n\tif (cp->string == NULL &&\n\t\t\t!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\n\t\tcp->string = usb_cache_string(dev, cp->desc.iConfiguration);\n\tusb_unlocked_enable_lpm(dev);\n\tusb_enable_ltm(dev);\n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface *intf = cp->interface[i];\n\t\tif (intf->dev.of_node &&\n\t\t    !of_device_is_available(intf->dev.of_node)) {\n\t\t\tdev_info(&dev->dev, \"skipping disabled interface %d\\n\",\n\t\t\t\t intf->cur_altsetting->desc.bInterfaceNumber);\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"adding %s (config #%d, interface %d)\\n\",\n\t\t\tdev_name(&intf->dev), configuration,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\tdevice_enable_async_suspend(&intf->dev);\n\t\tret = device_add(&intf->dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->dev, \"device_add(%s) --> %d\\n\",\n\t\t\t\tdev_name(&intf->dev), ret);\n\t\t\tcontinue;\n\t\t}\n\t\tcreate_intf_ep_devs(intf);\n\t}\n\tusb_autosuspend_device(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_configuration);\nstruct set_config_request {\n\tstruct usb_device\t*udev;\n\tint\t\t\tconfig;\n\tstruct work_struct\twork;\n\tstruct list_head\tnode;\n};\nEXPORT_SYMBOL_GPL(usb_driver_set_configuration);\nint cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\tunsigned int elength;\n\tint cnt = 0;\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: \n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_4498.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```IncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    while (tmp && *tmp)\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n        }\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n            merge = MERGE_OVERRIDE;\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) append);\n    return expr;\n}\nstatic void\nFreeInclude(IncludeStmt *incl);\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n        if (!incl)\n            break;\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n    return first;\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n    default:\n        break;\n    }\n}\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n    while (incl)\n    {\n        next = incl->next_incl;\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n        free(incl);\n        incl = next;\n    }\n}\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n    while (stmt)\n    {\n        next = stmt->next;\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n        free(stmt);\n        stmt = next;\n    }\n}\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_FLOAT] = \"float\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_3037.c",
        "project": "xkbcommon/libxkbcommon",
        "url": "https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static bool ldb_dn_explode(struct ldb_dn *dn)\n\tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;\n\tbool trim = true;\n\tbool in_extended = true;\n\tsize_t l = 0;\n\tif (dn == NULL || dn->invalid == true) {\n\t}\n\tif (dn->components != NULL) {\n\t}\n\tif (dn->ext_linearized != NULL) {\n\t\tparse_dn = dn->ext_linearized;\n\t} else {\n\t\tparse_dn = dn->linearized;\n\t}\n\tif (parse_dn == NULL) {\n\t}\n\tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);\n\tif (parse_dn[0] == '\\0') {\n\t}\n\tif (dn->special == true) {\n\t}\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\tdn->comp_num = 0;\n\tif (dn->components == NULL) {\n\t}\n\tif (data == NULL) {\n\t}\n\tp = parse_dn;\n\tt = NULL;\n\td = dt = data;\n\twhile (*p) {\n\t\tif (in_extended == true) {\n\t\t\tif (!in_ex_name && !in_ex_value) {\n\t\t\t\tif (p[0] == '<') {\n\t\t\t\t\tp++;\n\t\t\t\t\tex_name = d;\n\t\t\t\t} else {\n\t\t\t\t\tdt = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_ex_name && *p == '=') {\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tex_value = d;\n\t\t\t}\n\t\t\tif (in_ex_value && *p == '>') {\n\t\t\t\tstruct ldb_dn_ext_component *ext_comp = NULL;\n\t\t\t\tstruct ldb_val ex_val = {\n\t\t\t\t\t.data = (uint8_t *)ex_value,\n\t\t\t\t\t.length = d - ex_value\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tif (ext_comp == NULL) {\n\t\t\t\t}\n\t\t\t\tdn->ext_components = ext_comp;\n\t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);\n\t\t\t\tif (ext_syntax == NULL) {\n\t\t\t\t}\n\t\t\t\tdn->ext_components[dn->ext_comp_num].name = ext_syntax->name;\n\t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,\n\t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);\n\t\t\t\tdn->ext_comp_num++;\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t} else if (*p == ';') {\n\t\t\t\t\tp++;\n\t\t\t\t} else {\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t}\n\t\tif (in_attr == true) {\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (!isascii(*p)) {\n\t\t\t\t}\n\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t} else\n\t\t\t\tif ( ! isalpha(*p)) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tif (*p == ' ') {\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (*p == '=') {\n\t\t\t\tl = 0;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);\n\t\t\t\tif (dn->components[dn->comp_num].name == NULL) {\n\t\t\t\t}\n\t\t\t\tdt = d;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (!isascii(*p)) {\n\t\t\t}\n\t\t\tif (is_oid == true && ( ! (isdigit(*p) || (*p == '.')))) {\n\t\t\t} else\n\t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t}\n\t\tif (in_value == true) {\n\t\t\tif (in_quote == true) {\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tif (p[-1] != '\\\\') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tif (escape == true) {\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\td -= (p - t);\n\t\t\t\t\tl -= (p - t);\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].value.data = \\\n\t\t\t\t\t(uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n\t\t\t\tdn->components[dn->comp_num].value.length = l;\n\t\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\t}\n\t\t\t\tdt = d;\n\t\t\t\tdn->comp_num++;\n\t\t\t\tif (dn->comp_num > 2) {\n\t\t\t\t\tif (dn->components == NULL) {\n\t\t\t\t\t}\n\t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));\n\t\t\t\t}\n\t\t\t\tif (is_index == true) {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tif (escape == false) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tif (escape == true) {\n\t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {\n\t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t*d++ = (unsigned char)x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tif (t == NULL) {\n\t\t\t\t\t\tt = p;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t}\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"ldb_private.h\"\n#include <ctype.h>\n#define LDB_DN_NULL_FAILED(x) if (!(x)) goto failed\n#define LDB_FREE(x) do { talloc_free(x); x = NULL; } while(0)\nstruct ldb_dn_component {\n\tchar *name;\n\tstruct ldb_val value;\n\tchar *cf_name;\n\tstruct ldb_val cf_value;\n};\nstruct ldb_dn_ext_component {\n\tconst char *name;\n\tstruct ldb_val value;\n};\nstruct ldb_dn {\n\tstruct ldb_context *ldb;\n\tbool special;\n\tbool invalid;\n\tbool valid_case;\n\tchar *linearized;\n\tchar *ext_linearized;\n\tchar *casefold;\n\tunsigned int comp_num;\n\tstruct ldb_dn_component *components;\n\tunsigned int ext_comp_num;\n\tstruct ldb_dn_ext_component *ext_components;\n};\nstatic void ldb_dn_mark_invalid(struct ldb_dn *dn)\n{\n\tdn->invalid = true;\n}\nstruct ldb_dn *ldb_dn_from_ldb_val(TALLOC_CTX *mem_ctx,\n                                   struct ldb_context *ldb,\n                                   const struct ldb_val *strdn)\n{\n\tstruct ldb_dn *dn;\n\tif (ldb == NULL || strdn == NULL) {\n\t\treturn NULL;\n\t}\n\tif (strdn->data\n\t    && (strnlen((const char*)strdn->data, strdn->length) != strdn->length)) {\n\t\treturn NULL;\n\t}\n\tdn = talloc_zero(mem_ctx, struct ldb_dn);\n\tLDB_DN_NULL_FAILED(dn);\n\tdn->ldb = talloc_get_type(ldb, struct ldb_context);\n\tif (dn->ldb == NULL) {\n\t\ttalloc_free(dn);\n\t\treturn NULL;\n\t}\n\tif (strdn->data && strdn->length) {\n\t\tconst char *data = (const char *)strdn->data;\n\t\tsize_t length = strdn->length;\n\t\tif (data[0] == '@') {\n\t\t\tdn->special = true;\n\t\t}\n\t\tdn->ext_linearized = talloc_strndup(dn, data, length);\n\t\tLDB_DN_NULL_FAILED(dn->ext_linearized);\n\t\tif (data[0] == '<') {\n\t\t\tconst char *p_save, *p = dn->ext_linearized;\n\t\t\tdo {\n\t\t\t\tp_save = p;\n\t\t\t\tp = strstr(p, \">;\");\n\t\t\t\tif (p) {\n\t\t\t\t\tp = p + 2;\n\t\t\t\t}\n\t\t\t} while (p);\n\t\t\tif (p_save == dn->ext_linearized) {\n\t\t\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\t\t} else {\n\t\t\t\tdn->linearized = talloc_strdup(dn, p_save);\n\t\t\t}\n\t\t\tLDB_DN_NULL_FAILED(dn->linearized);\n\t\t} else {\n\t\t\tdn->linearized = dn->ext_linearized;\n\t\t\tdn->ext_linearized = NULL;\n\t\t}\n\t} else {\n\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\tLDB_DN_NULL_FAILED(dn->linearized);\n\t}\n\treturn dn;\nfailed:\n\ttalloc_free(dn);\n\treturn NULL;\n}\nstatic int ldb_dn_escape_internal(char *dst, const char *src, int len)\n{\n\tchar c;\n\tchar *d;\n\tint i;\n\td = dst;\n\tfor (i = 0; i < len; i++){\n\t\tc = src[i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tif (i == 0 || i == len - 1) {\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = c;\n\t\t\t} else {\n\t\t\t\t*d++ = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '#':\n\t\tcase ',':\n\t\tcase '+':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase '?':\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = c;\n\t\t\tbreak;\n\t\tcase ';':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\tcase '=':\n\t\tcase '\\0': {\n\t\t\tunsigned char v;\n\t\t\tconst char *hexbytes = \"0123456789ABCDEF\";\n\t\t\tv = (const unsigned char)c;\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = hexbytes[v>>4];\n\t\t\t*d++ = hexbytes[v&0xF];\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t*d++ = c;\n\t\t}\n\t}\n\treturn (d - dst);\n}\nstatic bool ldb_dn_explode(struct ldb_dn *dn)\n{\n\tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;\n\tbool trim = true;\n\tbool in_extended = true;\n\tbool in_ex_name = false;\n\tbool in_ex_value = false;\n\tbool in_attr = false;\n\tbool in_value = false;\n\tbool in_quote = false;\n\tbool is_oid = false;\n\tbool escape = false;\n\tunsigned int x;\n\tsize_t l = 0;\n\tint ret;\n\tchar *parse_dn;\n\tbool is_index;\n\tif (dn == NULL || dn->invalid == true) {\n\t\treturn false;\n\t}\n\tif (dn->components != NULL) {\n\t\treturn true;\n\t}\n\tif (dn->ext_linearized != NULL) {\n\t\tparse_dn = dn->ext_linearized;\n\t} else {\n\t\tparse_dn = dn->linearized;\n\t}\n\tif (parse_dn == NULL) {\n\t\treturn false;\n\t}\n\tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);\n\tif (parse_dn[0] == '\\0') {\n\t\treturn true;\n\t}\n\tif (dn->special == true) {\n\t\treturn true;\n\t}\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\tdn->comp_num = 0;\n\tdn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);\n\tif (dn->components == NULL) {\n\t\treturn false;\n\t}\n\tdata = talloc_array(dn->components, char, strlen(parse_dn) + 1);\n\tif (data == NULL) {\n\t\tgoto failed;\n\t}\n\tp = parse_dn;\n\tt = NULL;\n\td = dt = data;\n\twhile (*p) {\n\t\tif (in_extended == true) {\n\t\t\tif (!in_ex_name && !in_ex_value) {\n\t\t\t\tif (p[0] == '<') {\n\t\t\t\t\tp++;\n\t\t\t\t\tex_name = d;\n\t\t\t\t\tin_ex_name = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tin_extended = false;\n\t\t\t\t\tin_attr = true;\n\t\t\t\t\tdt = d;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_ex_name && *p == '=') {\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tex_value = d;\n\t\t\t\tin_ex_name = false;\n\t\t\t\tin_ex_value = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_ex_value && *p == '>') {\n\t\t\t\tstruct ldb_dn_ext_component *ext_comp = NULL;\n\t\t\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\t\t\tstruct ldb_val ex_val = {\n\t\t\t\t\t.data = (uint8_t *)ex_value,\n\t\t\t\t\t.length = d - ex_value\n\t\t\t\t};\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tin_ex_value = false;\n\t\t\t\text_comp = talloc_realloc(\n\t\t\t\t\tdn,\n\t\t\t\t\tdn->ext_components,\n\t\t\t\t\tstruct ldb_dn_ext_component,\n\t\t\t\t\tdn->ext_comp_num + 1);\n\t\t\t\tif (ext_comp == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_components = ext_comp;\n\t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);\n\t\t\t\tif (ext_syntax == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_components[dn->ext_comp_num].name = ext_syntax->name;\n\t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,\n\t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdn->ext_comp_num++;\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\ttalloc_free(data);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (*p == ';') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_attr == true) {\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrim = false;\n\t\t\t\tif (!isascii(*p)) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\tis_oid = true;\n\t\t\t\t} else\n\t\t\t\tif ( ! isalpha(*p)) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*p == ' ') {\n\t\t\t\tp++;\n\t\t\t\ttrim = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (*p == '=') {\n\t\t\t\tin_attr = false;\n\t\t\t\tin_value = true;\n\t\t\t\ttrim = true;\n\t\t\t\tl = 0;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);\n\t\t\t\tif (dn->components[dn->comp_num].name == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tdt = d;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!isascii(*p)) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tif (is_oid == true && ( ! (isdigit(*p) || (*p == '.')))) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t} else\n\t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_value == true) {\n\t\t\tif (in_quote == true) {\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tif (p[-1] != '\\\\') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tin_quote = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (trim == true) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttrim = false;\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tin_quote = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (*p) {\n\t\t\tcase ',':\n\t\t\t\tif (escape == true) {\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tescape = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\td -= (p - t);\n\t\t\t\t\tl -= (p - t);\n\t\t\t\t}\n\t\t\t\tin_attr = true;\n\t\t\t\tin_value = false;\n\t\t\t\ttrim = true;\n\t\t\t\tp++;\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].value.data = \\\n\t\t\t\t\t(uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n\t\t\t\tdn->components[dn->comp_num].value.length = l;\n\t\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\ttalloc_set_name_const(dn->components[dn->comp_num].value.data,\n\t\t\t\t\t\t      (const char *)dn->components[dn->comp_num].value.data);\n\t\t\t\tdt = d;\n\t\t\t\tdn->comp_num++;\n\t\t\t\tif (dn->comp_num > 2) {\n\t\t\t\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\t\t\t\tdn->comp_num + 1);\n\t\t\t\t\tif (dn->components == NULL) {\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase '+':\n\t\t\tcase '=':\n\t\t\t\tif (is_index == true) {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tFALL_THROUGH;\n\t\t\tcase '\\\"':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase ';':\n\t\t\t\tif (escape == false) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tif (escape == false) {\n\t\t\t\t\tescape = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tif (t != NULL) {\n\t\t\t\t\tt = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (escape == true) {\n\t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {\n\t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {\n\t\t\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t*d++ = (unsigned char)x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\t}\n\t\t\t\t\tescape = false;\n\t\t\t\t\tl++;\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tif (t == NULL) {\n\t\t\t\t\t\tt = p;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (t != NULL) {\n\t\t\t\t\t\tt = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (in_attr == true || in_quote == true) {\n\t\tldb_dn_mark_invalid(dn);\n\t\tgoto failed;\n\t}\n\tif (in_value == true) {\n\t\tif (t != NULL) {\n\t\t\td -= (p - t);\n\t\t\tl -= (p - t);\n\t\t}\n\t\t*d++ = '\\0';\n\t\tdn->components[dn->comp_num].value.length = l;\n\t\tdn->components[dn->comp_num].value.data =\n\t\t\t(uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\tgoto failed;\n\t\t}\n\t\ttalloc_set_name_const(dn->components[dn->comp_num].value.data,\n\t\t\t(const char *)dn->components[dn->comp_num].value.data);\n\t\tdn->comp_num++;\n\t}\n\ttalloc_free(data);\n\treturn true;\nfailed:\n\tLDB_FREE(dn->components); \n\tdn->comp_num = 0;\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn false;\n}\nconst char *ldb_dn_get_linearized(struct ldb_dn *dn)\n{\n\tunsigned int i;\n\tsize_t len;\n\tchar *d, *n;\n\tif ( ! dn || ( dn->invalid)) return NULL;\n\tif (dn->linearized) return dn->linearized;\n\tif ( ! dn->components) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn NULL;\n\t}\n\tif (dn->comp_num == 0) {\n\t\tdn->linearized = talloc_strdup(dn, \"\");\n\t\tif ( ! dn->linearized) return NULL;\n\t\treturn dn->linearized;\n\t}\n\tfor (len = 0, i = 0; i < dn->comp_num; i++) {\n\t\tlen += strlen(dn->components[i].name);\n\t\tlen += (dn->components[i].value.length * 3);\n\t\tlen += 2; \n\t}\n\tdn->linearized = talloc_array(dn, char, len);\n\tif ( ! dn->linearized) return NULL;\n\td = dn->linearized;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tn = dn->components[i].name;\n\t\twhile (*n) *d++ = *n++;\n\t\t*d++ = '=';\n\t\td += ldb_dn_escape_internal( d,\n\t\t\t\t(char *)dn->components[i].value.data,\n\t\t\t\tdn->components[i].value.length);\n\t\t*d++ = ',';\n\t}\n\t*(--d) = '\\0';\n\tdn->linearized = talloc_realloc(dn, dn->linearized,\n\t\t\t\t\tchar, (d - dn->linearized + 1));\n\treturn dn->linearized;\n}\nchar *ldb_dn_get_extended_linearized(TALLOC_CTX *mem_ctx, struct ldb_dn *dn, int mode)\n{\n\tconst char *linearized = ldb_dn_get_linearized(dn);\n\tchar *p = NULL;\n\tunsigned int i;\n\tif (!linearized) {\n\t\treturn NULL;\n\t}\n\tif (!ldb_dn_has_extended(dn)) {\n\t\treturn talloc_strdup(mem_ctx, linearized);\n\t}\n\tif (!ldb_dn_validate(dn)) {\n\t\treturn NULL;\n\t}\n\tTYPESAFE_QSORT(dn->ext_components, dn->ext_comp_num,\n\t\t       ldb_dn_extended_component_compare);\n\tfor (i = 0; i < dn->ext_comp_num; i++) {\n\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\tconst char *name = dn->ext_components[i].name;\n\t\tstruct ldb_val ec_val = dn->ext_components[i].value;\n\t\tstruct ldb_val val;\n\t\tint ret;\n\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, name);\n\t\tif (!ext_syntax) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (mode == 1) {\n\t\t\tret = ext_syntax->write_clear_fn(dn->ldb, mem_ctx,\n\t\t\t\t\t\t\t&ec_val, &val);\n\t\t} else if (mode == 0) {\n\t\t\tret = ext_syntax->write_hex_fn(dn->ldb, mem_ctx,\n\t\t\t\t\t\t\t&ec_val, &val);\n\t\t} else {\n\t\t\tret = -1;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (i == 0) {\n\t\t\tp = talloc_asprintf(mem_ctx, \"<%s=%.*s>\",\n\t\t\t\t\t    name,\n\t\t\t\t\t    (int)val.length,\n\t\t\t\t\t    val.data);\n\t\t} else {\n\t\t\tp = talloc_asprintf_append_buffer(p, \";<%s=%.*s>\",\n\t\t\t\t\t\t\t  name,\n\t\t\t\t\t\t\t  (int)val.length,\n\t\t\t\t\t\t\t  val.data);\n\t\t}\n\t\ttalloc_free(val.data);\n\t\tif (!p) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->ext_comp_num && *linearized) {\n\t\tp = talloc_asprintf_append_buffer(p, \";%s\", linearized);\n\t}\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\treturn p;\n}\nconst char *ldb_dn_get_casefold(struct ldb_dn *dn)\n{\n\tunsigned int i;\n\tsize_t len;\n\tchar *d, *n;\n\tif (dn->casefold) return dn->casefold;\n\tif (dn->special) {\n\t\tdn->casefold = talloc_strdup(dn, dn->linearized);\n\t\tif (!dn->casefold) return NULL;\n\t\tdn->valid_case = true;\n\t\treturn dn->casefold;\n\t}\n\tif ( ! ldb_dn_casefold_internal(dn)) {\n\t\treturn NULL;\n\t}\n\tif (dn->comp_num == 0) {\n\t\tdn->casefold = talloc_strdup(dn, \"\");\n\t\treturn dn->casefold;\n\t}\n\tfor (len = 0, i = 0; i < dn->comp_num; i++) {\n\t\tlen += strlen(dn->components[i].cf_name);\n\t\tlen += (dn->components[i].cf_value.length * 3);\n\t\tlen += 2; \n\t}\n\tdn->casefold = talloc_array(dn, char, len);\n\tif ( ! dn->casefold) return NULL;\n\td = dn->casefold;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tn = dn->components[i].cf_name;\n\t\twhile (*n) *d++ = *n++;\n\t\t*d++ = '=';\n\t\td += ldb_dn_escape_internal( d,\n\t\t\t\t(char *)dn->components[i].cf_value.data,\n\t\t\t\tdn->components[i].cf_value.length);\n\t\t*d++ = ',';\n\t}\n\t*(--d) = '\\0';\n\tdn->casefold = talloc_realloc(dn, dn->casefold,\n\t\t\t\t      char, strlen(dn->casefold) + 1);\n\treturn dn->casefold;\n}\nint ldb_dn_compare_base(struct ldb_dn *base, struct ldb_dn *dn)\n{\n\tint ret;\n\tunsigned int n_base, n_dn;\n\tif ( ! base || base->invalid) return 1;\n\tif ( ! dn || dn->invalid) return -1;\n\tif (( ! base->valid_case) || ( ! dn->valid_case)) {\n\t\tif (base->linearized && dn->linearized && dn->special == base->special) {\n\t\t\tint dif;\n\t\t\tdif = strlen(dn->linearized) - strlen(base->linearized);\n\t\t\tif (dif < 0) {\n\t\t\t\treturn dif;\n\t\t\t}\n\t\t\tif (strcmp(base->linearized,\n\t\t\t\t   &dn->linearized[dif]) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(base)) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (base->comp_num > dn->comp_num) {\n\t\treturn (dn->comp_num - base->comp_num);\n\t}\n\tif ((dn->comp_num == 0) || (base->comp_num == 0)) {\n\t\tif (dn->special && base->special) {\n\t\t\treturn strcmp(base->linearized, dn->linearized);\n\t\t} else if (dn->special) {\n\t\t\treturn -1;\n\t\t} else if (base->special) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn_base = base->comp_num - 1;\n\tn_dn = dn->comp_num - 1;\n\twhile (n_base != (unsigned int) -1) {\n\t\tchar *b_name = base->components[n_base].cf_name;\n\t\tchar *dn_name = dn->components[n_dn].cf_name;\n\t\tchar *b_vdata = (char *)base->components[n_base].cf_value.data;\n\t\tchar *dn_vdata = (char *)dn->components[n_dn].cf_value.data;\n\t\tsize_t b_vlen = base->components[n_base].cf_value.length;\n\t\tsize_t dn_vlen = dn->components[n_dn].cf_value.length;\n\t\tret = strcmp(b_name, dn_name);\n\t\tif (ret != 0) return ret;\n\t\tif (b_vlen != dn_vlen) {\n\t\t\treturn b_vlen - dn_vlen;\n\t\t}\n\t\tret = strncmp(b_vdata, dn_vdata, b_vlen);\n\t\tif (ret != 0) return ret;\n\t\tn_base--;\n\t\tn_dn--;\n\t}\n\treturn 0;\n}\nint ldb_dn_compare(struct ldb_dn *dn0, struct ldb_dn *dn1)\n{\n\tunsigned int i;\n\tint ret;\n\tif (( ! dn0) || dn0->invalid || ! dn1 || dn1->invalid) {\n\t\treturn -1;\n\t}\n\tif (( ! dn0->valid_case) || ( ! dn1->valid_case)) {\n\t\tif (dn0->linearized && dn1->linearized) {\n\t\t\tif (strcmp(dn0->linearized, dn1->linearized) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn0)) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ( ! ldb_dn_casefold_internal(dn1)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (dn0->comp_num != dn1->comp_num) {\n\t\treturn (dn1->comp_num - dn0->comp_num);\n\t}\n\tif (dn0->comp_num == 0) {\n\t\tif (dn0->special && dn1->special) {\n\t\t\treturn strcmp(dn0->linearized, dn1->linearized);\n\t\t} else if (dn0->special) {\n\t\t\treturn 1;\n\t\t} else if (dn1->special) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (i = 0; i < dn0->comp_num; i++) {\n\t\tchar *dn0_name = dn0->components[i].cf_name;\n\t\tchar *dn1_name = dn1->components[i].cf_name;\n\t\tchar *dn0_vdata = (char *)dn0->components[i].cf_value.data;\n\t\tchar *dn1_vdata = (char *)dn1->components[i].cf_value.data;\n\t\tsize_t dn0_vlen = dn0->components[i].cf_value.length;\n\t\tsize_t dn1_vlen = dn1->components[i].cf_value.length;\n\t\tret = strcmp(dn0_name, dn1_name);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (dn0_vlen != dn1_vlen) {\n\t\t\treturn dn0_vlen - dn1_vlen;\n\t\t}\n\t\tret = strncmp(dn0_vdata, dn1_vdata, dn0_vlen);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nstruct ldb_dn *ldb_dn_copy(TALLOC_CTX *mem_ctx, struct ldb_dn *dn)\n{\n\tstruct ldb_dn *new_dn;\n\tif (!dn || dn->invalid) {\n\t\treturn NULL;\n\t}\n\tnew_dn = talloc_zero(mem_ctx, struct ldb_dn);\n\tif ( !new_dn) {\n\t\treturn NULL;\n\t}\n\t*new_dn = *dn;\n\tif (dn->components) {\n\t\tunsigned int i;\n\t\tnew_dn->components =\n\t\t\ttalloc_zero_array(new_dn,\n\t\t\t\t\t  struct ldb_dn_component,\n\t\t\t\t\t  dn->comp_num);\n\t\tif ( ! new_dn->components) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tnew_dn->components[i] =\n\t\t\t\tldb_dn_copy_component(new_dn->components,\n\t\t\t\t\t\t      &dn->components[i]);\n\t\t\tif ( ! new_dn->components[i].value.data) {\n\t\t\t\ttalloc_free(new_dn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn->ext_components) {\n\t\tunsigned int i;\n\t\tnew_dn->ext_components =\n\t\t\ttalloc_zero_array(new_dn,\n\t\t\t\t\t  struct ldb_dn_ext_component,\n\t\t\t\t\t  dn->ext_comp_num);\n\t\tif ( ! new_dn->ext_components) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < dn->ext_comp_num; i++) {\n\t\t\tnew_dn->ext_components[i] =\n\t\t\t\t ldb_dn_ext_copy_component(\n\t\t\t\t\t\tnew_dn->ext_components,\n\t\t\t\t\t\t&dn->ext_components[i]);\n\t\t\tif ( ! new_dn->ext_components[i].value.data) {\n\t\t\t\ttalloc_free(new_dn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn->casefold) {\n\t\tnew_dn->casefold = talloc_strdup(new_dn, dn->casefold);\n\t\tif ( ! new_dn->casefold) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\tnew_dn->linearized = talloc_strdup(new_dn, dn->linearized);\n\t\tif ( ! new_dn->linearized) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (dn->ext_linearized) {\n\t\tnew_dn->ext_linearized = talloc_strdup(new_dn,\n\t\t\t\t\t\t\tdn->ext_linearized);\n\t\tif ( ! new_dn->ext_linearized) {\n\t\t\ttalloc_free(new_dn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn new_dn;\n}\nbool ldb_dn_add_base(struct ldb_dn *dn, struct ldb_dn *base)\n{\n\tconst char *s;\n\tchar *t;\n\tif ( !base || base->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\tif (dn == base) {\n\t\treturn false; \n\t}\n\tif (dn->components) {\n\t\tunsigned int i;\n\t\tif ( ! ldb_dn_validate(base)) {\n\t\t\treturn false;\n\t\t}\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(base))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tdn->comp_num + base->comp_num);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < base->comp_num; dn->comp_num++, i++) {\n\t\t\tdn->components[dn->comp_num] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&base->components[i]);\n\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (dn->casefold && s) {\n\t\t\tif (*dn->casefold) {\n\t\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t\t    dn->casefold, s);\n\t\t\t} else {\n\t\t\t\tt = talloc_strdup(dn, s);\n\t\t\t}\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\ts = ldb_dn_get_linearized(base);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\t\tif (*dn->linearized) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t    dn->linearized, s);\n\t\t} else {\n\t\t\tt = talloc_strdup(dn, s);\n\t\t}\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn true;\n}\nbool ldb_dn_add_child(struct ldb_dn *dn, struct ldb_dn *child)\n{\n\tconst char *s;\n\tchar *t;\n\tif ( !child || child->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\tif (dn->components) {\n\t\tunsigned int n;\n\t\tunsigned int i, j;\n\t\tif (dn->comp_num == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( ! ldb_dn_validate(child)) {\n\t\t\treturn false;\n\t\t}\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(child))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tn = dn->comp_num + child->comp_num;\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tn);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = dn->comp_num - 1, j = n - 1; i != (unsigned int) -1;\n\t\t     i--, j--) {\n\t\t\tdn->components[j] = dn->components[i];\n\t\t}\n\t\tfor (i = 0; i < child->comp_num; i++) {\n\t\t\tdn->components[i] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&child->components[i]);\n\t\t\tif (dn->components[i].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdn->comp_num = n;\n\t\tif (dn->casefold && s) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->casefold);\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\tif (dn->linearized) {\n\t\tif (dn->linearized[0] == '\\0') {\n\t\t\treturn false;\n\t\t}\n\t\ts = ldb_dn_get_linearized(child);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\t\tt = talloc_asprintf(dn, \"%s,%s\", s, dn->linearized);\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn true;\n}\nbool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)\n{\n\tunsigned int i;\n\tif ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tLDB_FREE(dn->components[i].name);\n\t\tLDB_FREE(dn->components[i].value.data);\n\t\tLDB_FREE(dn->components[i].cf_name);\n\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t}\n\tdn->components = talloc_realloc(dn,\n\t\t\t\t\tdn->components,\n\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\tnew_dn->comp_num);\n\tif (dn->components == NULL) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn false;\n\t}\n\tdn->comp_num = new_dn->comp_num;\n\tdn->valid_case = new_dn->valid_case;\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tdn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);\n\t\tif (dn->components[i].name == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (new_dn->linearized == NULL) {\n\t\tdn->linearized = NULL;\n\t} else {\n\t\tdn->linearized = talloc_strdup(dn, new_dn->linearized);\n\t\tif (dn->linearized == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nstatic char *ldb_dn_canonical(TALLOC_CTX *mem_ctx, struct ldb_dn *dn, int ex_format) {\n\tunsigned int i;\n\tTALLOC_CTX *tmpctx;\n\tchar *cracked = NULL;\n\tconst char *format = (ex_format ? \"\\n\" : \"/\" );\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn NULL;\n\t}\n\ttmpctx = talloc_new(mem_ctx);\n\tfor (i = dn->comp_num - 1; i != (unsigned int) -1; i--) {\n\t\tif (ldb_attr_cmp(dn->components[i].name, \"dc\") != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cracked) {\n\t\t\tcracked = talloc_asprintf(tmpctx, \"%s.%s\",\n\t\t\t\t\t\t  ldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value),\n\t\t\t\t\t\t  cracked);\n\t\t} else {\n\t\t\tcracked = ldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value);\n\t\t}\n\t\tif (!cracked) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (i == (unsigned int) -1) {\n\t\tcracked = talloc_strdup_append_buffer(cracked, format);\n\t\ttalloc_steal(mem_ctx, cracked);\n\t\tgoto done;\n\t}\n\tfor (; i > 0; i--) {\n\t\tcracked = talloc_asprintf_append_buffer(cracked, \"/%s\",\n\t\t\t\t\t\t\tldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value));\n\t\tif (!cracked) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\tcracked = talloc_asprintf_append_buffer(cracked, \"%s%s\", format,\n\t\t\t\t\t\tldb_dn_escape_value(tmpctx,\n\t\t\t\t\t\t\tdn->components[i].value));\n\ttalloc_steal(mem_ctx, cracked);\ndone:\n\ttalloc_free(tmpctx);\n\treturn cracked;\n}\nint ldb_dn_set_component(struct ldb_dn *dn, int num,\n\t\t\t const char *name, const struct ldb_val val)\n{\n\tchar *n;\n\tstruct ldb_val v;\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif (num < 0) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif ((unsigned)num >= dn->comp_num) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tif (val.length > val.length + 1) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tn = talloc_strdup(dn, name);\n\tif ( ! n) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tv.length = val.length;\n\tv.data = (uint8_t *)talloc_size(dn, v.length+1);\n\tif ( ! v.data) {\n\t\ttalloc_free(n);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\tmemcpy(v.data, val.data, val.length);\n\tv.data[v.length] = '\\0';\n\ttalloc_free(dn->components[num].name);\n\ttalloc_free(dn->components[num].value.data);\n\tdn->components[num].name = n;\n\tdn->components[num].value = v;\n\tif (dn->valid_case) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tLDB_FREE(dn->components[i].cf_name);\n\t\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t\t}\n\t\tdn->valid_case = false;\n\t}\n\tLDB_FREE(dn->casefold);\n\tLDB_FREE(dn->linearized);\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\treturn LDB_SUCCESS;\n}\nint ldb_dn_set_extended_component(struct ldb_dn *dn,\n\t\t\t\t  const char *name, const struct ldb_val *val)\n{\n\tstruct ldb_dn_ext_component *p;\n\tunsigned int i;\n\tstruct ldb_val v2;\n\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, name);\n\tif (ext_syntax == NULL) {\n\t\treturn LDB_ERR_INVALID_DN_SYNTAX;\n\t}\n\tfor (i=0; i < dn->ext_comp_num; i++) {\n\t\tif (ldb_attr_cmp(dn->ext_components[i].name, name) == 0) {\n\t\t\tif (val) {\n\t\t\t\tdn->ext_components[i].value =\n\t\t\t\t\tldb_val_dup(dn->ext_components, val);\n\t\t\t\tdn->ext_components[i].name = ext_syntax->name;\n\t\t\t\tif (!dn->ext_components[i].value.data) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tARRAY_DEL_ELEMENT(\n\t\t\t\t\tdn->ext_components,\n\t\t\t\t\ti,\n\t\t\t\t\tdn->ext_comp_num);\n\t\t\t\tdn->ext_comp_num--;\n\t\t\t\tdn->ext_components = talloc_realloc(dn,\n\t\t\t\t\t\t   dn->ext_components,\n\t\t\t\t\t\t   struct ldb_dn_ext_component,\n\t\t\t\t\t\t   dn->ext_comp_num);\n\t\t\t\tif (!dn->ext_components) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDB_FREE(dn->ext_linearized);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t}\n\tif (val == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tv2 = *val;\n\tp = dn->ext_components\n\t\t= talloc_realloc(dn,\n\t\t\t\t dn->ext_components,\n\t\t\t\t struct ldb_dn_ext_component,\n\t\t\t\t dn->ext_comp_num + 1);\n\tif (!dn->ext_components) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tp[dn->ext_comp_num].value = ldb_val_dup(dn->ext_components, &v2);\n\tp[dn->ext_comp_num].name = talloc_strdup(p, name);\n\tif (!dn->ext_components[i].name || !dn->ext_components[i].value.data) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tdn->ext_components = p;\n\tdn->ext_comp_num++;\n\tLDB_FREE(dn->ext_linearized);\n\treturn LDB_SUCCESS;\n}\nFile number 2:\nsamba.tests.segfault.samba.tests.segfault.SegfaultTests.test_net_replicate_init__3\nsamba.tests.segfault.samba.tests.segfault.SegfaultTests.test_ldb_dn_explode_crash\n\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_6029.c",
        "project": "samba-team/samba",
        "url": "https://github.com/samba-team/samba/commit/f89767bea7330ec1936d2312e2b1da7b435c04b7",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```void faad_resetbits(bitfile *ld, int bits)\n    int words = bits >> 5;\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"common.h\"\n#include \"structs.h\"\n#include <stdlib.h>\n#include \"bits.h\"\nvoid faad_initbits(bitfile *ld, const void *_buffer, const uint32_t buffer_size)\n{\n    uint32_t tmp;\n    if (ld == NULL)\n        return;\n    // useless\n    //memset(ld, 0, sizeof(bitfile));\n    if (buffer_size == 0 || _buffer == NULL)\n    {\n        ld->error = 1;\n        return;\n    }\n    ld->buffer = _buffer;\n    ld->buffer_size = buffer_size;\n    ld->bytes_left  = buffer_size;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword((uint32_t*)ld->buffer + 1);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n((uint32_t*)ld->buffer + 1, ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->start = (uint32_t*)ld->buffer;\n    ld->tail = ((uint32_t*)ld->buffer + 2);\n    ld->bits_left = 32;\n    ld->error = 0;\n}\nvoid faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}\nuint8_t *faad_getbitbuffer(bitfile *ld, uint32_t bits\n                       DEBUGDEC)\n{\n    int i;\n    unsigned int temp;\n    int bytes = bits >> 3;\n    int remainder = bits & 0x7;\n    uint8_t *buffer = (uint8_t*)faad_malloc((bytes+1)*sizeof(uint8_t));\n    for (i = 0; i < bytes; i++)\n    {\n        buffer[i] = (uint8_t)faad_getbits(ld, 8 DEBUGVAR(print,var,dbg));\n    }\n    if (remainder)\n    {\n        temp = faad_getbits(ld, remainder DEBUGVAR(print,var,dbg)) << (8-remainder);\n        buffer[bytes] = (uint8_t)temp;\n    }\n    return buffer;\n}\n#ifdef DRM\nvoid *faad_origbitbuffer(bitfile *ld)\n{\n    return (void*)ld->start;\n}\nuint32_t faad_origbitbuffer_size(bitfile *ld)\n{\n    return ld->buffer_size;\n}\n#endif\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_3772.c",
        "project": "knik0/faad2",
        "url": "https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\nSECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (message->MessageType != MESSAGE_TYPE_NEGOTIATE)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tStream_Read_UINT32(s, message->NegotiateFlags); \n\tif (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) \n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\nSECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tStartOffset = Stream_Pointer(s);\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tStream_Read_UINT32(s, message->NegotiateFlags); \n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tStream_Read(s, message->ServerChallenge, 8); \n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tStream_Read(s, message->Reserved, 8); \n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\nSECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <\n\t    0) \n\tif (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <\n\t    0) \n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) \n\t\treturn SEC_E_INVALID_TOKEN;\n\tif (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) \n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/stream.h>\n#include <winpr/sysinfo.h>\n#include \"ntlm_compute.h\"\n#include \"ntlm_message.h\"\n#include \"../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\nstatic const char NTLM_SIGNATURE[8] = { 'N', 'T', 'L', 'M', 'S', 'S', 'P', '\\0' };\n#ifdef WITH_DEBUG_NTLM\nstatic const char* const NTLM_NEGOTIATE_STRINGS[] = { \"NTLMSSP_NEGOTIATE_56\",\n\t                                                  \"NTLMSSP_NEGOTIATE_KEY_EXCH\",\n\t                                                  \"NTLMSSP_NEGOTIATE_128\",\n\t                                                  \"NTLMSSP_RESERVED1\",\n\t                                                  \"NTLMSSP_RESERVED2\",\n\t                                                  \"NTLMSSP_RESERVED3\",\n\t                                                  \"NTLMSSP_NEGOTIATE_VERSION\",\n\t                                                  \"NTLMSSP_RESERVED4\",\n\t                                                  \"NTLMSSP_NEGOTIATE_TARGET_INFO\",\n\t                                                  \"NTLMSSP_REQUEST_NON_NT_SESSION_KEY\",\n\t                                                  \"NTLMSSP_RESERVED5\",\n\t                                                  \"NTLMSSP_NEGOTIATE_IDENTIFY\",\n\t                                                  \"NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY\",\n\t                                                  \"NTLMSSP_RESERVED6\",\n\t                                                  \"NTLMSSP_TARGET_TYPE_SERVER\",\n\t                                                  \"NTLMSSP_TARGET_TYPE_DOMAIN\",\n\t                                                  \"NTLMSSP_NEGOTIATE_ALWAYS_SIGN\",\n\t                                                  \"NTLMSSP_RESERVED7\",\n\t                                                  \"NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED\",\n\t                                                  \"NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED\",\n\t                                                  \"NTLMSSP_NEGOTIATE_ANONYMOUS\",\n\t                                                  \"NTLMSSP_RESERVED8\",\n\t                                                  \"NTLMSSP_NEGOTIATE_NTLM\",\n\t                                                  \"NTLMSSP_RESERVED9\",\n\t                                                  \"NTLMSSP_NEGOTIATE_LM_KEY\",\n\t                                                  \"NTLMSSP_NEGOTIATE_DATAGRAM\",\n\t                                                  \"NTLMSSP_NEGOTIATE_SEAL\",\n\t                                                  \"NTLMSSP_NEGOTIATE_SIGN\",\n\t                                                  \"NTLMSSP_RESERVED10\",\n\t                                                  \"NTLMSSP_REQUEST_TARGET\",\n\t                                                  \"NTLMSSP_NEGOTIATE_OEM\",\n\t                                                  \"NTLMSSP_NEGOTIATE_UNICODE\" };\nstatic void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\" PRIX32 \"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}\n#endif\nstatic int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\tif (strncmp((char*)header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\treturn 1;\n}\nstatic int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len);          \n\tStream_Read_UINT16(s, fields->MaxLen);       \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}\n#ifdef WITH_DEBUG_NTLM\nstatic void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\" PRIu16 \" MaxLen: %\" PRIu16 \" BufferOffset: %\" PRIu32 \")\", name,\n\t         fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n#endif\nSECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (message->MessageType != MESSAGE_TYPE_NEGOTIATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tStream_Read_UINT32(s, message->NegotiateFlags); \n\tif (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) \n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %\" PRIu32 \")\", context->NegotiateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,\n\t              context->NegotiateMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\nSECURITY_STATUS ntlm_write_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*)message, MESSAGE_TYPE_NEGOTIATE);\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_LM_KEY;\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;\n\t}\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\tif (context->SendVersionInfo)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*)message);\n\tStream_Write_UINT32(s, message->NegotiateFlags); \n\tntlm_write_message_fields(s, &(message->DomainName));\n\tntlm_write_message_fields(s, &(message->Workstation));\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version));\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\nSECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tint length;\n\tPBYTE StartOffset;\n\tPBYTE PayloadOffset;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tStartOffset = Stream_Pointer(s);\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (message->MessageType != MESSAGE_TYPE_CHALLENGE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tStream_Read_UINT32(s, message->NegotiateFlags); \n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tStream_Read(s, message->ServerChallenge, 8); \n\tCopyMemory(context->ServerChallenge, message->ServerChallenge, 8);\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tStream_Read(s, message->Reserved, 8); \n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) \n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\tPayloadOffset = Stream_Pointer(s);\n\tif (message->TargetName.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t}\n\tif (message->TargetInfo.Len > 0)\n\t{\n\t\tsize_t cbAvTimestamp;\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t\tcontext->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;\n\t\tAvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*)message->TargetInfo.Buffer,\n\t\t                               message->TargetInfo.Len, MsvAvTimestamp, &cbAvTimestamp);\n\t\tif (AvTimestamp)\n\t\t{\n\t\t\tPBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);\n\t\t\tif (!ptr)\n\t\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t\tif (context->NTLMv2)\n\t\t\t\tcontext->UseMIC = TRUE;\n\t\t\tCopyMemory(context->ChallengeTimestamp, ptr, 8);\n\t\t}\n\t}\n\tlength = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(context->NegotiateFlags);\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n\tif (context->ChallengeTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"ChallengeTargetInfo (%\" PRIu32 \"):\", context->ChallengeTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->ChallengeTargetInfo.pvBuffer,\n\t\t                        context->ChallengeTargetInfo.cbBuffer);\n\t}\n#endif\n\tif (context->NTLMv2)\n\t{\n\t\tif (ntlm_construct_authenticate_target_info(context) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t\tsspi_SecBufferFree(&context->ChallengeTargetInfo);\n\t\tcontext->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = context->AuthenticateTargetInfo.cbBuffer;\n\t}\n\tntlm_generate_timestamp(context); \n\tif (ntlm_compute_lm_v2_response(context) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tntlm_generate_key_exchange_key(context);     \n\tntlm_generate_random_session_key(context);   \n\tntlm_generate_exported_session_key(context); \n\tntlm_encrypt_random_session_key(context);    \n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tntlm_free_message_fields_buffer(&(message->TargetName));\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\nSECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadOffset;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tntlm_get_version_info(&(message->Version)); \n\tntlm_generate_server_challenge(context);    \n\tntlm_generate_timestamp(context);           \n\tif (ntlm_construct_challenge_target_info(context) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(message->ServerChallenge, context->ServerChallenge, 8); \n\tmessage->NegotiateFlags = context->NegotiateFlags;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*)message, MESSAGE_TYPE_CHALLENGE);\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*)message);\n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t{\n\t\tmessage->TargetName.Len = (UINT16)context->TargetName.cbBuffer;\n\t\tmessage->TargetName.Buffer = (PBYTE)context->TargetName.pvBuffer;\n\t}\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t{\n\t\tmessage->TargetInfo.Len = (UINT16)context->ChallengeTargetInfo.cbBuffer;\n\t\tmessage->TargetInfo.Buffer = (PBYTE)context->ChallengeTargetInfo.pvBuffer;\n\t}\n\tPayloadOffset = 48;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadOffset += 8;\n\tmessage->TargetName.BufferOffset = PayloadOffset;\n\tmessage->TargetInfo.BufferOffset = message->TargetName.BufferOffset + message->TargetName.Len;\n\tntlm_write_message_fields(s, &(message->TargetName));\n\tStream_Write_UINT32(s, message->NegotiateFlags); \n\tStream_Write(s, message->ServerChallenge, 8);    \n\tStream_Write(s, message->Reserved, 8);           \n\tntlm_write_message_fields(s, &(message->TargetInfo));\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); \n\tif (message->NegotiateFlags & NTLMSSP_REQUEST_TARGET)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetName));\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)\n\t\tntlm_write_message_fields_buffer(s, &(message->TargetInfo));\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s), length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\nSECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 flags;\n\tNTLM_AV_PAIR* AvFlags;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tflags = 0;\n\tAvFlags = NULL;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tStream_Read_UINT32(s, message->NegotiateFlags); \n\tcontext->NegotiateKeyExchange =\n\t    (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE : FALSE;\n\tif ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||\n\t    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) \n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\tPayloadBufferOffset = Stream_GetPosition(s);\n\tif (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (ntlm_read_message_fields_buffer(s, &(message->LmChallengeResponse)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (ntlm_read_message_fields_buffer(s, &(message->NtChallengeResponse)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (message->NtChallengeResponse.Len > 0)\n\t{\n\t\tsize_t cbAvFlags;\n\t\twStream* snt =\n\t\t    Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);\n\t\tif (!snt)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t\tif (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\tStream_Free(snt, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t\tStream_Free(snt, FALSE);\n\t\tcontext->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;\n\t\tcontext->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;\n\t\tsspi_SecBufferFree(&(context->ChallengeTargetInfo));\n\t\tcontext->ChallengeTargetInfo.pvBuffer = (void*)context->NTLMv2Response.Challenge.AvPairs;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->NtChallengeResponse.Len - (28 + 16);\n\t\tCopyMemory(context->ClientChallenge, context->NTLMv2Response.Challenge.ClientChallenge, 8);\n\t\tAvFlags =\n\t\t    ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs,\n\t\t                     context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);\n\t\tif (AvFlags)\n\t\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\t}\n\tif (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) \n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tif (message->EncryptedRandomSessionKey.Len > 0)\n\t{\n\t\tif (message->EncryptedRandomSessionKey.Len != 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t\tCopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer,\n\t\t           16);\n\t}\n\tlength = Stream_GetPosition(s);\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tStream_SetPosition(s, PayloadBufferOffset);\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);\n\t\tif (Stream_GetRemainingLength(s) < 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t\tStream_Read(s, message->MessageIntegrityCheck, 16);\n\t}\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\" PRIu32 \")\",\n\t         context->AuthenticateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->AuthenticateMessage.pvBuffer,\n\t              context->AuthenticateMessage.cbBuffer);\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tntlm_print_av_pair_list(context->NTLMv2Response.Challenge.AvPairs,\n\t                        context->NTLMv2Response.Challenge.cbAvPairs);\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n#endif\n\tif (message->UserName.Len > 0)\n\t{\n\t\tcredentials->identity.User = (UINT16*)malloc(message->UserName.Len);\n\t\tif (!credentials->identity.User)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t\tCopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);\n\t\tcredentials->identity.UserLength = message->UserName.Len / 2;\n\t}\n\tif (message->DomainName.Len > 0)\n\t{\n\t\tcredentials->identity.Domain = (UINT16*)malloc(message->DomainName.Len);\n\t\tif (!credentials->identity.Domain)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t\tCopyMemory(credentials->identity.Domain, message->DomainName.Buffer,\n\t\t           message->DomainName.Len);\n\t\tcredentials->identity.DomainLength = message->DomainName.Len / 2;\n\t}\n\tStream_Free(s, FALSE);\n\tcontext->state = NTLM_STATE_COMPLETION;\n\treturn SEC_I_COMPLETE_NEEDED;\n}\nSECURITY_STATUS ntlm_write_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (context->NTLMv2)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_56;\n\t\tif (context->SendVersionInfo)\n\t\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_VERSION;\n\t}\n\tif (context->UseMIC)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;\n\tif (context->SendWorkstationName)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED;\n\tif (context->confidentiality)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;\n\tif (context->CHALLENGE_MESSAGE.NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_128;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXTENDED_SESSION_SECURITY;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_NTLM;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;\n\tmessage->NegotiateFlags |= NTLMSSP_REQUEST_TARGET;\n\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_get_version_info(&(message->Version));\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t{\n\t\tmessage->Workstation.Len = context->Workstation.Length;\n\t\tmessage->Workstation.Buffer = (BYTE*)context->Workstation.Buffer;\n\t}\n\tif (credentials->identity.DomainLength > 0)\n\t{\n\t\tmessage->NegotiateFlags |= NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED;\n\t\tmessage->DomainName.Len = (UINT16)credentials->identity.DomainLength * 2;\n\t\tmessage->DomainName.Buffer = (BYTE*)credentials->identity.Domain;\n\t}\n\tmessage->UserName.Len = (UINT16)credentials->identity.UserLength * 2;\n\tmessage->UserName.Buffer = (BYTE*)credentials->identity.User;\n\tmessage->LmChallengeResponse.Len = (UINT16)context->LmChallengeResponse.cbBuffer;\n\tmessage->LmChallengeResponse.Buffer = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\tmessage->NtChallengeResponse.Len = (UINT16)context->NtChallengeResponse.cbBuffer;\n\tmessage->NtChallengeResponse.Buffer = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t{\n\t\tmessage->EncryptedRandomSessionKey.Len = 16;\n\t\tmessage->EncryptedRandomSessionKey.Buffer = context->EncryptedRandomSessionKey;\n\t}\n\tPayloadBufferOffset = 64;\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tPayloadBufferOffset += 8; \n\tif (context->UseMIC)\n\t\tPayloadBufferOffset += 16; \n\tmessage->DomainName.BufferOffset = PayloadBufferOffset;\n\tmessage->UserName.BufferOffset = message->DomainName.BufferOffset + message->DomainName.Len;\n\tmessage->Workstation.BufferOffset = message->UserName.BufferOffset + message->UserName.Len;\n\tmessage->LmChallengeResponse.BufferOffset =\n\t    message->Workstation.BufferOffset + message->Workstation.Len;\n\tmessage->NtChallengeResponse.BufferOffset =\n\t    message->LmChallengeResponse.BufferOffset + message->LmChallengeResponse.Len;\n\tmessage->EncryptedRandomSessionKey.BufferOffset =\n\t    message->NtChallengeResponse.BufferOffset + message->NtChallengeResponse.Len;\n\tntlm_populate_message_header((NTLM_MESSAGE_HEADER*)message, MESSAGE_TYPE_AUTHENTICATE);\n\tntlm_write_message_header(s, (NTLM_MESSAGE_HEADER*)message); \n\tntlm_write_message_fields(\n\t    s, &(message->LmChallengeResponse)); \n\tntlm_write_message_fields(\n\t    s, &(message->NtChallengeResponse));               \n\tntlm_write_message_fields(s, &(message->DomainName));  \n\tntlm_write_message_fields(s, &(message->UserName));    \n\tntlm_write_message_fields(s, &(message->Workstation)); \n\tntlm_write_message_fields(\n\t    s, &(message->EncryptedRandomSessionKey));   \n\tStream_Write_UINT32(s, message->NegotiateFlags); \n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_write_version_info(s, &(message->Version)); \n\tif (context->UseMIC)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);\n\t\tStream_Zero(s, 16); \n\t}\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->DomainName)); \n\tntlm_write_message_fields_buffer(s, &(message->UserName)); \n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED)\n\t\tntlm_write_message_fields_buffer(s, &(message->Workstation)); \n\tntlm_write_message_fields_buffer(s, &(message->LmChallengeResponse)); \n\tntlm_write_message_fields_buffer(s, &(message->NtChallengeResponse)); \n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t\tntlm_write_message_fields_buffer(\n\t\t    s, &(message->EncryptedRandomSessionKey)); \n\tlength = Stream_GetPosition(s);\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tif (context->UseMIC)\n\t{\n\t\tntlm_compute_message_integrity_check(context, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, context->MessageIntegrityCheckOffset);\n\t\tStream_Write(s, message->MessageIntegrityCheck, 16);\n\t\tStream_SetPosition(s, length);\n\t}\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Buffer(s), length);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\tif (context->AuthenticateTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG,\n\t\t         \"AuthenticateTargetInfo (%\" PRIu32 \"):\", context->AuthenticateTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->AuthenticateTargetInfo.pvBuffer,\n\t\t                        context->AuthenticateTargetInfo.cbBuffer);\n\t}\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tif (context->UseMIC)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck (length = 16)\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_COMPLETE_NEEDED;\n}\nSECURITY_STATUS ntlm_server_AuthenticateComplete(NTLM_CONTEXT* context)\n{\n\tUINT32 flags = 0;\n\tsize_t cbAvFlags;\n\tNTLM_AV_PAIR* AvFlags = NULL;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tBYTE messageIntegrityCheck[16];\n\tif (!context)\n\t\treturn SEC_E_INVALID_PARAMETER;\n\tif (context->state != NTLM_STATE_COMPLETION)\n\t\treturn SEC_E_OUT_OF_SEQUENCE;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tAvFlags = ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs,\n\t                           context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);\n\tif (AvFlags)\n\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\tif (ntlm_compute_lm_v2_response(context) < 0) \n\t\treturn SEC_E_INTERNAL_ERROR;\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) \n\t\treturn SEC_E_INTERNAL_ERROR;\n\tntlm_generate_key_exchange_key(context);\n\tntlm_decrypt_random_session_key(context);\n\tntlm_generate_exported_session_key(context);\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tZeroMemory(\n\t\t    &((PBYTE)context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t    16);\n\t\tntlm_compute_message_integrity_check(context, messageIntegrityCheck,\n\t\t                                     sizeof(messageIntegrityCheck));\n\t\tCopyMemory(\n\t\t    &((PBYTE)context->AuthenticateMessage.pvBuffer)[context->MessageIntegrityCheckOffset],\n\t\t    message->MessageIntegrityCheck, 16);\n\t\tif (memcmp(messageIntegrityCheck, message->MessageIntegrityCheck, 16) != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Message Integrity Check (MIC) verification failed!\");\n#ifdef WITH_DEBUG_NTLM\n\t\t\tWLog_ERR(TAG, \"Expected MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, messageIntegrityCheck, sizeof(messageIntegrityCheck));\n\t\t\tWLog_ERR(TAG, \"Actual MIC:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, message->MessageIntegrityCheck,\n\t\t\t              sizeof(message->MessageIntegrityCheck));\n#endif\n\t\t\treturn SEC_E_MESSAGE_ALTERED;\n\t\t}\n\t}\n\telse\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_DBG(TAG, \"No MIC present, using NtProofString for verification.\");\n#endif\n\t\tif (memcmp(context->NTLMv2Response.Response, context->NtProofString, 16) != 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"NtProofString verification failed!\");\n#ifdef WITH_DEBUG_NTLM\n\t\t\tWLog_ERR(TAG, \"Expected NtProofString:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, context->NtProofString, sizeof(context->NtProofString));\n\t\t\tWLog_ERR(TAG, \"Actual NtProofString:\");\n\t\t\twinpr_HexDump(TAG, WLOG_ERROR, context->NTLMv2Response.Response,\n\t\t\t              sizeof(context->NTLMv2Response));\n#endif\n\t\t\treturn SEC_E_LOGON_DENIED;\n\t\t}\n\t}\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_FINAL;\n\tntlm_free_message_fields_buffer(&(message->DomainName));\n\tntlm_free_message_fields_buffer(&(message->UserName));\n\tntlm_free_message_fields_buffer(&(message->Workstation));\n\tntlm_free_message_fields_buffer(&(message->LmChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->NtChallengeResponse));\n\tntlm_free_message_fields_buffer(&(message->EncryptedRandomSessionKey));\n\treturn SEC_E_OK;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_4577.c",
        "project": "freerdp/freerdp",
        "url": "https://github.com/FreeRDP/FreeRDP/commit/8fa38359634a9910b91719818ab02f23c320dbae",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```void IGDdata(void * d, const char * data, int l)\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tchar * dstmember = 0;\n\t\tdstmember = datas->urlbase;\n\telse if( !strcmp(datas->cureltname, \"presentationURL\") )\n\t\tdstmember = datas->presentationurl;\n\telse if( !strcmp(datas->cureltname, \"serviceType\") )\n\t\tdstmember = datas->tmp.servicetype;\n\telse if( !strcmp(datas->cureltname, \"controlURL\") )\n\t\tdstmember = datas->tmp.controlurl;\n\telse if( !strcmp(datas->cureltname, \"eventSubURL\") )\n\t\tdstmember = datas->tmp.eventsuburl;\n\telse if( !strcmp(datas->cureltname, \"SCPDURL\") )\n\t\tdstmember = datas->tmp.scpdurl;\n\t\tif(l>=MINIUPNPC_URL_MAXSIZE)\n\t\t\tl = MINIUPNPC_URL_MAXSIZE-1;\n\t\tmemcpy(dstmember, data, l);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n/* $Id: igd_desc_parse.c,v 1.16 2014/11/17 17:19:13 nanard Exp $ */\n/* Project : miniupnp\n * http://miniupnp.free.fr/\n * Author : Thomas Bernard\n * Copyright (c) 2005-2014 Thomas Bernard\n * This software is subject to the conditions detailed in the\n * LICENCE file provided in this distribution. */\n\n#include \"igd_desc_parse.h\"\n#include <stdio.h>\n#include <string.h>\n\n/* Start element handler :\n * update nesting level counter and copy element name */\nvoid IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}\n\n#define COMPARE(str, cstr) (0==memcmp(str, cstr, sizeof(cstr) - 1))\n\n/* End element handler :\n * update nesting level counter and update parser state if\n * service element is parsed */\nvoid IGDendelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tdatas->level--;\n\t/*printf(\"endelt %2d %.*s\\n\", datas->level, l, name);*/\n\tif( (l==7) && !memcmp(name, \"service\", l) )\n\t{\n\t\tif(COMPARE(datas->tmp.servicetype,\n\t\t           \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\")) {\n\t\t\tmemcpy(&datas->CIF, &datas->tmp, sizeof(struct IGDdatas_service));\n\t\t} else if(COMPARE(datas->tmp.servicetype,\n\t\t\t                \"urn:schemas-upnp-org:service:WANIPv6FirewallControl:\")) {\n\t\t\tmemcpy(&datas->IPv6FC, &datas->tmp, sizeof(struct IGDdatas_service));\n\t\t} else if(COMPARE(datas->tmp.servicetype,\n\t\t                  \"urn:schemas-upnp-org:service:WANIPConnection:\")\n\t\t         || COMPARE(datas->tmp.servicetype,\n\t\t                    \"urn:schemas-upnp-org:service:WANPPPConnection:\") ) {\n\t\t\tif(datas->first.servicetype[0] == '\\0') {\n\t\t\t\tmemcpy(&datas->first, &datas->tmp, sizeof(struct IGDdatas_service));\n\t\t\t} else {\n\t\t\t\tmemcpy(&datas->second, &datas->tmp, sizeof(struct IGDdatas_service));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Data handler :\n * copy data depending on the current element name and state */\nvoid IGDdata(void * d, const char * data, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tchar * dstmember = 0;\n\t/*printf(\"%2d %s : %.*s\\n\",\n           datas->level, datas->cureltname, l, data);\t*/\n\tif( !strcmp(datas->cureltname, \"URLBase\") )\n\t\tdstmember = datas->urlbase;\n\telse if( !strcmp(datas->cureltname, \"presentationURL\") )\n\t\tdstmember = datas->presentationurl;\n\telse if( !strcmp(datas->cureltname, \"serviceType\") )\n\t\tdstmember = datas->tmp.servicetype;\n\telse if( !strcmp(datas->cureltname, \"controlURL\") )\n\t\tdstmember = datas->tmp.controlurl;\n\telse if( !strcmp(datas->cureltname, \"eventSubURL\") )\n\t\tdstmember = datas->tmp.eventsuburl;\n\telse if( !strcmp(datas->cureltname, \"SCPDURL\") )\n\t\tdstmember = datas->tmp.scpdurl;\n/*\telse if( !strcmp(datas->cureltname, \"deviceType\") )\n\t\tdstmember = datas->devicetype_tmp;*/\n\tif(dstmember)\n\t{\n\t\tif(l>=MINIUPNPC_URL_MAXSIZE)\n\t\t\tl = MINIUPNPC_URL_MAXSIZE-1;\n\t\tmemcpy(dstmember, data, l);\n\t\tdstmember[l] = '\\0';\n\t}\n}\n\n#ifdef DEBUG\nvoid printIGD(struct IGDdatas * d)\n{\n\tprintf(\"urlbase = '%s'\\n\", d->urlbase);\n\tprintf(\"WAN Device (Common interface config) :\\n\");\n\t/*printf(\" deviceType = '%s'\\n\", d->CIF.devicetype);*/\n\tprintf(\" serviceType = '%s'\\n\", d->CIF.servicetype);\n\tprintf(\" controlURL = '%s'\\n\", d->CIF.controlurl);\n\tprintf(\" eventSubURL = '%s'\\n\", d->CIF.eventsuburl);\n\tprintf(\" SCPDURL = '%s'\\n\", d->CIF.scpdurl);\n\tprintf(\"primary WAN Connection Device (IP or PPP Connection):\\n\");\n\t/*printf(\" deviceType = '%s'\\n\", d->first.devicetype);*/\n\tprintf(\" servicetype = '%s'\\n\", d->first.servicetype);\n\tprintf(\" controlURL = '%s'\\n\", d->first.controlurl);\n\tprintf(\" eventSubURL = '%s'\\n\", d->first.eventsuburl);\n\tprintf(\" SCPDURL = '%s'\\n\", d->first.scpdurl);\n\tprintf(\"secondary WAN Connection Device (IP or PPP Connection):\\n\");\n\t/*printf(\" deviceType = '%s'\\n\", d->second.devicetype);*/\n\tprintf(\" servicetype = '%s'\\n\", d->second.servicetype);\n\tprintf(\" controlURL = '%s'\\n\", d->second.controlurl);\n\tprintf(\" eventSubURL = '%s'\\n\", d->second.eventsuburl);\n\tprintf(\" SCPDURL = '%s'\\n\", d->second.scpdurl);\n\tprintf(\"WAN IPv6 Firewall Control :\\n\");\n\t/*printf(\" deviceType = '%s'\\n\", d->IPv6FC.devicetype);*/\n\tprintf(\" servicetype = '%s'\\n\", d->IPv6FC.servicetype);\n\tprintf(\" controlURL = '%s'\\n\", d->IPv6FC.controlurl);\n\tprintf(\" eventSubURL = '%s'\\n\", d->IPv6FC.eventsuburl);\n\tprintf(\" SCPDURL = '%s'\\n\", d->IPv6FC.scpdurl);\n}\n#endif /* DEBUG */\n\n\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_979.c",
        "project": "miniupnp/miniupnp",
        "url": "https://github.com/miniupnp/miniupnp/commit/79cca974a4c2ab1199786732a67ff6d898051b78",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int snd_seq_device_new(struct snd_card *card, int device, const char *id,\n\t\t       int argsize, struct snd_seq_device **result)\n\tstatic struct snd_device_ops dops = {\n\t\t.dev_free = snd_seq_device_dev_free,\n\t\t.dev_register = snd_seq_device_dev_register,\n\t\t.dev_disconnect = snd_seq_device_dev_disconnect,\n\tif (result)\n\t\t*result = NULL;\n\tif (snd_BUG_ON(!id))\n\t\treturn -EINVAL;\n\tdev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->card = card;\n\tdev->device = device;\n\tdev->id = id;\n\tdev->argsize = argsize;\n\tdevice_initialize(&dev->dev);\n\tdev->dev.parent = &card->card_dev;\n\tdev->dev.bus = &snd_seq_bus_type;\n\tdev->dev.release = snd_seq_dev_release;\n\tdev_set_name(&dev->dev, \"%s-%d-%d\", dev->id, card->number, device);\n\terr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/seq_device.h>\n#include <sound/seq_kernel.h>\n#include <sound/initval.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ALSA sequencer device management\");\nMODULE_LICENSE(\"GPL\");\nstatic struct bus_type snd_seq_bus_type = {\n\t.name = \"snd_seq\",\n\t.match = snd_seq_bus_match,\n};\n#ifdef CONFIG_SND_PROC_FS\nstatic struct snd_info_entry *info_entry;\nstatic int print_dev_info(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tstruct snd_info_buffer *buffer = data;\n\tsnd_iprintf(buffer, \"snd-%s,%s,%d\\n\", sdev->id,\n\t\t    dev->driver ? \"loaded\" : \"empty\",\n\t\t    dev->driver ? 1 : 0);\n\treturn 0;\n}\nstatic void snd_seq_device_info(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tbus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);\n}\n#endif\n#ifdef CONFIG_MODULES\nstatic atomic_t snd_seq_in_init = ATOMIC_INIT(1); \nstatic int request_seq_drv(struct device *dev, void *data)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\tif (!dev->driver)\n\t\trequest_module(\"snd-%s\", sdev->id);\n\treturn 0;\n}\nstatic void autoload_drivers(struct work_struct *work)\n{\n\tif (atomic_inc_return(&snd_seq_in_init) == 1)\n\t\tbus_for_each_dev(&snd_seq_bus_type, NULL, NULL,\n\t\t\t\t request_seq_drv);\n\tatomic_dec(&snd_seq_in_init);\n}\nstatic DECLARE_WORK(autoload_work, autoload_drivers);\nstatic void queue_autoload_drivers(void)\n{\n\tschedule_work(&autoload_work);\n}\nvoid snd_seq_autoload_init(void)\n{\n\tatomic_dec(&snd_seq_in_init);\n#ifdef CONFIG_SND_SEQUENCER_MODULE\n\tqueue_autoload_drivers();\n#endif\n}\nEXPORT_SYMBOL(snd_seq_autoload_init);\nvoid snd_seq_autoload_exit(void)\n{\n\tatomic_inc(&snd_seq_in_init);\n}\nEXPORT_SYMBOL(snd_seq_autoload_exit);\nvoid snd_seq_device_load_drivers(void)\n{\n\tqueue_autoload_drivers();\n\tflush_work(&autoload_work);\n}\nEXPORT_SYMBOL(snd_seq_device_load_drivers);\n#else\n#define queue_autoload_drivers() \n#endif\nstatic int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tput_device(&dev->dev);\n\treturn 0;\n}\nint snd_seq_device_new(struct snd_card *card, int device, const char *id,\n\t\t       int argsize, struct snd_seq_device **result)\n{\n\tstruct snd_seq_device *dev;\n\tint err;\n\tstatic struct snd_device_ops dops = {\n\t\t.dev_free = snd_seq_device_dev_free,\n\t\t.dev_register = snd_seq_device_dev_register,\n\t\t.dev_disconnect = snd_seq_device_dev_disconnect,\n\t};\n\tif (result)\n\t\t*result = NULL;\n\tif (snd_BUG_ON(!id))\n\t\treturn -EINVAL;\n\tdev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->card = card;\n\tdev->device = device;\n\tdev->id = id;\n\tdev->argsize = argsize;\n\tdevice_initialize(&dev->dev);\n\tdev->dev.parent = &card->card_dev;\n\tdev->dev.bus = &snd_seq_bus_type;\n\tdev->dev.release = snd_seq_dev_release;\n\tdev_set_name(&dev->dev, \"%s-%d-%d\", dev->id, card->number, device);\n\terr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\n\tif (err < 0) {\n\t\tput_device(&dev->dev);\n\t\treturn err;\n\t}\n\tif (result)\n\t\t*result = dev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_seq_driver_unregister);\nstatic int __init seq_dev_proc_init(void)\n{\n#ifdef CONFIG_SND_PROC_FS\n\tinfo_entry = snd_info_create_module_entry(THIS_MODULE, \"drivers\",\n\t\t\t\t\t\t  snd_seq_root);\n\tif (info_entry == NULL)\n\t\treturn -ENOMEM;\n\tinfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\n\tinfo_entry->c.text.read = snd_seq_device_info;\n\tif (snd_info_register(info_entry) < 0) {\n\t\tsnd_info_free_entry(info_entry);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\nstatic int __init alsa_seq_device_init(void)\n{\n\tint err;\n\terr = bus_register(&snd_seq_bus_type);\n\tif (err < 0)\n\t\treturn err;\n\terr = seq_dev_proc_init();\n\tif (err < 0)\n\t\tbus_unregister(&snd_seq_bus_type);\n\treturn err;\n}\nstatic void __exit alsa_seq_device_exit(void)\n{\n#ifdef CONFIG_MODULES\n\tcancel_work_sync(&autoload_work);\n#endif\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_info_free_entry(info_entry);\n#endif\n\tbus_unregister(&snd_seq_bus_type);\n}\nmodule_exit(alsa_seq_device_exit)\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_2565.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize)\n\tstruct device *dev = &port->dev;\n\tdev_dbg(dev, \"%s - command %d\\n\", __func__, command);\n\ttransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\n\ttransfer_buffer[0] = command;\n\tmemcpy(&transfer_buffer[1], data, datasize);\nstatic void firm_setup_port(struct tty_struct *tty)\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tport_settings.port = port->port_number + 1;\n\tcase CS5:\tport_settings.bits = 5;   break;\n\tcase CS6:\tport_settings.bits = 6;   break;\n\tcase CS7:\tport_settings.bits = 7;   break;\n\tcase CS8:\tport_settings.bits = 8;   break;\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\tport_settings.baud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, port_settings.baud);\n\ttty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\n\tport_settings.lloop = 0;\n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <asm/termbits.h>\n#include <linux/usb.h>\n#include <linux/serial_reg.h>\n#include <linux/serial.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n#include \"whiteheat.h\"\t\t\t\n#ifndef CMSPAR\n#define CMSPAR 0\n#endif\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Stuart MacDonald <stuartm@connecttech.com>\"\n#define DRIVER_DESC \"USB ConnectTech WhiteHEAT driver\"\n#define CONNECT_TECH_VENDOR_ID\t\t0x0710\n#define CONNECT_TECH_FAKE_WHITE_HEAT_ID\t0x0001\n#define CONNECT_TECH_WHITE_HEAT_ID\t0x8001\nstatic const struct usb_device_id id_table_std[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t\n};\nstatic const struct usb_device_id id_table_prerenumeration[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t\n};\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t\n};\nstatic int  whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  whiteheat_firmware_attach(struct usb_serial *serial);\nstatic int  whiteheat_attach(struct usb_serial *serial);\nstatic void whiteheat_release(struct usb_serial *serial);\nstatic int  whiteheat_port_probe(struct usb_serial_port *port);\nstatic int  whiteheat_port_remove(struct usb_serial_port *port);\nstatic int  whiteheat_open(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port);\nstatic void whiteheat_close(struct usb_serial_port *port);\nstatic int  whiteheat_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg);\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port, struct ktermios *old);\nstatic int  whiteheat_tiocmget(struct tty_struct *tty);\nstatic int  whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state);\nstatic struct usb_serial_driver whiteheat_fake_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheatnofirm\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT - (prerenumeration)\",\n\t.id_table =\t\tid_table_prerenumeration,\n\t.num_ports =\t\t1,\n\t.probe =\t\twhiteheat_firmware_download,\n\t.attach =\t\twhiteheat_firmware_attach,\n};\nstatic struct usb_serial_driver whiteheat_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheat\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT\",\n\t.id_table =\t\tid_table_std,\n\t.num_ports =\t\t4,\n\t.attach =\t\twhiteheat_attach,\n\t.release =\t\twhiteheat_release,\n\t.port_probe =\t\twhiteheat_port_probe,\n\t.port_remove =\t\twhiteheat_port_remove,\n\t.open =\t\t\twhiteheat_open,\n\t.close =\t\twhiteheat_close,\n\t.ioctl =\t\twhiteheat_ioctl,\n\t.set_termios =\t\twhiteheat_set_termios,\n\t.break_ctl =\t\twhiteheat_break_ctl,\n\t.tiocmget =\t\twhiteheat_tiocmget,\n\t.tiocmset =\t\twhiteheat_tiocmset,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n};\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&whiteheat_fake_device, &whiteheat_device, NULL\n};\nstruct whiteheat_command_private {\n\tstruct mutex\t\tmutex;\n\t__u8\t\t\tport_running;\n\t__u8\t\t\tcommand_finished;\n\twait_queue_head_t\twait_command; \n\t__u8\t\t\tresult_buffer[64];\n};\nstruct whiteheat_private {\n\t__u8\t\t\tmcr;\t\t\n};\nstatic int start_command_port(struct usb_serial *serial);\nstatic void stop_command_port(struct usb_serial *serial);\nstatic void command_port_write_callback(struct urb *urb);\nstatic void command_port_read_callback(struct urb *urb);\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize);\nstatic int firm_open(struct usb_serial_port *port);\nstatic int firm_close(struct usb_serial_port *port);\nstatic void firm_setup_port(struct tty_struct *tty);\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx);\nstatic int firm_get_dtr_rts(struct usb_serial_port *port);\nstatic int firm_report_tx_done(struct usb_serial_port *port);\n#define COMMAND_PORT\t\t4\n#define COMMAND_TIMEOUT\t\t(2*HZ)\t\n#define\tCOMMAND_TIMEOUT_MS\t2000\n#define CLOSING_DELAY\t\t(30 * HZ)\nstatic int whiteheat_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\tcommand_port = serial->port[COMMAND_PORT];\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\treturn 0;\nno_firmware:\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\nstatic void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - empty response, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&\n\t\t(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_private *info;\n\tstruct device *dev = &port->dev;\n\t__u8 *transfer_buffer;\n\tint retval = 0;\n\tint t;\n\tdev_dbg(dev, \"%s - command %d\\n\", __func__, command);\n\tcommand_port = port->serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->command_finished = false;\n\ttransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\n\ttransfer_buffer[0] = command;\n\tmemcpy(&transfer_buffer[1], data, datasize);\n\tcommand_port->write_urb->transfer_buffer_length = datasize + 1;\n\tretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\n\tif (retval) {\n\t\tdev_dbg(dev, \"%s - submit urb failed\\n\", __func__);\n\t\tgoto exit;\n\t}\n\tt = wait_event_timeout(command_info->wait_command,\n\t\t(bool)command_info->command_finished, COMMAND_TIMEOUT);\n\tif (!t)\n\t\tusb_kill_urb(command_port->write_urb);\n\tif (command_info->command_finished == false) {\n\t\tdev_dbg(dev, \"%s - command timed out.\\n\", __func__);\n\t\tretval = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\tif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\n\t\tdev_dbg(dev, \"%s - command failed.\\n\", __func__);\n\t\tretval = -EIO;\n\t\tgoto exit;\n\t}\n\tif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\n\t\tdev_dbg(dev, \"%s - command completed.\\n\", __func__);\n\t\tswitch (command) {\n\t\tcase WHITEHEAT_GET_DTR_RTS:\n\t\t\tinfo = usb_get_serial_port_data(port);\n\t\t\tmemcpy(&info->mcr, command_info->result_buffer,\n\t\t\t\t\tsizeof(struct whiteheat_dr_info));\n\t\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\nstatic void firm_setup_port(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct whiteheat_port_settings port_settings;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tport_settings.port = port->port_number + 1;\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\tport_settings.bits = 5;   break;\n\tcase CS6:\tport_settings.bits = 6;   break;\n\tcase CS7:\tport_settings.bits = 7;   break;\n\tdefault:\n\tcase CS8:\tport_settings.bits = 8;   break;\n\t}\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\tport_settings.baud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, port_settings.baud);\n\ttty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\n\tport_settings.lloop = 0;\n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n}\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"whiteheat.fw\");\nMODULE_FIRMWARE(\"whiteheat_loader.fw\");\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_701.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static u8 nci_core_init_rsp_packet_v2(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n\tconst struct nci_core_init_rsp_nci_ver2 *rsp = (void *)skb->data;\n\tconst u8 *supported_rf_interface = rsp->supported_rf_interfaces;\n\tu8 rf_interface_idx = 0;\n\tu8 rf_extension_cnt = 0;\n\tpr_debug(\"status %x\\n\", rsp->status);\n\tif (rsp->status != NCI_STATUS_OK)\n\t\treturn rsp->status;\n\tndev->nfcc_features = __le32_to_cpu(rsp->nfcc_features);\n\tndev->num_supported_rf_interfaces = rsp->num_supported_rf_interfaces;\n\t\t    NCI_MAX_SUPPORTED_RF_INTERFACES);\n\tndev->max_logical_connections = rsp->max_logical_connections;\n\t\t\t__le16_to_cpu(rsp->max_routing_table_size);\n\t\t\trsp->max_ctrl_pkt_payload_len;\n\tndev->max_size_for_large_params = NCI_MAX_LARGE_PARAMS_NCI_v2;\n\treturn NCI_STATUS_OK;\nstatic void nci_core_init_rsp_packet(struct nci_dev *ndev, const struct sk_buff *skb)\n\tif (!(ndev->nci_ver & NCI_VER_2_MASK))\n\t\tstatus = nci_core_init_rsp_packet_v1(ndev, skb);\n\telse\n\t\tstatus = nci_core_init_rsp_packet_v2(ndev, skb);\nvoid nci_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)\n\t__u16 rsp_opcode = nci_opcode(skb->data);\n\tdel_timer(&ndev->cmd_timer);\n\t\t nci_pbf(skb->data),\n\t\t nci_plen(skb->data));\n\tskb_pull(skb, NCI_CTRL_HDR_SIZE);\n\t\tnci_core_init_rsp_packet(ndev, skb);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\nstatic u8 nci_core_init_rsp_packet_v1(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\tconst struct nci_core_init_rsp_1 *rsp_1 = (void *)skb->data;\n\tconst struct nci_core_init_rsp_2 *rsp_2;\n\tpr_debug(\"status 0x%x\\n\", rsp_1->status);\n\tif (rsp_1->status != NCI_STATUS_OK)\n\t\treturn rsp_1->status;\n\tndev->nfcc_features = __le32_to_cpu(rsp_1->nfcc_features);\n\tndev->num_supported_rf_interfaces = rsp_1->num_supported_rf_interfaces;\n\tndev->num_supported_rf_interfaces =\n\t\tmin((int)ndev->num_supported_rf_interfaces,\n\t\t    NCI_MAX_SUPPORTED_RF_INTERFACES);\n\tmemcpy(ndev->supported_rf_interfaces,\n\t       rsp_1->supported_rf_interfaces,\n\t       ndev->num_supported_rf_interfaces);\n\trsp_2 = (void *) (skb->data + 6 + rsp_1->num_supported_rf_interfaces);\n\tndev->max_logical_connections = rsp_2->max_logical_connections;\n\tndev->max_routing_table_size =\n\t\t__le16_to_cpu(rsp_2->max_routing_table_size);\n\tndev->max_ctrl_pkt_payload_len =\n\t\trsp_2->max_ctrl_pkt_payload_len;\n\tndev->max_size_for_large_params =\n\t\t__le16_to_cpu(rsp_2->max_size_for_large_params);\n\tndev->manufact_id =\n\t\trsp_2->manufact_id;\n\tndev->manufact_specific_info =\n\t\t__le32_to_cpu(rsp_2->manufact_specific_info);\n\treturn NCI_STATUS_OK;\n}\nstatic u8 nci_core_init_rsp_packet_v2(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\tconst struct nci_core_init_rsp_nci_ver2 *rsp = (void *)skb->data;\n\tconst u8 *supported_rf_interface = rsp->supported_rf_interfaces;\n\tu8 rf_interface_idx = 0;\n\tu8 rf_extension_cnt = 0;\n\tpr_debug(\"status %x\\n\", rsp->status);\n\tif (rsp->status != NCI_STATUS_OK)\n\t\treturn rsp->status;\n\tndev->nfcc_features = __le32_to_cpu(rsp->nfcc_features);\n\tndev->num_supported_rf_interfaces = rsp->num_supported_rf_interfaces;\n\tndev->num_supported_rf_interfaces =\n\t\tmin((int)ndev->num_supported_rf_interfaces,\n\t\t    NCI_MAX_SUPPORTED_RF_INTERFACES);\n\twhile (rf_interface_idx < ndev->num_supported_rf_interfaces) {\n\t\tndev->supported_rf_interfaces[rf_interface_idx++] = *supported_rf_interface++;\n\t\trf_extension_cnt = *supported_rf_interface++;\n\t\tsupported_rf_interface += rf_extension_cnt;\n\t}\n\tndev->max_logical_connections = rsp->max_logical_connections;\n\tndev->max_routing_table_size =\n\t\t\t__le16_to_cpu(rsp->max_routing_table_size);\n\tndev->max_ctrl_pkt_payload_len =\n\t\t\trsp->max_ctrl_pkt_payload_len;\n\tndev->max_size_for_large_params = NCI_MAX_LARGE_PARAMS_NCI_v2;\n\treturn NCI_STATUS_OK;\n}\nstatic void nci_core_init_rsp_packet(struct nci_dev *ndev, const struct sk_buff *skb)\n{\n\tu8 status = 0;\n\tif (!(ndev->nci_ver & NCI_VER_2_MASK))\n\t\tstatus = nci_core_init_rsp_packet_v1(ndev, skb);\n\telse\n\t\tstatus = nci_core_init_rsp_packet_v2(ndev, skb);\n\tif (status != NCI_STATUS_OK)\n\t\tgoto exit;\n\tpr_debug(\"nfcc_features 0x%x\\n\",\n\t\t ndev->nfcc_features);\n\tpr_debug(\"num_supported_rf_interfaces %d\\n\",\n\t\t ndev->num_supported_rf_interfaces);\n\tpr_debug(\"supported_rf_interfaces[0] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[0]);\n\tpr_debug(\"supported_rf_interfaces[1] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[1]);\n\tpr_debug(\"supported_rf_interfaces[2] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[2]);\n\tpr_debug(\"supported_rf_interfaces[3] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[3]);\n\tpr_debug(\"max_logical_connections %d\\n\",\n\t\t ndev->max_logical_connections);\n\tpr_debug(\"max_routing_table_size %d\\n\",\n\t\t ndev->max_routing_table_size);\n\tpr_debug(\"max_ctrl_pkt_payload_len %d\\n\",\n\t\t ndev->max_ctrl_pkt_payload_len);\n\tpr_debug(\"max_size_for_large_params %d\\n\",\n\t\t ndev->max_size_for_large_params);\n\tpr_debug(\"manufact_id 0x%x\\n\",\n\t\t ndev->manufact_id);\n\tpr_debug(\"manufact_specific_info 0x%x\\n\",\n\t\t ndev->manufact_specific_info);\nexit:\n\tnci_req_complete(ndev, status);\n}\nstatic void nci_core_conn_create_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t    const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\tstruct nci_conn_info *conn_info = NULL;\n\tconst struct nci_core_conn_create_rsp *rsp;\n\tpr_debug(\"status 0x%x\\n\", status);\n\tif (status == NCI_STATUS_OK) {\n\t\trsp = (struct nci_core_conn_create_rsp *)skb->data;\n\t\tconn_info = devm_kzalloc(&ndev->nfc_dev->dev,\n\t\t\t\t\t sizeof(*conn_info), GFP_KERNEL);\n\t\tif (!conn_info) {\n\t\t\tstatus = NCI_STATUS_REJECTED;\n\t\t\tgoto exit;\n\t\t}\n\t\tconn_info->dest_params = devm_kzalloc(&ndev->nfc_dev->dev,\n\t\t\t\t\t\tsizeof(struct dest_spec_params),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!conn_info->dest_params) {\n\t\t\tstatus = NCI_STATUS_REJECTED;\n\t\t\tgoto free_conn_info;\n\t\t}\n\t\tconn_info->dest_type = ndev->cur_dest_type;\n\t\tconn_info->dest_params->id = ndev->cur_params.id;\n\t\tconn_info->dest_params->protocol = ndev->cur_params.protocol;\n\t\tconn_info->conn_id = rsp->conn_id;\n\t\tINIT_LIST_HEAD(&conn_info->list);\n\t\tlist_add(&conn_info->list, &ndev->conn_info_list);\n\t\tif (ndev->cur_params.id == ndev->hci_dev->nfcee_id)\n\t\t\tndev->hci_dev->conn_info = conn_info;\n\t\tconn_info->conn_id = rsp->conn_id;\n\t\tconn_info->max_pkt_payload_len = rsp->max_ctrl_pkt_payload_len;\n\t\tatomic_set(&conn_info->credits_cnt, rsp->credits_cnt);\n\t}\nfree_conn_info:\n\tif (status == NCI_STATUS_REJECTED)\n\t\tdevm_kfree(&ndev->nfc_dev->dev, conn_info);\nexit:\n\tnci_req_complete(ndev, status);\n}\nstatic void nci_core_conn_close_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t   const struct sk_buff *skb)\n{\n\tstruct nci_conn_info *conn_info;\n\t__u8 status = skb->data[0];\n\tpr_debug(\"status 0x%x\\n\", status);\n\tif (status == NCI_STATUS_OK) {\n\t\tconn_info = nci_get_conn_info_by_conn_id(ndev,\n\t\t\t\t\t\t\t ndev->cur_conn_id);\n\t\tif (conn_info) {\n\t\t\tlist_del(&conn_info->list);\n\t\t\tdevm_kfree(&ndev->nfc_dev->dev, conn_info);\n\t\t}\n\t}\n\tnci_req_complete(ndev, status);\n}\nvoid nci_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\t__u16 rsp_opcode = nci_opcode(skb->data);\n\tdel_timer(&ndev->cmd_timer);\n\tpr_debug(\"NCI RX: MT=rsp, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\\n\",\n\t\t nci_pbf(skb->data),\n\t\t nci_opcode_gid(rsp_opcode),\n\t\t nci_opcode_oid(rsp_opcode),\n\t\t nci_plen(skb->data));\n\tskb_pull(skb, NCI_CTRL_HDR_SIZE);\n\tif (nci_opcode_gid(rsp_opcode) == NCI_GID_PROPRIETARY) {\n\t\tif (nci_prop_rsp_packet(ndev, rsp_opcode, skb) == -ENOTSUPP) {\n\t\t\tpr_err(\"unsupported rsp opcode 0x%x\\n\",\n\t\t\t       rsp_opcode);\n\t\t}\n\t\tgoto end;\n\t}\n\tswitch (rsp_opcode) {\n\tcase NCI_OP_CORE_RESET_RSP:\n\t\tnci_core_reset_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_CORE_INIT_RSP:\n\t\tnci_core_init_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_CORE_SET_CONFIG_RSP:\n\t\tnci_core_set_config_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_CORE_CONN_CREATE_RSP:\n\t\tnci_core_conn_create_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_CORE_CONN_CLOSE_RSP:\n\t\tnci_core_conn_close_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_RF_DISCOVER_MAP_RSP:\n\t\tnci_rf_disc_map_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_RF_DISCOVER_RSP:\n\t\tnci_rf_disc_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_RF_DISCOVER_SELECT_RSP:\n\t\tnci_rf_disc_select_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_RF_DEACTIVATE_RSP:\n\t\tnci_rf_deactivate_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_NFCEE_DISCOVER_RSP:\n\t\tnci_nfcee_discover_rsp_packet(ndev, skb);\n\t\tbreak;\n\tcase NCI_OP_NFCEE_MODE_SET_RSP:\n\t\tnci_nfcee_mode_set_rsp_packet(ndev, skb);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown rsp opcode 0x%x\\n\", rsp_opcode);\n\t\tbreak;\n\t}\n\tnci_core_rsp_packet(ndev, rsp_opcode, skb);\nend:\n\tkfree_skb(skb);\n\tatomic_set(&ndev->cmd_cnt, 1);\n\tif (!skb_queue_empty(&ndev->cmd_q))\n\t\tqueue_work(ndev->cmd_wq, &ndev->cmd_work);\n}\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_7361.c",
        "project": "gregkh/linux",
        "url": "https://github.com/gregkh/linux/commit/1b1499a817c90fd1ce9453a2c98d2a01cca0e775",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```  char *url = NULL, *p = NULL;\n  struct Connection *conn = NULL;\n  struct Message *msg = NULL;\n  struct PopData *pop_data = NULL;\n  if (!PopHost)\n    return;\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  ret = pop_parse_path(url, &acct);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  if (pop_open_connection(pop_data) < 0)\n    return;\n  conn->data = pop_data;\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"config.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"format_flags.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mutt_window.h\"\n#include \"mx.h\"\n#include \"nntp.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\nstruct BodyCache;\nint nntp_newsrc_parse(struct NntpServer *nserv)\n{\n  char *line = NULL;\n  struct stat sb;\n  if (nserv->newsrc_fp)\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  else\n  {\n    nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"a\");\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"r\");\n  if (!nserv->newsrc_fp)\n  {\n    mutt_perror(nserv->newsrc_file);\n    return -1;\n  }\n  mutt_debug(1, \"Locking %s\\n\", nserv->newsrc_file);\n  if (mutt_file_lock(fileno(nserv->newsrc_fp), 0, 1))\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n    return -1;\n  }\n  if (stat(nserv->newsrc_file, &sb))\n  {\n    mutt_perror(nserv->newsrc_file);\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)\n    return 0;\n  nserv->size = sb.st_size;\n  nserv->mtime = sb.st_mtime;\n  nserv->newsrc_modified = true;\n  mutt_debug(1, \"Parsing %s\\n\", nserv->newsrc_file);\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n    if (!nntp_data)\n      continue;\n    nntp_data->subscribed = false;\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n  line = mutt_mem_malloc(sb.st_size + 1);\n  while (sb.st_size && fgets(line, sb.st_size + 1, nserv->newsrc_fp))\n  {\n    char *b = NULL, *h = NULL;\n    unsigned int j = 1;\n    bool subs = false;\n    char *p = strpbrk(line, \":!\");\n    if (!p)\n      continue;\n    if (*p == ':')\n      subs = true;\n    *p++ = '\\0';\n    struct NntpData *nntp_data = nntp_data_find(nserv, line);\n    FREE(&nntp_data->newsrc_ent);\n    b = p;\n    while (*b)\n      if (*b++ == ',')\n        j++;\n    nntp_data->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));\n    nntp_data->subscribed = subs;\n    j = 0;\n    while (p)\n    {\n      b = p;\n      p = strchr(p, ',');\n      if (p)\n        *p++ = '\\0';\n      h = strchr(b, '-');\n      if (h)\n        *h++ = '\\0';\n      else\n        h = b;\n      if (sscanf(b, ANUM, &nntp_data->newsrc_ent[j].first) == 1 &&\n          sscanf(h, ANUM, &nntp_data->newsrc_ent[j].last) == 1)\n      {\n        j++;\n      }\n    }\n    if (j == 0)\n    {\n      nntp_data->newsrc_ent[j].first = 1;\n      nntp_data->newsrc_ent[j].last = 0;\n      j++;\n    }\n    if (nntp_data->last_message == 0)\n      nntp_data->last_message = nntp_data->newsrc_ent[j - 1].last;\n    nntp_data->newsrc_len = j;\n    mutt_mem_realloc(&nntp_data->newsrc_ent, j * sizeof(struct NewsrcEntry));\n    nntp_group_unread_stat(nntp_data);\n    mutt_debug(2, \"%s\\n\", nntp_data->group);\n  }\n  FREE(&line);\n  return 1;\n}\nvoid nntp_newsrc_gen_entries(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  anum_t last = 0, first = 1;\n  bool series;\n  int save_sort = SORT_ORDER;\n  unsigned int entries;\n  if (Sort != SORT_ORDER)\n  {\n    save_sort = Sort;\n    Sort = SORT_ORDER;\n    mutt_sort_headers(ctx, 0);\n  }\n  entries = nntp_data->newsrc_len;\n  if (!entries)\n  {\n    entries = 5;\n    nntp_data->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));\n  }\n  nntp_data->newsrc_len = 0;\n  series = true;\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    if (series)\n    {\n      last = NHDR(ctx->hdrs[i])->article_num;\n      if (last >= nntp_data->first_message && !ctx->hdrs[i]->deleted &&\n          !ctx->hdrs[i]->read)\n      {\n        if (nntp_data->newsrc_len >= entries)\n        {\n          entries *= 2;\n          mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n        }\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;\n        nntp_data->newsrc_len++;\n        series = false;\n      }\n    }\n    else\n    {\n      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)\n      {\n        first = last + 1;\n        series = true;\n      }\n      last = NHDR(ctx->hdrs[i])->article_num;\n    }\n  }\n  if (series && first <= nntp_data->last_loaded)\n  {\n    if (nntp_data->newsrc_len >= entries)\n    {\n      entries++;\n      mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n    }\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->last_loaded;\n    nntp_data->newsrc_len++;\n  }\n  mutt_mem_realloc(&nntp_data->newsrc_ent, nntp_data->newsrc_len * sizeof(struct NewsrcEntry));\n  if (save_sort != Sort)\n  {\n    Sort = save_sort;\n    mutt_sort_headers(ctx, 0);\n  }\n}\nstatic int update_file(char *filename, char *buf)\n{\n  FILE *fp = NULL;\n  char tmpfile[PATH_MAX];\n  int rc = -1;\n  while (true)\n  {\n    snprintf(tmpfile, sizeof(tmpfile), \"%s.tmp\", filename);\n    fp = mutt_file_fopen(tmpfile, \"w\");\n    if (!fp)\n    {\n      mutt_perror(tmpfile);\n      *tmpfile = '\\0';\n      break;\n    }\n    if (fputs(buf, fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      break;\n    }\n    if (mutt_file_fclose(&fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      fp = NULL;\n      break;\n    }\n    fp = NULL;\n    if (rename(tmpfile, filename) < 0)\n    {\n      mutt_perror(filename);\n      break;\n    }\n    *tmpfile = '\\0';\n    rc = 0;\n    break;\n  }\n  if (fp)\n    mutt_file_fclose(&fp);\n  if (*tmpfile)\n    unlink(tmpfile);\n  return rc;\n}\nint nntp_newsrc_update(struct NntpServer *nserv)\n{\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc = -1;\n  if (!nserv)\n    return -1;\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  off = 0;\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n    if (!nntp_data || !nntp_data->newsrc_ent)\n      continue;\n    if (off + strlen(nntp_data->group) + 3 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s%c \", nntp_data->group,\n             nntp_data->subscribed ? ':' : '!');\n    off += strlen(buf + off);\n    for (unsigned int j = 0; j < nntp_data->newsrc_len; j++)\n    {\n      if (off + LONG_STRING > buflen)\n      {\n        buflen *= 2;\n        mutt_mem_realloc(&buf, buflen);\n      }\n      if (j)\n        buf[off++] = ',';\n      if (nntp_data->newsrc_ent[j].first == nntp_data->newsrc_ent[j].last)\n        snprintf(buf + off, buflen - off, \"%u\", nntp_data->newsrc_ent[j].first);\n      else if (nntp_data->newsrc_ent[j].first < nntp_data->newsrc_ent[j].last)\n      {\n        snprintf(buf + off, buflen - off, \"%u-%u\",\n                 nntp_data->newsrc_ent[j].first, nntp_data->newsrc_ent[j].last);\n      }\n      off += strlen(buf + off);\n    }\n    buf[off++] = '\\n';\n  }\n  buf[off] = '\\0';\n  mutt_debug(1, \"Updating %s\\n\", nserv->newsrc_file);\n  if (nserv->newsrc_file && update_file(nserv->newsrc_file, buf) == 0)\n  {\n    struct stat sb;\n    rc = stat(nserv->newsrc_file, &sb);\n    if (rc == 0)\n    {\n      nserv->size = sb.st_size;\n      nserv->mtime = sb.st_mtime;\n    }\n    else\n    {\n      mutt_perror(nserv->newsrc_file);\n    }\n  }\n  FREE(&buf);\n  return rc;\n}\nstatic void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)\n{\n  char *c = NULL;\n  char file[PATH_MAX];\n  if (acct)\n  {\n    struct Url url;\n    mutt_account_tourl(acct, &url);\n    url.path = src;\n    url_tostring(&url, file, sizeof(file), U_PATH);\n  }\n  else\n    mutt_str_strfcpy(file, src ? src : \"\", sizeof(file));\n  snprintf(dst, dstlen, \"%s/%s\", NewsCacheDir, file);\n  c = dst + strlen(dst) - 1;\n  if (*c == '/')\n    *c = '\\0';\n  mutt_expand_path(dst, dstlen);\n  mutt_encode_path(dst, dstlen, dst);\n}\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING] = \"\";\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)\n  {\n    mutt_debug(4, \"Cannot parse server line: %s\\n\", line);\n    return 0;\n  }\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\nint nntp_active_save_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc;\n  if (!nserv->cacheable)\n    return 0;\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  snprintf(buf, buflen, \"%lu\\n\", (unsigned long) nserv->newgroups_time);\n  off = strlen(buf);\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n    if (!nntp_data || nntp_data->deleted)\n      continue;\n    if (off + strlen(nntp_data->group) + (nntp_data->desc ? strlen(nntp_data->desc) : 0) + 50 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s %u %u %c%s%s\\n\", nntp_data->group,\n             nntp_data->last_message, nntp_data->first_message,\n             nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? \" \" : \"\",\n             nntp_data->desc ? nntp_data->desc : \"\");\n    off += strlen(buf + off);\n  }\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Updating %s\\n\", file);\n  rc = update_file(file, buf);\n  FREE(&buf);\n  return rc;\n}\n#ifdef USE_HCACHE\nstatic int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}\nheader_cache_t *nntp_hcache_open(struct NntpData *nntp_data)\n{\n  struct Url url;\n  char file[PATH_MAX];\n  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||\n      !nntp_data->nserv->conn || !nntp_data->group ||\n      !(nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n  {\n    return NULL;\n  }\n  mutt_account_tourl(&nntp_data->nserv->conn->account, &url);\n  url.path = nntp_data->group;\n  url_tostring(&url, file, sizeof(file), U_PATH);\n  return mutt_hcache_open(NewsCacheDir, file, nntp_hcache_namer);\n}\nvoid nntp_hcache_update(struct NntpData *nntp_data, header_cache_t *hc)\n{\n  char buf[16];\n  bool old = false;\n  void *hdata = NULL;\n  anum_t first = 0, last = 0;\n  if (!hc)\n    return;\n  hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n  if (hdata)\n  {\n    mutt_debug(2, \"mutt_hcache_fetch index: %s\\n\", (char *) hdata);\n    if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n    {\n      old = true;\n      nntp_data->last_cached = last;\n      for (anum_t current = first; current <= last; current++)\n      {\n        if (current >= nntp_data->first_message && current <= nntp_data->last_message)\n          continue;\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n        mutt_hcache_delete(hc, buf, strlen(buf));\n      }\n    }\n    mutt_hcache_free(hc, &hdata);\n  }\n  if (!old || nntp_data->first_message != first || nntp_data->last_message != last)\n  {\n    snprintf(buf, sizeof(buf), \"%u %u\", nntp_data->first_message, nntp_data->last_message);\n    mutt_debug(2, \"mutt_hcache_store index: %s\\n\", buf);\n    mutt_hcache_store_raw(hc, \"index\", 5, buf, strlen(buf));\n  }\n}\n#endif\nvoid nntp_clear_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *fp = NULL;\n  struct dirent *entry = NULL;\n  DIR *dp = NULL;\n  if (!nserv || !nserv->cacheable)\n    return;\n  cache_expand(file, sizeof(file), &nserv->conn->account, NULL);\n  dp = opendir(file);\n  if (dp)\n  {\n    mutt_str_strncat(file, sizeof(file), \"/\", 1);\n    fp = file + strlen(file);\n    while ((entry = readdir(dp)))\n    {\n      char *group = entry->d_name;\n      struct stat sb;\n      struct NntpData *nntp_data = NULL;\n      struct NntpData nntp_tmp;\n      if ((mutt_str_strcmp(group, \".\") == 0) || (mutt_str_strcmp(group, \"..\") == 0))\n        continue;\n      *fp = '\\0';\n      mutt_str_strncat(file, sizeof(file), group, strlen(group));\n      if (stat(file, &sb))\n        continue;\n#ifdef USE_HCACHE\n      if (S_ISREG(sb.st_mode))\n      {\n        char *ext = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (mutt_str_strcmp(ext, \".hcache\") != 0))\n          continue;\n        *ext = '\\0';\n      }\n      else\n#endif\n          if (!S_ISDIR(sb.st_mode))\n        continue;\n      nntp_data = mutt_hash_find(nserv->groups_hash, group);\n      if (!nntp_data)\n      {\n        nntp_data = &nntp_tmp;\n        nntp_data->nserv = nserv;\n        nntp_data->group = group;\n        nntp_data->bcache = NULL;\n      }\n      else if (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed)\n        continue;\n      nntp_delete_group_cache(nntp_data);\n      if (S_ISDIR(sb.st_mode))\n      {\n        rmdir(file);\n        mutt_debug(2, \"%s\\n\", file);\n      }\n    }\n    closedir(dp);\n  }\n}\nconst char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,\n                            const char *src, const char *prec, const char *if_str,\n                            const char *else_str, unsigned long data, enum FormatFlag flags)\n{\n  struct NntpServer *nserv = (struct NntpServer *) data;\n  struct Account *acct = &nserv->conn->account;\n  struct Url url;\n  char fn[SHORT_STRING], fmt[SHORT_STRING], *p = NULL;\n  switch (op)\n  {\n    case 'a':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, '/');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'p':\n      snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n      snprintf(buf, buflen, fmt, acct->port);\n      break;\n    case 'P':\n      *buf = '\\0';\n      if (acct->flags & MUTT_ACCT_PORT)\n      {\n        snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n        snprintf(buf, buflen, fmt, acct->port);\n      }\n      break;\n    case 's':\n      strncpy(fn, acct->host, sizeof(fn) - 1);\n      mutt_str_strlower(fn);\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'S':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, ':');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'u':\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, acct->user);\n      break;\n  }\n  return src;\n}\nstruct NntpServer *nntp_select_server(char *server, bool leave_lock)\n{\n  char file[PATH_MAX];\n#ifdef USE_HCACHE\n  char *p = NULL;\n#endif\n  int rc;\n  struct Account acct;\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  struct Connection *conn = NULL;\n  struct Url url;\n  if (!server || !*server)\n  {\n    mutt_error(_(\"No news server defined!\"));\n    return NULL;\n  }\n  acct.flags = 0;\n  acct.port = NNTP_PORT;\n  acct.type = MUTT_ACCT_TYPE_NNTP;\n  snprintf(file, sizeof(file), \"%s%s\", strstr(server, \"://\") ? \"\" : \"news://\", server);\n  if (url_parse(&url, file) < 0 || (url.path && *url.path) ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) || !url.host ||\n      mutt_account_fromurl(&acct, &url) < 0)\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid news server specification!\"), server);\n    return NULL;\n  }\n  if (url.scheme == U_NNTPS)\n  {\n    acct.flags |= MUTT_ACCT_SSL;\n    acct.port = NNTP_SSL_PORT;\n  }\n  url_free(&url);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return NULL;\n  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)\n  {\n    conn->account.flags |= MUTT_ACCT_USER;\n    conn->account.user[0] = '\\0';\n  }\n  nserv = conn->data;\n  if (nserv)\n  {\n    if (nserv->status == NNTP_BYE)\n      nserv->status = NNTP_NONE;\n    if (nntp_open_connection(nserv) < 0)\n      return NULL;\n    rc = nntp_newsrc_parse(nserv);\n    if (rc < 0)\n      return NULL;\n    if (!leave_lock && nntp_check_new_groups(nserv) < 0)\n      rc = -1;\n    if (rc > 0)\n      nntp_clear_cache(nserv);\n    if (rc < 0 || !leave_lock)\n      nntp_newsrc_close(nserv);\n    return (rc < 0) ? NULL : nserv;\n  }\n  nserv = mutt_mem_calloc(1, sizeof(struct NntpServer));\n  nserv->conn = conn;\n  nserv->groups_hash = mutt_hash_create(1009, 0);\n  mutt_hash_set_destructor(nserv->groups_hash, nntp_hash_destructor, 0);\n  nserv->groups_max = 16;\n  nserv->groups_list = mutt_mem_malloc(nserv->groups_max * sizeof(nntp_data));\n  rc = nntp_open_connection(nserv);\n  nserv->cacheable = false;\n  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)\n  {\n    cache_expand(file, sizeof(file), &conn->account, NULL);\n    if (mutt_file_mkdir(file, S_IRWXU) < 0)\n    {\n      mutt_error(_(\"Can't create %s: %s.\"), file, strerror(errno));\n    }\n    nserv->cacheable = true;\n  }\n  if (rc >= 0)\n  {\n    mutt_expando_format(file, sizeof(file), 0, MuttIndexWindow->cols,\n                        NONULL(Newsrc), nntp_format_str, (unsigned long) nserv, 0);\n    mutt_expand_path(file, sizeof(file));\n    nserv->newsrc_file = mutt_str_strdup(file);\n    rc = nntp_newsrc_parse(nserv);\n  }\n  if (rc >= 0)\n  {\n    if (nserv->cacheable && active_get_cache(nserv) == 0)\n      rc = nntp_check_new_groups(nserv);\n    else\n      rc = nntp_active_fetch(nserv, false);\n  }\n  if (rc >= 0)\n    nntp_clear_cache(nserv);\n#ifdef USE_HCACHE\n  if (rc >= 0 && nserv->cacheable)\n  {\n    struct dirent *entry = NULL;\n    DIR *dp = opendir(file);\n    if (dp)\n    {\n      while ((entry = readdir(dp)))\n      {\n        header_cache_t *hc = NULL;\n        void *hdata = NULL;\n        char *group = entry->d_name;\n        p = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (strcmp(p, \".hcache\") != 0))\n          continue;\n        *p = '\\0';\n        nntp_data = mutt_hash_find(nserv->groups_hash, group);\n        if (!nntp_data)\n          continue;\n        hc = nntp_hcache_open(nntp_data);\n        if (!hc)\n          continue;\n        hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n        if (hdata)\n        {\n          anum_t first, last;\n          if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n          {\n            if (nntp_data->deleted)\n            {\n              nntp_data->first_message = first;\n              nntp_data->last_message = last;\n            }\n            if (last >= nntp_data->first_message && last <= nntp_data->last_message)\n            {\n              nntp_data->last_cached = last;\n              mutt_debug(2, \"%s last_cached=%u\\n\", nntp_data->group, last);\n            }\n          }\n          mutt_hcache_free(hc, &hdata);\n        }\n        mutt_hcache_close(hc);\n      }\n      closedir(dp);\n    }\n  }\n#endif\n  if (rc < 0 || !leave_lock)\n    nntp_newsrc_close(nserv);\n  if (rc < 0)\n  {\n    mutt_hash_destroy(&nserv->groups_hash);\n    FREE(&nserv->groups_list);\n    FREE(&nserv->newsrc_file);\n    FREE(&nserv->authenticators);\n    FREE(&nserv);\n    mutt_socket_close(conn);\n    mutt_socket_free(conn);\n    return NULL;\n  }\n  conn->data = nserv;\n  return nserv;\n}\nFile number 2:\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"pop.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n#ifdef USE_HCACHE\n#define HC_FNAME \"neomutt\" \n#define HC_FEXT \"hcache\"   \n#endif\nstatic int pop_read_header(struct PopData *pop_data, struct Header *h)\n{\n  int rc, index;\n  size_t length;\n  char buf[LONG_STRING];\n  FILE *f = mutt_file_mkstemp();\n  if (!f)\n  {\n    mutt_perror(\"mutt_file_mkstemp failed!\");\n    return -3;\n  }\n  snprintf(buf, sizeof(buf), \"LIST %d\\r\\n\", h->refno);\n  rc = pop_query(pop_data, buf, sizeof(buf));\n  if (rc == 0)\n  {\n    sscanf(buf, \"+OK %d %zu\", &index, &length);\n    snprintf(buf, sizeof(buf), \"TOP %d 0\\r\\n\", h->refno);\n    rc = pop_fetch_data(pop_data, buf, NULL, fetch_message, f);\n    if (pop_data->cmd_top == 2)\n    {\n      if (rc == 0)\n      {\n        pop_data->cmd_top = 1;\n        mutt_debug(1, \"set TOP capability\\n\");\n      }\n      if (rc == -2)\n      {\n        pop_data->cmd_top = 0;\n        mutt_debug(1, \"unset TOP capability\\n\");\n        snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n                 _(\"Command TOP is not supported by server.\"));\n      }\n    }\n  }\n  switch (rc)\n  {\n    case 0:\n    {\n      rewind(f);\n      h->env = mutt_rfc822_read_header(f, h, 0, 0);\n      h->content->length = length - h->content->offset + 1;\n      rewind(f);\n      while (!feof(f))\n      {\n        h->content->length--;\n        fgets(buf, sizeof(buf), f);\n      }\n      break;\n    }\n    case -2:\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    case -3:\n    {\n      mutt_error(_(\"Can't write header to temporary file!\"));\n      break;\n    }\n  }\n  mutt_file_fclose(&f);\n  return rc;\n}\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n#ifdef USE_HCACHE\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n  return mutt_bcache_del(bcache, id);\n}\n#ifdef USE_HCACHE\nstatic int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\nstatic header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}\n#endif\nstatic int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n      ctx->msgcount++;\n    }\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n  mutt_clear_error();\n  return (new_count - old_count);\n}\nstatic int pop_open_mailbox(struct Context *ctx)\n{\n  char buf[PATH_MAX];\n  struct Connection *conn = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  struct Url url;\n  if (pop_parse_path(ctx->path, &acct))\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), ctx->path);\n    return -1;\n  }\n  mutt_account_tourl(&acct, &url);\n  url.path = NULL;\n  url_tostring(&url, buf, sizeof(buf), 0);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return -1;\n  FREE(&ctx->path);\n  FREE(&ctx->realpath);\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  ctx->data = pop_data;\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n  conn->data = pop_data;\n  pop_data->bcache = mutt_bcache_open(&acct, NULL);\n  memset(ctx->rights, 0, sizeof(ctx->rights));\n  mutt_bit_set(ctx->rights, MUTT_ACL_SEEN);\n  mutt_bit_set(ctx->rights, MUTT_ACL_DELETE);\n#ifdef USE_HCACHE\n  mutt_bit_set(ctx->rights, MUTT_ACL_WRITE);\n#endif\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n    ctx->size = pop_data->size;\n    mutt_message(_(\"Fetching list of messages...\"));\n    const int ret = pop_fetch_headers(ctx);\n    if (ret >= 0)\n      return 0;\n    if (ret < -1)\n    {\n      mutt_sleep(2);\n      return -1;\n    }\n  }\n}\nstatic void pop_clear_cache(struct PopData *pop_data)\n{\n  if (!pop_data->clear_cache)\n    return;\n  mutt_debug(1, \"delete cached messages\\n\");\n  for (int i = 0; i < POP_CACHE_LEN; i++)\n  {\n    if (pop_data->cache[i].path)\n    {\n      unlink(pop_data->cache[i].path);\n      FREE(&pop_data->cache[i].path);\n    }\n  }\n}\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n  if (msg->fp)\n    return 0;\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n    if (!msg->fp)\n    {\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n    mutt_file_fclose(&msg->fp);\n    if (!bcache)\n      unlink(path);\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n  h->content->length = ftello(msg->fp) - h->content->offset;\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n  mutt_clear_error();\n  rewind(msg->fp);\n  return 0;\n}\nstatic int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n  pop_data->check_time = 0;\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}\nvoid pop_fetch_mail(void)\n{\n  char buffer[LONG_STRING];\n  char msgbuf[SHORT_STRING];\n  char *url = NULL, *p = NULL;\n  int delanswer, last = 0, msgs, bytes, rset = 0, ret;\n  struct Connection *conn = NULL;\n  struct Context ctx;\n  struct Message *msg = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  if (!PopHost)\n  {\n    mutt_error(_(\"POP host is not defined.\"));\n    return;\n  }\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n  {\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  }\n  strcpy(p, PopHost);\n  ret = pop_parse_path(url, &acct);\n  FREE(&url);\n  if (ret)\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), PopHost);\n    return;\n  }\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  if (pop_open_connection(pop_data) < 0)\n  {\n    mutt_socket_free(pop_data->conn);\n    FREE(&pop_data);\n    return;\n  }\n  conn->data = pop_data;\n  mutt_message(_(\"Checking for new messages...\"));\n  mutt_str_strfcpy(buffer, \"STAT\\r\\n\", sizeof(buffer));\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  if (ret == -1)\n    goto fail;\n  if (ret == -2)\n  {\n    mutt_error(\"%s\", pop_data->err_msg);\n    goto finish;\n  }\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n  if (msgs > 0 && PopLast)\n  {\n    mutt_str_strfcpy(buffer, \"LAST\\r\\n\", sizeof(buffer));\n    ret = pop_query(pop_data, buffer, sizeof(buffer));\n    if (ret == -1)\n      goto fail;\n    if (ret == 0)\n      sscanf(buffer, \"+OK %d\", &last);\n  }\n  if (msgs <= last)\n  {\n    mutt_message(_(\"No new mail in POP mailbox.\"));\n    goto finish;\n  }\n  if (mx_mbox_open(NONULL(Spoolfile), MUTT_APPEND, &ctx) == NULL)\n    goto finish;\n  delanswer = query_quadoption(PopDelete, _(\"Delete messages from server?\"));\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n  mutt_message(\"%s\", msgbuf);\n  for (int i = last + 1; i <= msgs; i++)\n  {\n    msg = mx_msg_open_new(&ctx, NULL, MUTT_ADD_FROM);\n    if (!msg)\n      ret = -3;\n    else\n    {\n      snprintf(buffer, sizeof(buffer), \"RETR %d\\r\\n\", i);\n      ret = pop_fetch_data(pop_data, buffer, NULL, fetch_message, msg->fp);\n      if (ret == -3)\n        rset = 1;\n      if (ret == 0 && mx_msg_commit(&ctx, msg) != 0)\n      {\n        rset = 1;\n        ret = -3;\n      }\n      mx_msg_close(&ctx, &msg);\n    }\n    if (ret == 0 && delanswer == MUTT_YES)\n    {\n      snprintf(buffer, sizeof(buffer), \"DELE %d\\r\\n\", i);\n      ret = pop_query(pop_data, buffer, sizeof(buffer));\n    }\n    if (ret == -1)\n    {\n      mx_mbox_close(&ctx, NULL);\n      goto fail;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Error while writing mailbox!\"));\n      break;\n    }\n    mutt_message(ngettext(\"%s [%d of %d message read]\",\n                          \"%s [%d of %d messages read]\", msgs - last),\n                 msgbuf, i - last, msgs - last);\n  }\n  mx_mbox_close(&ctx, NULL);\n  if (rset)\n  {\n    mutt_str_strfcpy(buffer, \"RSET\\r\\n\", sizeof(buffer));\n    if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n      goto fail;\n  }\nfinish:\n  mutt_str_strfcpy(buffer, \"QUIT\\r\\n\", sizeof(buffer));\n  if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n    goto fail;\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n  return;\nfail:\n  mutt_error(_(\"Server closed connection!\"));\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n}\nstruct MxOps mx_pop_ops = {\n  .mbox_open        = pop_open_mailbox,\n  .mbox_open_append = NULL,\n  .mbox_check       = pop_check_mailbox,\n  .mbox_sync        = pop_sync_mailbox,\n  .mbox_close       = pop_close_mailbox,\n  .msg_open         = pop_fetch_message,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = pop_close_message,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_2974.c",
        "project": "neomutt/neomutt",
        "url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void rstrip_spaces_buf(AVBPrint *buf)\n    if (av_bprint_is_complete(buf))\n        while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n            buf->str[--buf->len] = 0;\nint ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    for (; !end && *in; in++) {\n            if (line_start) {\n                end = 1;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            len = 0;\n            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                    } else\n                }\n            av_bprint_chars(dst, *in, 1);\n            tag_close = in[1] == '/';\n            len = 0;\n            if (sscanf(in+tag_close+1, \"%127[^<>]>%n\", buffer, &len) >= 1 && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n            }\n            av_bprint_chars(dst, *in, 1);\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    rstrip_spaces_buf(dst);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"libavutil/avstring.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/parseutils.h\"\n#include \"htmlsubtitles.h\"\nstatic int html_color_parse(void *log_ctx, const char *str)\n{\n    uint8_t rgba[4];\n    if (av_parse_color(rgba, str, strcspn(str, \"\\\" >\"), log_ctx) < 0)\n        return -1;\n    return rgba[0] | rgba[1] << 8 | rgba[2] << 16;\n}\nenum {\n    PARAM_UNKNOWN = -1,\n    PARAM_SIZE,\n    PARAM_COLOR,\n    PARAM_FACE,\n    PARAM_NUMBER\n};\ntypedef struct SrtStack {\n    char tag[128];\n    char param[PARAM_NUMBER][128];\n} SrtStack;\nstatic void rstrip_spaces_buf(AVBPrint *buf)\n{\n    if (av_bprint_is_complete(buf))\n        while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n            buf->str[--buf->len] = 0;\n}\nint ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n{\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    int closing_brace_missing = 0;\n    stack[0].tag[0] = 0;\n    strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");\n    strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");\n    strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");\n    for (; !end && *in; in++) {\n        switch (*in) {\n        case '\\r':\n            break;\n        case '\\n':\n            if (line_start) {\n                end = 1;\n                break;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            line_start = 1;\n            break;\n        case ' ':\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            break;\n        case '{':    \n            len = 0;\n            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                        break;\n                    } else\n                        closing_brace_missing = 1;\n                }\n            }\n            av_bprint_chars(dst, *in, 1);\n            break;\n        case '<':\n            tag_close = in[1] == '/';\n            len = 0;\n            if (sscanf(in+tag_close+1, \"%127[^<>]>%n\", buffer, &len) >= 1 && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    int i, j, unknown = 0;\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    unsigned font_size;\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             sizeof(stack[0].param[PARAM_SIZE]),\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                    snprintf(stack[sptr].param[PARAM_COLOR],\n                                         sizeof(stack[0].param[PARAM_COLOR]),\n                                         \"{\\\\c&H%X&}\",\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             sizeof(stack[0].param[PARAM_FACE]),\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        unknown = 1;\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n                    break;\n                }\n            }\n        default:\n            av_bprint_chars(dst, *in, 1);\n            break;\n        }\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    dst->str[dst->len] = 0;\n    rstrip_spaces_buf(dst);\n    return 0;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_3419.c",
        "project": "ffmpeg/ffmpeg",
        "url": "https://github.com/FFmpeg/FFmpeg/commit/23ccf3cabb4baf6e8af4b1af3fcc59c904736f21",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```write_buffer(struct reqelem * req)\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\tint n = write(req->socket,\n\t\t              req->output_buffer + req->output_buffer_offset,\n\t\t              req->output_buffer_len);\nwrite_or_buffer(struct reqelem * req, const unsigned char * data, int len)\n\tif(write_buffer(req) < 0)\n\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\tif(!req->is_notify) continue;\n\t\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\nvoid processRequest(struct reqelem * req)\n\tunsigned char nrep = 0;\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\tif(n==0) {\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\tif(l == 0 && type != MINISSDPD_SEARCH_ALL\n\t   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\twhile(d && (nrep < 255)) {\n\t\t\t} else {\n\t\t\t\t\tnrep++;\n\t\t\t}\n\t\t    serv && (nrep < 255);\n\t\t\t\tnrep++;\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\nint main(int argc, char * * argv)\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tunsigned char ttl = 2;\t\n\tconst char * searched_device = NULL;\t\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&lan_addrs);\n\t\telse {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t}\n\tif(lan_addrs.lh_first == NULL)\n\tupnp_bootid = (unsigned int)time(NULL);\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\tif(sigaction(SIGINT, &sa, NULL))\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\tif(try_sendto(&writefds) < 0) {\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\telse\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\t}\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\treq = reqnext;\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n$Id: Changelog.txt,v 1.43 2015/08/06 14:05:49 nanard Exp $\n\nVERSION 1.5:\n\n2016/01/13:\n\tadd \"notification\" mode (command 5)\n\n2015/08/06:\n\tdisable multicast loop\n\tadd -f command line option to filter for a specific device type\n\nVERSION 1.4:\n\n2015/08/06:\n\tadded command 0 (version)\n\n2015/07/21:\n\tset multicast TTL to 2 by default and configurable\n\n2015/05/27:\n\tsupport larger buffer size (useful for type 3 requests)\n\nVERSION 1.3:\n\n2014/12/05:\n\tclean up select call()\n\tfix non blocking write to sockets\n\n2014/12/04:\n\tFixes removing of devices on ssdp:byebye\n\thandle ssdp:update messages\n\n2014/11/28:\n\trevert \"listen on only 1 IPv4 if only 1 interface is specified\"\n\tbecause it prevents broadcast messages to be received\n\tChange the list of LAN addresses/interfaces (code taken from miniupnpd)\n\tCheck that the peer is from a LAN for each SSDP packet\n\n2014/11/06:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\talso when ENABLE_IPV6 is not defined\n\n2014/09/06:\n\tfreebsd-glue for Debian/kFreeBSD\n\tuse LDFLAGS when linking binary\n\n2014/05/01:\n\tlisten on only 1 IPv4 if only 1 interface is specified\n\n2014/02/03:\n\tsilently ignore EAGAIN, EWOULDBLOCK, EINTR of recv calls\n\tDiscover devices on the network at startup\n\n2013/08/19:\n\tTranslate README in english\n\n2012/09/27:\n\tRename all include guards to not clash with C99\n\t(7.1.3 Reserved identifiers).\n\nVERSION 1.2:\n\n2012/05/21:\n\tClean signal handling\n\tSet sockets non blocking\n\n2012/05/18:\n\tImprove ProcessInterfaceWatch() under BSD.\n\n2012/05/15:\n\tImprove ProcessInterfaceWatch() under linux.\n\n2012/05/02:\n\tClean CLFAGS in Makefile.\n\tRemove a few signed/unsigned compares\n\n2012/04/09:\n\tAdded -ansi to compilation flags.\n\tHandle ssdp:update messages and update logging\n\n2012/01/02:\n\tInstall manpage. Fix installation under Mac OS X.\n\n2011/10/07:\n\tunlink unix socket before binding.\n\tset SO_REUSEADDR on SSDP socket.\n\tdaemonize after init\n\nVERSION 1.1:\n\n2011/07/30:\n\tfixes. More overflow checks\n\n2011/07/29:\n\tadded a lot of buffer overflow checks. Check malloc() failure, etc.\n\tBetter cleanup in case of crash at start.\n\tnetwork interface watch to add/drop multicast membership when the interface get live.\n\n2011/06/18:\n\tStarting to add support for UPnP Device Architecture v1.1\n\n2011/05/23:\n\tAdded IPv6 support.\n\t-i option now understands interface names as well as addresses.\n\nVERSION 1.0:\n\n2008/10/07:\n\tadded codelength.h\n\tFixing response to M-SEARCH\n\tDoc update\n\n2008/10/06:\n\tUPnP server support (answering M-SEARCH)\n\n2008/10/04:\n\tlistening on several interfaces.\n\n2008/10/01:\n\tuse of daemon() instead of home made daemonize.\n\n2007/12/19:\n\tadded uuid in responses\n\t3 types of requests supported.\n\tpreventing buffer overflow\n\n2007/12/18:\n\tIt is now possible to change the location of both pid file and\n\tunix socket.\n\n2007/10/08:\n\tAdded a man page\n\n2007/09/27:\n\tSupport for install in different location $ PREFIX=... make install\n\n2007/09/23:\n\tadded a script for use in /etc/init.d\n\timproved Makefile\n\tcreating /var/run/minissdpd.pid\n\tadding synthetic messages for new devices/removed devices\n\n2007/09/19:\n\tTake SSDP announce packets lifetime into account.\n\n\nFile number 2:\n#include \"config.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#if 0\n#include <pwd.h>\n#include <grp.h>\n#endif\n#include \"getifaddr.h\"\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n#include \"minissdpdtypes.h\"\n#include \"asyncsendto.h\"\n#define SET_MAX(max, x)\tif((x) > (max)) (max) = (x)\nstruct reqelem {\n\tint socket;\n\tint is_notify;\t\n\tLIST_ENTRY(reqelem) entries;\n\tunsigned char * output_buffer;\n\tint output_buffer_offset;\n\tint output_buffer_len;\n};\nstruct header {\n\tconst char * p; \n\tint l;          \n};\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 \n\tstruct header headers[3]; \n\tchar data[];\n};\nstruct service {\n\tchar * st;\t\n\tchar * usn;\t\n\tchar * server;\t\n\tchar * location;\t\n\tLIST_ENTRY(service) entries;\n};\n servicelisthead;\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\nenum request_type {\n\tMINISSDPD_GET_VERSION = 0,\n\tMINISSDPD_SEARCH_TYPE = 1,\n\tMINISSDPD_SEARCH_USN = 2,\n\tMINISSDPD_SEARCH_ALL = 3,\n\tMINISSDPD_SUBMIT = 4,\n\tMINISSDPD_NOTIF = 5\n};\nstruct device * devlist = 0;\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\nstruct lan_addr_list lan_addrs;\nLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n#define NOTIF_NEW    1\n#define NOTIF_UPDATE 2\n#define NOTIF_REMOVE 3\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv);\nstatic int\nparselanaddr(struct lan_addr_s * lan_addr, const char * str)\n{\n\tconst char * p;\n\tint n;\n\tchar tmp[16];\n\tmemset(lan_addr, 0, sizeof(struct lan_addr_s));\n\tp = str;\n\twhile(*p && *p != '/' && !isspace(*p))\n\t\tp++;\n\tn = p - str;\n\tif(!isdigit(str[0]) && n < (int)sizeof(lan_addr->ifname)) {\n\t\tmemcpy(lan_addr->ifname, str, n);\n\t\tlan_addr->ifname[n] = '\\0';\n\t\tif(getifaddr(lan_addr->ifname, lan_addr->str, sizeof(lan_addr->str),\n\t\t             &lan_addr->addr, &lan_addr->mask) < 0)\n\t\t\tgoto parselan_error;\n\t} else {\n\t\tif(n>15)\n\t\t\tgoto parselan_error;\n\t\tmemcpy(lan_addr->str, str, n);\n\t\tlan_addr->str[n] = '\\0';\n\t\tif(!inet_aton(lan_addr->str, &lan_addr->addr))\n\t\t\tgoto parselan_error;\n\t}\n\tif(*p == '/') {\n\t\tconst char * q = ++p;\n\t\twhile(*p && isdigit(*p))\n\t\t\tp++;\n\t\tif(*p=='.') {\n\t\t\twhile(*p && (*p=='.' || isdigit(*p)))\n\t\t\t\tp++;\n\t\t\tn = p - q;\n\t\t\tif(n>15)\n\t\t\t\tgoto parselan_error;\n\t\t\tmemcpy(tmp, q, n);\n\t\t\ttmp[n] = '\\0';\n\t\t\tif(!inet_aton(tmp, &lan_addr->mask))\n\t\t\t\tgoto parselan_error;\n\t\t} else {\n\t\t\tint nbits = atoi(q);\n\t\t\tif(nbits > 32 || nbits < 0)\n\t\t\t\tgoto parselan_error;\n\t\t\tlan_addr->mask.s_addr = htonl(nbits ? (0xffffffffu << (32 - nbits)) : 0);\n\t\t}\n\t} else if(lan_addr->mask.s_addr == 0) {\n\t\tlan_addr->mask.s_addr = htonl(0xffffff00u);\n\t}\n#ifdef ENABLE_IPV6\n\tif(lan_addr->ifname[0] != '\\0') {\n\t\tlan_addr->index = if_nametoindex(lan_addr->ifname);\n\t\tif(lan_addr->index == 0)\n\t\t\tfprintf(stderr, \"Cannot get index for network interface %s\",\n\t\t\t        lan_addr->ifname);\n\t} else {\n\t\tfprintf(stderr,\n\t\t        \"Error: please specify LAN network interface by name instead of IPv4 address : %s\\n\",\n\t\t        str);\n\t\treturn -1;\n\t}\n#endif \n\treturn 0;\nparselan_error:\n\tfprintf(stderr, \"Error parsing address/mask (or interface name) : %s\\n\",\n\t        str);\n\treturn -1;\n}\nstatic int\nwrite_buffer(struct reqelem * req)\n{\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\tint n = write(req->socket,\n\t\t              req->output_buffer + req->output_buffer_offset,\n\t\t              req->output_buffer_len);\n\t\tif(n >= 0) {\n\t\t\treq->output_buffer_offset += n;\n\t\t\treq->output_buffer_len -= n;\n\t\t} else if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn n;\n\t} else {\n\t\treturn 0;\n\t}\n}\nstatic int\nadd_to_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tunsigned char * tmp;\n\tif(req->output_buffer_offset > 0) {\n\t\tmemmove(req->output_buffer, req->output_buffer + req->output_buffer_offset, req->output_buffer_len);\n\t\treq->output_buffer_offset = 0;\n\t}\n\ttmp = realloc(req->output_buffer, req->output_buffer_len + len);\n\tif(tmp == NULL) {\n\t\tsyslog(LOG_ERR, \"%s: failed to allocate %d bytes\",\n\t\t       __func__, req->output_buffer_len + len);\n\t\treturn -1;\n\t}\n\treq->output_buffer = tmp;\n\tmemcpy(req->output_buffer + req->output_buffer_len, data, len);\n\treq->output_buffer_len += len;\n\treturn len;\n}\nstatic int\nwrite_or_buffer(struct reqelem * req, const unsigned char * data, int len)\n{\n\tif(write_buffer(req) < 0)\n\t\treturn -1;\n\tif(req->output_buffer && req->output_buffer_len > 0) {\n\t\treturn add_to_buffer(req, data, len);\n\t} else {\n\t\tint n = write(req->socket, data, len);\n\t\tif(n == len)\n\t\t\treturn len;\n\t\tif(n < 0) {\n\t\t\tif(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN) {\n\t\t\t\tn = add_to_buffer(req, data, len);\n\t\t\t\tif(n < 0) return n;\n\t\t\t} else {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else {\n\t\t\tn = add_to_buffer(req, data + n, len - n);\n\t\t\tif(n < 0) return n;\n\t\t}\n\t}\n\treturn len;\n}\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}\nstatic void\nsendNotifications(int notif_type, const struct device * dev, const struct service * serv)\n{\n\tstruct reqelem * req;\n\tunsigned int m;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\tif(!req->is_notify) continue;\n\t\trbuf[0] = '\\xff'; \n\t\trbuf[1] = (unsigned char)notif_type;\n\t\trbuf[2] = 0;\n\t\trp = rbuf + 3;\n\t\tif(dev) {\n\t\t\tm = dev->headers[HEADER_LOCATION].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_LOCATION].p, dev->headers[HEADER_LOCATION].l);\n\t\t\trp += dev->headers[HEADER_LOCATION].l;\n\t\t\tm = dev->headers[HEADER_NT].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_NT].p, dev->headers[HEADER_NT].l);\n\t\t\trp += dev->headers[HEADER_NT].l;\n\t\t\tm = dev->headers[HEADER_USN].l;\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, dev->headers[HEADER_USN].p, dev->headers[HEADER_USN].l);\n\t\t\trp += dev->headers[HEADER_USN].l;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(serv) {\n\t\t\tm = strlen(serv->location);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->location, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->st);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->st, m);\n\t\t\trp += m;\n\t\t\tm = strlen(serv->usn);\n\t\t\tCODELENGTH(m, rp);\n\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\trp += m;\n\t\t\trbuf[2]++;\n\t\t}\n\t\tif(rbuf[2] > 0) {\n\t\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[512];\n\tsocklen_t sockname_len;\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t\"ST: %s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" \n\t\t\"01-NLS: %u\\r\\n\" \n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" \n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" \n\t\t\"\\r\\n\",\n\t\tst, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\t\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\t\n\tn = sendto_or_schedule(s, buf, l, 0, sockname, sockname_len);\n\tif(n < 0) {\n\t\tsyslog(LOG_ERR, \"%s: sendto(udp): %m\", __func__);\n\t}\n}\nstatic void\nprocessMSEARCH(int s, const char * st, int st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif \n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, st_len, st);\n#else\t\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       st_len, st);\n#endif\t\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif(st[st_len-2]==':' && isdigit(st[st_len-1]))\n\t\t\tst_len -= 2;\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\nstatic int\ncontainsForbiddenChars(const unsigned char * p, int len)\n{\n\twhile(len > 0) {\n\t\tif(*p < ' ' || *p >= '\\x7f')\n\t\t\treturn 1;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn 0;\n}\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr,\n                const char * searched_device)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t\n\tconst char * st = NULL;\n\tint st_len = 0;\n\tif(get_lan_for_peer(addr) == NULL) {\n\t\tchar addr_str[64];\n\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\tsyslog(LOG_WARNING, \"peer %s is not from a LAN\",\n\t\t       addr_str);\n\t\treturn 0;\n\t}\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t\n\t\t\tint m = lineend - valuestart;\t\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\tconst char * name = valuestart;\t\n\t\t\t\tconst char * val;\t\t\t\t\n\t\t\t\tint rem = m;\t\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((*linestart == '\\n' || *linestart == '\\r') && linestart < p + n)\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(nts==NTS_SSDP_ALIVE || nts==NTS_SSDP_UPDATE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\t\tif(searched_device &&\n\t\t\t\t   0 != memcmp(headers[HEADER_NT].p, searched_device, headers[HEADER_NT].l))\n\t\t\t\t\tbreak;\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p location=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p,\n\t\t\t\t       headers[HEADER_LOCATION].p);\n\t\t\t}\n\t\t} else if(nts==NTS_SSDP_BYEBYE) {\n\t\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_WARNING, \"missing header nt=%p usn=%p\",\n\t\t\t\t       headers[HEADER_NT].p, headers[HEADER_USN].p);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tchar addr_str[64];\n\t\t\tsockaddr_to_string(addr, addr_str, sizeof(addr_str));\n\t\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do (from %s)\",\n\t\t\t       methodlen, p, addr_str);\n\t\t}\n\t}\n\treturn r;\n}\nvoid processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tenum request_type type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[RESPONSE_BUFFER_SIZE];\n\tunsigned char * rp;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\",\n\t\t       l, (unsigned)n);\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != MINISSDPD_SEARCH_ALL\n\t   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0, type=%d)\", type);\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase MINISSDPD_GET_VERSION:\n\t\trp = rbuf;\n\t\tCODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);\n\t\tmemcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);\n\t\trp += (sizeof(MINISSDPD_VERSION) - 1);\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SEARCH_TYPE:\t\n\tcase MINISSDPD_SEARCH_USN:\t\n\tcase MINISSDPD_SEARCH_ALL:\t\n\t\trp = rbuf+1;\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==MINISSDPD_SEARCH_ALL) ) {\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write_or_buffer(req, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase MINISSDPD_SUBMIT:\t\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(newserv, 0, sizeof(struct service));\t\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service already in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tsendNotifications(NOTIF_NEW, NULL, newserv);\n\t\tnewserv = NULL;\n\t\tbreak;\n\tcase MINISSDPD_NOTIF:\t\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\treq->is_notify = 1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write_or_buffer(req, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\nstatic volatile sig_atomic_t quitting = 0;\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" \n#define UPNP_MCAST_SL_ADDR \"FF05::C\" \nstatic void ssdpDiscover(int s, int ipv6, const char * search)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: %s\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR,\n\t\t             (search ? search : \"ssdp:all\"), mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\t\tn = sendto_or_schedule(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t                       ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: sendto: %m\", __func__);\n\t\t}\n\t}\n}\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t\n#else\t\n#define s_ssdp6 (-1)\n#endif\t\n\tint s_unix = -1;\t\n\tint s_ifacewatch = -1;\t\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tfd_set writefds;\n\tstruct timeval now;\n\tint max_fd;\n\tstruct lan_addr_s * lan_addr;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n#ifdef ENABLE_IPV6\n\tint ipv6 = 0;\n#endif \n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\t\n\tunsigned char ttl = 2;\t\n\tconst char * searched_device = NULL;\t\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\tLIST_INIT(&lan_addrs);\n\tfor(i=1; i<argc; i++)\n\t{\n \t\tif(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\t\n\t\telse {\n\t\t\tif((i + 1) >= argc) {\n\t\t\t\tfprintf(stderr, \"option %s needs an argument.\\n\", argv[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\t\tlan_addr = malloc(sizeof(struct lan_addr_s));\n\t\t\t\tif(lan_addr == NULL) {\n\t\t\t\t\tfprintf(stderr, \"malloc(%d) FAILED\\n\", (int)sizeof(struct lan_addr_s));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(parselanaddr(lan_addr, argv[++i]) != 0) {\n\t\t\t\t\tfprintf(stderr, \"can't parse \\\"%s\\\" as a valid address or interface name\\n\", argv[i]);\n\t\t\t\t\tfree(lan_addr);\n\t\t\t\t} else {\n\t\t\t\t\tLIST_INSERT_HEAD(&lan_addrs, lan_addr, list);\n\t\t\t\t}\n\t\t\t} else if(0==strcmp(argv[i], \"-s\"))\n\t\t\t\tsockpath = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\t\tpidfilename = argv[++i];\n\t\t\telse if(0==strcmp(argv[i], \"-t\"))\n\t\t\t\tttl = (unsigned char)atoi(argv[++i]);\n\t\t\telse if(0==strcmp(argv[i], \"-f\"))\n\t\t\t\tsearched_device = argv[++i];\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"unknown commandline option %s.\\n\", argv[i]);\n\t\t}\n\t}\n\tif(lan_addrs.lh_first == NULL)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] \"\n#ifdef ENABLE_IPV6\n\t\t        \"[-6] \"\n#endif \n\t\t        \"[-s socket] [-p pidfile] [-t TTL] \"\n\t\t        \"[-f device] \"\n\t\t        \"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address with mask such as\\n\"\n\t\t        \"  192.168.1.42/255.255.255.0, or an interface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"  and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) \n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\tupnp_bootid = (unsigned int)time(NULL);\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(0, ttl);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(1, ttl);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\t\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#if 0\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else  \n\t\tpid = daemonize();\n#endif \n\t}\n\twritepidfile(pidfilename, pid);\n\tif(s_ssdp >= 0)\n\t\tssdpDiscover(s_ssdp, 0, searched_device);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscover(s_ssdp6, 1, searched_device);\n\twhile(!quitting) {\n\t\tFD_ZERO(&readfds);\n\t\tFD_ZERO(&writefds);\n\t\tFD_SET(s_unix, &readfds);\n\t\tmax_fd = s_unix;\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t\tSET_MAX(max_fd, s_ssdp6);\n\t\t}\n#endif \n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t\tSET_MAX(max_fd, s_ifacewatch);\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next) {\n\t\t\tif(req->socket >= 0) {\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t\tif(req->output_buffer_len > 0) {\n\t\t\t\tFD_SET(req->socket, &writefds);\n\t\t\t\tSET_MAX(max_fd, req->socket);\n\t\t\t}\n\t\t}\n\t\tgettimeofday(&now, NULL);\n\t\ti = get_sendto_fds(&writefds, &max_fd, &now);\n\t\tif(select(max_fd + 1, &readfds, &writefds, 0, 0) < 0) {\n\t\t\tif(errno != EINTR) {\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(try_sendto(&writefds) < 0) {\n\t\t\tsyslog(LOG_ERR, \"try_sendto: %m\");\n\t\t\tbreak;\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\t\n\t\tif((s_ssdp >= 0) && FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername, searched_device);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(req = reqlisthead.lh_first; req;) {\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds)) {\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &writefds)) {\n\t\t\t\twrite_buffer(req);\n\t\t\t}\n\t\t\tif(req->socket < 0) {\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req->output_buffer);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\tint s = accept(s_unix, NULL, NULL);\n\t\t\tif(s < 0) {\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp) {\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t} else {\n\t\t\t\t\tmemset(tmp, 0, sizeof(struct reqelem));\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6);\n\t\t}\n\t}\n\tsyslog(LOG_DEBUG, \"quitting...\");\n\tfinalize_sendto();\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\t\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\twhile(lan_addrs.lh_first != NULL) {\n\t\tlan_addr = lan_addrs.lh_first;\n\t\tLIST_REMOVE(lan_addrs.lh_first, list);\n\t\tfree(lan_addr);\n\t}\n\twhile(devlist != NULL) {\n\t\tstruct device * next = devlist->next;\n\t\tfree(devlist);\n\t\tdevlist = next;\n\t}\n\twhile(servicelisthead.lh_first != NULL) {\n\t\tstruct service * serv = servicelisthead.lh_first;\n\t\tLIST_REMOVE(servicelisthead.lh_first, entries);\n\t\tfree(serv->st);\n\t\tfree(serv->usn);\n\t\tfree(serv->server);\n\t\tfree(serv->location);\n\t\tfree(serv);\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\nFile number 3:\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include \"codelength.h\"\n#include \"printresponse.h\"\nvoid printversion(const unsigned char * resp, int n)\n{\n\tint l;\n\tconst unsigned char * p;\n\tp = resp;\n\tDECODELENGTH(l, p);\n\tif(resp + n < p + l) {\n\t\tprintf(\"get version error\\n\");\n\t}\n\tprintf(\"MiniSSDPd version : %.*s\\n\", l, p);\n}\n#define SENDCOMMAND(command, size) write(s, command, size); \\\n              printf(\"Command written type=%u\\n\", (unsigned char)command[0]);\nint connect_unix_socket(const char * sockpath)\n{\n\tint s;\n\tstruct sockaddr_un addr;\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, sockpath, sizeof(addr.sun_path));\n\tif(connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0) {\n\t\tfprintf(stderr, \"connecting to %s : \", addr.sun_path);\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n\tprintf(\"Connected to %s\\n\", addr.sun_path);\n\treturn s;\n}\nint\nmain(int argc, char * * argv)\n{\n\tconst char command0[] = { 0x00, 0x00 };\n\tchar command1[] = \"\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice\";\n\tchar command2[] = \"\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice\";\n\tconst char command3[] = { 0x03, 0x00 };\n\tchar command3compat[] = \"\\x03\\x00ssdp:all\";\n\tchar command4[] = \"\\x04\\x00test:test:test\";\n\tconst char bad_command[] = { 0xff, 0xff };\n\tconst char overflow[] = { 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tconst char command5[] = { 0x05, 0x00 };\n\tint s;\n\tint i;\n\tvoid * tmp;\n\tunsigned char * resp = NULL;\n\tsize_t respsize = 0;\n\tunsigned char buf[4096];\n\tssize_t n;\n\tint total = 0;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tfor(i=0; i<argc-1; i++) {\n\t\tif(0==strcmp(argv[i], \"-s\"))\n\t\t\tsockpath = argv[++i];\n\t}\n\tcommand1[1] = sizeof(command1) - 3;\n\tcommand2[1] = sizeof(command2) - 3;\n\tcommand3compat[1] = sizeof(command3compat) - 3;\n\tcommand4[1] = sizeof(command4) - 3;\n\ts = connect_unix_socket(sockpath);\n\tn = SENDCOMMAND(command0, sizeof(command0));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tif(n > 0) {\n\t\tprintversion(buf, n);\n\t} else {\n\t\tprintf(\"Command 0 (get version) not supported\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tn = SENDCOMMAND(command1, sizeof(command1) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tn = SENDCOMMAND(command2, sizeof(command2) - 1);\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tbuf[0] = 0; \n\tn = SENDCOMMAND(command3, sizeof(command3));\n\tn = read(s, buf, sizeof(buf));\n\tif(n == 0) {\n\t\tprintf(\"command3 failed, testing compatible one\\n\");\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t\tn = SENDCOMMAND(command3compat, sizeof(command3compat) - 1);\n\t\tn = read(s, buf, sizeof(buf));\n\t}\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintf(\"Number of devices %d\\n\", (int)buf[0]);\n\twhile(n > 0) {\n\t\ttmp = realloc(resp, respsize + n);\n\t\tif(tmp == NULL) {\n\t\t\tfprintf(stderr, \"memory allocation error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tresp = tmp;\n\t\trespsize += n;\n\t\tif (n > 0) {\n\t\t\tmemcpy(resp + total, buf, n);\n\t\t\ttotal += n;\n\t\t}\n\t\tif (n < (ssize_t)sizeof(buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tn = read(s, buf, sizeof(buf));\n\t\tprintf(\"response received %d bytes\\n\", (int)n);\n\t}\n\tif(resp != NULL) {\n\t\tprintresponse(resp, total);\n\t\tfree(resp);\n\t\tresp = NULL;\n\t}\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tn = SENDCOMMAND(command4, sizeof(command4));\n\tn = SENDCOMMAND(bad_command, sizeof(bad_command));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tn = SENDCOMMAND(overflow, sizeof(overflow));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tif(n == 0) {\n\t\tclose(s);\n\t\ts = connect_unix_socket(sockpath);\n\t}\n\tn = SENDCOMMAND(command5, sizeof(command5));\n\tn = read(s, buf, sizeof(buf));\n\tprintf(\"Response received %d bytes\\n\", (int)n);\n\tprintresponse(buf, n);\n\tclose(s);\n\treturn 0;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_1720.c",
        "project": "miniupnp/miniupnp",
        "url": "https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n\tstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\n\tpos = (u8 *) assoc;\n\tpriv->attempted_bss_desc = bss_desc;\n\tmemcpy(assoc->peer_sta_addr,\n\t       bss_desc->mac_address, sizeof(assoc->peer_sta_addr));\n\tpos += sizeof(assoc->peer_sta_addr);\n\tassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\n\tpos += sizeof(assoc->cap_info_bitmap);\n\tpos += sizeof(assoc->listen_interval);\n\tpos += sizeof(assoc->beacon_period);\n\tpos += sizeof(assoc->dtim_period);\n\tssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\n\tssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\n\tmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\n\t       le16_to_cpu(ssid_tlv->header.len));\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n#define CAPINFO_MASK    (~(BIT(15) | BIT(14) | BIT(12) | BIT(11) | BIT(9)))\nstatic int\nmwifiex_cmd_append_generic_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint ret_len = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tif (priv->gen_ie_buf_len) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: %s: append generic ie len %d to %p\\n\",\n\t\t\t    __func__, priv->gen_ie_buf_len, *buffer);\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->gen_ie_buf_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\t\t*buffer += sizeof(ie_header);\n\t\tret_len += sizeof(ie_header);\n\t\tmemcpy(*buffer, priv->gen_ie_buf, priv->gen_ie_buf_len);\n\t\t*buffer += priv->gen_ie_buf_len;\n\t\tret_len += priv->gen_ie_buf_len;\n\t\tpriv->gen_ie_buf_len = 0;\n\t}\n\treturn ret_len;\n}\nstatic int\nmwifiex_cmd_append_tsf_tlv(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct mwifiex_ie_types_tsf_timestamp tsf_tlv;\n\t__le64 tsf_val;\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\tmemset(&tsf_tlv, 0x00, sizeof(struct mwifiex_ie_types_tsf_timestamp));\n\ttsf_tlv.header.type = cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);\n\ttsf_tlv.header.len = cpu_to_le16(2 * sizeof(tsf_val));\n\tmemcpy(*buffer, &tsf_tlv, sizeof(tsf_tlv.header));\n\t*buffer += sizeof(tsf_tlv.header);\n\ttsf_val = cpu_to_le64(bss_desc->fw_tsf);\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\ttsf_val = cpu_to_le64(bss_desc->timestamp);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: %s: TSF offset calc: %016llx - %016llx\\n\",\n\t\t    __func__, bss_desc->timestamp, bss_desc->fw_tsf);\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\treturn sizeof(tsf_tlv.header) + (2 * sizeof(tsf_val));\n}\nstatic int mwifiex_get_common_rates(struct mwifiex_private *priv, u8 *rate1,\n\t\t\t\t    u32 rate1_size, u8 *rate2, u32 rate2_size)\n{\n\tint ret;\n\tu8 *ptr = rate1, *tmp;\n\tu32 i, j;\n\ttmp = kmemdup(rate1, rate1_size, GFP_KERNEL);\n\tif (!tmp) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"failed to alloc tmp buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(rate1, 0, rate1_size);\n\tfor (i = 0; i < rate2_size && rate2[i]; i++) {\n\t\tfor (j = 0; j < rate1_size && tmp[j]; j++) {\n\t\t\tif ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {\n\t\t\t\t*rate1++ = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Tx data rate set to %#x\\n\",\n\t\t    priv->data_rate);\n\tif (!priv->is_data_rate_auto) {\n\t\twhile (*ptr) {\n\t\t\tif ((*ptr & 0x7f) == priv->data_rate) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"previously set fixed data rate %#x\\t\"\n\t\t\t    \"is not compatible with the network\\n\",\n\t\t\t    priv->data_rate);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tkfree(tmp);\n\treturn ret;\n}\nstatic int\nmwifiex_cmd_append_wapi_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\tif (priv->wapi_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wapi ie %d to %p\\n\",\n\t\t\t    priv->wapi_ie_len, *buffer);\n\t\tie_header.type = cpu_to_le16(TLV_TYPE_WAPI_IE);\n\t\tie_header.len = cpu_to_le16(priv->wapi_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\t\tmemcpy(*buffer, priv->wapi_ie, priv->wapi_ie_len);\n\t\t*buffer += priv->wapi_ie_len;\n\t\tretLen += priv->wapi_ie_len;\n\t}\n\treturn retLen;\n}\nstatic int mwifiex_append_rsn_ie_wpa_wpa2(struct mwifiex_private *priv,\n\t\t\t\t\t  u8 **buffer)\n{\n\tstruct mwifiex_ie_types_rsn_param_set *rsn_ie_tlv;\n\tint rsn_ie_len;\n\tif (!buffer || !(*buffer))\n\t\treturn 0;\n\trsn_ie_tlv = (struct mwifiex_ie_types_rsn_param_set *) (*buffer);\n\trsn_ie_tlv->header.type = cpu_to_le16((u16) priv->wpa_ie[0]);\n\trsn_ie_tlv->header.type = cpu_to_le16(\n\t\t\t\t le16_to_cpu(rsn_ie_tlv->header.type) & 0x00FF);\n\trsn_ie_tlv->header.len = cpu_to_le16((u16) priv->wpa_ie[1]);\n\trsn_ie_tlv->header.len = cpu_to_le16(le16_to_cpu(rsn_ie_tlv->header.len)\n\t\t\t\t\t\t\t & 0x00FF);\n\tif (le16_to_cpu(rsn_ie_tlv->header.len) <= (sizeof(priv->wpa_ie) - 2))\n\t\tmemcpy(rsn_ie_tlv->rsn_ie, &priv->wpa_ie[2],\n\t\t       le16_to_cpu(rsn_ie_tlv->header.len));\n\telse\n\t\treturn -1;\n\trsn_ie_len = sizeof(rsn_ie_tlv->header) +\n\t\t\t\t\tle16_to_cpu(rsn_ie_tlv->header.len);\n\t*buffer += rsn_ie_len;\n\treturn rsn_ie_len;\n}\nint mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\n\tstruct mwifiex_ie_types_ssid_param_set *ssid_tlv;\n\tstruct mwifiex_ie_types_phy_param_set *phy_tlv;\n\tstruct mwifiex_ie_types_ss_param_set *ss_tlv;\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tstruct mwifiex_ie_types_auth_type *auth_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 rates_size;\n\tu16 tmp_cap;\n\tu8 *pos;\n\tint rsn_ie_len = 0;\n\tpos = (u8 *) assoc;\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);\n\tpriv->attempted_bss_desc = bss_desc;\n\tmemcpy(assoc->peer_sta_addr,\n\t       bss_desc->mac_address, sizeof(assoc->peer_sta_addr));\n\tpos += sizeof(assoc->peer_sta_addr);\n\tassoc->listen_interval = cpu_to_le16(priv->listen_interval);\n\tassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\n\tpos += sizeof(assoc->cap_info_bitmap);\n\tpos += sizeof(assoc->listen_interval);\n\tpos += sizeof(assoc->beacon_period);\n\tpos += sizeof(assoc->dtim_period);\n\tssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\n\tssid_tlv->header.type = cpu_to_le16(WLAN_EID_SSID);\n\tssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\n\tmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\n\t       le16_to_cpu(ssid_tlv->header.len));\n\tpos += sizeof(ssid_tlv->header) + le16_to_cpu(ssid_tlv->header.len);\n\tphy_tlv = (struct mwifiex_ie_types_phy_param_set *) pos;\n\tphy_tlv->header.type = cpu_to_le16(WLAN_EID_DS_PARAMS);\n\tphy_tlv->header.len = cpu_to_le16(sizeof(phy_tlv->fh_ds.ds_param_set));\n\tmemcpy(&phy_tlv->fh_ds.ds_param_set,\n\t       &bss_desc->phy_param_set.ds_param_set.current_chan,\n\t       sizeof(phy_tlv->fh_ds.ds_param_set));\n\tpos += sizeof(phy_tlv->header) + le16_to_cpu(phy_tlv->header.len);\n\tss_tlv = (struct mwifiex_ie_types_ss_param_set *) pos;\n\tss_tlv->header.type = cpu_to_le16(WLAN_EID_CF_PARAMS);\n\tss_tlv->header.len = cpu_to_le16(sizeof(ss_tlv->cf_ibss.cf_param_set));\n\tpos += sizeof(ss_tlv->header) + le16_to_cpu(ss_tlv->header.len);\n\tif (mwifiex_setup_rates_from_bssdesc\n\t    (priv, bss_desc, rates, &rates_size))\n\t\treturn -1;\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, rates, rates_size);\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *) pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tpos += sizeof(rates_tlv->header) + rates_size;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_CMD: rates size = %d\\n\",\n\t\t    rates_size);\n\tauth_tlv = (struct mwifiex_ie_types_auth_type *) pos;\n\tauth_tlv->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\tauth_tlv->header.len = cpu_to_le16(sizeof(auth_tlv->auth_type));\n\tif (priv->sec_info.wep_enabled)\n\t\tauth_tlv->auth_type = cpu_to_le16(\n\t\t\t\t(u16) priv->sec_info.authentication_mode);\n\telse\n\t\tauth_tlv->auth_type = cpu_to_le16(NL80211_AUTHTYPE_OPEN_SYSTEM);\n\tpos += sizeof(auth_tlv->header) + le16_to_cpu(auth_tlv->header.len);\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter) &&\n\t    !(ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN) &&\n\t    (bss_desc->bcn_ht_cap)\n\t    )\n\t\t) {\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\tif (!priv->wps.session_enable) {\n\t\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t}\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))\n\t\tmwifiex_cmd_append_11n_tlv(priv, bss_desc, &pos);\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);\n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_ASSOC, &pos);\n\tmwifiex_wmm_process_association_req(priv, &pos, &bss_desc->wmm_ie,\n\t\t\t\t\t    bss_desc->bcn_ht_cap);\n\tif (priv->sec_info.wapi_enabled && priv->wapi_ie_len)\n\t\tmwifiex_cmd_append_wapi_ie(priv, &pos);\n\tif (priv->wps.session_enable && priv->wps_ie_len)\n\t\tmwifiex_cmd_append_wps_ie(priv, &pos);\n\tmwifiex_cmd_append_generic_ie(priv, &pos);\n\tmwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);\n\tmwifiex_11h_process_join(priv, &pos, bss_desc);\n\tcmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\tif (priv->adapter->config_bands == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\ttmp_cap &= CAPINFO_MASK;\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\tassoc->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\treturn 0;\n}\nint mwifiex_ret_802_11_associate(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct ieee_types_assoc_rsp *assoc_rsp;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tbool enable_data = true;\n\tu16 cap_info, status_code, aid;\n\tconst u8 *ie_ptr;\n\tstruct ieee80211_ht_operation *assoc_resp_ht_oper;\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\tassoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;\n\tcap_info = le16_to_cpu(assoc_rsp->cap_info_bitmap);\n\tstatus_code = le16_to_cpu(assoc_rsp->status_code);\n\taid = le16_to_cpu(assoc_rsp->a_id);\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14)))\n\t\tdev_err(priv->adapter->dev,\n\t\t\t\"invalid AID value 0x%x; bits 15:14 not set\\n\",\n\t\t\taid);\n\taid &= ~(BIT(15) | BIT(14));\n\tpriv->assoc_rsp_size = min(le16_to_cpu(resp->size) - S_DS_GEN,\n\t\t\t\t   sizeof(priv->assoc_rsp_buf));\n\tassoc_rsp->a_id = cpu_to_le16(aid);\n\tmemcpy(priv->assoc_rsp_buf, &resp->params, priv->assoc_rsp_size);\n\tif (status_code) {\n\t\tpriv->adapter->dbg.num_cmd_assoc_failure++;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed,\\t\"\n\t\t\t    \"status code=%d err=%#x a_id=%#x\\n\",\n\t\t\t    status_code, cap_info,\n\t\t\t    le16_to_cpu(assoc_rsp->a_id));\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"assoc failure: reason %s\\n\",\n\t\t\t    assoc_failure_reason_to_str(cap_info));\n\t\tif (cap_info == CONNECT_ERR_ASSOC_ERR_TIMEOUT) {\n\t\t\tif (status_code == MWIFIEX_ASSOC_CMD_FAILURE_AUTH) {\n\t\t\t\tret = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: AUTH timeout\\n\");\n\t\t\t} else {\n\t\t\t\tret = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: UNSPECIFIED failure\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = status_code;\n\t\t}\n\t\tgoto done;\n\t}\n\tpriv->media_connected = true;\n\tpriv->adapter->ps_state = PS_STATE_AWAKE;\n\tpriv->adapter->pps_uapsd_mode = false;\n\tpriv->adapter->tx_lock_flag = false;\n\tbss_desc = priv->attempted_bss_desc;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: %s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\tpriv->curr_bss_params.bss_descriptor.channel\n\t\t= bss_desc->phy_param_set.ds_param_set.current_chan;\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\tif (bss_desc->wmm_ie.vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC)\n\t\tpriv->curr_bss_params.wmm_enabled = true;\n\telse\n\t\tpriv->curr_bss_params.wmm_enabled = false;\n\tif ((priv->wmm_required || bss_desc->bcn_ht_cap) &&\n\t    priv->curr_bss_params.wmm_enabled)\n\t\tpriv->wmm_enabled = true;\n\telse\n\t\tpriv->wmm_enabled = false;\n\tpriv->curr_bss_params.wmm_uapsd_enabled = false;\n\tif (priv->wmm_enabled)\n\t\tpriv->curr_bss_params.wmm_uapsd_enabled\n\t\t\t= ((bss_desc->wmm_ie.qos_info_bitmap &\n\t\t\t\tIEEE80211_WMM_IE_AP_QOSINFO_UAPSD) ? 1 : 0);\n\tie_ptr = cfg80211_find_ie(WLAN_EID_HT_OPERATION, assoc_rsp->ie_buffer,\n\t\t\t\t  priv->assoc_rsp_size\n\t\t\t\t  - sizeof(struct ieee_types_assoc_rsp));\n\tif (ie_ptr) {\n\t\tassoc_resp_ht_oper = (struct ieee80211_ht_operation *)(ie_ptr\n\t\t\t\t\t+ sizeof(struct ieee_types_header));\n\t\tpriv->assoc_resp_ht_param = assoc_resp_ht_oper->ht_param;\n\t\tpriv->ht_param_present = true;\n\t} else {\n\t\tpriv->ht_param_present = false;\n\t}\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_RESP: curr_pkt_filter is %#x\\n\",\n\t\t    priv->curr_pkt_filter);\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->wpa_is_gtk_set = false;\n\tif (priv->wmm_enabled) {\n\t\tenable_data = false;\n\t} else {\n\t\tmwifiex_wmm_setup_queue_priorities(priv, NULL);\n\t\tmwifiex_wmm_setup_ac_downgrade(priv);\n\t}\n\tif (enable_data)\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: post association, re-enabling data flow\\n\");\n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\tmwifiex_save_curr_bcn(priv);\n\tpriv->adapter->dbg.num_cmd_assoc_success++;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: associated\\n\");\n\tmwifiex_ralist_add(priv,\n\t\t\t   priv->curr_bss_params.bss_descriptor.mac_address);\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->scan_block = true;\n\telse\n\t\tpriv->port_open = true;\ndone:\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\t}\n\treturn ret;\n}\nint\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\tif (!adapter)\n\t\treturn -1;\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n#define DS_PARA_IE_ID   3\n#define DS_PARA_IE_LEN  1\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n#define IBSS_PARA_IE_ID   6\n#define IBSS_PARA_IE_LEN  2\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\tif (priv->sec_info.encryption_mode) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\tpriv->curr_bss_params.num_of_rates = i;\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\tif (adapter->adhoc_11n_enabled) {\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\treturn 0;\n}\nint\nmwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tint rsn_ie_len = 0;\n\tstruct host_cmd_ds_802_11_ad_hoc_join *adhoc_join =\n\t\t&cmd->params.adhoc_join;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu32 cmd_append_size = 0;\n\tu16 tmp_cap;\n\tu32 i, rates_size = 0;\n\tu16 curr_pkt_filter;\n\tu8 *pos =\n\t\t(u8 *) adhoc_join +\n\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_join);\n#define USE_G_PROTECTION        0x02\n\tif (bss_desc->erp_flags & USE_G_PROTECTION) {\n\t\tcurr_pkt_filter =\n\t\t\tpriv->\n\t\t\tcurr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"ADHOC_J_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tpriv->attempted_bss_desc = bss_desc;\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);\n\tadhoc_join->bss_descriptor.bss_mode = HostCmd_BSS_MODE_IBSS;\n\tadhoc_join->bss_descriptor.beacon_period\n\t\t= cpu_to_le16(bss_desc->beacon_period);\n\tmemcpy(&adhoc_join->bss_descriptor.bssid,\n\t       &bss_desc->mac_address, ETH_ALEN);\n\tmemcpy(&adhoc_join->bss_descriptor.ssid,\n\t       &bss_desc->ssid.ssid, bss_desc->ssid.ssid_len);\n\tmemcpy(&adhoc_join->bss_descriptor.phy_param_set,\n\t       &bss_desc->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\tmemcpy(&adhoc_join->bss_descriptor.ss_param_set,\n\t       &bss_desc->ss_param_set, sizeof(union ieee_types_ss_param_set));\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\ttmp_cap &= CAPINFO_MASK;\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: BSSID=%pM, SSID='%s'\\n\",\n\t\t    adhoc_join->bss_descriptor.bssid,\n\t\t    adhoc_join->bss_descriptor.ssid);\n\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES &&\n\t\t    bss_desc->supported_rates[i]; i++)\n\t\t;\n\trates_size = i;\n\tmemset(adhoc_join->bss_descriptor.data_rates, 0,\n\t       sizeof(adhoc_join->bss_descriptor.data_rates));\n\tmemcpy(adhoc_join->bss_descriptor.data_rates,\n\t       bss_desc->supported_rates, rates_size);\n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, bss_desc->supported_rates,\n\t       rates_size);\n\tpriv->curr_bss_params.bss_descriptor.channel = bss_desc->channel;\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\tif (priv->sec_info.wep_enabled || priv->sec_info.wpa_enabled)\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter)) {\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Chan=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Band=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\tif (priv->sec_info.wpa_enabled)\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\tif (rsn_ie_len == -1)\n\t\treturn -1;\n\tcmd_append_size += rsn_ie_len;\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\tcmd_append_size += mwifiex_cmd_append_11n_tlv(priv,\n\t\t\tbss_desc, &pos);\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\tcmd->size = cpu_to_le16\n\t\t((u16) (sizeof(struct host_cmd_ds_802_11_ad_hoc_join)\n\t\t\t+ S_DS_GEN + cmd_append_size));\n\tadhoc_join->bss_descriptor.cap_info_bitmap = cpu_to_le16(tmp_cap);\n\treturn 0;\n}\nint mwifiex_ret_802_11_ad_hoc(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start_result *start_result =\n\t\t\t\t&resp->params.start_result;\n\tstruct host_cmd_ds_802_11_ad_hoc_join_result *join_result =\n\t\t\t\t&resp->params.join_result;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu16 cmd = le16_to_cpu(resp->command);\n\tu8 result;\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ADHOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\tif (cmd == HostCmd_CMD_802_11_AD_HOC_START)\n\t\tresult = start_result->result;\n\telse\n\t\tresult = join_result->result;\n\tbss_desc = priv->attempted_bss_desc;\n\tif (result) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"ADHOC_RESP: failed\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_reset_connect_state(priv, result, true);\n\t\tmemset(&priv->curr_bss_params.bss_descriptor,\n\t\t       0x00, sizeof(struct mwifiex_bssdescriptor));\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tpriv->media_connected = true;\n\tif (le16_to_cpu(resp->command) == HostCmd_CMD_802_11_AD_HOC_START) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_S_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\t\tmemcpy(bss_desc->mac_address,\n\t\t       start_result->bssid, ETH_ALEN);\n\t\tpriv->adhoc_state = ADHOC_STARTED;\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\t\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\t\tpriv->adhoc_state = ADHOC_JOINED;\n\t}\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: BSSID = %pM\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.mac_address);\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\tmwifiex_save_curr_bcn(priv);\ndone:\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\t}\n\treturn ret;\n}\nint mwifiex_adhoc_join(struct mwifiex_private *priv,\n\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid =%s\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid_len =%u\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid_len);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid =%s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid_len =%u\\n\",\n\t\t    bss_desc->ssid.ssid_len);\n\tif (priv->curr_bss_params.bss_descriptor.ssid.ssid_len &&\n\t    !mwifiex_ssid_cmp(&bss_desc->ssid,\n\t\t\t      &priv->curr_bss_params.bss_descriptor.ssid) &&\n\t    (priv->curr_bss_params.bss_descriptor.bss_mode ==\n\t\t\t\t\t\t\tNL80211_IFTYPE_ADHOC)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_CMD: new ad-hoc SSID\\t\"\n\t\t\t    \"is the same as current; not attempting to re-join\\n\");\n\t\treturn -1;\n\t}\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.band = %c\\n\",\n\t\t    priv->curr_bss_params.band);\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\nu8\nmwifiex_band_to_radio_type(u8 band)\n{\n\tswitch (band) {\n\tcase BAND_A:\n\tcase BAND_AN:\n\tcase BAND_A | BAND_AN:\n\tcase BAND_A | BAND_AN | BAND_AAC:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_A;\n\tcase BAND_B:\n\tcase BAND_G:\n\tcase BAND_B | BAND_G:\n\tdefault:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_BG;\n\t}\n}\n",
        "cwe": "CWE-120",
        "file_name": "safe_respovul_idx_5396.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tpin_reg = readl(gpio_dev->base + pin*4);\n\t\twritel(pin_reg, gpio_dev->base + pin*4);\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/gpio.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include \"pinctrl-utils.h\"\n#include \"pinctrl-amd.h\"\nstatic int amd_gpio_set_debounce(struct gpio_chip *gc, unsigned offset,\n\t\tunsigned debounce)\n{\n\tu32 time;\n\tu32 pin_reg;\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (debounce) {\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tif (debounce < 61) {\n\t\t\tpin_reg |= 1;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 976) {\n\t\t\ttime = debounce / 61;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 3900) {\n\t\t\ttime = debounce / 244;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 250000) {\n\t\t\ttime = debounce / 15600;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 1000000) {\n\t\t\ttime = debounce / 62500;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else {\n\t\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t}\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\treturn ret;\n}\n#ifdef CONFIG_DEBUG_FS\nstatic void amd_gpio_dbg_show(struct seq_file *s, struct gpio_chip *gc)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tunsigned int bank, i, pin_num;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\tchar *level_trig;\n\tchar *active_level;\n\tchar *interrupt_enable;\n\tchar *interrupt_mask;\n\tchar *wake_cntrl0;\n\tchar *wake_cntrl1;\n\tchar *wake_cntrl2;\n\tchar *pin_sts;\n\tchar *pull_up_sel;\n\tchar *pull_up_enable;\n\tchar *pull_down_enable;\n\tchar *output_value;\n\tchar *output_enable;\n\tfor (bank = 0; bank < gpio_dev->hwbank_num; bank++) {\n\t\tseq_printf(s, \"GPIO bank%d\\t\", bank);\n\t\tswitch (bank) {\n\t\tcase 0:\n\t\t\ti = 0;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti = 64;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK1 + i;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ti = 128;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK2 + i;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ti = 192;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK3 + i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tfor (; i < pin_num; i++) {\n\t\t\tseq_printf(s, \"pin%d\\t\", i);\n\t\t\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\t\t\tpin_reg = readl(gpio_dev->base + i * 4);\n\t\t\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\t\t\tif (pin_reg & BIT(INTERRUPT_ENABLE_OFF)) {\n\t\t\t\tinterrupt_enable = \"interrupt is enabled|\";\n\t\t\t\tif (!(pin_reg & BIT(ACTIVE_LEVEL_OFF)) &&\n\t\t\t\t    !(pin_reg & BIT(ACTIVE_LEVEL_OFF + 1)))\n\t\t\t\t\tactive_level = \"Active low|\";\n\t\t\t\telse if (pin_reg & BIT(ACTIVE_LEVEL_OFF) &&\n\t\t\t\t\t !(pin_reg & BIT(ACTIVE_LEVEL_OFF + 1)))\n\t\t\t\t\tactive_level = \"Active high|\";\n\t\t\t\telse if (!(pin_reg & BIT(ACTIVE_LEVEL_OFF)) &&\n\t\t\t\t\t pin_reg & BIT(ACTIVE_LEVEL_OFF + 1))\n\t\t\t\t\tactive_level = \"Active on both|\";\n\t\t\t\telse\n\t\t\t\t\tactive_level = \"Unknow Active level|\";\n\t\t\t\tif (pin_reg & BIT(LEVEL_TRIG_OFF))\n\t\t\t\t\tlevel_trig = \"Level trigger|\";\n\t\t\t\telse\n\t\t\t\t\tlevel_trig = \"Edge trigger|\";\n\t\t\t} else {\n\t\t\t\tinterrupt_enable =\n\t\t\t\t\t\"interrupt is disabled|\";\n\t\t\t\tactive_level = \" \";\n\t\t\t\tlevel_trig = \" \";\n\t\t\t}\n\t\t\tif (pin_reg & BIT(INTERRUPT_MASK_OFF))\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is unmasked|\";\n\t\t\telse\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is masked|\";\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S0I3))\n\t\t\t\twake_cntrl0 = \"enable wakeup in S0i3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl0 = \"disable wakeup in S0i3 state|\";\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S3))\n\t\t\t\twake_cntrl1 = \"enable wakeup in S3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl1 = \"disable wakeup in S3 state|\";\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S4))\n\t\t\t\twake_cntrl2 = \"enable wakeup in S4/S5 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl2 = \"disable wakeup in S4/S5 state|\";\n\t\t\tif (pin_reg & BIT(PULL_UP_ENABLE_OFF)) {\n\t\t\t\tpull_up_enable = \"pull-up is enabled|\";\n\t\t\t\tif (pin_reg & BIT(PULL_UP_SEL_OFF))\n\t\t\t\t\tpull_up_sel = \"8k pull-up|\";\n\t\t\t\telse\n\t\t\t\t\tpull_up_sel = \"4k pull-up|\";\n\t\t\t} else {\n\t\t\t\tpull_up_enable = \"pull-up is disabled|\";\n\t\t\t\tpull_up_sel = \" \";\n\t\t\t}\n\t\t\tif (pin_reg & BIT(PULL_DOWN_ENABLE_OFF))\n\t\t\t\tpull_down_enable = \"pull-down is enabled|\";\n\t\t\telse\n\t\t\t\tpull_down_enable = \"Pull-down is disabled|\";\n\t\t\tif (pin_reg & BIT(OUTPUT_ENABLE_OFF)) {\n\t\t\t\tpin_sts = \" \";\n\t\t\t\toutput_enable = \"output is enabled|\";\n\t\t\t\tif (pin_reg & BIT(OUTPUT_VALUE_OFF))\n\t\t\t\t\toutput_value = \"output is high|\";\n\t\t\t\telse\n\t\t\t\t\toutput_value = \"output is low|\";\n\t\t\t} else {\n\t\t\t\toutput_enable = \"output is disabled|\";\n\t\t\t\toutput_value = \" \";\n\t\t\t\tif (pin_reg & BIT(PIN_STS_OFF))\n\t\t\t\t\tpin_sts = \"input is high|\";\n\t\t\t\telse\n\t\t\t\t\tpin_sts = \"input is low|\";\n\t\t\t}\n\t\t\tseq_printf(s, \"%s %s %s %s %s %s\\n\"\n\t\t\t\t\" %s %s %s %s %s %s %s 0x%x\\n\",\n\t\t\t\tlevel_trig, active_level, interrupt_enable,\n\t\t\t\tinterrupt_mask, wake_cntrl0, wake_cntrl1,\n\t\t\t\twake_cntrl2, pin_sts, pull_up_sel,\n\t\t\t\tpull_up_enable, pull_down_enable,\n\t\t\t\toutput_value, output_enable, pin_reg);\n\t\t}\n\t}\n}\n#else\n#define amd_gpio_dbg_show NULL\n#endif\nstatic int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tbool level_trig;\n\tu32 active_level;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tlevel_trig = !(pin_reg & (LEVEL_TRIGGER << LEVEL_TRIG_OFF));\n\tactive_level = pin_reg & (ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\tif(level_trig &&\n\t   ((active_level >> ACTIVE_LEVEL_OFF) == ACTIVE_HIGH))\n\t\ttype = IRQ_TYPE_EDGE_FALLING;\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= BOTH_EADGE << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_LOW_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_HIGH_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\tcase IRQ_TYPE_NONE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid type value\\n\");\n\t\tret = -EINVAL;\n\t}\n\tpin_reg |= CLR_INTR_STAT << INTERRUPT_STS_OFF;\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\treturn ret;\n}\nstatic struct irq_chip amd_gpio_irqchip = {\n\t.name         = \"amd_gpio\",\n\t.irq_ack      = amd_irq_ack,\n\t.irq_enable   = amd_gpio_irq_enable,\n\t.irq_disable  = amd_gpio_irq_disable,\n\t.irq_mask     = amd_gpio_irq_mask,\n\t.irq_unmask   = amd_gpio_irq_unmask,\n\t.irq_eoi      = amd_gpio_irq_eoi,\n\t.irq_set_type = amd_gpio_irq_set_type,\n\t.flags        = IRQCHIP_SKIP_SET_WAKE,\n};\nstatic void amd_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 i;\n\tu32 off;\n\tu32 reg;\n\tu32 pin_reg;\n\tu64 reg64;\n\tint handled = 0;\n\tunsigned int irq;\n\tunsigned long flags;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\tchained_irq_enter(chip, desc);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG1);\n\treg64 = reg;\n\treg64 = reg64 << 32;\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG0);\n\treg64 |= reg;\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\tfor (off = 0; off < 46 ; off++) {\n\t\tif (reg64 & BIT(off)) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpin_reg = readl(gpio_dev->base +\n\t\t\t\t\t\t(off * 4 + i) * 4);\n\t\t\t\tif ((pin_reg & BIT(INTERRUPT_STS_OFF)) ||\n\t\t\t\t\t(pin_reg & BIT(WAKE_STS_OFF))) {\n\t\t\t\t\tirq = irq_find_mapping(gc->irqdomain,\n\t\t\t\t\t\t\t\toff * 4 + i);\n\t\t\t\t\tgeneric_handle_irq(irq);\n\t\t\t\t\twritel(pin_reg,\n\t\t\t\t\t\tgpio_dev->base\n\t\t\t\t\t\t+ (off * 4 + i) * 4);\n\t\t\t\t\thandled++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (handled == 0)\n\t\thandle_bad_irq(desc);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\tchained_irq_exit(chip, desc);\n}\nstatic const struct pinctrl_ops amd_pinctrl_ops = {\n\t.get_groups_count\t= amd_get_groups_count,\n\t.get_group_name\t\t= amd_get_group_name,\n\t.get_group_pins\t\t= amd_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n#endif\n};\nstatic int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tint i;\n\tu32 arg;\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tenum pin_config_param param;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\t\tpin_reg = readl(gpio_dev->base + pin*4);\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= arg & DB_TMR_OUT_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpin_reg &= ~BIT(PULL_DOWN_ENABLE_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_DOWN_ENABLE_OFF;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin_reg &= ~BIT(PULL_UP_SEL_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_UP_SEL_OFF;\n\t\t\tpin_reg &= ~BIT(PULL_UP_ENABLE_OFF);\n\t\t\tpin_reg |= ((arg>>1) & BIT(0)) << PULL_UP_ENABLE_OFF;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpin_reg &= ~(DRV_STRENGTH_SEL_MASK\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF);\n\t\t\tpin_reg |= (arg & DRV_STRENGTH_SEL_MASK)\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&gpio_dev->pdev->dev,\n\t\t\t\t\"Invalid config param %04x\\n\", param);\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\t\twritel(pin_reg, gpio_dev->base + pin*4);\n\t}\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\treturn ret;\n}\nstatic const struct pinconf_ops amd_pinconf_ops = {\n\t.pin_config_get\t\t= amd_pinconf_get,\n\t.pin_config_set\t\t= amd_pinconf_set,\n\t.pin_config_group_get = amd_pinconf_group_get,\n\t.pin_config_group_set = amd_pinconf_group_set,\n};\nstatic struct pinctrl_desc amd_pinctrl_desc = {\n\t.pins\t= kerncz_pins,\n\t.npins = ARRAY_SIZE(kerncz_pins),\n\t.pctlops = &amd_pinctrl_ops,\n\t.confops = &amd_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\nstatic int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gpio_dev->lock);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\tgpio_dev->gc.base\t\t= -1;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= resource_size(res) / 4;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\tgpio_dev->hwbank_num = gpio_dev->gc.ngpio / 64;\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n\t\t\t\t\t\tgpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\treturn ret;\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, gpio_dev->gc.ngpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\tplatform_set_drvdata(pdev, gpio_dev);\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\treturn ret;\n}\nstatic int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = platform_get_drvdata(pdev);\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn 0;\n}\nstatic const struct acpi_device_id amd_gpio_acpi_match[] = {\n\t{ \"AMD0030\", 0 },\n\t{ \"AMDI0030\", 0},\n\t{ },\n};\nstatic struct platform_driver amd_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"amd_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(amd_gpio_acpi_match),\n\t},\n\t.probe\t\t= amd_gpio_probe,\n\t.remove\t\t= amd_gpio_remove,\n};\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Ken Xue <Ken.Xue@amd.com>, Jeff Wu <Jeff.Wu@amd.com>\");\nMODULE_DESCRIPTION(\"AMD GPIO pinctrl driver\");\n",
        "cwe": "CWE-415",
        "file_name": "vul_respovul_idx_2700.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n    }\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n            if (data == 0xFF00 || data == 0x0) {\n                memcpy(rsp, req, req_length);\n            } else {\n        }\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <limits.h>\n#include <time.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#endif\n#include <config.h>\n#include \"modbus.h\"\n#include \"modbus-private.h\"\n#define MSG_LENGTH_UNDEFINED -1\nconst unsigned int libmodbus_version_major = LIBMODBUS_VERSION_MAJOR;\nconst unsigned int libmodbus_version_minor = LIBMODBUS_VERSION_MINOR;\nconst unsigned int libmodbus_version_micro = LIBMODBUS_VERSION_MICRO;\n#define MAX_MESSAGE_LENGTH 260\ntypedef enum {\n    _STEP_FUNCTION,\n    _STEP_META,\n    _STEP_DATA\n} _step_t;\nconst char *modbus_strerror(int errnum) {\n    switch (errnum) {\n    case EMBXILFUN:\n        return \"Illegal function\";\n    case EMBXILADD:\n        return \"Illegal data address\";\n    case EMBXILVAL:\n        return \"Illegal data value\";\n    case EMBXSFAIL:\n        return \"Slave device or server failure\";\n    case EMBXACK:\n        return \"Acknowledge\";\n    case EMBXSBUSY:\n        return \"Slave device or server is busy\";\n    case EMBXNACK:\n        return \"Negative acknowledge\";\n    case EMBXMEMPAR:\n        return \"Memory parity error\";\n    case EMBXGPATH:\n        return \"Gateway path unavailable\";\n    case EMBXGTAR:\n        return \"Target device failed to respond\";\n    case EMBBADCRC:\n        return \"Invalid CRC\";\n    case EMBBADDATA:\n        return \"Invalid data\";\n    case EMBBADEXC:\n        return \"Invalid exception code\";\n    case EMBMDATA:\n        return \"Too many data\";\n    case EMBBADSLAVE:\n        return \"Response not from requested slave\";\n    default:\n        return strerror(errnum);\n    }\n}\nvoid _error_print(modbus_t *ctx, const char *context)\n{\n    if (ctx->debug) {\n        fprintf(stderr, \"ERROR %s\", modbus_strerror(errno));\n        if (context != NULL) {\n            fprintf(stderr, \": %s\\n\", context);\n        } else {\n            fprintf(stderr, \"\\n\");\n        }\n    }\n}\nstatic void _sleep_response_timeout(modbus_t *ctx)\n{\n#ifdef _WIN32\n    Sleep((ctx->response_timeout.tv_sec * 1000) +\n          (ctx->response_timeout.tv_usec / 1000));\n#else\n    struct timespec request, remaining;\n    request.tv_sec = ctx->response_timeout.tv_sec;\n    request.tv_nsec = ((long int)ctx->response_timeout.tv_usec) * 1000;\n    while (nanosleep(&request, &remaining) == -1 && errno == EINTR) {\n        request = remaining;\n    }\n#endif\n}\nint modbus_flush(modbus_t *ctx)\n{\n    int rc;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    rc = ctx->backend->flush(ctx);\n    if (rc != -1 && ctx->debug) {\n        printf(\"Bytes flushed (%d)\\n\", rc);\n    }\n    return rc;\n}\nstatic unsigned int compute_response_length_from_request(modbus_t *ctx, uint8_t *req)\n{\n    int length;\n    const int offset = ctx->backend->header_length;\n    switch (req[offset]) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        int nb = (req[offset + 3] << 8) | req[offset + 4];\n        length = 2 + (nb / 8) + ((nb % 8) ? 1 : 0);\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS:\n        length = 2 + 2 * (req[offset + 3] << 8 | req[offset + 4]);\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        length = 3;\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID:\n        return MSG_LENGTH_UNDEFINED;\n    case MODBUS_FC_MASK_WRITE_REGISTER:\n        length = 7;\n        break;\n    default:\n        length = 5;\n    }\n    return offset + length + ctx->backend->checksum_length;\n}\nstatic int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)\n{\n    int rc;\n    int i;\n    msg_length = ctx->backend->send_msg_pre(msg, msg_length);\n    if (ctx->debug) {\n        for (i = 0; i < msg_length; i++)\n            printf(\"[%.2X]\", msg[i]);\n        printf(\"\\n\");\n    }\n    do {\n        rc = ctx->backend->send(ctx, msg, msg_length);\n        if (rc == -1) {\n            _error_print(ctx, NULL);\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n                if ((errno == EBADF || errno == ECONNRESET || errno == EPIPE)) {\n                    modbus_close(ctx);\n                    _sleep_response_timeout(ctx);\n                    modbus_connect(ctx);\n                } else {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                }\n                errno = saved_errno;\n            }\n        }\n    } while ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n             rc == -1);\n    if (rc > 0 && rc != msg_length) {\n        errno = EMBBADDATA;\n        return -1;\n    }\n    return rc;\n}\nint modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req, int raw_req_length)\n{\n    sft_t sft;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    int req_length;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (raw_req_length < 2 || raw_req_length > (MODBUS_MAX_PDU_LENGTH + 1)) {\n        errno = EINVAL;\n        return -1;\n    }\n    sft.slave = raw_req[0];\n    sft.function = raw_req[1];\n    sft.t_id = 0;\n    req_length = ctx->backend->build_response_basis(&sft, req);\n    if (raw_req_length > 2) {\n        memcpy(req + req_length, raw_req + 2, raw_req_length - 2);\n        req_length += raw_req_length - 2;\n    }\n    return send_msg(ctx, req, req_length);\n}\nstatic uint8_t compute_meta_length_after_function(int function,\n                                                  msg_type_t msg_type)\n{\n    int length;\n    if (msg_type == MSG_INDICATION) {\n        if (function <= MODBUS_FC_WRITE_SINGLE_REGISTER) {\n            length = 4;\n        } else if (function == MODBUS_FC_WRITE_MULTIPLE_COILS ||\n                   function == MODBUS_FC_WRITE_MULTIPLE_REGISTERS) {\n            length = 5;\n        } else if (function == MODBUS_FC_MASK_WRITE_REGISTER) {\n            length = 6;\n        } else if (function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = 9;\n        } else {\n            length = 0;\n        }\n    } else {\n        switch (function) {\n        case MODBUS_FC_WRITE_SINGLE_COIL:\n        case MODBUS_FC_WRITE_SINGLE_REGISTER:\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = 4;\n            break;\n        case MODBUS_FC_MASK_WRITE_REGISTER:\n            length = 6;\n            break;\n        default:\n            length = 1;\n        }\n    }\n    return length;\n}\nstatic int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg,\n                                          msg_type_t msg_type)\n{\n    int function = msg[ctx->backend->header_length];\n    int length;\n    if (msg_type == MSG_INDICATION) {\n        switch (function) {\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = msg[ctx->backend->header_length + 5];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n            length = msg[ctx->backend->header_length + 9];\n            break;\n        default:\n            length = 0;\n        }\n    } else {\n        if (function <= MODBUS_FC_READ_INPUT_REGISTERS ||\n            function == MODBUS_FC_REPORT_SLAVE_ID ||\n            function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = msg[ctx->backend->header_length + 1];\n        } else {\n            length = 0;\n        }\n    }\n    length += ctx->backend->checksum_length;\n    return length;\n}\nint _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)\n{\n    int rc;\n    fd_set rset;\n    struct timeval tv;\n    struct timeval *p_tv;\n    int length_to_read;\n    int msg_length = 0;\n    _step_t step;\n    if (ctx->debug) {\n        if (msg_type == MSG_INDICATION) {\n            printf(\"Waiting for an indication...\\n\");\n        } else {\n            printf(\"Waiting for a confirmation...\\n\");\n        }\n    }\n    FD_ZERO(&rset);\n    FD_SET(ctx->s, &rset);\n    step = _STEP_FUNCTION;\n    length_to_read = ctx->backend->header_length + 1;\n    if (msg_type == MSG_INDICATION) {\n        if (ctx->indication_timeout.tv_sec == 0 && ctx->indication_timeout.tv_usec == 0) {\n            p_tv = NULL;\n        } else {\n            tv.tv_sec = ctx->indication_timeout.tv_sec;\n            tv.tv_usec = ctx->indication_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    } else {\n        tv.tv_sec = ctx->response_timeout.tv_sec;\n        tv.tv_usec = ctx->response_timeout.tv_usec;\n        p_tv = &tv;\n    }\n    while (length_to_read != 0) {\n        rc = ctx->backend->select(ctx, &rset, p_tv, length_to_read);\n        if (rc == -1) {\n            _error_print(ctx, \"select\");\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n                if (errno == ETIMEDOUT) {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                } else if (errno == EBADF) {\n                    modbus_close(ctx);\n                    modbus_connect(ctx);\n                }\n                errno = saved_errno;\n            }\n            return -1;\n        }\n        rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);\n        if (rc == 0) {\n            errno = ECONNRESET;\n            rc = -1;\n        }\n        if (rc == -1) {\n            _error_print(ctx, \"read\");\n            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n                (errno == ECONNRESET || errno == ECONNREFUSED ||\n                 errno == EBADF)) {\n                int saved_errno = errno;\n                modbus_close(ctx);\n                modbus_connect(ctx);\n                errno = saved_errno;\n            }\n            return -1;\n        }\n        if (ctx->debug) {\n            int i;\n            for (i=0; i < rc; i++)\n                printf(\"<%.2X>\", msg[msg_length + i]);\n        }\n        msg_length += rc;\n        length_to_read -= rc;\n        if (length_to_read == 0) {\n            switch (step) {\n            case _STEP_FUNCTION:\n                length_to_read = compute_meta_length_after_function(\n                    msg[ctx->backend->header_length],\n                    msg_type);\n                if (length_to_read != 0) {\n                    step = _STEP_META;\n                    break;\n                } \n            case _STEP_META:\n                length_to_read = compute_data_length_after_meta(\n                    ctx, msg, msg_type);\n                if ((msg_length + length_to_read) > (int)ctx->backend->max_adu_length) {\n                    errno = EMBBADDATA;\n                    _error_print(ctx, \"too many data\");\n                    return -1;\n                }\n                step = _STEP_DATA;\n                break;\n            default:\n                break;\n            }\n        }\n        if (length_to_read > 0 &&\n            (ctx->byte_timeout.tv_sec > 0 || ctx->byte_timeout.tv_usec > 0)) {\n            tv.tv_sec = ctx->byte_timeout.tv_sec;\n            tv.tv_usec = ctx->byte_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    }\n    if (ctx->debug)\n        printf(\"\\n\");\n    return ctx->backend->check_integrity(ctx, msg, msg_length);\n}\nstatic int check_confirmation(modbus_t *ctx, uint8_t *req,\n                              uint8_t *rsp, int rsp_length)\n{\n    int rc;\n    int rsp_length_computed;\n    const int offset = ctx->backend->header_length;\n    const int function = rsp[offset];\n    if (ctx->backend->pre_check_confirmation) {\n        rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);\n        if (rc == -1) {\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            return -1;\n        }\n    }\n    rsp_length_computed = compute_response_length_from_request(ctx, req);\n    if (function >= 0x80) {\n        if (rsp_length == (offset + 2 + (int)ctx->backend->checksum_length) &&\n            req[offset] == (rsp[offset] - 0x80)) {\n            int exception_code = rsp[offset + 1];\n            if (exception_code < MODBUS_EXCEPTION_MAX) {\n                errno = MODBUS_ENOBASE + exception_code;\n            } else {\n                errno = EMBBADEXC;\n            }\n            _error_print(ctx, NULL);\n            return -1;\n        } else {\n            errno = EMBBADEXC;\n            _error_print(ctx, NULL);\n            return -1;\n        }\n    }\n    if ((rsp_length == rsp_length_computed ||\n         rsp_length_computed == MSG_LENGTH_UNDEFINED) &&\n        function < 0x80) {\n        int req_nb_value;\n        int rsp_nb_value;\n        if (function != req[offset]) {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Received function not corresponding to the request (0x%X != 0x%X)\\n\",\n                        function, req[offset]);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            return -1;\n        }\n        switch (function) {\n        case MODBUS_FC_READ_COILS:\n        case MODBUS_FC_READ_DISCRETE_INPUTS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            req_nb_value = (req_nb_value / 8) + ((req_nb_value % 8) ? 1 : 0);\n            rsp_nb_value = rsp[offset + 1];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n        case MODBUS_FC_READ_HOLDING_REGISTERS:\n        case MODBUS_FC_READ_INPUT_REGISTERS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 1] / 2);\n            break;\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];\n            break;\n        case MODBUS_FC_REPORT_SLAVE_ID:\n            req_nb_value = rsp_nb_value = rsp[offset + 1];\n            break;\n        default:\n            req_nb_value = rsp_nb_value = 1;\n        }\n        if (req_nb_value == rsp_nb_value) {\n            rc = rsp_nb_value;\n        } else {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Quantity not corresponding to the request (%d != %d)\\n\",\n                        rsp_nb_value, req_nb_value);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            rc = -1;\n        }\n    } else {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"Message length not corresponding to the computed length (%d != %d)\\n\",\n                    rsp_length, rsp_length_computed);\n        }\n        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n            _sleep_response_timeout(ctx);\n            modbus_flush(ctx);\n        }\n        errno = EMBBADDATA;\n        rc = -1;\n    }\n    return rc;\n}\nstatic int response_io_status(uint8_t *tab_io_status,\n                              int address, int nb,\n                              uint8_t *rsp, int offset)\n{\n    int shift = 0;\n    int one_byte = 0;\n    int i;\n    for (i = address; i < address + nb; i++) {\n        one_byte |= tab_io_status[i] << shift;\n        if (shift == 7) {\n            rsp[offset++] = one_byte;\n            one_byte = shift = 0;\n        } else {\n            shift++;\n        }\n    }\n    if (shift != 0)\n        rsp[offset++] = one_byte;\n    return offset;\n}\nstatic int response_exception(modbus_t *ctx, sft_t *sft,\n                              int exception_code, uint8_t *rsp,\n                              unsigned int to_flush,\n                              const char* template, ...)\n{\n    int rsp_length;\n    if (ctx->debug) {\n        va_list ap;\n        va_start(ap, template);\n        vfprintf(stderr, template, ap);\n        va_end(ap);\n    }\n    if (to_flush) {\n        _sleep_response_timeout(ctx);\n        modbus_flush(ctx);\n    }\n    sft->function = sft->function + 0x80;\n    rsp_length = ctx->backend->build_response_basis(sft, rsp);\n    rsp[rsp_length++] = exception_code;\n    return rsp_length;\n}\nint modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - start_bits;\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - start_registers;\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        rsp[rsp_length++] = 0xFF;\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}\nstatic int read_io_status(modbus_t *ctx, int function,\n                          int addr, int nb, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i, temp, bit;\n        int pos = 0;\n        int offset;\n        int offset_end;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length + 2;\n        offset_end = offset + rc;\n        for (i = offset; i < offset_end; i++) {\n            temp = rsp[i];\n            for (bit = 0x01; (bit & 0xff) && (pos < nb);) {\n                dest[pos++] = (temp & bit) ? TRUE : FALSE;\n                bit = bit << 1;\n            }\n        }\n    }\n    return rc;\n}\nstatic int read_registers(modbus_t *ctx, int function, int addr, int nb,\n                          uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        int i;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n    return rc;\n}\nint modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)\n{\n    int rc;\n    int i;\n    int byte_count;\n    int req_length;\n    int bit_check = 0;\n    int pos = 0;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (nb > MODBUS_MAX_WRITE_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr, \"ERROR Writing too many bits (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_COILS,\n                                                   addr, nb, req);\n    byte_count = (nb / 8) + ((nb % 8) ? 1 : 0);\n    req[req_length++] = byte_count;\n    for (i = 0; i < byte_count; i++) {\n        int bit;\n        bit = 0x01;\n        req[req_length] = 0;\n        while ((bit & 0xFF) && (bit_check++ < nb)) {\n            if (src[pos++])\n                req[req_length] |= bit;\n            else\n                req[req_length] &=~ bit;\n            bit = bit << 1;\n        }\n        req_length++;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)\n{\n    int rc;\n    int i;\n    int req_length;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (nb > MODBUS_MAX_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Trying to write to too many registers (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_REGISTERS,\n                                                   addr, nb, req);\n    byte_count = nb * 2;\n    req[req_length++] = byte_count;\n    for (i = 0; i < nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH + 2];\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_MASK_WRITE_REGISTER,\n                                                   addr, 0, req);\n    req_length -= 2;\n    req[req_length++] = and_mask >> 8;\n    req[req_length++] = and_mask & 0x00ff;\n    req[req_length++] = or_mask >> 8;\n    req[req_length++] = or_mask & 0x00ff;\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\nint modbus_write_and_read_registers(modbus_t *ctx,\n                                    int write_addr, int write_nb,\n                                    const uint16_t *src,\n                                    int read_addr, int read_nb,\n                                    uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    int i;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (write_nb > MODBUS_MAX_WR_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers to write (%d > %d)\\n\",\n                    write_nb, MODBUS_MAX_WR_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    if (read_nb > MODBUS_MAX_WR_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    read_nb, MODBUS_MAX_WR_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_AND_READ_REGISTERS,\n                                                   read_addr, read_nb, req);\n    req[req_length++] = write_addr >> 8;\n    req[req_length++] = write_addr & 0x00ff;\n    req[req_length++] = write_nb >> 8;\n    req[req_length++] = write_nb & 0x00ff;\n    byte_count = write_nb * 2;\n    req[req_length++] = byte_count;\n    for (i = 0; i < write_nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n    return rc;\n}\nint modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    if (ctx == NULL || max_dest <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx, MODBUS_FC_REPORT_SLAVE_ID,\n                                                   0, 0, req);\n    req_length -= 4;\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i;\n        int offset;\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n        offset = ctx->backend->header_length + 2;\n        for (i=0; i < rc && i < max_dest; i++) {\n            dest[i] = rsp[offset + i];\n        }\n    }\n    return rc;\n}\nint modbus_connect(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    return ctx->backend->connect(ctx);\n}\nvoid modbus_close(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n    ctx->backend->close(ctx);\n}\nmodbus_mapping_t* modbus_mapping_new_start_address(\n    unsigned int start_bits, unsigned int nb_bits,\n    unsigned int start_input_bits, unsigned int nb_input_bits,\n    unsigned int start_registers, unsigned int nb_registers,\n    unsigned int start_input_registers, unsigned int nb_input_registers)\n{\n    modbus_mapping_t *mb_mapping;\n    mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));\n    if (mb_mapping == NULL) {\n        return NULL;\n    }\n    mb_mapping->nb_bits = nb_bits;\n    mb_mapping->start_bits = start_bits;\n    if (nb_bits == 0) {\n        mb_mapping->tab_bits = NULL;\n    } else {\n        mb_mapping->tab_bits =\n            (uint8_t *) malloc(nb_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_bits == NULL) {\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_bits, 0, nb_bits * sizeof(uint8_t));\n    }\n    mb_mapping->nb_input_bits = nb_input_bits;\n    mb_mapping->start_input_bits = start_input_bits;\n    if (nb_input_bits == 0) {\n        mb_mapping->tab_input_bits = NULL;\n    } else {\n        mb_mapping->tab_input_bits =\n            (uint8_t *) malloc(nb_input_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_input_bits == NULL) {\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_bits, 0, nb_input_bits * sizeof(uint8_t));\n    }\n    mb_mapping->nb_registers = nb_registers;\n    mb_mapping->start_registers = start_registers;\n    if (nb_registers == 0) {\n        mb_mapping->tab_registers = NULL;\n    } else {\n        mb_mapping->tab_registers =\n            (uint16_t *) malloc(nb_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_registers == NULL) {\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_registers, 0, nb_registers * sizeof(uint16_t));\n    }\n    mb_mapping->nb_input_registers = nb_input_registers;\n    mb_mapping->start_input_registers = start_input_registers;\n    if (nb_input_registers == 0) {\n        mb_mapping->tab_input_registers = NULL;\n    } else {\n        mb_mapping->tab_input_registers =\n            (uint16_t *) malloc(nb_input_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_input_registers == NULL) {\n            free(mb_mapping->tab_registers);\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_registers, 0,\n               nb_input_registers * sizeof(uint16_t));\n    }\n    return mb_mapping;\n}\n#ifndef HAVE_STRLCPY\n#endif\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_3613.c",
        "project": "stephane/libmodbus",
        "url": "https://github.com/stephane/libmodbus/commit/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tint nfsv3_data_offset = 0;\n\tmemcpy((unsigned char *)&rpc_pkt, pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\tif (!(supported_nfs_versions & NFSV2_FLAG)) { \n\t\tnfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t}\n\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\treturn -NFS_RPC_DROP;\n\tif (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {\n\t\tstrcat(nfs_path, \"/\");\n\t\tpathlen = strlen(nfs_path);\n\t\tmemcpy(nfs_path + pathlen,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t} else {\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <common.h>\n#include <command.h>\n#include <net.h>\n#include <malloc.h>\n#include <mapmem.h>\n#include \"nfs.h\"\n#include \"bootp.h\"\n#define HASHES_PER_LINE 65\t\n#define NFS_RETRY_COUNT 30\n#ifndef CONFIG_NFS_TIMEOUT\n# define NFS_TIMEOUT 2000UL\n#else\n# define NFS_TIMEOUT CONFIG_NFS_TIMEOUT\n#endif\n#define NFS_RPC_ERR\t1\n#define NFS_RPC_DROP\t124\nstatic int fs_mounted;\nstatic unsigned long rpc_id;\nstatic int nfs_offset = -1;\nstatic int nfs_len;\nstatic ulong nfs_timeout = NFS_TIMEOUT;\nstatic char dirfh[NFS_FHSIZE];\t\nstatic char filefh[NFS3_FHSIZE]; \nstatic int filefh3_length;\t\nstatic enum net_loop_state nfs_download_state;\nstatic struct in_addr nfs_server_ip;\nstatic int nfs_server_mount_port;\nstatic int nfs_server_port;\nstatic int nfs_our_port;\nstatic int nfs_timeout_count;\nstatic int nfs_state;\n#define STATE_PRCLOOKUP_PROG_MOUNT_REQ\t1\n#define STATE_PRCLOOKUP_PROG_NFS_REQ\t2\n#define STATE_MOUNT_REQ\t\t\t3\n#define STATE_UMOUNT_REQ\t\t4\n#define STATE_LOOKUP_REQ\t\t5\n#define STATE_READ_REQ\t\t\t6\n#define STATE_READLINK_REQ\t\t7\nstatic char *nfs_filename;\nstatic char *nfs_path;\nstatic char nfs_path_buff[2048];\n#define NFSV2_FLAG 1\n#define NFSV3_FLAG 1 << 1\nstatic char supported_nfs_versions = NFSV2_FLAG | NFSV3_FLAG;\nstatic void rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)\n{\n\tstruct rpc_t rpc_pkt;\n\tunsigned long id;\n\tuint32_t *p;\n\tint pktlen;\n\tint sport;\n\tid = ++rpc_id;\n\trpc_pkt.u.call.id = htonl(id);\n\trpc_pkt.u.call.type = htonl(MSG_CALL);\n\trpc_pkt.u.call.rpcvers = htonl(2);\t\n\trpc_pkt.u.call.prog = htonl(rpc_prog);\n\tswitch (rpc_prog) {\n\tcase PROG_NFS:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_pkt.u.call.vers = htonl(2);\t\n\t\telse \n\t\t\trpc_pkt.u.call.vers = htonl(3);\t\n\t\tbreak;\n\tcase PROG_PORTMAP:\n\tcase PROG_MOUNT:\n\tdefault:\n\t\trpc_pkt.u.call.vers = htonl(2);\t\n\t}\n\trpc_pkt.u.call.proc = htonl(rpc_proc);\n\tp = (uint32_t *)&(rpc_pkt.u.call.data);\n\tif (datalen)\n\t\tmemcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));\n\tpktlen = (char *)p + datalen * sizeof(uint32_t) - (char *)&rpc_pkt;\n\tmemcpy((char *)net_tx_packet + net_eth_hdr_size() + IP_UDP_HDR_SIZE,\n\t       &rpc_pkt.u.data[0], pktlen);\n\tif (rpc_prog == PROG_PORTMAP)\n\t\tsport = SUNRPC_PORT;\n\telse if (rpc_prog == PROG_MOUNT)\n\t\tsport = nfs_server_mount_port;\n\telse\n\t\tsport = nfs_server_port;\n\tnet_send_udp_packet(net_server_ethaddr, nfs_server_ip, sport,\n\t\t\t    nfs_our_port, pktlen);\n}\nstatic int nfs_lookup_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tswitch (ntohl(rpc_pkt.u.reply.astatus)) {\n\t\tcase NFS_RPC_SUCCESS: \n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_MISMATCH:\n\t\t\tswitch (ntohl(rpc_pkt.u.reply.data[0])) {\n\t\t\tcase 3:\n\t\t\t\tdebug(\"*** Warning: NFS version not supported: Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tdebug(\"Will retry with NFSv3\\n\");\n\t\t\t\tsupported_nfs_versions &= ~NFSV2_FLAG;\n\t\t\t\treturn -NFS_RPC_PROG_MISMATCH;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tputs(\"*** ERROR: NFS version not supported\");\n\t\t\t\tdebug(\": Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tputs(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_UNAVAIL:\n\t\tcase NFS_RPC_PROC_UNAVAIL:\n\t\tcase NFS_RPC_GARBAGE_ARGS:\n\t\tcase NFS_RPC_SYSTEM_ERR:\n\t\tdefault: \n\t\t\tdebug(\"*** ERROR: accept state error (%d)\\n\",\n\t\t\t      ntohl(rpc_pkt.u.reply.astatus));\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + NFS_FHSIZE) > len)\n\t\t\treturn -NFS_RPC_DROP;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\t} else {  \n\t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\t\tif (filefh3_length > NFS3_FHSIZE)\n\t\t\tfilefh3_length  = NFS3_FHSIZE;\n\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + filefh3_length) > len)\n\t\t\treturn -NFS_RPC_DROP;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);\n\t}\n\treturn 0;\n}\nstatic int nfs_readlink_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tint nfsv3_data_offset = 0;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy((unsigned char *)&rpc_pkt, pkt, len);\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\tif (!(supported_nfs_versions & NFSV2_FLAG)) { \n\t\tnfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t}\n\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\treturn -NFS_RPC_DROP;\n\tif (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {\n\t\tint pathlen;\n\t\tstrcat(nfs_path, \"/\");\n\t\tpathlen = strlen(nfs_path);\n\t\tmemcpy(nfs_path + pathlen,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[pathlen + rlen] = 0;\n\t} else {\n\t\tmemcpy(nfs_path,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n\treturn 0;\n}\nstatic int nfs_read_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tuchar *data_ptr;\n\tdebug(\"%s\\n\", __func__);\n\tmemcpy(&rpc_pkt.u.data[0], pkt, sizeof(rpc_pkt.u.reply));\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tif (rpc_pkt.u.reply.rstatus)\n\t\t\treturn -9999;\n\t\tif (rpc_pkt.u.reply.astatus)\n\t\t\treturn -9999;\n\t\treturn -ntohl(rpc_pkt.u.reply.data[0]);\n\t}\n\tif ((nfs_offset != 0) && !((nfs_offset) %\n\t\t\t(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))\n\t\tputs(\"\\n\\t \");\n\tif (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))\n\t\tputc('#');\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\trlen = ntohl(rpc_pkt.u.reply.data[18]);\n\t\tdata_ptr = (uchar *)&(rpc_pkt.u.reply.data[19]);\n\t} else {  \n\t\tint nfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\t\tdata_ptr = (uchar *)\n\t\t\t&(rpc_pkt.u.reply.data[4 + nfsv3_data_offset]);\n\t}\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\t\treturn -9999;\n\tif (store_block(data_ptr, nfs_offset, rlen))\n\t\t\treturn -9999;\n\treturn rlen;\n}\nstatic void nfs_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n\t\t\tunsigned src, unsigned len)\n{\n\tint rlen;\n\tint reply;\n\tdebug(\"%s\\n\", __func__);\n\tif (len > sizeof(struct rpc_t))\n\t\treturn;\n\tif (dest != nfs_our_port)\n\t\treturn;\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (rpc_lookup_reply(PROG_MOUNT, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_PRCLOOKUP_PROG_NFS_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (rpc_lookup_reply(PROG_NFS, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_MOUNT_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\tcase STATE_MOUNT_REQ:\n\t\treply = nfs_mount_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Cannot mount\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_LOOKUP_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_UMOUNT_REQ:\n\t\treply = nfs_umountall_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tdebug(\"*** ERROR: Cannot umount\\n\");\n\t\t\tnet_set_state(NETLOOP_FAIL);\n\t\t} else {\n\t\t\tputs(\"\\ndone\\n\");\n\t\t\tnet_set_state(nfs_download_state);\n\t\t}\n\t\tbreak;\n\tcase STATE_LOOKUP_REQ:\n\t\treply = nfs_lookup_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: File lookup fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else if (reply == -NFS_RPC_PROG_MISMATCH &&\n\t\t\t   supported_nfs_versions != 0) {\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_READ_REQ;\n\t\t\tnfs_offset = 0;\n\t\t\tnfs_len = NFS_READ_SIZE;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_READLINK_REQ:\n\t\treply = nfs_readlink_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Symlink fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tdebug(\"Symlink --> %s\\n\", nfs_path);\n\t\t\tnfs_filename = basename(nfs_path);\n\t\t\tnfs_path     = dirname(nfs_path);\n\t\t\tnfs_state = STATE_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\tcase STATE_READ_REQ:\n\t\trlen = nfs_read_reply(pkt, len);\n\t\tif (rlen == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\t\tif (rlen > 0) {\n\t\t\tnfs_offset += rlen;\n\t\t\tnfs_send();\n\t\t} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {\n\t\t\tnfs_state = STATE_READLINK_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tif (!rlen)\n\t\t\t\tnfs_download_state = NETLOOP_SUCCESS;\n\t\t\tif (rlen < 0)\n\t\t\t\tdebug(\"NFS READ error (%d)\\n\", rlen);\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\t}\n}\nvoid nfs_start(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\tnfs_download_state = NETLOOP_FAIL;\n\tnfs_server_ip = net_server_ip;\n\tnfs_path = (char *)nfs_path_buff;\n\tif (nfs_path == NULL) {\n\t\tnet_set_state(NETLOOP_FAIL);\n\t\tprintf(\"*** ERROR: Fail allocate memory\\n\");\n\t\treturn;\n\t}\n\tif (!net_parse_bootfile(&nfs_server_ip, nfs_path,\n\t\t\t\tsizeof(nfs_path_buff))) {\n\t\tsprintf(nfs_path, \"/nfsroot/%02X%02X%02X%02X.img\",\n\t\t\tnet_ip.s_addr & 0xFF,\n\t\t\t(net_ip.s_addr >>  8) & 0xFF,\n\t\t\t(net_ip.s_addr >> 16) & 0xFF,\n\t\t\t(net_ip.s_addr >> 24) & 0xFF);\n\t\tprintf(\"*** Warning: no boot file name; using '%s'\\n\",\n\t\t       nfs_path);\n\t}\n\tnfs_filename = basename(nfs_path);\n\tnfs_path     = dirname(nfs_path);\n\tprintf(\"Using %s device\\n\", eth_get_name());\n\tprintf(\"File transfer via NFS from server %pI4; our IP address is %pI4\",\n\t       &nfs_server_ip, &net_ip);\n\tif (net_gateway.s_addr && net_netmask.s_addr) {\n\t\tstruct in_addr our_net;\n\t\tstruct in_addr server_net;\n\t\tour_net.s_addr = net_ip.s_addr & net_netmask.s_addr;\n\t\tserver_net.s_addr = nfs_server_ip.s_addr & net_netmask.s_addr;\n\t\tif (our_net.s_addr != server_net.s_addr)\n\t\t\tprintf(\"; sending through gateway %pI4\",\n\t\t\t       &net_gateway);\n\t}\n\tprintf(\"\\nFilename '%s/%s'.\", nfs_path, nfs_filename);\n\tif (net_boot_file_expected_size_in_blocks) {\n\t\tprintf(\" Size is 0x%x Bytes = \",\n\t\t       net_boot_file_expected_size_in_blocks << 9);\n\t\tprint_size(net_boot_file_expected_size_in_blocks << 9, \"\");\n\t}\n\tprintf(\"\\nLoad address: 0x%lx\\nLoading: *\\b\", load_addr);\n\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\tnet_set_udp_handler(nfs_handler);\n\tnfs_timeout_count = 0;\n\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\tnfs_our_port = 1000;\n\tmemset(net_server_ethaddr, 0, 6);\n\tnfs_send();\n}\n",
        "cwe": "CWE-120",
        "file_name": "safe_respovul_idx_8224.c",
        "project": "u-boot/u-boot",
        "url": "https://github.com/u-boot/u-boot/commit/5d14ee4e53a81055d34ba280cb8fd90330f22a96",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int usb_get_configuration(struct usb_device *dev)\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tcfgno = 0;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\tif (ncfg < 1) {\n\t}\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t}\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n#define USB_MAXALTSETTING\t\t128\t\n#define USB_MAXCONFIG\t\t\t8\t\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_warn(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_warn(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_warn(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_warn(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_warn(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_warn(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 512,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,\n    int asnum, struct usb_host_interface *ifp, int num_ep,\n    unsigned char *buffer, int size)\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\tfor (i = 0; i < ifp->desc.bNumEndpoints; ++i) {\n\t\tif (ifp->endpoint[i].desc.bEndpointAddress ==\n\t\t    d->bEndpointAddress) {\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\ti = 0;\t\t\n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t\n\t\t\tj = 16;\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t\n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t\n\t\t\tbreak;\n\t\tdefault:\t\t\n\t\t\tn = 4;\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\tif (to_usb_device(ddev)->speed == USB_SPEED_LOW &&\n\t\t\tusb_endpoint_xfer_bulk(d)) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\tmaxp = usb_endpoint_maxp(&endpoint->desc);\n\ti = 0;\t\t\n\tswitch (to_usb_device(ddev)->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & (BIT(12) | BIT(11));\n\t\t\tmaxp &= ~i;\n\t\t}\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\tif (maxp > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\tif (to_usb_device(ddev)->speed == USB_SPEED_HIGH\n\t\t\t&& usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\tif (to_usb_device(ddev)->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_warn(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t\n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_warn(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\tif (num_ep > 0) {\n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,\n\t\t    num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\tif (n != num_ep_orig)\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinum = d->bInterfaceNumber;\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] =\n\t\t\t\t\t(struct usb_interface_assoc_descriptor\n\t\t\t\t\t*)header;\n\t\t\t\tiad_num++;\n\t\t\t}\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\t}\t\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\treturn 0;\n}\nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tint result = 0;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\tcfgno = 0;\n\tresult = -ENOMEM;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\tresult = 0;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_err(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tresult = 0;\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\nerr2:\n\tif (result == -ENOMEM)\n\t\tdev_err(ddev, \"out of memory\\n\");\n\treturn result;\n}\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\nFile number 2:\n/*\n * This file holds USB constants and structures that are needed for\n * USB device APIs.  These are used by the USB device model, which is\n * defined in chapter 9 of the USB 2.0 specification and in the\n * Wireless USB 1.0 (spread around).  Linux has several APIs in C that\n * need these:\n *\n * - the master/host side Linux-USB kernel driver API;\n * - the \"usbfs\" user space API; and\n * - the Linux \"gadget\" slave/device/peripheral side driver API.\n *\n * USB 2.0 adds an additional \"On The Go\" (OTG) mode, which lets systems\n * act either as a USB master/host or as a USB slave/device.  That means\n * the master and slave side APIs benefit from working well together.\n *\n * There's also \"Wireless USB\", using low power short range radios for\n * peripheral interconnection but otherwise building on the USB framework.\n *\n * Note all descriptors are declared '__attribute__((packed))' so that:\n *\n * [a] they never get padded, either internally (USB spec writers\n *     probably handled that) or externally;\n *\n * [b] so that accessing bigger-than-a-bytes fields will never\n *     generate bus errors on any platform, even when the location of\n *     its descriptor inside a bundle isn't \"naturally aligned\", and\n *\n * [c] for consistency, removing all doubt even when it appears to\n *     someone that the two other points are non-issues for that\n *     particular descriptor type.\n */\n\n#ifndef _UAPI__LINUX_USB_CH9_H\n#define _UAPI__LINUX_USB_CH9_H\n\n#include <linux/types.h>\t/* __u8 etc */\n#include <asm/byteorder.h>\t/* le16_to_cpu */\n\n/*-------------------------------------------------------------------------*/\n\n/* CONTROL REQUEST SUPPORT */\n\n/*\n * USB directions\n *\n * This bit flag is used in endpoint descriptors' bEndpointAddress field.\n * It's also one of three fields in control requests bRequestType.\n */\n#define USB_DIR_OUT\t\t\t0\t\t/* to device */\n#define USB_DIR_IN\t\t\t0x80\t\t/* to host */\n\n/*\n * USB types, the second of three bRequestType fields\n */\n#define USB_TYPE_MASK\t\t\t(0x03 << 5)\n#define USB_TYPE_STANDARD\t\t(0x00 << 5)\n#define USB_TYPE_CLASS\t\t\t(0x01 << 5)\n#define USB_TYPE_VENDOR\t\t\t(0x02 << 5)\n#define USB_TYPE_RESERVED\t\t(0x03 << 5)\n\n/*\n * USB recipients, the third of three bRequestType fields\n */\n#define USB_RECIP_MASK\t\t\t0x1f\n#define USB_RECIP_DEVICE\t\t0x00\n#define USB_RECIP_INTERFACE\t\t0x01\n#define USB_RECIP_ENDPOINT\t\t0x02\n#define USB_RECIP_OTHER\t\t\t0x03\n/* From Wireless USB 1.0 */\n#define USB_RECIP_PORT\t\t\t0x04\n#define USB_RECIP_RPIPE\t\t0x05\n\n/*\n * Standard requests, for the bRequest field of a SETUP packet.\n *\n * These are qualified by the bRequestType field, so that for example\n * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved\n * by a GET_STATUS request.\n */\n#define USB_REQ_GET_STATUS\t\t0x00\n#define USB_REQ_CLEAR_FEATURE\t\t0x01\n#define USB_REQ_SET_FEATURE\t\t0x03\n#define USB_REQ_SET_ADDRESS\t\t0x05\n#define USB_REQ_GET_DESCRIPTOR\t\t0x06\n#define USB_REQ_SET_DESCRIPTOR\t\t0x07\n#define USB_REQ_GET_CONFIGURATION\t0x08\n#define USB_REQ_SET_CONFIGURATION\t0x09\n#define USB_REQ_GET_INTERFACE\t\t0x0A\n#define USB_REQ_SET_INTERFACE\t\t0x0B\n#define USB_REQ_SYNCH_FRAME\t\t0x0C\n#define USB_REQ_SET_SEL\t\t\t0x30\n#define USB_REQ_SET_ISOCH_DELAY\t\t0x31\n\n#define USB_REQ_SET_ENCRYPTION\t\t0x0D\t/* Wireless USB */\n#define USB_REQ_GET_ENCRYPTION\t\t0x0E\n#define USB_REQ_RPIPE_ABORT\t\t0x0E\n#define USB_REQ_SET_HANDSHAKE\t\t0x0F\n#define USB_REQ_RPIPE_RESET\t\t0x0F\n#define USB_REQ_GET_HANDSHAKE\t\t0x10\n#define USB_REQ_SET_CONNECTION\t\t0x11\n#define USB_REQ_SET_SECURITY_DATA\t0x12\n#define USB_REQ_GET_SECURITY_DATA\t0x13\n#define USB_REQ_SET_WUSB_DATA\t\t0x14\n#define USB_REQ_LOOPBACK_DATA_WRITE\t0x15\n#define USB_REQ_LOOPBACK_DATA_READ\t0x16\n#define USB_REQ_SET_INTERFACE_DS\t0x17\n\n/* specific requests for USB Power Delivery */\n#define USB_REQ_GET_PARTNER_PDO\t\t20\n#define USB_REQ_GET_BATTERY_STATUS\t21\n#define USB_REQ_SET_PDO\t\t\t22\n#define USB_REQ_GET_VDM\t\t\t23\n#define USB_REQ_SEND_VDM\t\t24\n\n/* The Link Power Management (LPM) ECN defines USB_REQ_TEST_AND_SET command,\n * used by hubs to put ports into a new L1 suspend state, except that it\n * forgot to define its number ...\n */\n\n/*\n * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and\n * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there\n * are at most sixteen features of each type.)  Hubs may also support a\n * new USB_REQ_TEST_AND_SET_FEATURE to put ports into L1 suspend.\n */\n#define USB_DEVICE_SELF_POWERED\t\t0\t/* (read only) */\n#define USB_DEVICE_REMOTE_WAKEUP\t1\t/* dev may initiate wakeup */\n#define USB_DEVICE_TEST_MODE\t\t2\t/* (wired high speed only) */\n#define USB_DEVICE_BATTERY\t\t2\t/* (wireless) */\n#define USB_DEVICE_B_HNP_ENABLE\t\t3\t/* (otg) dev may initiate HNP */\n#define USB_DEVICE_WUSB_DEVICE\t\t3\t/* (wireless)*/\n#define USB_DEVICE_A_HNP_SUPPORT\t4\t/* (otg) RH port supports HNP */\n#define USB_DEVICE_A_ALT_HNP_SUPPORT\t5\t/* (otg) other RH port does */\n#define USB_DEVICE_DEBUG_MODE\t\t6\t/* (special devices only) */\n\n/*\n * Test Mode Selectors\n * See USB 2.0 spec Table 9-7\n */\n#define\tTEST_J\t\t1\n#define\tTEST_K\t\t2\n#define\tTEST_SE0_NAK\t3\n#define\tTEST_PACKET\t4\n#define\tTEST_FORCE_EN\t5\n\n/*\n * New Feature Selectors as added by USB 3.0\n * See USB 3.0 spec Table 9-7\n */\n#define USB_DEVICE_U1_ENABLE\t48\t/* dev may initiate U1 transition */\n#define USB_DEVICE_U2_ENABLE\t49\t/* dev may initiate U2 transition */\n#define USB_DEVICE_LTM_ENABLE\t50\t/* dev may send LTM */\n#define USB_INTRF_FUNC_SUSPEND\t0\t/* function suspend */\n\n#define USB_INTR_FUNC_SUSPEND_OPT_MASK\t0xFF00\n/*\n * Suspend Options, Table 9-8 USB 3.0 spec\n */\n#define USB_INTRF_FUNC_SUSPEND_LP\t(1 << (8 + 0))\n#define USB_INTRF_FUNC_SUSPEND_RW\t(1 << (8 + 1))\n\n/*\n * Interface status, Figure 9-5 USB 3.0 spec\n */\n#define USB_INTRF_STAT_FUNC_RW_CAP     1\n#define USB_INTRF_STAT_FUNC_RW         2\n\n#define USB_ENDPOINT_HALT\t\t0\t/* IN/OUT will STALL */\n\n/* Bit array elements as returned by the USB_REQ_GET_STATUS request. */\n#define USB_DEV_STAT_U1_ENABLED\t\t2\t/* transition into U1 state */\n#define USB_DEV_STAT_U2_ENABLED\t\t3\t/* transition into U2 state */\n#define USB_DEV_STAT_LTM_ENABLED\t4\t/* Latency tolerance messages */\n\n/*\n * Feature selectors from Table 9-8 USB Power Delivery spec\n */\n#define USB_DEVICE_BATTERY_WAKE_MASK\t40\n#define USB_DEVICE_OS_IS_PD_AWARE\t41\n#define USB_DEVICE_POLICY_MODE\t\t42\n#define USB_PORT_PR_SWAP\t\t43\n#define USB_PORT_GOTO_MIN\t\t44\n#define USB_PORT_RETURN_POWER\t\t45\n#define USB_PORT_ACCEPT_PD_REQUEST\t46\n#define USB_PORT_REJECT_PD_REQUEST\t47\n#define USB_PORT_PORT_PD_RESET\t\t48\n#define USB_PORT_C_PORT_PD_CHANGE\t49\n#define USB_PORT_CABLE_PD_RESET\t\t50\n#define USB_DEVICE_CHARGING_POLICY\t54\n\n/**\n * struct usb_ctrlrequest - SETUP data for a USB device control request\n * @bRequestType: matches the USB bmRequestType field\n * @bRequest: matches the USB bRequest field\n * @wValue: matches the USB wValue field (le16 byte order)\n * @wIndex: matches the USB wIndex field (le16 byte order)\n * @wLength: matches the USB wLength field (le16 byte order)\n *\n * This structure is used to send control requests to a USB device.  It matches\n * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the\n * USB spec for a fuller description of the different fields, and what they are\n * used for.\n *\n * Note that the driver for any interface can issue control requests.\n * For most devices, interfaces don't coordinate with each other, so\n * such requests may be made at any time.\n */\nstruct usb_ctrlrequest {\n\t__u8 bRequestType;\n\t__u8 bRequest;\n\t__le16 wValue;\n\t__le16 wIndex;\n\t__le16 wLength;\n} __attribute__ ((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or\n * (rarely) accepted by SET_DESCRIPTOR.\n *\n * Note that all multi-byte values here are encoded in little endian\n * byte order \"on the wire\".  Within the kernel and when exposed\n * through the Linux-USB APIs, they are not converted to cpu byte\n * order; it is the responsibility of the client code to do this.\n * The single exception is when device and configuration descriptors (but\n * not other descriptors) are read from character devices\n * (i.e. /dev/bus/usb/BBB/DDD);\n * in this case the fields are converted to host endianness by the kernel.\n */\n\n/*\n * Descriptor types ... USB 2.0 spec table 9.5\n */\n#define USB_DT_DEVICE\t\t\t0x01\n#define USB_DT_CONFIG\t\t\t0x02\n#define USB_DT_STRING\t\t\t0x03\n#define USB_DT_INTERFACE\t\t0x04\n#define USB_DT_ENDPOINT\t\t\t0x05\n#define USB_DT_DEVICE_QUALIFIER\t\t0x06\n#define USB_DT_OTHER_SPEED_CONFIG\t0x07\n#define USB_DT_INTERFACE_POWER\t\t0x08\n/* these are from a minor usb 2.0 revision (ECN) */\n#define USB_DT_OTG\t\t\t0x09\n#define USB_DT_DEBUG\t\t\t0x0a\n#define USB_DT_INTERFACE_ASSOCIATION\t0x0b\n/* these are from the Wireless USB spec */\n#define USB_DT_SECURITY\t\t\t0x0c\n#define USB_DT_KEY\t\t\t0x0d\n#define USB_DT_ENCRYPTION_TYPE\t\t0x0e\n#define USB_DT_BOS\t\t\t0x0f\n#define USB_DT_DEVICE_CAPABILITY\t0x10\n#define USB_DT_WIRELESS_ENDPOINT_COMP\t0x11\n#define USB_DT_WIRE_ADAPTER\t\t0x21\n#define USB_DT_RPIPE\t\t\t0x22\n#define USB_DT_CS_RADIO_CONTROL\t\t0x23\n/* From the T10 UAS specification */\n#define USB_DT_PIPE_USAGE\t\t0x24\n/* From the USB 3.0 spec */\n#define\tUSB_DT_SS_ENDPOINT_COMP\t\t0x30\n/* From the USB 3.1 spec */\n#define\tUSB_DT_SSP_ISOC_ENDPOINT_COMP\t0x31\n\n/* Conventional codes for class-specific descriptors.  The convention is\n * defined in the USB \"Common Class\" Spec (3.11).  Individual class specs\n * are authoritative for their usage, not the \"common class\" writeup.\n */\n#define USB_DT_CS_DEVICE\t\t(USB_TYPE_CLASS | USB_DT_DEVICE)\n#define USB_DT_CS_CONFIG\t\t(USB_TYPE_CLASS | USB_DT_CONFIG)\n#define USB_DT_CS_STRING\t\t(USB_TYPE_CLASS | USB_DT_STRING)\n#define USB_DT_CS_INTERFACE\t\t(USB_TYPE_CLASS | USB_DT_INTERFACE)\n#define USB_DT_CS_ENDPOINT\t\t(USB_TYPE_CLASS | USB_DT_ENDPOINT)\n\n/* All standard descriptors have these 2 fields at the beginning */\nstruct usb_descriptor_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE: Device descriptor */\nstruct usb_device_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\t__u8  iManufacturer;\n\t__u8  iProduct;\n\t__u8  iSerialNumber;\n\t__u8  bNumConfigurations;\n} __attribute__ ((packed));\n\n#define USB_DT_DEVICE_SIZE\t\t18\n\n\n/*\n * Device and/or Interface Class codes\n * as found in bDeviceClass or bInterfaceClass\n * and defined by www.usb.org documents\n */\n#define USB_CLASS_PER_INTERFACE\t\t0\t/* for DeviceClass */\n#define USB_CLASS_AUDIO\t\t\t1\n#define USB_CLASS_COMM\t\t\t2\n#define USB_CLASS_HID\t\t\t3\n#define USB_CLASS_PHYSICAL\t\t5\n#define USB_CLASS_STILL_IMAGE\t\t6\n#define USB_CLASS_PRINTER\t\t7\n#define USB_CLASS_MASS_STORAGE\t\t8\n#define USB_CLASS_HUB\t\t\t9\n#define USB_CLASS_CDC_DATA\t\t0x0a\n#define USB_CLASS_CSCID\t\t\t0x0b\t/* chip+ smart card */\n#define USB_CLASS_CONTENT_SEC\t\t0x0d\t/* content security */\n#define USB_CLASS_VIDEO\t\t\t0x0e\n#define USB_CLASS_WIRELESS_CONTROLLER\t0xe0\n#define USB_CLASS_MISC\t\t\t0xef\n#define USB_CLASS_APP_SPEC\t\t0xfe\n#define USB_CLASS_VENDOR_SPEC\t\t0xff\n\n#define USB_SUBCLASS_VENDOR_SPEC\t0xff\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_CONFIG: Configuration descriptor information.\n *\n * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the\n * descriptor type is different.  Highspeed-capable devices can look\n * different depending on what speed they're currently running.  Only\n * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG\n * descriptors.\n */\nstruct usb_config_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumInterfaces;\n\t__u8  bConfigurationValue;\n\t__u8  iConfiguration;\n\t__u8  bmAttributes;\n\t__u8  bMaxPower;\n} __attribute__ ((packed));\n\n#define USB_DT_CONFIG_SIZE\t\t9\n\n/* from config descriptor bmAttributes */\n#define USB_CONFIG_ATT_ONE\t\t(1 << 7)\t/* must be set */\n#define USB_CONFIG_ATT_SELFPOWER\t(1 << 6)\t/* self powered */\n#define USB_CONFIG_ATT_WAKEUP\t\t(1 << 5)\t/* can wakeup */\n#define USB_CONFIG_ATT_BATTERY\t\t(1 << 4)\t/* battery powered */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_STRING: String descriptor */\nstruct usb_string_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wData[1];\t\t/* UTF-16LE encoded */\n} __attribute__ ((packed));\n\n/* note that \"string\" zero is special, it holds language codes that\n * the device supports, not Unicode characters.\n */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE: Interface descriptor */\nstruct usb_interface_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bInterfaceNumber;\n\t__u8  bAlternateSetting;\n\t__u8  bNumEndpoints;\n\t__u8  bInterfaceClass;\n\t__u8  bInterfaceSubClass;\n\t__u8  bInterfaceProtocol;\n\t__u8  iInterface;\n} __attribute__ ((packed));\n\n#define USB_DT_INTERFACE_SIZE\t\t9\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENDPOINT: Endpoint descriptor */\nstruct usb_endpoint_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEndpointAddress;\n\t__u8  bmAttributes;\n\t__le16 wMaxPacketSize;\n\t__u8  bInterval;\n\n\t/* NOTE:  these two are _only_ in audio endpoints. */\n\t/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */\n\t__u8  bRefresh;\n\t__u8  bSynchAddress;\n} __attribute__ ((packed));\n\n#define USB_DT_ENDPOINT_SIZE\t\t7\n#define USB_DT_ENDPOINT_AUDIO_SIZE\t9\t/* Audio extension */\n\n\n/*\n * Endpoints\n */\n#define USB_ENDPOINT_NUMBER_MASK\t0x0f\t/* in bEndpointAddress */\n#define USB_ENDPOINT_DIR_MASK\t\t0x80\n\n#define USB_ENDPOINT_XFERTYPE_MASK\t0x03\t/* in bmAttributes */\n#define USB_ENDPOINT_XFER_CONTROL\t0\n#define USB_ENDPOINT_XFER_ISOC\t\t1\n#define USB_ENDPOINT_XFER_BULK\t\t2\n#define USB_ENDPOINT_XFER_INT\t\t3\n#define USB_ENDPOINT_MAX_ADJUSTABLE\t0x80\n\n#define USB_ENDPOINT_MAXP_MASK\t0x07ff\n#define USB_EP_MAXP_MULT_SHIFT\t11\n#define USB_EP_MAXP_MULT_MASK\t(3 << USB_EP_MAXP_MULT_SHIFT)\n#define USB_EP_MAXP_MULT(m) \\\n\t(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)\n\n/* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */\n#define USB_ENDPOINT_INTRTYPE\t\t0x30\n#define USB_ENDPOINT_INTR_PERIODIC\t(0 << 4)\n#define USB_ENDPOINT_INTR_NOTIFICATION\t(1 << 4)\n\n#define USB_ENDPOINT_SYNCTYPE\t\t0x0c\n#define USB_ENDPOINT_SYNC_NONE\t\t(0 << 2)\n#define USB_ENDPOINT_SYNC_ASYNC\t\t(1 << 2)\n#define USB_ENDPOINT_SYNC_ADAPTIVE\t(2 << 2)\n#define USB_ENDPOINT_SYNC_SYNC\t\t(3 << 2)\n\n#define USB_ENDPOINT_USAGE_MASK\t\t0x30\n#define USB_ENDPOINT_USAGE_DATA\t\t0x00\n#define USB_ENDPOINT_USAGE_FEEDBACK\t0x10\n#define USB_ENDPOINT_USAGE_IMPLICIT_FB\t0x20\t/* Implicit feedback Data endpoint */\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * usb_endpoint_num - get the endpoint's number\n * @epd: endpoint to be checked\n *\n * Returns @epd's number: 0 to 15.\n */\nstatic inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\n}\n\n/**\n * usb_endpoint_type - get the endpoint's transfer type\n * @epd: endpoint to be checked\n *\n * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according\n * to @epd's transfer type.\n */\nstatic inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n}\n\n/**\n * usb_endpoint_dir_in - check if the endpoint has IN direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type IN, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);\n}\n\n/**\n * usb_endpoint_dir_out - check if the endpoint has OUT direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type OUT, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\n}\n\n/**\n * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type bulk, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_bulk(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_BULK);\n}\n\n/**\n * usb_endpoint_xfer_control - check if the endpoint has control transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type control, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_control(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_CONTROL);\n}\n\n/**\n * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type interrupt, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_int(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_INT);\n}\n\n/**\n * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type isochronous, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_isoc(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_ISOC);\n}\n\n/**\n * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_int_in - check if the endpoint is interrupt IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_maxp - get endpoint's max packet size\n * @epd: endpoint to be checked\n *\n * Returns @epd's max packet bits [10:0]\n */\nstatic inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)\n{\n\treturn __le16_to_cpu(epd->wMaxPacketSize) & USB_ENDPOINT_MAXP_MASK;\n}\n\n/**\n * usb_endpoint_maxp_mult - get endpoint's transactional opportunities\n * @epd: endpoint to be checked\n *\n * Return @epd's wMaxPacketSize[12:11] + 1\n */\nstatic inline int\nusb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)\n{\n\tint maxp = __le16_to_cpu(epd->wMaxPacketSize);\n\n\treturn USB_EP_MAXP_MULT(maxp) + 1;\n}\n\nstatic inline int usb_endpoint_interrupt_type(\n\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_INTRTYPE;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SSP_ISOC_ENDPOINT_COMP: SuperSpeedPlus Isochronous Endpoint Companion\n * descriptor\n */\nstruct usb_ssp_isoc_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__le16 wReseved;\n\t__le32 dwBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SSP_ISOC_EP_COMP_SIZE\t\t8\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */\nstruct usb_ss_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bmAttributes;\n\t__le16 wBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SS_EP_COMP_SIZE\t\t6\n\n/* Bits 4:0 of bmAttributes if this is a bulk endpoint */\nstatic inline int\nusb_ss_max_streams(const struct usb_ss_ep_comp_descriptor *comp)\n{\n\tint\t\tmax_streams;\n\n\tif (!comp)\n\t\treturn 0;\n\n\tmax_streams = comp->bmAttributes & 0x1f;\n\n\tif (!max_streams)\n\t\treturn 0;\n\n\tmax_streams = 1 << max_streams;\n\n\treturn max_streams;\n}\n\n/* Bits 1:0 of bmAttributes if this is an isoc endpoint */\n#define USB_SS_MULT(p)\t\t\t(1 + ((p) & 0x3))\n/* Bit 7 of bmAttributes if a SSP isoc endpoint companion descriptor exists */\n#define USB_SS_SSP_ISOC_COMP(p)\t\t((p) & (1 << 7))\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */\nstruct usb_qualifier_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__u8  bNumConfigurations;\n\t__u8  bRESERVED;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_OTG (from OTG 1.0a supplement) */\nstruct usb_otg_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP, etc */\n} __attribute__ ((packed));\n\n/* USB_DT_OTG (from OTG 2.0 supplement) */\nstruct usb_otg20_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP and ADP, etc */\n\t__le16 bcdOTG;\t\t/* OTG and EH supplement release number\n\t\t\t\t * in binary-coded decimal(i.e. 2.0 is 0200H)\n\t\t\t\t */\n} __attribute__ ((packed));\n\n/* from usb_otg_descriptor.bmAttributes */\n#define USB_OTG_SRP\t\t(1 << 0)\n#define USB_OTG_HNP\t\t(1 << 1)\t/* swap host/device roles */\n#define USB_OTG_ADP\t\t(1 << 2)\t/* support ADP */\n\n#define OTG_STS_SELECTOR\t0xF000\t\t/* OTG status selector */\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEBUG:  for special highspeed devices, replacing serial console */\nstruct usb_debug_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t/* bulk endpoints with 8 byte maxpacket */\n\t__u8  bDebugInEndpoint;\n\t__u8  bDebugOutEndpoint;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */\nstruct usb_interface_assoc_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bFirstInterface;\n\t__u8  bInterfaceCount;\n\t__u8  bFunctionClass;\n\t__u8  bFunctionSubClass;\n\t__u8  bFunctionProtocol;\n\t__u8  iFunction;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SECURITY:  group of wireless security descriptors, including\n * encryption types available for setting up a CC/association.\n */\nstruct usb_security_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumEncryptionTypes;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys\n * may be retrieved.\n */\nstruct usb_key_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  tTKID[3];\n\t__u8  bReserved;\n\t__u8  bKeyData[0];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */\nstruct usb_encryption_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEncryptionType;\n#define\tUSB_ENC_TYPE_UNSECURE\t\t0\n#define\tUSB_ENC_TYPE_WIRED\t\t1\t/* non-wireless mode */\n#define\tUSB_ENC_TYPE_CCM_1\t\t2\t/* aes128/cbc session */\n#define\tUSB_ENC_TYPE_RSA_1\t\t3\t/* rsa3072/sha1 auth */\n\t__u8  bEncryptionValue;\t\t/* use in SET_ENCRYPTION */\n\t__u8  bAuthKeyIndex;\n} __attribute__((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_BOS:  group of device-level capabilities */\nstruct usb_bos_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumDeviceCaps;\n} __attribute__((packed));\n\n#define USB_DT_BOS_SIZE\t\t5\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_CAPABILITY:  grouped with BOS */\nstruct usb_dev_cap_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n#define\tUSB_CAP_TYPE_WIRELESS_USB\t1\n\nstruct usb_wireless_cap_descriptor {\t/* Ultra Wide Band */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\n\t__u8  bmAttributes;\n#define\tUSB_WIRELESS_P2P_DRD\t\t(1 << 1)\n#define\tUSB_WIRELESS_BEACON_MASK\t(3 << 2)\n#define\tUSB_WIRELESS_BEACON_SELF\t(1 << 2)\n#define\tUSB_WIRELESS_BEACON_DIRECTED\t(2 << 2)\n#define\tUSB_WIRELESS_BEACON_NONE\t(3 << 2)\n\t__le16 wPHYRates;\t/* bit rates, Mbps */\n#define\tUSB_WIRELESS_PHY_53\t\t(1 << 0)\t/* always set */\n#define\tUSB_WIRELESS_PHY_80\t\t(1 << 1)\n#define\tUSB_WIRELESS_PHY_107\t\t(1 << 2)\t/* always set */\n#define\tUSB_WIRELESS_PHY_160\t\t(1 << 3)\n#define\tUSB_WIRELESS_PHY_200\t\t(1 << 4)\t/* always set */\n#define\tUSB_WIRELESS_PHY_320\t\t(1 << 5)\n#define\tUSB_WIRELESS_PHY_400\t\t(1 << 6)\n#define\tUSB_WIRELESS_PHY_480\t\t(1 << 7)\n\t__u8  bmTFITXPowerInfo;\t/* TFI power levels */\n\t__u8  bmFFITXPowerInfo;\t/* FFI power levels */\n\t__le16 bmBandGroup;\n\t__u8  bReserved;\n} __attribute__((packed));\n\n/* USB 2.0 Extension descriptor */\n#define\tUSB_CAP_TYPE_EXT\t\t2\n\nstruct usb_ext_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__le32 bmAttributes;\n#define USB_LPM_SUPPORT\t\t\t(1 << 1)\t/* supports LPM */\n#define USB_BESL_SUPPORT\t\t(1 << 2)\t/* supports BESL */\n#define USB_BESL_BASELINE_VALID\t\t(1 << 3)\t/* Baseline BESL valid*/\n#define USB_BESL_DEEP_VALID\t\t(1 << 4)\t/* Deep BESL valid */\n#define USB_GET_BESL_BASELINE(p)\t(((p) & (0xf << 8)) >> 8)\n#define USB_GET_BESL_DEEP(p)\t\t(((p) & (0xf << 12)) >> 12)\n} __attribute__((packed));\n\n#define USB_DT_USB_EXT_CAP_SIZE\t7\n\n/*\n * SuperSpeed USB Capability descriptor: Defines the set of SuperSpeed USB\n * specific device level capabilities\n */\n#define\t\tUSB_SS_CAP_TYPE\t\t3\nstruct usb_ss_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bmAttributes;\n#define USB_LTM_SUPPORT\t\t\t(1 << 1) /* supports LTM */\n\t__le16 wSpeedSupported;\n#define USB_LOW_SPEED_OPERATION\t\t(1)\t /* Low speed operation */\n#define USB_FULL_SPEED_OPERATION\t(1 << 1) /* Full speed operation */\n#define USB_HIGH_SPEED_OPERATION\t(1 << 2) /* High speed operation */\n#define USB_5GBPS_OPERATION\t\t(1 << 3) /* Operation at 5Gbps */\n\t__u8  bFunctionalitySupport;\n\t__u8  bU1devExitLat;\n\t__le16 bU2DevExitLat;\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CAP_SIZE\t10\n\n/*\n * Container ID Capability descriptor: Defines the instance unique ID used to\n * identify the instance across all operating modes\n */\n#define\tCONTAINER_ID_TYPE\t4\nstruct usb_ss_container_id_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__u8  ContainerID[16]; /* 128-bit number */\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CONTN_ID_SIZE\t20\n\n/*\n * SuperSpeed Plus USB Capability descriptor: Defines the set of\n * SuperSpeed Plus USB specific device level capabilities\n */\n#define\tUSB_SSP_CAP_TYPE\t0xa\nstruct usb_ssp_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_SSP_SUBLINK_SPEED_ATTRIBS\t(0x1f << 0) /* sublink speed entries */\n#define USB_SSP_SUBLINK_SPEED_IDS\t(0xf << 5)  /* speed ID entries */\n\t__le16  wFunctionalitySupport;\n#define USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID\t(0xf)\n#define USB_SSP_MIN_RX_LANE_COUNT\t\t(0xf << 8)\n#define USB_SSP_MIN_TX_LANE_COUNT\t\t(0xf << 12)\n\t__le16 wReserved;\n\t__le32 bmSublinkSpeedAttr[1]; /* list of sublink speed attrib entries */\n#define USB_SSP_SUBLINK_SPEED_SSID\t(0xf)\t\t/* sublink speed ID */\n#define USB_SSP_SUBLINK_SPEED_LSE\t(0x3 << 4)\t/* Lanespeed exponent */\n#define USB_SSP_SUBLINK_SPEED_ST\t(0x3 << 6)\t/* Sublink type */\n#define USB_SSP_SUBLINK_SPEED_RSVD\t(0x3f << 8)\t/* Reserved */\n#define USB_SSP_SUBLINK_SPEED_LP\t(0x3 << 14)\t/* Link protocol */\n#define USB_SSP_SUBLINK_SPEED_LSM\t(0xff << 16)\t/* Lanespeed mantissa */\n} __attribute__((packed));\n\n/*\n * USB Power Delivery Capability Descriptor:\n * Defines capabilities for PD\n */\n/* Defines the various PD Capabilities of this device */\n#define USB_PD_POWER_DELIVERY_CAPABILITY\t0x06\n/* Provides information on each battery supported by the device */\n#define USB_PD_BATTERY_INFO_CAPABILITY\t\t0x07\n/* The Consumer characteristics of a Port on the device */\n#define USB_PD_PD_CONSUMER_PORT_CAPABILITY\t0x08\n/* The provider characteristics of a Port on the device */\n#define USB_PD_PD_PROVIDER_PORT_CAPABILITY\t0x09\n\nstruct usb_pd_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType; /* set to USB_PD_POWER_DELIVERY_CAPABILITY */\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_PD_CAP_BATTERY_CHARGING\t(1 << 1) /* supports Battery Charging specification */\n#define USB_PD_CAP_USB_PD\t\t(1 << 2) /* supports USB Power Delivery specification */\n#define USB_PD_CAP_PROVIDER\t\t(1 << 3) /* can provide power */\n#define USB_PD_CAP_CONSUMER\t\t(1 << 4) /* can consume power */\n#define USB_PD_CAP_CHARGING_POLICY\t(1 << 5) /* supports CHARGING_POLICY feature */\n#define USB_PD_CAP_TYPE_C_CURRENT\t(1 << 6) /* supports power capabilities defined in the USB Type-C Specification */\n\n#define USB_PD_CAP_PWR_AC\t\t(1 << 8)\n#define USB_PD_CAP_PWR_BAT\t\t(1 << 9)\n#define USB_PD_CAP_PWR_USE_V_BUS\t(1 << 14)\n\n\t__le16 bmProviderPorts; /* Bit zero refers to the UFP of the device */\n\t__le16 bmConsumerPorts;\n\t__le16 bcdBCVersion;\n\t__le16 bcdPDVersion;\n\t__le16 bcdUSBTypeCVersion;\n} __attribute__((packed));\n\nstruct usb_pd_cap_battery_info_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t/* Index of string descriptor shall contain the user friendly name for this battery */\n\t__u8 iBattery;\n\t/* Index of string descriptor shall contain the Serial Number String for this battery */\n\t__u8 iSerial;\n\t__u8 iManufacturer;\n\t__u8 bBatteryId; /* uniquely identifies this battery in status Messages */\n\t__u8 bReserved;\n\t/*\n\t * Shall contain the Battery Charge value above which this\n\t * battery is considered to be fully charged but not necessarily\n\t * \u201ctopped off.\u201d\n\t */\n\t__le32 dwChargedThreshold; /* in mWh */\n\t/*\n\t * Shall contain the minimum charge level of this battery such\n\t * that above this threshold, a device can be assured of being\n\t * able to power up successfully (see Battery Charging 1.2).\n\t */\n\t__le32 dwWeakThreshold; /* in mWh */\n\t__le32 dwBatteryDesignCapacity; /* in mWh */\n\t__le32 dwBatteryLastFullchargeCapacity; /* in mWh */\n} __attribute__((packed));\n\nstruct usb_pd_cap_consumer_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_CONSUMER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_CONSUMER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_CONSUMER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__le16 wMinVoltage; /* in 50mV units */\n\t__le16 wMaxVoltage; /* in 50mV units */\n\t__u16 wReserved;\n\t__le32 dwMaxOperatingPower; /* in 10 mW - operating at steady state */\n\t__le32 dwMaxPeakPower; /* in 10mW units - operating at peak power */\n\t__le32 dwMaxPeakPowerTime; /* in 100ms units - duration of peak */\n#define USB_PD_CAP_CONSUMER_UNKNOWN_PEAK_POWER_TIME 0xffff\n} __attribute__((packed));\n\nstruct usb_pd_cap_provider_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved1;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_PROVIDER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_PROVIDER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_PROVIDER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__u8 bNumOfPDObjects;\n\t__u8 bReserved2;\n\t__le32 wPowerDataObject[];\n} __attribute__((packed));\n\n/*\n * Precision time measurement capability descriptor: advertised by devices and\n * hubs that support PTM\n */\n#define\tUSB_PTM_CAP_TYPE\t0xb\nstruct usb_ptm_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n/*\n * The size of the descriptor for the Sublink Speed Attribute Count\n * (SSAC) specified in bmAttributes[4:0].\n */\n#define USB_DT_USB_SSP_CAP_SIZE(ssac)\t(16 + ssac * 4)\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with\n * each endpoint descriptor for a wireless device\n */\nstruct usb_wireless_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bMaxSequence;\n\t__le16 wMaxStreamDelay;\n\t__le16 wOverTheAirPacketSize;\n\t__u8  bOverTheAirInterval;\n\t__u8  bmCompAttributes;\n#define USB_ENDPOINT_SWITCH_MASK\t0x03\t/* in bmCompAttributes */\n#define USB_ENDPOINT_SWITCH_NO\t\t0\n#define USB_ENDPOINT_SWITCH_SWITCH\t1\n#define USB_ENDPOINT_SWITCH_SCALE\t2\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless\n * host and a device for connection set up, mutual authentication, and\n * exchanging short lived session keys.  The handshake depends on a CC.\n */\nstruct usb_handshake {\n\t__u8 bMessageNumber;\n\t__u8 bStatus;\n\t__u8 tTKID[3];\n\t__u8 bReserved;\n\t__u8 CDID[16];\n\t__u8 nonce[16];\n\t__u8 MIC[8];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).\n * A CC may also be set up using non-wireless secure channels (including\n * wired USB!), and some devices may support CCs with multiple hosts.\n */\nstruct usb_connection_context {\n\t__u8 CHID[16];\t\t/* persistent host id */\n\t__u8 CDID[16];\t\t/* device id (unique w/in host context) */\n\t__u8 CK[16];\t\t/* connection key */\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB 2.0 defines three speeds, here's how Linux identifies them */\n\nenum usb_device_speed {\n\tUSB_SPEED_UNKNOWN = 0,\t\t\t/* enumerating */\n\tUSB_SPEED_LOW, USB_SPEED_FULL,\t\t/* usb 1.1 */\n\tUSB_SPEED_HIGH,\t\t\t\t/* usb 2.0 */\n\tUSB_SPEED_WIRELESS,\t\t\t/* wireless (usb 2.5) */\n\tUSB_SPEED_SUPER,\t\t\t/* usb 3.0 */\n\tUSB_SPEED_SUPER_PLUS,\t\t\t/* usb 3.1 */\n};\n\n\nenum usb_device_state {\n\t/* NOTATTACHED isn't in the USB spec, and this state acts\n\t * the same as ATTACHED ... but it's clearer this way.\n\t */\n\tUSB_STATE_NOTATTACHED = 0,\n\n\t/* chapter 9 and authentication (wireless) device states */\n\tUSB_STATE_ATTACHED,\n\tUSB_STATE_POWERED,\t\t\t/* wired */\n\tUSB_STATE_RECONNECTING,\t\t\t/* auth */\n\tUSB_STATE_UNAUTHENTICATED,\t\t/* auth */\n\tUSB_STATE_DEFAULT,\t\t\t/* limited function */\n\tUSB_STATE_ADDRESS,\n\tUSB_STATE_CONFIGURED,\t\t\t/* most functions */\n\n\tUSB_STATE_SUSPENDED\n\n\t/* NOTE:  there are actually four different SUSPENDED\n\t * states, returning to POWERED, DEFAULT, ADDRESS, or\n\t * CONFIGURED respectively when SOF tokens flow again.\n\t * At this level there's no difference between L1 and L2\n\t * suspend states.  (L2 being original USB 1.1 suspend.)\n\t */\n};\n\nenum usb3_link_state {\n\tUSB3_LPM_U0 = 0,\n\tUSB3_LPM_U1,\n\tUSB3_LPM_U2,\n\tUSB3_LPM_U3\n};\n\n/*\n * A U1 timeout of 0x0 means the parent hub will reject any transitions to U1.\n * 0xff means the parent hub will accept transitions to U1, but will not\n * initiate a transition.\n *\n * A U1 timeout of 0x1 to 0x7F also causes the hub to initiate a transition to\n * U1 after that many microseconds.  Timeouts of 0x80 to 0xFE are reserved\n * values.\n *\n * A U2 timeout of 0x0 means the parent hub will reject any transitions to U2.\n * 0xff means the parent hub will accept transitions to U2, but will not\n * initiate a transition.\n *\n * A U2 timeout of 0x1 to 0xFE also causes the hub to initiate a transition to\n * U2 after N*256 microseconds.  Therefore a U2 timeout value of 0x1 means a U2\n * idle timer of 256 microseconds, 0x2 means 512 microseconds, 0xFE means\n * 65.024ms.\n */\n#define USB3_LPM_DISABLED\t\t0x0\n#define USB3_LPM_U1_MAX_TIMEOUT\t\t0x7F\n#define USB3_LPM_U2_MAX_TIMEOUT\t\t0xFE\n#define USB3_LPM_DEVICE_INITIATED\t0xFF\n\nstruct usb_set_sel_req {\n\t__u8\tu1_sel;\n\t__u8\tu1_pel;\n\t__le16\tu2_sel;\n\t__le16\tu2_pel;\n} __attribute__ ((packed));\n\n/*\n * The Set System Exit Latency control transfer provides one byte each for\n * U1 SEL and U1 PEL, so the max exit latency is 0xFF.  U2 SEL and U2 PEL each\n * are two bytes long.\n */\n#define USB3_LPM_MAX_U1_SEL_PEL\t\t0xFF\n#define USB3_LPM_MAX_U2_SEL_PEL\t\t0xFFFF\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * As per USB compliance update, a device that is actively drawing\n * more than 100mA from USB must report itself as bus-powered in\n * the GetStatus(DEVICE) call.\n * http://compliance.usb.org/index.asp?UpdateFile=Electrical&Format=Standard#34\n */\n#define USB_SELF_POWER_VBUS_MAX_DRAW\t\t100\n\n#endif /* _UAPI__LINUX_USB_CH9_H */\n\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_2570.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void decode_plane(FFV1Context *s, uint8_t *src,\n                         int w, int h, int stride, int plane_index)\n    int16_t *sample[2];\n    sample[0] = s->sample_buffer + 3;\n    sample[1] = s->sample_buffer + w + 6 + 3;\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        int16_t *temp = sample[0]; // FIXME: try a normal buffer\n        sample[0] = sample[1];\n        sample[1] = temp;\n        sample[1][-1] = sample[0][0];\n        sample[0][w]  = sample[0][w - 1];\n        if (s->avctx->bits_per_raw_sample <= 8) {\n            decode_line(s, w, sample, plane_index, 8);\n            for (x = 0; x < w; x++)\n                src[x + stride * y] = sample[1][x];\n        } else {\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n            if (s->packed_at_lsb) {\n                for (x = 0; x < w; x++) {\n                    ((uint16_t*)(src + stride*y))[x] = sample[1][x];\n                }\n            } else {\n                for (x = 0; x < w; x++) {\n                    ((uint16_t*)(src + stride*y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);\n                }\n            }\n        }\n    }\nstatic int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n    RangeCoder *c = &fs->c;\n    memset(state, 128, sizeof(state));\n    av_assert0(f->version > 2);\n    fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n    fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n    fs->slice_x /= f->num_h_slices;\n    fs->slice_y /= f->num_v_slices;\n    fs->slice_width  = fs->slice_width /f->num_h_slices - fs->slice_x;\n    fs->slice_height = fs->slice_height/f->num_v_slices - fs->slice_y;\n    if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height)\n        return -1;\n    FFV1Context *fs   = *(void **)arg;\n    FFV1Context *f    = fs->avctx->priv_data;\n    const int ps      = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;\n    AVFrame * const p = f->cur;\n    for( si=0; fs != f->slice_context[si]; si ++)\n    if(f->fsrc && !p->key_frame)\n        ff_thread_await_progress(&f->last_picture, si, 0);\n    if(f->fsrc && !p->key_frame) {\n        FFV1Context *fssrc = f->fsrc->slice_context[si];\n        FFV1Context *fsdst = f->slice_context[si];\n        av_assert1(fsdst->plane_count == fssrc->plane_count);\n        av_assert1(fsdst == fs);\n        if (!p->key_frame)\n            fsdst->slice_damaged |= fssrc->slice_damaged;\n        for (i = 0; i < f->plane_count; i++) {\n        }\n    if (f->version > 2) {\n        if (ffv1_init_slice_state(f, fs) < 0)\n            return AVERROR(ENOMEM);\n        if (decode_slice_header(f, fs) < 0) {\n        }\n    }\n    if ((ret = ffv1_init_slice_state(f, fs)) < 0)\n        return ret;\n    if (f->cur->key_frame)\n        ffv1_clear_slice_state(f, fs);\n    width  = fs->slice_width;\n    height = fs->slice_height;\n    x      = fs->slice_x;\n    y      = fs->slice_y;\n    if (!fs->ac) {\n        if (f->version == 3 && f->micro_version > 1 || f->version > 3)\n            get_rac(&fs->c, (uint8_t[]) { 129 });\n        fs->ac_byte_count = f->version > 2 || (!x && !y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;\n        init_get_bits(&fs->gb,\n                      fs->c.bytestream_start + fs->ac_byte_count,\n                      (fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count) * 8);\n    }\n    av_assert1(width && height);\n    if (f->colorspace == 0) {\n        const int chroma_width  = FF_CEIL_RSHIFT(width,  f->chroma_h_shift);\n        const int chroma_height = FF_CEIL_RSHIFT(height, f->chroma_v_shift);\n        const int cx            = x >> f->chroma_h_shift;\n        const int cy            = y >> f->chroma_v_shift;\n        decode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);\n        if (f->chroma_planes) {\n            decode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);\n            decode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);\n        }\n        if (fs->transparency)\n            decode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);\n    } else {\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"libavutil/avassert.h\"\n#include \"libavutil/crc.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/timer.h\"\n#include \"avcodec.h\"\n#include \"internal.h\"\n#include \"get_bits.h\"\n#include \"rangecoder.h\"\n#include \"golomb.h\"\n#include \"mathops.h\"\n#include \"ffv1.h\"\nstatic inline av_flatten int get_symbol_inline(RangeCoder *c, uint8_t *state,\n                                               int is_signed)\n{\n    if (get_rac(c, state + 0))\n        return 0;\n    else {\n        int i, e, a;\n        e = 0;\n        while (get_rac(c, state + 1 + FFMIN(e, 9))) // 1..10\n            e++;\n        a = 1;\n        for (i = e - 1; i >= 0; i--)\n            a += a + get_rac(c, state + 22 + FFMIN(i, 9));  // 22..31\n        e = -(is_signed && get_rac(c, state + 11 + FFMIN(e, 10))); // 11..21\n        return (a ^ e) - e;\n    }\n}\nstatic av_noinline int get_symbol(RangeCoder *c, uint8_t *state, int is_signed)\n{\n    return get_symbol_inline(c, state, is_signed);\n}\nstatic av_always_inline void decode_line(FFV1Context *s, int w,\n                                         int16_t *sample[2],\n                                         int plane_index, int bits)\n{\n    PlaneContext *const p = &s->plane[plane_index];\n    RangeCoder *const c   = &s->c;\n    int x;\n    int run_count = 0;\n    int run_mode  = 0;\n    int run_index = s->run_index;\n    for (x = 0; x < w; x++) {\n        int diff, context, sign;\n        context = get_context(p, sample[1] + x, sample[0] + x, sample[1] + x);\n        if (context < 0) {\n            context = -context;\n            sign    = 1;\n        } else\n            sign = 0;\n        av_assert2(context < p->context_count);\n        if (s->ac) {\n            diff = get_symbol_inline(c, p->state[context], 1);\n        } else {\n            if (context == 0 && run_mode == 0)\n                run_mode = 1;\n            if (run_mode) {\n                if (run_count == 0 && run_mode == 1) {\n                    if (get_bits1(&s->gb)) {\n                        run_count = 1 << ff_log2_run[run_index];\n                        if (x + run_count <= w)\n                            run_index++;\n                    } else {\n                        if (ff_log2_run[run_index])\n                            run_count = get_bits(&s->gb, ff_log2_run[run_index]);\n                        else\n                            run_count = 0;\n                        if (run_index)\n                            run_index--;\n                        run_mode = 2;\n                    }\n                }\n                run_count--;\n                if (run_count < 0) {\n                    run_mode  = 0;\n                    run_count = 0;\n                    diff      = get_vlc_symbol(&s->gb, &p->vlc_state[context],\n                                               bits);\n                    if (diff >= 0)\n                        diff++;\n                } else\n                    diff = 0;\n            } else\n                diff = get_vlc_symbol(&s->gb, &p->vlc_state[context], bits);\n            av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",\n                    run_count, run_index, run_mode, x, get_bits_count(&s->gb));\n        }\n        if (sign)\n            diff = -diff;\n        sample[1][x] = (predict(sample[1] + x, sample[0] + x) + diff) &\n                       ((1 << bits) - 1);\n    }\n    s->run_index = run_index;\n}\nstatic void decode_plane(FFV1Context *s, uint8_t *src,\n                         int w, int h, int stride, int plane_index)\n{\n    int x, y;\n    int16_t *sample[2];\n    sample[0] = s->sample_buffer + 3;\n    sample[1] = s->sample_buffer + w + 6 + 3;\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        int16_t *temp = sample[0]; // FIXME: try a normal buffer\n        sample[0] = sample[1];\n        sample[1] = temp;\n        sample[1][-1] = sample[0][0];\n        sample[0][w]  = sample[0][w - 1];\n        if (s->avctx->bits_per_raw_sample <= 8) {\n            decode_line(s, w, sample, plane_index, 8);\n            for (x = 0; x < w; x++)\n                src[x + stride * y] = sample[1][x];\n        } else {\n            decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);\n            if (s->packed_at_lsb) {\n                for (x = 0; x < w; x++) {\n                    ((uint16_t*)(src + stride*y))[x] = sample[1][x];\n                }\n            } else {\n                for (x = 0; x < w; x++) {\n                    ((uint16_t*)(src + stride*y))[x] = sample[1][x] << (16 - s->avctx->bits_per_raw_sample);\n                }\n            }\n        }\n    }\n}\nstatic void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; // FIXME: try a normal buffer\n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + 1);\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            b -= offset;\n            r -= offset;\n            g -= (b + r) >> 2;\n            b += g;\n            r += g;\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}\nstatic int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n{\n    RangeCoder *c = &fs->c;\n    uint8_t state[CONTEXT_SIZE];\n    unsigned ps, i, context_count;\n    memset(state, 128, sizeof(state));\n    av_assert0(f->version > 2);\n    fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n    fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n    fs->slice_x /= f->num_h_slices;\n    fs->slice_y /= f->num_v_slices;\n    fs->slice_width  = fs->slice_width /f->num_h_slices - fs->slice_x;\n    fs->slice_height = fs->slice_height/f->num_v_slices - fs->slice_y;\n    if ((unsigned)fs->slice_width > f->width || (unsigned)fs->slice_height > f->height)\n        return -1;\n    if (    (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n         || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n        return -1;\n    for (i = 0; i < f->plane_count; i++) {\n        PlaneContext * const p = &fs->plane[i];\n        int idx = get_symbol(c, state, 0);\n        if (idx > (unsigned)f->quant_table_count) {\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n            return -1;\n        }\n        p->quant_table_index = idx;\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n        context_count = f->context_count[idx];\n        if (p->context_count < context_count) {\n            av_freep(&p->state);\n            av_freep(&p->vlc_state);\n        }\n        p->context_count = context_count;\n    }\n    ps = get_symbol(c, state, 0);\n    if (ps == 1) {\n        f->cur->interlaced_frame = 1;\n        f->cur->top_field_first  = 1;\n    } else if (ps == 2) {\n        f->cur->interlaced_frame = 1;\n        f->cur->top_field_first  = 0;\n    } else if (ps == 3) {\n        f->cur->interlaced_frame = 0;\n    }\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n    return 0;\n}\nstatic int decode_slice(AVCodecContext *c, void *arg)\n{\n    FFV1Context *fs   = *(void **)arg;\n    FFV1Context *f    = fs->avctx->priv_data;\n    int width, height, x, y, ret;\n    const int ps      = av_pix_fmt_desc_get(c->pix_fmt)->comp[0].step_minus1 + 1;\n    AVFrame * const p = f->cur;\n    int i, si;\n    for( si=0; fs != f->slice_context[si]; si ++)\n        ;\n    if(f->fsrc && !p->key_frame)\n        ff_thread_await_progress(&f->last_picture, si, 0);\n    if(f->fsrc && !p->key_frame) {\n        FFV1Context *fssrc = f->fsrc->slice_context[si];\n        FFV1Context *fsdst = f->slice_context[si];\n        av_assert1(fsdst->plane_count == fssrc->plane_count);\n        av_assert1(fsdst == fs);\n        if (!p->key_frame)\n            fsdst->slice_damaged |= fssrc->slice_damaged;\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *psrc = &fssrc->plane[i];\n            PlaneContext *pdst = &fsdst->plane[i];\n            av_free(pdst->state);\n            av_free(pdst->vlc_state);\n            memcpy(pdst, psrc, sizeof(*pdst));\n            pdst->state = NULL;\n            pdst->vlc_state = NULL;\n            if (fssrc->ac) {\n                pdst->state = av_malloc(CONTEXT_SIZE * psrc->context_count);\n                memcpy(pdst->state, psrc->state, CONTEXT_SIZE * psrc->context_count);\n            } else {\n                pdst->vlc_state = av_malloc(sizeof(*pdst->vlc_state) * psrc->context_count);\n                memcpy(pdst->vlc_state, psrc->vlc_state, sizeof(*pdst->vlc_state) * psrc->context_count);\n            }\n        }\n    }\n    if (f->version > 2) {\n        if (ffv1_init_slice_state(f, fs) < 0)\n            return AVERROR(ENOMEM);\n        if (decode_slice_header(f, fs) < 0) {\n            fs->slice_damaged = 1;\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    if ((ret = ffv1_init_slice_state(f, fs)) < 0)\n        return ret;\n    if (f->cur->key_frame)\n        ffv1_clear_slice_state(f, fs);\n    width  = fs->slice_width;\n    height = fs->slice_height;\n    x      = fs->slice_x;\n    y      = fs->slice_y;\n    if (!fs->ac) {\n        if (f->version == 3 && f->micro_version > 1 || f->version > 3)\n            get_rac(&fs->c, (uint8_t[]) { 129 });\n        fs->ac_byte_count = f->version > 2 || (!x && !y) ? fs->c.bytestream - fs->c.bytestream_start - 1 : 0;\n        init_get_bits(&fs->gb,\n                      fs->c.bytestream_start + fs->ac_byte_count,\n                      (fs->c.bytestream_end - fs->c.bytestream_start - fs->ac_byte_count) * 8);\n    }\n    av_assert1(width && height);\n    if (f->colorspace == 0) {\n        const int chroma_width  = FF_CEIL_RSHIFT(width,  f->chroma_h_shift);\n        const int chroma_height = FF_CEIL_RSHIFT(height, f->chroma_v_shift);\n        const int cx            = x >> f->chroma_h_shift;\n        const int cy            = y >> f->chroma_v_shift;\n        decode_plane(fs, p->data[0] + ps*x + y*p->linesize[0], width, height, p->linesize[0], 0);\n        if (f->chroma_planes) {\n            decode_plane(fs, p->data[1] + ps*cx+cy*p->linesize[1], chroma_width, chroma_height, p->linesize[1], 1);\n            decode_plane(fs, p->data[2] + ps*cx+cy*p->linesize[2], chroma_width, chroma_height, p->linesize[2], 1);\n        }\n        if (fs->transparency)\n            decode_plane(fs, p->data[3] + ps*x + y*p->linesize[3], width, height, p->linesize[3], 2);\n    } else {\n        uint8_t *planes[3] = { p->data[0] + ps * x + y * p->linesize[0],\n                               p->data[1] + ps * x + y * p->linesize[1],\n                               p->data[2] + ps * x + y * p->linesize[2] };\n        decode_rgb_frame(fs, planes, width, height, p->linesize);\n    }\n    if (fs->ac && f->version > 2) {\n        int v;\n        get_rac(&fs->c, (uint8_t[]) { 129 });\n        v = fs->c.bytestream_end - fs->c.bytestream - 2 - 5*f->ec;\n        if (v) {\n            av_log(f->avctx, AV_LOG_ERROR, \"bytestream end mismatching by %d\\n\", v);\n            fs->slice_damaged = 1;\n        }\n    }\n    emms_c();\n    ff_thread_report_progress(&f->picture, si, 0);\n    return 0;\n}\nstatic int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n{\n    int v;\n    int i = 0;\n    uint8_t state[CONTEXT_SIZE];\n    memset(state, 128, sizeof(state));\n    for (v = 0; i < 128; v++) {\n        unsigned len = get_symbol(c, state, 0) + 1;\n        if (len > 128 - i)\n            return AVERROR_INVALIDDATA;\n        while (len--) {\n            quant_table[i] = scale * v;\n            i++;\n        }\n    }\n    for (i = 1; i < 128; i++)\n        quant_table[256 - i] = -quant_table[i];\n    quant_table[128] = -quant_table[127];\n    return 2 * v - 1;\n}\nstatic int read_quant_tables(RangeCoder *c,\n                             int16_t quant_table[MAX_CONTEXT_INPUTS][256])\n{\n    int i;\n    int context_count = 1;\n    for (i = 0; i < 5; i++) {\n        context_count *= read_quant_table(c, quant_table[i], context_count);\n        if (context_count > 32768U) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return (context_count + 1) / 2;\n}\nstatic int read_extra_header(FFV1Context *f)\n{\n    RangeCoder *const c = &f->c;\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, k, ret;\n    uint8_t state2[32][CONTEXT_SIZE];\n    memset(state2, 128, sizeof(state2));\n    memset(state, 128, sizeof(state));\n    ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);\n    ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);\n    f->version = get_symbol(c, state, 0);\n    if (f->version < 2) {\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid version in global header\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (f->version > 2) {\n        c->bytestream_end -= 4;\n        f->micro_version = get_symbol(c, state, 0);\n    }\n    f->ac = f->avctx->coder_type = get_symbol(c, state, 0);\n    if (f->ac > 1) {\n        for (i = 1; i < 256; i++)\n            f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n    }\n    f->colorspace                 = get_symbol(c, state, 0); //YUV cs type\n    f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n    f->chroma_planes              = get_rac(c, state);\n    f->chroma_h_shift             = get_symbol(c, state, 0);\n    f->chroma_v_shift             = get_symbol(c, state, 0);\n    f->transparency               = get_rac(c, state);\n    f->plane_count                = 1 + (f->chroma_planes || f->version<4) + f->transparency;\n    f->num_h_slices               = 1 + get_symbol(c, state, 0);\n    f->num_v_slices               = 1 + get_symbol(c, state, 0);\n    if (f->num_h_slices > (unsigned)f->width  || !f->num_h_slices ||\n        f->num_v_slices > (unsigned)f->height || !f->num_v_slices\n       ) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    f->quant_table_count = get_symbol(c, state, 0);\n    if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < f->quant_table_count; i++) {\n        f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);\n        if (f->context_count[i] < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    if ((ret = ffv1_allocate_initial_states(f)) < 0)\n        return ret;\n    for (i = 0; i < f->quant_table_count; i++)\n        if (get_rac(c, state)) {\n            for (j = 0; j < f->context_count[i]; j++)\n                for (k = 0; k < CONTEXT_SIZE; k++) {\n                    int pred = j ? f->initial_states[i][j - 1][k] : 128;\n                    f->initial_states[i][j][k] =\n                        (pred + get_symbol(c, state2[k], 1)) & 0xFF;\n                }\n        }\n    if (f->version > 2) {\n        f->ec = get_symbol(c, state, 0);\n        if (f->micro_version > 2)\n            f->intra = get_symbol(c, state, 0);\n    }\n    if (f->version > 2) {\n        unsigned v;\n        v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,\n                   f->avctx->extradata, f->avctx->extradata_size);\n        if (v) {\n            av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    if (f->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(f->avctx, AV_LOG_DEBUG,\n               \"global: ver:%d.%d, coder:%d, colorspace: %d bpr:%d chroma:%d(%d:%d), alpha:%d slices:%dx%d qtabs:%d ec:%d intra:%d\\n\",\n               f->version, f->micro_version,\n               f->ac,\n               f->colorspace,\n               f->avctx->bits_per_raw_sample,\n               f->chroma_planes, f->chroma_h_shift, f->chroma_v_shift,\n               f->transparency,\n               f->num_h_slices, f->num_v_slices,\n               f->quant_table_count,\n               f->ec,\n               f->intra\n              );\n    return 0;\n}\nstatic int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n    memset(state, 128, sizeof(state));\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n        if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n        f->plane_count    = 2 + f->transparency;\n    }\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n        fs->slice_damaged = 0;\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    FFV1Context *f = avctx->priv_data;\n    int ret;\n    if ((ret = ffv1_common_init(avctx)) < 0)\n        return ret;\n    if (avctx->extradata && (ret = read_extra_header(f)) < 0)\n        return ret;\n    if ((ret = ffv1_init_slice_contexts(f)) < 0)\n        return ret;\n    avctx->internal->allocate_progress = 1;\n    return 0;\n}\nstatic int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf  = avpkt->data;\n    int buf_size        = avpkt->size;\n    FFV1Context *f      = avctx->priv_data;\n    RangeCoder *const c = &f->slice_context[0]->c;\n    int i, ret;\n    uint8_t keystate = 128;\n    const uint8_t *buf_p;\n    AVFrame *p;\n    if (f->last_picture.f)\n        ff_thread_release_buffer(avctx, &f->last_picture);\n    FFSWAP(ThreadFrame, f->picture, f->last_picture);\n    f->cur = p = f->picture.f;\n    if (f->version < 3 && avctx->field_order > AV_FIELD_PROGRESSIVE) {\n        p->interlaced_frame = 1;\n        if (avctx->field_order == AV_FIELD_TT || avctx->field_order == AV_FIELD_TB)\n            p->top_field_first = 1;\n    }\n    f->avctx = avctx;\n    ff_init_range_decoder(c, buf, buf_size);\n    ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);\n    p->pict_type = AV_PICTURE_TYPE_I; //FIXME I vs. P\n    if (get_rac(c, &keystate)) {\n        p->key_frame    = 1;\n        f->key_frame_ok = 0;\n        if ((ret = read_header(f)) < 0)\n            return ret;\n        f->key_frame_ok = 1;\n    } else {\n        if (!f->key_frame_ok) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Cannot decode non-keyframe without valid keyframe\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        p->key_frame = 0;\n    }\n    if ((ret = ff_thread_get_buffer(avctx, &f->picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n        return ret;\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(avctx, AV_LOG_DEBUG, \"ver:%d keyframe:%d coder:%d ec:%d slices:%d bps:%d\\n\",\n               f->version, p->key_frame, f->ac, f->ec, f->slice_count, f->avctx->bits_per_raw_sample);\n    ff_thread_finish_setup(avctx);\n    buf_p = buf + buf_size;\n    for (i = f->slice_count - 1; i >= 0; i--) {\n        FFV1Context *fs = f->slice_context[i];\n        int trailer = 3 + 5*!!f->ec;\n        int v;\n        if (i || f->version > 2) v = AV_RB24(buf_p-trailer) + trailer;\n        else                     v = buf_p - c->bytestream_start;\n        if (buf_p - c->bytestream_start < v) {\n            av_log(avctx, AV_LOG_ERROR, \"Slice pointer chain broken\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        buf_p -= v;\n        if (f->ec) {\n            unsigned crc = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, v);\n            if (crc) {\n                int64_t ts = avpkt->pts != AV_NOPTS_VALUE ? avpkt->pts : avpkt->dts;\n                av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\", crc);\n                if (ts != AV_NOPTS_VALUE && avctx->pkt_timebase.num) {\n                    av_log(f->avctx, AV_LOG_ERROR, \"at %f seconds\\n\", ts*av_q2d(avctx->pkt_timebase));\n                } else if (ts != AV_NOPTS_VALUE) {\n                    av_log(f->avctx, AV_LOG_ERROR, \"at %\"PRId64\"\\n\", ts);\n                } else {\n                    av_log(f->avctx, AV_LOG_ERROR, \"\\n\");\n                }\n                fs->slice_damaged = 1;\n            }\n        }\n        if (i) {\n            ff_init_range_decoder(&fs->c, buf_p, v);\n        } else\n            fs->c.bytestream_end = (uint8_t *)(buf_p + v);\n        fs->avctx = avctx;\n        fs->cur = p;\n    }\n    avctx->execute(avctx,\n                   decode_slice,\n                   &f->slice_context[0],\n                   NULL,\n                   f->slice_count,\n                   sizeof(void*));\n    for (i = f->slice_count - 1; i >= 0; i--) {\n        FFV1Context *fs = f->slice_context[i];\n        int j;\n        if (fs->slice_damaged && f->last_picture.f->data[0]) {\n            const uint8_t *src[4];\n            uint8_t *dst[4];\n            ff_thread_await_progress(&f->last_picture, INT_MAX, 0);\n            for (j = 0; j < 4; j++) {\n                int sh = (j==1 || j==2) ? f->chroma_h_shift : 0;\n                int sv = (j==1 || j==2) ? f->chroma_v_shift : 0;\n                dst[j] = p->data[j] + p->linesize[j]*\n                         (fs->slice_y>>sv) + (fs->slice_x>>sh);\n                src[j] = f->last_picture.f->data[j] + f->last_picture.f->linesize[j]*\n                         (fs->slice_y>>sv) + (fs->slice_x>>sh);\n            }\n            av_image_copy(dst, p->linesize, (const uint8_t **)src,\n                          f->last_picture.f->linesize,\n                          avctx->pix_fmt,\n                          fs->slice_width,\n                          fs->slice_height);\n        }\n    }\n    ff_thread_report_progress(&f->picture, INT_MAX, 0);\n    f->picture_number++;\n    if (f->last_picture.f)\n        ff_thread_release_buffer(avctx, &f->last_picture);\n    f->cur = NULL;\n    if ((ret = av_frame_ref(data, f->picture.f)) < 0)\n        return ret;\n    *got_frame = 1;\n    return buf_size;\n}\nstatic int update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n{\n    FFV1Context *fsrc = src->priv_data;\n    FFV1Context *fdst = dst->priv_data;\n    int i, ret;\n    if (dst == src)\n        return 0;\n    if (!fdst->picture.f) {\n        memcpy(fdst, fsrc, sizeof(*fdst));\n        for (i = 0; i < fdst->quant_table_count; i++) {\n            fdst->initial_states[i] = av_malloc(fdst->context_count[i] * sizeof(*fdst->initial_states[i]));\n            memcpy(fdst->initial_states[i], fsrc->initial_states[i], fdst->context_count[i] * sizeof(*fdst->initial_states[i]));\n        }\n        fdst->picture.f      = av_frame_alloc();\n        fdst->last_picture.f = av_frame_alloc();\n        if ((ret = ffv1_init_slice_contexts(fdst)) < 0)\n            return ret;\n    }\n    av_assert1(fdst->slice_count == fsrc->slice_count);\n    fdst->key_frame_ok = fsrc->key_frame_ok;\n    ff_thread_release_buffer(dst, &fdst->picture);\n    if (fsrc->picture.f->data[0]) {\n        if ((ret = ff_thread_ref_frame(&fdst->picture, &fsrc->picture)) < 0)\n            return ret;\n    }\n    for (i = 0; i < fdst->slice_count; i++) {\n        FFV1Context *fsdst = fdst->slice_context[i];\n        FFV1Context *fssrc = fsrc->slice_context[i];\n        fsdst->slice_damaged = fssrc->slice_damaged;\n    }\n    fdst->fsrc = fsrc;\n    return 0;\n}\nAVCodec ff_ffv1_decoder = {\n    .name           = \"ffv1\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_FFV1,\n    .priv_data_size = sizeof(FFV1Context),\n    .init           = decode_init,\n    .close          = ffv1_close,\n    .decode         = decode_frame,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(init_thread_copy),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),\n    .capabilities   = CODEC_CAP_DR1  |\n                      CODEC_CAP_FRAME_THREADS | CODEC_CAP_SLICE_THREADS,\n    .long_name      = NULL_IF_CONFIG_SMALL(\"FFmpeg video codec #1\"),\n};\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_481.c",
        "project": "ffmpeg/ffmpeg",
        "url": "https://github.com/FFmpeg/FFmpeg/commit/b05cd1ea7e45a836f7f6071a716c38bb30326e0f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```mrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1  + num));\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 ;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n  }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <mruby.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/opcode.h>\n#include <mruby/data.h>\n#include <mruby/presym.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\nstatic const mrb_code call_iseq[] = {\n  OP_CALL,\n};\nstatic const mrb_irep call_irep = {\n  0,                                   \n  2,                                   \n  0,                                   \n  MRB_ISEQ_NO_FREE | MRB_IREP_NO_FREE, \n  call_iseq,                           \n  NULL,                                \n  NULL,                                \n  NULL,                                \n  NULL,                                \n  NULL,                                \n  1,                                   \n  0,                                   \n  0,                                   \n  1,                                   \n  0,                                   \n};\nstatic const struct RProc call_proc = {\n  NULL, NULL, MRB_TT_PROC, MRB_GC_RED, MRB_FL_OBJ_IS_FROZEN | MRB_PROC_SCOPE | MRB_PROC_STRICT,\n  { &call_irep }, NULL, { NULL }\n};\nMRB_API \nMRB_API \nMRB_API \nMRB_API mrb_value\nvoid\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}\n#define IREP_LVAR_MERGE_DEFAULT  50\n#define IREP_LVAR_MERGE_MINIMUM   8\n#define IREP_LVAR_MERGE_MAXIMUM 240\n#ifdef MRB_IREP_LVAR_MERGE_LIMIT\n# define IREP_LVAR_MERGE_LIMIT \\\n  ((MRB_IREP_LVAR_MERGE_LIMIT) < IREP_LVAR_MERGE_MINIMUM ? IREP_LVAR_MERGE_MINIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT) > IREP_LVAR_MERGE_MAXIMUM ? IREP_LVAR_MERGE_MAXIMUM : \\\n   (MRB_IREP_LVAR_MERGE_LIMIT))\n#else\n# define IREP_LVAR_MERGE_LIMIT IREP_LVAR_MERGE_DEFAULT\n#endif\nvoid\nmrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, const mrb_sym *lv, const mrb_value *stack)\n{\n  mrb_assert(!(irep->flags & MRB_IREP_NO_FREE));\n  if ((irep->nlocals + num) > IREP_LVAR_MERGE_LIMIT) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"too many local variables for binding (mruby limitation)\");\n  }\n  if (!lv) {\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"unavailable local variable names\");\n  }\n  irep->lv = (mrb_sym*)mrb_realloc(mrb, (mrb_sym*)irep->lv, sizeof(mrb_sym) * (irep->nlocals + num));\n  env->stack = (mrb_value*)mrb_realloc(mrb, env->stack, sizeof(mrb_value) * (irep->nlocals + 1  + num));\n  mrb_sym *destlv = (mrb_sym*)irep->lv + irep->nlocals - 1 ;\n  mrb_value *destst = env->stack + irep->nlocals;\n  memmove(destlv, lv, sizeof(mrb_sym) * num);\n  if (stack) {\n    memmove(destst, stack, sizeof(mrb_value) * num);\n    for (int i = 0; i < num; i++) {\n      if (!mrb_immediate_p(stack[i])) {\n        mrb_field_write_barrier(mrb, (struct RBasic*)env, (struct RBasic*)mrb_obj_ptr(stack[i]));\n      }\n    }\n  }\n  else {\n    for (int i = num; i > 0; i--, destst++) {\n      *destst = mrb_nil_value();\n    }\n  }\n  irep->nlocals += num;\n  irep->nregs = irep->nlocals;\n  MRB_ENV_SET_LEN(env, irep->nlocals);\n}\n",
        "cwe": "CWE-122",
        "file_name": "vul_respovul_idx_7239.c",
        "project": "mruby/mruby",
        "url": "https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```ext4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n\tentry = IFIRST(header);\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 0);\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (unlikely(size > EXT4_XATTR_SIZE_MAX))\n\t\tgoto cleanup;\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tu16 offset = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *p = (void *)IFIRST(header) + offset;\n\t\t\tif (unlikely(p + size > end))\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(buffer, p, size);\n\t\t}\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/mbcache.h>\n#include <linux/quotaops.h>\n#include <linux/iversion.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#ifdef EXT4_XATTR_DEBUG\n# define ea_idebug(inode, fmt, ...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"inode %s:%lu: \" fmt \"\\n\",\t\t\t\\\n\t       inode->i_sb->s_id, inode->i_ino, ##__VA_ARGS__)\n# define ea_bdebug(bh, fmt, ...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"block %pg:%lu: \" fmt \"\\n\",\t\t\t\\\n\t       bh->b_bdev, (unsigned long)bh->b_blocknr, ##__VA_ARGS__)\n#else\n# define ea_idebug(inode, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n# define ea_bdebug(bh, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\nstatic void ext4_xattr_block_cache_insert(struct mb_cache *,\n\t\t\t\t\t  struct buffer_head *);\nstatic struct buffer_head *\next4_xattr_block_cache_find(struct inode *, struct ext4_xattr_header *,\n\t\t\t    struct mb_cache_entry **);\nstatic __le32 ext4_xattr_hash_entry(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *);\nstatic const struct xattr_handler * const ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n\t[EXT4_XATTR_INDEX_HURD]\t\t     = &ext4_xattr_hurd_handler,\n};\nconst struct xattr_handler *ext4_xattr_handlers[] = {\n\t&ext4_xattr_user_handler,\n\t&ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t&ext4_xattr_security_handler,\n#endif\n\t&ext4_xattr_hurd_handler,\n\tNULL\n};\n#define EA_BLOCK_CACHE(inode)\t(((struct ext4_sb_info *) \\\n\t\t\t\tinode->i_sb->s_fs_info)->s_ea_block_cache)\n#define EA_INODE_CACHE(inode)\t(((struct ext4_sb_info *) \\\n\t\t\t\tinode->i_sb->s_fs_info)->s_ea_inode_cache)\nstatic int\next4_expand_inode_array(struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\tstruct inode *inode);\n#ifdef CONFIG_LOCKDEP\nvoid ext4_xattr_inode_set_class(struct inode *ea_inode)\n{\n\tlockdep_set_subclass(&ea_inode->i_rwsem, 1);\n}\n#endif\nstatic int\next4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,\n\t\t\t void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (strnlen(e->e_name, e->e_name_len) != e->e_name_len)\n\t\t\treturn -EFSCORRUPTED;\n\t\te = next;\n\t}\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tu32 size = le32_to_cpu(entry->e_value_size);\n\t\tif (size > EXT4_XATTR_SIZE_MAX)\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (size != 0 && entry->e_value_inum == 0) {\n\t\t\tu16 offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *value;\n\t\t\tif (offs > end - value_start)\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\tvalue = value_start + offs;\n\t\t\tif (value < (void *)e + sizeof(u32) ||\n\t\t\t    size > end - value ||\n\t\t\t    EXT4_XATTR_SIZE(size) > end - value)\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\treturn 0;\n}\n#define ext4_xattr_check_block(inode, bh) \\\n\t__ext4_xattr_check_block((inode), (bh),  __func__, __LINE__)\nstatic int\n__xattr_check_inode(struct inode *inode, struct ext4_xattr_ibody_header *header,\n\t\t\t void *end, const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\tif (end - (void *)header < sizeof(*header) + sizeof(u32) ||\n\t    (header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(IFIRST(header), end, IFIRST(header));\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0, -error,\n\t\t\t\t   \"corrupted in-inode xattr\");\n\treturn error;\n}\n#define xattr_check_inode(inode, header, end) \\\n\t__xattr_check_inode((inode), (header), (end), __func__, __LINE__)\nstatic int\nxattr_find_entry(struct inode *inode, struct ext4_xattr_entry **pentry,\n\t\t void *end, int name_index, const char *name, int sorted)\n{\n\tstruct ext4_xattr_entry *entry, *next;\n\tsize_t name_len;\n\tint cmp = 1;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tfor (entry = *pentry; !IS_LAST_ENTRY(entry); entry = next) {\n\t\tnext = EXT4_XATTR_NEXT(entry);\n\t\tif ((void *) next >= end) {\n\t\t\tEXT4_ERROR_INODE(inode, \"corrupted xattr entries\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\treturn cmp ? -ENODATA : 0;\n}\nstatic u32\next4_xattr_inode_hash(struct ext4_sb_info *sbi, const void *buffer, size_t size)\n{\n\treturn ext4_chksum(sbi, sbi->s_csum_seed, buffer, size);\n}\nstatic u64 ext4_xattr_inode_get_ref(struct inode *ea_inode)\n{\n\treturn ((u64)ea_inode->i_ctime.tv_sec << 32) |\n\t\t(u32) inode_peek_iversion_raw(ea_inode);\n}\nstatic void ext4_xattr_inode_set_ref(struct inode *ea_inode, u64 ref_count)\n{\n\tea_inode->i_ctime.tv_sec = (u32)(ref_count >> 32);\n\tinode_set_iversion_raw(ea_inode, ref_count & 0xffffffff);\n}\nstatic u32 ext4_xattr_inode_get_hash(struct inode *ea_inode)\n{\n\treturn (u32)ea_inode->i_atime.tv_sec;\n}\nstatic void ext4_xattr_inode_set_hash(struct inode *ea_inode, u32 hash)\n{\n\tea_inode->i_atime.tv_sec = hash;\n}\nstatic int ext4_xattr_inode_read(struct inode *ea_inode, void *buf, size_t size)\n{\n\tint blocksize = 1 << ea_inode->i_blkbits;\n\tint bh_count = (size + blocksize - 1) >> ea_inode->i_blkbits;\n\tint tail_size = (size % blocksize) ?: blocksize;\n\tstruct buffer_head *bhs_inline[8];\n\tstruct buffer_head **bhs = bhs_inline;\n\tint i, ret;\n\tif (bh_count > ARRAY_SIZE(bhs_inline)) {\n\t\tbhs = kmalloc_array(bh_count, sizeof(*bhs), GFP_NOFS);\n\t\tif (!bhs)\n\t\t\treturn -ENOMEM;\n\t}\n\tret = ext4_bread_batch(ea_inode, 0 , bh_count,\n\t\t\t       true , bhs);\n\tif (ret)\n\t\tgoto free_bhs;\n\tfor (i = 0; i < bh_count; i++) {\n\t\tif (!bhs[i]) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto put_bhs;\n\t\t}\n\t\tmemcpy((char *)buf + blocksize * i, bhs[i]->b_data,\n\t\t       i < bh_count - 1 ? blocksize : tail_size);\n\t}\n\tret = 0;\nput_bhs:\n\tfor (i = 0; i < bh_count; i++)\n\t\tbrelse(bhs[i]);\nfree_bhs:\n\tif (bhs != bhs_inline)\n\t\tkfree(bhs);\n\treturn ret;\n}\n#define EXT4_XATTR_INODE_GET_PARENT(inode) ((__u32)(inode)->i_mtime.tv_sec)\nstatic int ext4_xattr_inode_iget(struct inode *parent, unsigned long ea_ino,\n\t\t\t\t u32 ea_inode_hash, struct inode **ea_inode)\n{\n\tstruct inode *inode;\n\tint err;\n\tinode = ext4_iget(parent->i_sb, ea_ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\text4_error(parent->i_sb,\n\t\t\t   \"error while reading EA inode %lu err=%d\", ea_ino,\n\t\t\t   err);\n\t\treturn err;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\text4_error(parent->i_sb,\n\t\t\t   \"error while reading EA inode %lu is_bad_inode\",\n\t\t\t   ea_ino);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EA_INODE_FL)) {\n\t\text4_error(parent->i_sb,\n\t\t\t   \"EA inode %lu does not have EXT4_EA_INODE_FL flag\",\n\t\t\t    ea_ino);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\text4_xattr_inode_set_class(inode);\n\tif (ea_inode_hash != ext4_xattr_inode_get_hash(inode) &&\n\t    EXT4_XATTR_INODE_GET_PARENT(inode) == parent->i_ino &&\n\t    inode->i_generation == parent->i_generation) {\n\t\text4_set_inode_state(inode, EXT4_STATE_LUSTRE_EA_INODE);\n\t\text4_xattr_inode_set_ref(inode, 1);\n\t} else {\n\t\tinode_lock(inode);\n\t\tinode->i_flags |= S_NOQUOTA;\n\t\tinode_unlock(inode);\n\t}\n\t*ea_inode = inode;\n\treturn 0;\nerror:\n\tiput(inode);\n\treturn err;\n}\nstatic int\next4_xattr_inode_verify_hashes(struct inode *ea_inode,\n\t\t\t       struct ext4_xattr_entry *entry, void *buffer,\n\t\t\t       size_t size)\n{\n\tu32 hash;\n\thash = ext4_xattr_inode_hash(EXT4_SB(ea_inode->i_sb), buffer, size);\n\tif (hash != ext4_xattr_inode_get_hash(ea_inode))\n\t\treturn -EFSCORRUPTED;\n\tif (entry) {\n\t\t__le32 e_hash, tmp_data;\n\t\ttmp_data = cpu_to_le32(hash);\n\t\te_hash = ext4_xattr_hash_entry(entry->e_name, entry->e_name_len,\n\t\t\t\t\t       &tmp_data, 1);\n\t\tif (e_hash != entry->e_hash)\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\nstatic int\next4_xattr_inode_get(struct inode *inode, struct ext4_xattr_entry *entry,\n\t\t     void *buffer, size_t size)\n{\n\tstruct mb_cache *ea_inode_cache = EA_INODE_CACHE(inode);\n\tstruct inode *ea_inode;\n\tint err;\n\terr = ext4_xattr_inode_iget(inode, le32_to_cpu(entry->e_value_inum),\n\t\t\t\t    le32_to_cpu(entry->e_hash), &ea_inode);\n\tif (err) {\n\t\tea_inode = NULL;\n\t\tgoto out;\n\t}\n\tif (i_size_read(ea_inode) != size) {\n\t\text4_warning_inode(ea_inode,\n\t\t\t\t   \"ea_inode file size=%llu entry size=%zu\",\n\t\t\t\t   i_size_read(ea_inode), size);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\terr = ext4_xattr_inode_read(ea_inode, buffer, size);\n\tif (err)\n\t\tgoto out;\n\tif (!ext4_test_inode_state(ea_inode, EXT4_STATE_LUSTRE_EA_INODE)) {\n\t\terr = ext4_xattr_inode_verify_hashes(ea_inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t   \"EA inode hash validation failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (ea_inode_cache)\n\t\t\tmb_cache_entry_create(ea_inode_cache, GFP_NOFS,\n\t\t\t\t\text4_xattr_inode_get_hash(ea_inode),\n\t\t\t\t\tea_inode->i_ino, true );\n\t}\nout:\n\tiput(ea_inode);\n\treturn err;\n}\nstatic int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\treturn -ENODATA;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\terror = ext4_xattr_check_block(inode, bh);\n\tif (error)\n\t\tgoto cleanup;\n\text4_xattr_block_cache_insert(ea_block_cache, bh);\n\tentry = BFIRST(bh);\n\tend = bh->b_data + bh->b_size;\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 1);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\terror = -ERANGE;\n\tif (unlikely(size > EXT4_XATTR_SIZE_MAX))\n\t\tgoto cleanup;\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\terror = ext4_xattr_inode_get(inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tu16 offset = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *p = bh->b_data + offset;\n\t\t\tif (unlikely(p + size > end))\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(buffer, p, size);\n\t\t}\n\t}\n\terror = size;\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\tentry = IFIRST(header);\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\terror = -ERANGE;\n\tif (unlikely(size > EXT4_XATTR_SIZE_MAX))\n\t\tgoto cleanup;\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\terror = ext4_xattr_inode_get(inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tu16 offset = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *p = (void *)IFIRST(header) + offset;\n\t\t\tif (unlikely(p + size > end))\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(buffer, p, size);\n\t\t}\n\t}\n\terror = size;\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}\nint ext4_get_inode_usage(struct inode *inode, qsize_t *usage)\n{\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tqsize_t ea_inode_refs = 0;\n\tvoid *end;\n\tint ret;\n\tlockdep_assert_held_read(&EXT4_I(inode)->xattr_sem);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\tret = ext4_get_inode_loc(inode, &iloc);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\traw_inode = ext4_raw_inode(&iloc);\n\t\theader = IHDR(inode, raw_inode);\n\t\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\t\tret = xattr_check_inode(inode, header, end);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tfor (entry = IFIRST(header); !IS_LAST_ENTRY(entry);\n\t\t     entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\tea_inode_refs++;\n\t}\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = ext4_xattr_check_block(inode, bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tfor (entry = BFIRST(bh); !IS_LAST_ENTRY(entry);\n\t\t     entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\tea_inode_refs++;\n\t}\n\t*usage = ea_inode_refs + 1;\n\tret = 0;\nout:\n\tbrelse(iloc.bh);\n\tbrelse(bh);\n\treturn ret;\n}\nstatic inline size_t round_up_cluster(struct inode *inode, size_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tsize_t cluster_size = 1 << (EXT4_SB(sb)->s_cluster_bits +\n\t\t\t\t    inode->i_blkbits);\n\tsize_t mask = ~(cluster_size - 1);\n\treturn (length + cluster_size - 1) & mask;\n}\nstatic int ext4_xattr_inode_alloc_quota(struct inode *inode, size_t len)\n{\n\tint err;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\treturn err;\n\terr = dquot_alloc_space_nodirty(inode, round_up_cluster(inode, len));\n\tif (err)\n\t\tdquot_free_inode(inode);\n\treturn err;\n}\nstatic void ext4_xattr_inode_free_quota(struct inode *parent,\n\t\t\t\t\tstruct inode *ea_inode,\n\t\t\t\t\tsize_t len)\n{\n\tif (ea_inode &&\n\t    ext4_test_inode_state(ea_inode, EXT4_STATE_LUSTRE_EA_INODE))\n\t\treturn;\n\tdquot_free_space_nodirty(parent, round_up_cluster(parent, len));\n\tdquot_free_inode(parent);\n}\nint __ext4_xattr_set_credits(struct super_block *sb, struct inode *inode,\n\t\t\t     struct buffer_head *block_bh, size_t value_len,\n\t\t\t     bool is_create)\n{\n\tint credits;\n\tint blocks;\n\tcredits = 7;\n\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(sb);\n\tif (inode && ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\tif (!ext4_has_feature_ea_inode(sb))\n\t\treturn credits;\n\tcredits += 4;\n\tblocks = (value_len + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tblocks += 1;\n\tcredits += blocks * 2;\n\tcredits += blocks;\n\tif (!is_create) {\n\t\tcredits += 4;\n\t\tblocks = XATTR_SIZE_MAX >> sb->s_blocksize_bits;\n\t\tblocks += 1;\n\t\tcredits += blocks * 2;\n\t}\n\tif (block_bh) {\n\t\tstruct ext4_xattr_entry *entry = BFIRST(block_bh);\n\t\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\tcredits += 1;\n\t}\n\treturn credits;\n}\nstatic int ext4_xattr_inode_update_ref(handle_t *handle, struct inode *ea_inode,\n\t\t\t\t       int ref_change)\n{\n\tstruct mb_cache *ea_inode_cache = EA_INODE_CACHE(ea_inode);\n\tstruct ext4_iloc iloc;\n\ts64 ref_count;\n\tu32 hash;\n\tint ret;\n\tinode_lock(ea_inode);\n\tret = ext4_reserve_inode_write(handle, ea_inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\tref_count = ext4_xattr_inode_get_ref(ea_inode);\n\tref_count += ref_change;\n\text4_xattr_inode_set_ref(ea_inode, ref_count);\n\tif (ref_change > 0) {\n\t\tWARN_ONCE(ref_count <= 0, \"EA inode %lu ref_count=%lld\",\n\t\t\t  ea_inode->i_ino, ref_count);\n\t\tif (ref_count == 1) {\n\t\t\tWARN_ONCE(ea_inode->i_nlink, \"EA inode %lu i_nlink=%u\",\n\t\t\t\t  ea_inode->i_ino, ea_inode->i_nlink);\n\t\t\tset_nlink(ea_inode, 1);\n\t\t\text4_orphan_del(handle, ea_inode);\n\t\t\tif (ea_inode_cache) {\n\t\t\t\thash = ext4_xattr_inode_get_hash(ea_inode);\n\t\t\t\tmb_cache_entry_create(ea_inode_cache,\n\t\t\t\t\t\t      GFP_NOFS, hash,\n\t\t\t\t\t\t      ea_inode->i_ino,\n\t\t\t\t\t\t      true );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tWARN_ONCE(ref_count < 0, \"EA inode %lu ref_count=%lld\",\n\t\t\t  ea_inode->i_ino, ref_count);\n\t\tif (ref_count == 0) {\n\t\t\tWARN_ONCE(ea_inode->i_nlink != 1,\n\t\t\t\t  \"EA inode %lu i_nlink=%u\",\n\t\t\t\t  ea_inode->i_ino, ea_inode->i_nlink);\n\t\t\tclear_nlink(ea_inode);\n\t\t\text4_orphan_add(handle, ea_inode);\n\t\t\tif (ea_inode_cache) {\n\t\t\t\thash = ext4_xattr_inode_get_hash(ea_inode);\n\t\t\t\tmb_cache_entry_delete(ea_inode_cache, hash,\n\t\t\t\t\t\t      ea_inode->i_ino);\n\t\t\t}\n\t\t}\n\t}\n\tret = ext4_mark_iloc_dirty(handle, ea_inode, &iloc);\n\tif (ret)\n\t\text4_warning_inode(ea_inode,\n\t\t\t\t   \"ext4_mark_iloc_dirty() failed ret=%d\", ret);\nout:\n\tinode_unlock(ea_inode);\n\treturn ret;\n}\nstatic int ext4_xattr_inode_inc_ref(handle_t *handle, struct inode *ea_inode)\n{\n\treturn ext4_xattr_inode_update_ref(handle, ea_inode, 1);\n}\nstatic int ext4_xattr_inode_dec_ref(handle_t *handle, struct inode *ea_inode)\n{\n\treturn ext4_xattr_inode_update_ref(handle, ea_inode, -1);\n}\nstatic int ext4_xattr_inode_inc_ref_all(handle_t *handle, struct inode *parent,\n\t\t\t\t\tstruct ext4_xattr_entry *first)\n{\n\tstruct inode *ea_inode;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *failed_entry;\n\tunsigned int ea_ino;\n\tint err, saved_err;\n\tfor (entry = first; !IS_LAST_ENTRY(entry);\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\terr = ext4_xattr_inode_inc_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode, \"inc ref error %d\", err);\n\t\t\tiput(ea_inode);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tiput(ea_inode);\n\t}\n\treturn 0;\ncleanup:\n\tsaved_err = err;\n\tfailed_entry = entry;\n\tfor (entry = first; entry != failed_entry;\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err) {\n\t\t\text4_warning(parent->i_sb,\n\t\t\t\t     \"cleanup ea_ino %u iget error %d\", ea_ino,\n\t\t\t\t     err);\n\t\t\tcontinue;\n\t\t}\n\t\terr = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (err)\n\t\t\text4_warning_inode(ea_inode, \"cleanup dec ref error %d\",\n\t\t\t\t\t   err);\n\t\tiput(ea_inode);\n\t}\n\treturn saved_err;\n}\nstatic void\next4_xattr_inode_dec_ref_all(handle_t *handle, struct inode *parent,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     struct ext4_xattr_entry *first, bool block_csum,\n\t\t\t     struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t     int extra_credits, bool skip_quota)\n{\n\tstruct inode *ea_inode;\n\tstruct ext4_xattr_entry *entry;\n\tbool dirty = false;\n\tunsigned int ea_ino;\n\tint err;\n\tint credits;\n\tcredits = 2 + extra_credits;\n\tfor (entry = first; !IS_LAST_ENTRY(entry);\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err)\n\t\t\tcontinue;\n\t\terr = ext4_expand_inode_array(ea_inode_array, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t   \"Expand inode array err=%d\", err);\n\t\t\tiput(ea_inode);\n\t\t\tcontinue;\n\t\t}\n\t\terr = ext4_journal_ensure_credits_fn(handle, credits, credits,\n\t\t\text4_free_metadata_revoke_credits(parent->i_sb, 1),\n\t\t\text4_xattr_restart_fn(handle, parent, bh, block_csum,\n\t\t\t\t\t      dirty));\n\t\tif (err < 0) {\n\t\t\text4_warning_inode(ea_inode, \"Ensure credits err=%d\",\n\t\t\t\t\t   err);\n\t\t\tcontinue;\n\t\t}\n\t\tif (err > 0) {\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\tparent->i_sb, bh, EXT4_JTR_NONE);\n\t\t\tif (err) {\n\t\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t\t\"Re-get write access err=%d\",\n\t\t\t\t\t\terr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\terr = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode, \"ea_inode dec ref err=%d\",\n\t\t\t\t\t   err);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!skip_quota)\n\t\t\text4_xattr_inode_free_quota(parent, ea_inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\tentry->e_value_inum = 0;\n\t\tentry->e_value_size = 0;\n\t\tdirty = true;\n\t}\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\text4_warning_inode(parent,\n\t\t\t\t\t   \"handle dirty metadata err=%d\", err);\n\t}\n}\nstatic void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh,\n\t\t\t struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t int extra_credits)\n{\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\tu32 hash, ref;\n\tint error = 0;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, inode->i_sb, bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\thash = le32_to_cpu(BHDR(bh)->h_hash);\n\tref = le32_to_cpu(BHDR(bh)->h_refcount);\n\tif (ref == 1) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ea_block_cache)\n\t\t\tmb_cache_entry_delete(ea_block_cache, hash,\n\t\t\t\t\t      bh->b_blocknr);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb))\n\t\t\text4_xattr_inode_dec_ref_all(handle, inode, bh,\n\t\t\t\t\t\t     BFIRST(bh),\n\t\t\t\t\t\t     true ,\n\t\t\t\t\t\t     ea_inode_array,\n\t\t\t\t\t\t     extra_credits,\n\t\t\t\t\t\t     true );\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tref--;\n\t\tBHDR(bh)->h_refcount = cpu_to_le32(ref);\n\t\tif (ref == EXT4_XATTR_REFCOUNT_MAX - 1) {\n\t\t\tstruct mb_cache_entry *ce;\n\t\t\tif (ea_block_cache) {\n\t\t\t\tce = mb_cache_entry_get(ea_block_cache, hash,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (ce) {\n\t\t\t\t\tce->e_reusable = 1;\n\t\t\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\text4_xattr_block_csum_set(inode, bh);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}\nstatic int ext4_xattr_inode_write(handle_t *handle, struct inode *ea_inode,\n\t\t\t\t  const void *buf, int bufsize)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block = 0;\n\tint blocksize = ea_inode->i_sb->s_blocksize;\n\tint max_blocks = (bufsize + blocksize - 1) >> ea_inode->i_blkbits;\n\tint csize, wsize = 0;\n\tint ret = 0, ret2 = 0;\n\tint retries = 0;\nretry:\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tstruct ext4_map_blocks map;\n\t\tmap.m_lblk = block += ret;\n\t\tmap.m_len = max_blocks -= ret;\n\t\tret = ext4_map_blocks(handle, ea_inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_CREATE);\n\t\tif (ret <= 0) {\n\t\t\text4_mark_inode_dirty(handle, ea_inode);\n\t\t\tif (ret == -ENOSPC &&\n\t\t\t    ext4_should_retry_alloc(ea_inode->i_sb, &retries)) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\tblock = 0;\n\twhile (wsize < bufsize) {\n\t\tbrelse(bh);\n\t\tcsize = (bufsize - wsize) > blocksize ? blocksize :\n\t\t\t\t\t\t\t\tbufsize - wsize;\n\t\tbh = ext4_getblk(handle, ea_inode, block, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tif (!bh) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tEXT4_ERROR_INODE(ea_inode,\n\t\t\t\t\t \"ext4_getblk() return bh = NULL\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tret = ext4_journal_get_write_access(handle, ea_inode->i_sb, bh,\n\t\t\t\t\t\t   EXT4_JTR_NONE);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(bh->b_data, buf, csize);\n\t\tset_buffer_uptodate(bh);\n\t\text4_handle_dirty_metadata(handle, ea_inode, bh);\n\t\tbuf += csize;\n\t\twsize += csize;\n\t\tblock += 1;\n\t}\n\tinode_lock(ea_inode);\n\ti_size_write(ea_inode, wsize);\n\text4_update_i_disksize(ea_inode, wsize);\n\tinode_unlock(ea_inode);\n\tret2 = ext4_mark_inode_dirty(handle, ea_inode);\n\tif (unlikely(ret2 && !ret))\n\t\tret = ret2;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\nstatic struct inode *ext4_xattr_inode_create(handle_t *handle,\n\t\t\t\t\t     struct inode *inode, u32 hash)\n{\n\tstruct inode *ea_inode = NULL;\n\tuid_t owner[2] = { i_uid_read(inode), i_gid_read(inode) };\n\tint err;\n\tea_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t  S_IFREG | 0600, NULL, inode->i_ino + 1, owner,\n\t\t\t\t  EXT4_EA_INODE_FL);\n\tif (!IS_ERR(ea_inode)) {\n\t\tea_inode->i_op = &ext4_file_inode_operations;\n\t\tea_inode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(ea_inode);\n\t\text4_xattr_inode_set_class(ea_inode);\n\t\tunlock_new_inode(ea_inode);\n\t\text4_xattr_inode_set_ref(ea_inode, 1);\n\t\text4_xattr_inode_set_hash(ea_inode, hash);\n\t\terr = ext4_mark_inode_dirty(handle, ea_inode);\n\t\tif (!err)\n\t\t\terr = ext4_inode_attach_jinode(ea_inode);\n\t\tif (err) {\n\t\t\tiput(ea_inode);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tdquot_free_inode(ea_inode);\n\t\tdquot_drop(ea_inode);\n\t\tinode_lock(ea_inode);\n\t\tea_inode->i_flags |= S_NOQUOTA;\n\t\tinode_unlock(ea_inode);\n\t}\n\treturn ea_inode;\n}\nstatic struct inode *\next4_xattr_inode_cache_find(struct inode *inode, const void *value,\n\t\t\t    size_t value_len, u32 hash)\n{\n\tstruct inode *ea_inode;\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ea_inode_cache = EA_INODE_CACHE(inode);\n\tvoid *ea_data;\n\tif (!ea_inode_cache)\n\t\treturn NULL;\n\tce = mb_cache_entry_find_first(ea_inode_cache, hash);\n\tif (!ce)\n\t\treturn NULL;\n\tWARN_ON_ONCE(ext4_handle_valid(journal_current_handle()) &&\n\t\t     !(current->flags & PF_MEMALLOC_NOFS));\n\tea_data = kvmalloc(value_len, GFP_KERNEL);\n\tif (!ea_data) {\n\t\tmb_cache_entry_put(ea_inode_cache, ce);\n\t\treturn NULL;\n\t}\n\twhile (ce) {\n\t\tea_inode = ext4_iget(inode->i_sb, ce->e_value,\n\t\t\t\t     EXT4_IGET_NORMAL);\n\t\tif (!IS_ERR(ea_inode) &&\n\t\t    !is_bad_inode(ea_inode) &&\n\t\t    (EXT4_I(ea_inode)->i_flags & EXT4_EA_INODE_FL) &&\n\t\t    i_size_read(ea_inode) == value_len &&\n\t\t    !ext4_xattr_inode_read(ea_inode, ea_data, value_len) &&\n\t\t    !ext4_xattr_inode_verify_hashes(ea_inode, NULL, ea_data,\n\t\t\t\t\t\t    value_len) &&\n\t\t    !memcmp(value, ea_data, value_len)) {\n\t\t\tmb_cache_entry_touch(ea_inode_cache, ce);\n\t\t\tmb_cache_entry_put(ea_inode_cache, ce);\n\t\t\tkvfree(ea_data);\n\t\t\treturn ea_inode;\n\t\t}\n\t\tif (!IS_ERR(ea_inode))\n\t\t\tiput(ea_inode);\n\t\tce = mb_cache_entry_find_next(ea_inode_cache, ce);\n\t}\n\tkvfree(ea_data);\n\treturn NULL;\n}\nstatic int ext4_xattr_inode_lookup_create(handle_t *handle, struct inode *inode,\n\t\t\t\t\t  const void *value, size_t value_len,\n\t\t\t\t\t  struct inode **ret_inode)\n{\n\tstruct inode *ea_inode;\n\tu32 hash;\n\tint err;\n\thash = ext4_xattr_inode_hash(EXT4_SB(inode->i_sb), value, value_len);\n\tea_inode = ext4_xattr_inode_cache_find(inode, value, value_len, hash);\n\tif (ea_inode) {\n\t\terr = ext4_xattr_inode_inc_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\tiput(ea_inode);\n\t\t\treturn err;\n\t\t}\n\t\t*ret_inode = ea_inode;\n\t\treturn 0;\n\t}\n\tea_inode = ext4_xattr_inode_create(handle, inode, hash);\n\tif (IS_ERR(ea_inode))\n\t\treturn PTR_ERR(ea_inode);\n\terr = ext4_xattr_inode_write(handle, ea_inode, value, value_len);\n\tif (err) {\n\t\text4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tiput(ea_inode);\n\t\treturn err;\n\t}\n\tif (EA_INODE_CACHE(inode))\n\t\tmb_cache_entry_create(EA_INODE_CACHE(inode), GFP_NOFS, hash,\n\t\t\t\t      ea_inode->i_ino, true );\n\t*ret_inode = ea_inode;\n\treturn 0;\n}\n#define EXT4_XATTR_BLOCK_RESERVE(inode)\tmin(i_blocksize(inode)/8, 1024U)\nstatic int ext4_xattr_set_entry(struct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_search *s,\n\t\t\t\thandle_t *handle, struct inode *inode,\n\t\t\t\tbool is_block)\n{\n\tstruct ext4_xattr_entry *last, *next;\n\tstruct ext4_xattr_entry *here = s->here;\n\tsize_t min_offs = s->end - s->base, name_len = strlen(i->name);\n\tint in_inode = i->in_inode;\n\tstruct inode *old_ea_inode = NULL;\n\tstruct inode *new_ea_inode = NULL;\n\tsize_t old_size, new_size;\n\tint ret;\n\told_size = (!s->not_found && !here->e_value_inum) ?\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(here->e_value_size)) : 0;\n\tnew_size = (i->value && !in_inode) ? EXT4_XATTR_SIZE(i->value_len) : 0;\n\tif (new_size && new_size == old_size) {\n\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\tvoid *val = s->base + offs;\n\t\there->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\tmemset(val, 0, new_size);\n\t\t} else {\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\tmemset(val + i->value_len, 0, new_size - i->value_len);\n\t\t}\n\t\tgoto update_hash;\n\t}\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = next) {\n\t\tnext = EXT4_XATTR_NEXT(last);\n\t\tif ((void *)next >= s->end) {\n\t\t\tEXT4_ERROR_INODE(inode, \"corrupted xattr entries\");\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!last->e_value_inum && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tif (i->value) {\n\t\tsize_t free;\n\t\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\t\tif (!s->not_found)\n\t\t\tfree += EXT4_XATTR_LEN(name_len) + old_size;\n\t\tif (free < EXT4_XATTR_LEN(name_len) + new_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t    new_size && is_block &&\n\t\t    (min_offs + old_size - new_size) <\n\t\t\t\t\tEXT4_XATTR_BLOCK_RESERVE(inode)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (!s->not_found && here->e_value_inum) {\n\t\tret = ext4_xattr_inode_iget(inode,\n\t\t\t\t\t    le32_to_cpu(here->e_value_inum),\n\t\t\t\t\t    le32_to_cpu(here->e_hash),\n\t\t\t\t\t    &old_ea_inode);\n\t\tif (ret) {\n\t\t\told_ea_inode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (i->value && in_inode) {\n\t\tWARN_ON_ONCE(!i->value_len);\n\t\tret = ext4_xattr_inode_alloc_quota(inode, i->value_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = ext4_xattr_inode_lookup_create(handle, inode, i->value,\n\t\t\t\t\t\t     i->value_len,\n\t\t\t\t\t\t     &new_ea_inode);\n\t\tif (ret) {\n\t\t\tnew_ea_inode = NULL;\n\t\t\text4_xattr_inode_free_quota(inode, NULL, i->value_len);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (old_ea_inode) {\n\t\tret = ext4_xattr_inode_dec_ref(handle, old_ea_inode);\n\t\tif (ret) {\n\t\t\tif (new_ea_inode) {\n\t\t\t\tint err;\n\t\t\t\terr = ext4_xattr_inode_dec_ref(handle,\n\t\t\t\t\t\t\t       new_ea_inode);\n\t\t\t\tif (err)\n\t\t\t\t\text4_warning_inode(new_ea_inode,\n\t\t\t\t\t\t  \"dec ref new_ea_inode err=%d\",\n\t\t\t\t\t\t  err);\n\t\t\t\text4_xattr_inode_free_quota(inode, new_ea_inode,\n\t\t\t\t\t\t\t    i->value_len);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\text4_xattr_inode_free_quota(inode, old_ea_inode,\n\t\t\t\t\t    le32_to_cpu(here->e_value_size));\n\t}\n\tif (!s->not_found && here->e_value_size && !here->e_value_inum) {\n\t\tvoid *first_val = s->base + min_offs;\n\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\tvoid *val = s->base + offs;\n\t\tmemmove(first_val + old_size, first_val, val - first_val);\n\t\tmemset(first_val, 0, old_size);\n\t\tmin_offs += old_size;\n\t\tlast = s->first;\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\tif (!last->e_value_inum &&\n\t\t\t    last->e_value_size && o < offs)\n\t\t\t\tlast->e_value_offs = cpu_to_le16(o + old_size);\n\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t}\n\t}\n\tif (!i->value) {\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tlast = ENTRY((void *)last - size);\n\t\tmemmove(here, (void *)here + size,\n\t\t\t(void *)last - (void *)here + sizeof(__u32));\n\t\tmemset(last, 0, size);\n\t} else if (s->not_found) {\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)here + sizeof(__u32);\n\t\tmemmove((void *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = i->name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, i->name, name_len);\n\t} else {\n\t\there->e_value_inum = 0;\n\t\there->e_value_offs = 0;\n\t\there->e_value_size = 0;\n\t}\n\tif (i->value) {\n\t\tif (in_inode) {\n\t\t\there->e_value_inum = cpu_to_le32(new_ea_inode->i_ino);\n\t\t} else if (i->value_len) {\n\t\t\tvoid *val = s->base + min_offs - new_size;\n\t\t\there->e_value_offs = cpu_to_le16(min_offs - new_size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, new_size);\n\t\t\t} else {\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\tmemset(val + i->value_len, 0,\n\t\t\t\t       new_size - i->value_len);\n\t\t\t}\n\t\t}\n\t\there->e_value_size = cpu_to_le32(i->value_len);\n\t}\nupdate_hash:\n\tif (i->value) {\n\t\t__le32 hash = 0;\n\t\tif (in_inode) {\n\t\t\t__le32 crc32c_hash;\n\t\t\tcrc32c_hash = cpu_to_le32(\n\t\t\t\t       ext4_xattr_inode_get_hash(new_ea_inode));\n\t\t\thash = ext4_xattr_hash_entry(here->e_name,\n\t\t\t\t\t\t     here->e_name_len,\n\t\t\t\t\t\t     &crc32c_hash, 1);\n\t\t} else if (is_block) {\n\t\t\t__le32 *value = s->base + le16_to_cpu(\n\t\t\t\t\t\t\there->e_value_offs);\n\t\t\thash = ext4_xattr_hash_entry(here->e_name,\n\t\t\t\t\t\t     here->e_name_len, value,\n\t\t\t\t\t\t     new_size >> 2);\n\t\t}\n\t\there->e_hash = hash;\n\t}\n\tif (is_block)\n\t\text4_xattr_rehash((struct ext4_xattr_header *)s->base);\n\tret = 0;\nout:\n\tiput(old_ea_inode);\n\tiput(new_ea_inode);\n\treturn ret;\n}\nstruct ext4_xattr_block_find {\n\tstruct ext4_xattr_search s;\n\tstruct buffer_head *bh;\n};\nstatic int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbs->bh = ext4_sb_bread(sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bs->bh)) {\n\t\t\terror = PTR_ERR(bs->bh);\n\t\t\tbs->bh = NULL;\n\t\t\treturn error;\n\t\t}\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\terror = ext4_xattr_check_block(inode, bs->bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = xattr_find_entry(inode, &bs->s.here, bs->s.end,\n\t\t\t\t\t i->name_index, i->name, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tbs->s.not_found = error;\n\t}\n\treturn 0;\n}\nstatic int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search s_copy = bs->s;\n\tstruct ext4_xattr_search *s = &s_copy;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\tstruct inode *ea_inode = NULL, *tmp_inode;\n\tsize_t old_ea_inode_quota = 0;\n\tunsigned int ea_ino;\n#define header(x) ((struct ext4_xattr_header *)(x))\n\tif (s->base) {\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, sb, bs->bh,\n\t\t\t\t\t\t      EXT4_JTR_NONE);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(BHDR(bs->bh)->h_hash);\n\t\t\tif (ea_block_cache)\n\t\t\t\tmb_cache_entry_delete(ea_block_cache, hash,\n\t\t\t\t\t\t      bs->bh->b_blocknr);\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s, handle, inode,\n\t\t\t\t\t\t     true );\n\t\t\text4_xattr_block_csum_set(inode, bs->bh);\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmemdup(BHDR(bs->bh), bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t\tif (!s->not_found && s->here->e_value_inum) {\n\t\t\t\tea_ino = le32_to_cpu(s->here->e_value_inum);\n\t\t\t\terror = ext4_xattr_inode_iget(inode, ea_ino,\n\t\t\t\t\t      le32_to_cpu(s->here->e_hash),\n\t\t\t\t\t      &tmp_inode);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tif (!ext4_test_inode_state(tmp_inode,\n\t\t\t\t\t\tEXT4_STATE_LUSTRE_EA_INODE)) {\n\t\t\t\t\told_ea_inode_quota = le32_to_cpu(\n\t\t\t\t\t\t\ts->here->e_value_size);\n\t\t\t\t}\n\t\t\t\tiput(tmp_inode);\n\t\t\t\ts->here->e_value_inum = 0;\n\t\t\t\ts->here->e_value_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\terror = ext4_xattr_set_entry(i, s, handle, inode, true );\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (i->value && s->here->e_value_inum) {\n\t\tea_ino = le32_to_cpu(s->here->e_value_inum);\n\t\terror = ext4_xattr_inode_iget(inode, ea_ino,\n\t\t\t\t\t      le32_to_cpu(s->here->e_hash),\n\t\t\t\t\t      &ea_inode);\n\t\tif (error) {\n\t\t\tea_inode = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_block_cache_find(inode, header(s->base),\n\t\t\t\t\t\t     &ce);\n\t\tif (new_bh) {\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\tu32 ref;\n\t\t\t\tWARN_ON_ONCE(dquot_initialize_needed(inode));\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(\n\t\t\t\t\t\thandle, sb, new_bh,\n\t\t\t\t\t\tEXT4_JTR_NONE);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tif (hlist_bl_unhashed(&ce->e_hash_list) ||\n\t\t\t\t    !ce->e_reusable) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tdquot_free_block(inode,\n\t\t\t\t\t\t\t EXT4_C2B(EXT4_SB(sb),\n\t\t\t\t\t\t\t\t  1));\n\t\t\t\t\tbrelse(new_bh);\n\t\t\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\t\t\tce = NULL;\n\t\t\t\t\tnew_bh = NULL;\n\t\t\t\t\tgoto inserted;\n\t\t\t\t}\n\t\t\t\tref = le32_to_cpu(BHDR(new_bh)->h_refcount) + 1;\n\t\t\t\tBHDR(new_bh)->h_refcount = cpu_to_le32(ref);\n\t\t\t\tif (ref >= EXT4_XATTR_REFCOUNT_MAX)\n\t\t\t\t\tce->e_reusable = 0;\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\t  ref);\n\t\t\t\text4_xattr_block_csum_set(inode, new_bh);\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_touch(ea_block_cache, ce);\n\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\text4_xattr_block_cache_insert(ea_block_cache, bs->bh);\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\text4_fsblk_t goal, block;\n\t\t\tWARN_ON_ONCE(dquot_initialize_needed(inode));\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_inode_inc_ref_all(handle, inode,\n\t\t\t\t\t\t      ENTRY(header(s->base)+1));\n\t\t\tif (error)\n\t\t\t\tgoto getblk_failed;\n\t\t\tif (ea_inode) {\n\t\t\t\terror = ext4_xattr_inode_dec_ref(handle,\n\t\t\t\t\t\t\t\t ea_inode);\n\t\t\t\tif (error)\n\t\t\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t\t\t   \"dec ref error=%d\",\n\t\t\t\t\t\t\t   error);\n\t\t\t\tiput(ea_inode);\n\t\t\t\tea_inode = NULL;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, sb,\n\t\t\t\t\t\t\tnew_bh, EXT4_JTR_NONE);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\text4_xattr_block_csum_set(inode, new_bh);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_block_cache_insert(ea_block_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode,\n\t\t\t\t\t\t\t   new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tif (old_ea_inode_quota)\n\t\text4_xattr_inode_free_quota(inode, NULL, old_ea_inode_quota);\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tif (bs->bh && bs->bh != new_bh) {\n\t\tstruct ext4_xattr_inode_array *ea_inode_array = NULL;\n\t\text4_xattr_release_block(handle, inode, bs->bh,\n\t\t\t\t\t &ea_inode_array,\n\t\t\t\t\t 0 );\n\t\text4_xattr_inode_array_free(ea_inode_array);\n\t}\n\terror = 0;\ncleanup:\n\tif (ea_inode) {\n\t\tint error2;\n\t\terror2 = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (error2)\n\t\t\text4_warning_inode(ea_inode, \"dec ref error=%d\",\n\t\t\t\t\t   error2);\n\t\tif (error)\n\t\t\text4_xattr_inode_free_quota(inode, ea_inode,\n\t\t\t\t\t\t    i_size_read(ea_inode));\n\t\tiput(ea_inode);\n\t}\n\tif (ce)\n\t\tmb_cache_entry_put(ea_block_cache, ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\treturn error;\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n#undef header\n}\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = xattr_check_inode(inode, header, is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xattr_find_entry(inode, &is->s.here, is->s.end,\n\t\t\t\t\t i->name_index, i->name, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}\nint ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s, handle, inode, false );\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}\nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\t\t.in_inode = 0,\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint no_expand;\n\tint error;\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\text4_write_lock_xattr(inode, &no_expand);\n\tif (ext4_handle_valid(handle)) {\n\t\tstruct buffer_head *bh;\n\t\tint credits;\n\t\tbh = ext4_xattr_get_block(inode);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcredits = __ext4_xattr_set_credits(inode->i_sb, inode, bh,\n\t\t\t\t\t\t   value_len,\n\t\t\t\t\t\t   flags & XATTR_CREATE);\n\t\tbrelse(bh);\n\t\tif (jbd2_handle_buffer_credits(handle) < credits) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tWARN_ON_ONCE(!(current->flags & PF_MEMALLOC_NOFS));\n\t}\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = 0;\n\t\tif (!is.s.not_found && ext4_xattr_value_same(&is.s, &i))\n\t\t\tgoto cleanup;\n\t\tif (!bs.s.not_found && ext4_xattr_value_same(&bs.s, &i))\n\t\t\tgoto cleanup;\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t    (EXT4_XATTR_SIZE(i.value_len) >\n\t\t\tEXT4_XATTR_MIN_LARGE_EA_SIZE(inode->i_sb->s_blocksize)))\n\t\t\ti.in_inode = 1;\nretry_inode:\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\tbrelse(bs.bh);\n\t\t\t\tbs.bh = NULL;\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (!error && !is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t} else if (error == -ENOSPC) {\n\t\t\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t\t\t    i.value_len && !i.in_inode) {\n\t\t\t\t\ti.in_inode = 1;\n\t\t\t\t\tgoto retry_inode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = current_time(inode);\n\t\tif (!value)\n\t\t\tno_expand = 0;\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\text4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_XATTR, handle);\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\text4_write_unlock_xattr(inode, &no_expand);\n\treturn error;\n}\nstatic int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,\n\t\t\t\t    struct ext4_inode *raw_inode,\n\t\t\t\t    struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\tstruct ext4_xattr_info i = {\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t\t.name_index = entry->e_name_index,\n\t\t.in_inode = !!entry->e_value_inum,\n\t};\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tint error;\n\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\tbuffer = kmalloc(value_size, GFP_NOFS);\n\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\tif (!is || !bs || !buffer || !b_entry_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tis->s.not_found = -ENODATA;\n\tbs->s.not_found = -ENODATA;\n\tis->iloc.bh = NULL;\n\tbs->bh = NULL;\n\tif (entry->e_value_inum) {\n\t\terror = ext4_xattr_inode_get(inode, entry, buffer, value_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tsize_t value_offs = le16_to_cpu(entry->e_value_offs);\n\t\tmemcpy(buffer, (void *)IFIRST(header) + value_offs, value_size);\n\t}\n\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\tb_entry_name[entry->e_name_len] = '\\0';\n\ti.name = b_entry_name;\n\terror = ext4_get_inode_loc(inode, &is->iloc);\n\tif (error)\n\t\tgoto out;\n\terror = ext4_xattr_ibody_find(inode, &i, is);\n\tif (error)\n\t\tgoto out;\n\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\tif (error)\n\t\tgoto out;\n\ti.value = buffer;\n\ti.value_len = value_size;\n\terror = ext4_xattr_block_find(inode, &i, bs);\n\tif (error)\n\t\tgoto out;\n\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\tif (error)\n\t\tgoto out;\n\terror = 0;\nout:\n\tkfree(b_entry_name);\n\tkfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tif (bs)\n\t\tbrelse(bs->bh);\n\tkfree(is);\n\tkfree(bs);\n\treturn error;\n}\nstatic int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,\n\t\t\t\t       struct ext4_inode *raw_inode,\n\t\t\t\t       int isize_diff, size_t ifree,\n\t\t\t\t       size_t bfree, int *total_ino)\n{\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tstruct ext4_xattr_entry *small_entry;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *last;\n\tunsigned int entry_size;\t\n\tunsigned int total_size;\t\n\tunsigned int min_total_size;\n\tint error;\n\twhile (isize_diff > ifree) {\n\t\tentry = NULL;\n\t\tsmall_entry = NULL;\n\t\tmin_total_size = ~0U;\n\t\tlast = IFIRST(header);\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\tif ((last->e_name_len == 4) &&\n\t\t\t    (last->e_name_index == EXT4_XATTR_INDEX_SYSTEM) &&\n\t\t\t    !memcmp(last->e_name, \"data\", 4))\n\t\t\t\tcontinue;\n\t\t\ttotal_size = EXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (!last->e_value_inum)\n\t\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t       le32_to_cpu(last->e_value_size));\n\t\t\tif (total_size <= bfree &&\n\t\t\t    total_size < min_total_size) {\n\t\t\t\tif (total_size + ifree < isize_diff) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry == NULL)\n\t\t\t\treturn -ENOSPC;\n\t\t\tentry = small_entry;\n\t\t}\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ttotal_size = entry_size;\n\t\tif (!entry->e_value_inum)\n\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\terror = ext4_xattr_move_to_block(handle, inode, raw_inode,\n\t\t\t\t\t\t entry);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*total_ino -= entry_size;\n\t\tifree += total_size;\n\t\tbfree -= total_size;\n\t}\n\treturn 0;\n}\nint ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tsize_t min_offs;\n\tsize_t ifree, bfree;\n\tint total_ino;\n\tvoid *base, *end;\n\tint error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(sbi->s_es->s_min_extra_isize);\n\tint isize_diff;\t\nretry:\n\tisize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\theader = IHDR(inode, raw_inode);\n\tbase = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header) + sizeof(u32);\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\tifree = ext4_xattr_free_space(base, &min_offs, base, &total_ino);\n\tif (ifree >= isize_diff)\n\t\tgoto shift;\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tstruct buffer_head *bh;\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\t\terror = ext4_xattr_check_block(inode, bh);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tbfree = ext4_xattr_free_space(BFIRST(bh), &min_offs, base,\n\t\t\t\t\t      NULL);\n\t\tbrelse(bh);\n\t\tif (bfree + ifree < isize_diff) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tbfree = inode->i_sb->s_blocksize;\n\t}\n\terror = ext4_xattr_make_inode_space(handle, inode, raw_inode,\n\t\t\t\t\t    isize_diff, ifree, bfree,\n\t\t\t\t\t    &total_ino);\n\tif (error) {\n\t\tif (error == -ENOSPC && !tried_min_extra_isize &&\n\t\t    s_min_extra_isize) {\n\t\t\ttried_min_extra_isize++;\n\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\tgoto retry;\n\t\t}\n\t\tgoto cleanup;\n\t}\nshift:\n\text4_xattr_shift_entries(IFIRST(header), EXT4_I(inode)->i_extra_isize\n\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t(void *)header, total_ino);\n\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\ncleanup:\n\tif (error && (mnt_count != le16_to_cpu(sbi->s_es->s_mnt_count))) {\n\t\text4_warning(inode->i_sb, \"Unable to expand inode %lu. Delete some EAs or run e2fsck.\",\n\t\t\t     inode->i_ino);\n\t\tmnt_count = le16_to_cpu(sbi->s_es->s_mnt_count);\n\t}\n\treturn error;\n}\n#define EIA_INCR 16 \n#define EIA_MASK (EIA_INCR - 1)\nstatic int\next4_expand_inode_array(struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\tstruct inode *inode)\n{\n\tif (*ea_inode_array == NULL) {\n\t\t(*ea_inode_array) =\n\t\t\tkmalloc(offsetof(struct ext4_xattr_inode_array,\n\t\t\t\t\t inodes[EIA_MASK]),\n\t\t\t\tGFP_NOFS);\n\t\tif (*ea_inode_array == NULL)\n\t\t\treturn -ENOMEM;\n\t\t(*ea_inode_array)->count = 0;\n\t} else if (((*ea_inode_array)->count & EIA_MASK) == EIA_MASK) {\n\t\tstruct ext4_xattr_inode_array *new_array = NULL;\n\t\tint count = (*ea_inode_array)->count;\n\t\tnew_array = kmalloc(\n\t\t\t\toffsetof(struct ext4_xattr_inode_array,\n\t\t\t\t\t inodes[count + EIA_INCR]),\n\t\t\t\tGFP_NOFS);\n\t\tif (new_array == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(new_array, *ea_inode_array,\n\t\t       offsetof(struct ext4_xattr_inode_array, inodes[count]));\n\t\tkfree(*ea_inode_array);\n\t\t*ea_inode_array = new_array;\n\t}\n\t(*ea_inode_array)->inodes[(*ea_inode_array)->count++] = inode;\n\treturn 0;\n}\nint ext4_xattr_delete_inode(handle_t *handle, struct inode *inode,\n\t\t\t    struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t    int extra_credits)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\tstruct ext4_xattr_entry *entry;\n\tstruct inode *ea_inode;\n\tint error;\n\terror = ext4_journal_ensure_credits(handle, extra_credits,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1));\n\tif (error < 0) {\n\t\tEXT4_ERROR_INODE(inode, \"ensure credits (error %d)\", error);\n\t\tgoto cleanup;\n\t}\n\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_get_inode_loc(inode, &iloc);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"inode loc (error %d)\", error);\n\t\t\tgoto cleanup;\n\t\t}\n\t\terror = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\t\t\tiloc.bh, EXT4_JTR_NONE);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"write access (error %d)\",\n\t\t\t\t\t error);\n\t\t\tgoto cleanup;\n\t\t}\n\t\theader = IHDR(inode, ext4_raw_inode(&iloc));\n\t\tif (header->h_magic == cpu_to_le32(EXT4_XATTR_MAGIC))\n\t\t\text4_xattr_inode_dec_ref_all(handle, inode, iloc.bh,\n\t\t\t\t\t\t     IFIRST(header),\n\t\t\t\t\t\t     false ,\n\t\t\t\t\t\t     ea_inode_array,\n\t\t\t\t\t\t     extra_credits,\n\t\t\t\t\t\t     false );\n\t}\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tif (error == -EIO) {\n\t\t\t\tEXT4_ERROR_INODE_ERR(inode, EIO,\n\t\t\t\t\t\t     \"block %llu read error\",\n\t\t\t\t\t\t     EXT4_I(inode)->i_file_acl);\n\t\t\t}\n\t\t\tbh = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\terror = ext4_xattr_check_block(inode, bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb)) {\n\t\t\tfor (entry = BFIRST(bh); !IS_LAST_ENTRY(entry);\n\t\t\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\t\t\tif (!entry->e_value_inum)\n\t\t\t\t\tcontinue;\n\t\t\t\terror = ext4_xattr_inode_iget(inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_inum),\n\t\t\t\t\t      le32_to_cpu(entry->e_hash),\n\t\t\t\t\t      &ea_inode);\n\t\t\t\tif (error)\n\t\t\t\t\tcontinue;\n\t\t\t\text4_xattr_inode_free_quota(inode, ea_inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\t\t\tiput(ea_inode);\n\t\t\t}\n\t\t}\n\t\text4_xattr_release_block(handle, inode, bh, ea_inode_array,\n\t\t\t\t\t extra_credits);\n\t\tEXT4_I(inode)->i_file_acl = 0;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"mark inode dirty (error %d)\",\n\t\t\t\t\t error);\n\t\t\tgoto cleanup;\n\t\t}\n\t\text4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_XATTR, handle);\n\t}\n\terror = 0;\ncleanup:\n\tbrelse(iloc.bh);\n\tbrelse(bh);\n\treturn error;\n}\n#define NAME_HASH_SHIFT 5\n#define VALUE_HASH_SHIFT 16\nstatic __le32 ext4_xattr_hash_entry(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count)\n{\n\t__u32 hash = 0;\n\twhile (name_len--) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\twhile (value_count--) {\n\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(*value++);\n\t}\n\treturn cpu_to_le32(hash);\n}\n#undef NAME_HASH_SHIFT\n#undef VALUE_HASH_SHIFT\n#define BLOCK_HASH_SHIFT 16\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *header)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}\n#undef BLOCK_HASH_SHIFT\n#define\tHASH_BUCKET_BITS\t10\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_11561.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/67d7d8ad99beccd9fe92d585b87f1760dc9018e3",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void import_palette(CDXLVideoContext *c, uint32_t *new_palette)\n    for (i = 0; i < c->palette_size / 2; i++) {\n        unsigned rgb = AV_RB16(&c->palette[i * 2]);\n    }\nstatic void chunky2chunky(CDXLVideoContext *c, int linesize, uint8_t *out)\n    bytestream2_init(&gb, c->video, c->video_size);\n    for (y = 0; y < c->avctx->height; y++) {\n        bytestream2_get_buffer(&gb, out + linesize * y, c->avctx->width * 3);\n    }\nstatic void import_format(CDXLVideoContext *c, int linesize, uint8_t *out)\n    memset(out, 0, linesize * c->avctx->height);\n        chunky2chunky(c, linesize, out);\nstatic void cdxl_decode_rgb(CDXLVideoContext *c, AVFrame *frame)\n    import_palette(c, new_palette);\n    import_format(c, frame->linesize[0], frame->data[0]);\nstatic void cdxl_decode_raw(CDXLVideoContext *c, AVFrame *frame)\n    import_format(c, frame->linesize[0], frame->data[0]);\nstatic void cdxl_decode_ham6(CDXLVideoContext *c, AVFrame *frame)\n    AVCodecContext *avctx = c->avctx;\n    ptr = c->new_video;\n    import_palette(c, new_palette);\n    import_format(c, avctx->width, c->new_video);\nstatic void cdxl_decode_ham8(CDXLVideoContext *c, AVFrame *frame)\n    AVCodecContext *avctx = c->avctx;\n    uint32_t new_palette[64], r, g, b;\n    ptr = c->new_video;\n    import_palette(c, new_palette);\n    import_format(c, avctx->width, c->new_video);\nstatic int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n    }\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n    }\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define UNCHECKED_BITSTREAM_READER 1\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/imgutils.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"get_bits.h\"\n#include \"internal.h\"\n#define BIT_PLANAR   0x00\n#define CHUNKY       0x20\n#define BYTE_PLANAR  0x40\n#define BIT_LINE     0x80\n#define BYTE_LINE    0xC0\ntypedef struct CDXLVideoContext {\n    AVCodecContext *avctx;\n    int            bpp;\n    int            format;\n    int            padded_bits;\n    const uint8_t  *palette;\n    int            palette_size;\n    const uint8_t  *video;\n    int            video_size;\n    uint8_t        *new_video;\n    int            new_video_size;\n} CDXLVideoContext;\nstatic av_cold int cdxl_decode_init(AVCodecContext *avctx)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    c->new_video_size = 0;\n    c->avctx          = avctx;\n    return 0;\n}\nstatic void import_palette(CDXLVideoContext *c, uint32_t *new_palette)\n{\n    int i;\n    for (i = 0; i < c->palette_size / 2; i++) {\n        unsigned rgb = AV_RB16(&c->palette[i * 2]);\n        unsigned r   = ((rgb >> 8) & 0xF) * 0x11;\n        unsigned g   = ((rgb >> 4) & 0xF) * 0x11;\n        unsigned b   =  (rgb       & 0xF) * 0x11;\n        AV_WN32(&new_palette[i], (0xFFU << 24) | (r << 16) | (g << 8) | b);\n    }\n}\nstatic void bitplanar2chunky(CDXLVideoContext *c, int linesize, uint8_t *out)\n{\n    GetBitContext gb;\n    int x, y, plane;\n    if (init_get_bits8(&gb, c->video, c->video_size) < 0)\n        return;\n    for (plane = 0; plane < c->bpp; plane++) {\n        for (y = 0; y < c->avctx->height; y++) {\n            for (x = 0; x < c->avctx->width; x++)\n                out[linesize * y + x] |= get_bits1(&gb) << plane;\n            skip_bits(&gb, c->padded_bits);\n        }\n    }\n}\nstatic void bitline2chunky(CDXLVideoContext *c, int linesize, uint8_t *out)\n{\n    GetBitContext  gb;\n    int x, y, plane;\n    if (init_get_bits8(&gb, c->video, c->video_size) < 0)\n        return;\n    for (y = 0; y < c->avctx->height; y++) {\n        for (plane = 0; plane < c->bpp; plane++) {\n            for (x = 0; x < c->avctx->width; x++)\n                out[linesize * y + x] |= get_bits1(&gb) << plane;\n            skip_bits(&gb, c->padded_bits);\n        }\n    }\n}\nstatic void chunky2chunky(CDXLVideoContext *c, int linesize, uint8_t *out)\n{\n    GetByteContext gb;\n    int y;\n    bytestream2_init(&gb, c->video, c->video_size);\n    for (y = 0; y < c->avctx->height; y++) {\n        bytestream2_get_buffer(&gb, out + linesize * y, c->avctx->width * 3);\n    }\n}\nstatic void import_format(CDXLVideoContext *c, int linesize, uint8_t *out)\n{\n    memset(out, 0, linesize * c->avctx->height);\n    switch (c->format) {\n    case BIT_PLANAR:\n        bitplanar2chunky(c, linesize, out);\n        break;\n    case BIT_LINE:\n        bitline2chunky(c, linesize, out);\n        break;\n    case CHUNKY:\n        chunky2chunky(c, linesize, out);\n        break;\n    }\n}\nstatic void cdxl_decode_rgb(CDXLVideoContext *c, AVFrame *frame)\n{\n    uint32_t *new_palette = (uint32_t *)frame->data[1];\n    memset(frame->data[1], 0, AVPALETTE_SIZE);\n    import_palette(c, new_palette);\n    import_format(c, frame->linesize[0], frame->data[0]);\n}\nstatic void cdxl_decode_raw(CDXLVideoContext *c, AVFrame *frame)\n{\n    import_format(c, frame->linesize[0], frame->data[0]);\n}\nstatic void cdxl_decode_ham6(CDXLVideoContext *c, AVFrame *frame)\n{\n    AVCodecContext *avctx = c->avctx;\n    uint32_t new_palette[16], r, g, b;\n    uint8_t *ptr, *out, index, op;\n    int x, y;\n    ptr = c->new_video;\n    out = frame->data[0];\n    import_palette(c, new_palette);\n    import_format(c, avctx->width, c->new_video);\n    for (y = 0; y < avctx->height; y++) {\n        r = new_palette[0] & 0xFF0000;\n        g = new_palette[0] & 0xFF00;\n        b = new_palette[0] & 0xFF;\n        for (x = 0; x < avctx->width; x++) {\n            index  = *ptr++;\n            op     = index >> 4;\n            index &= 15;\n            switch (op) {\n            case 0:\n                r = new_palette[index] & 0xFF0000;\n                g = new_palette[index] & 0xFF00;\n                b = new_palette[index] & 0xFF;\n                break;\n            case 1:\n                b = index * 0x11;\n                break;\n            case 2:\n                r = index * 0x11 << 16;\n                break;\n            case 3:\n                g = index * 0x11 << 8;\n                break;\n            }\n            AV_WL24(out + x * 3, r | g | b);\n        }\n        out += frame->linesize[0];\n    }\n}\nstatic void cdxl_decode_ham8(CDXLVideoContext *c, AVFrame *frame)\n{\n    AVCodecContext *avctx = c->avctx;\n    uint32_t new_palette[64], r, g, b;\n    uint8_t *ptr, *out, index, op;\n    int x, y;\n    ptr = c->new_video;\n    out = frame->data[0];\n    import_palette(c, new_palette);\n    import_format(c, avctx->width, c->new_video);\n    for (y = 0; y < avctx->height; y++) {\n        r = new_palette[0] & 0xFF0000;\n        g = new_palette[0] & 0xFF00;\n        b = new_palette[0] & 0xFF;\n        for (x = 0; x < avctx->width; x++) {\n            index  = *ptr++;\n            op     = index >> 6;\n            index &= 63;\n            switch (op) {\n            case 0:\n                r = new_palette[index] & 0xFF0000;\n                g = new_palette[index] & 0xFF00;\n                b = new_palette[index] & 0xFF;\n                break;\n            case 1:\n                b = (index <<  2) | (b & 3);\n                break;\n            case 2:\n                r = (index << 18) | (r & (3 << 16));\n                break;\n            case 3:\n                g = (index << 10) | (g & (3 << 8));\n                break;\n            }\n            AV_WL24(out + x * 3, r | g | b);\n        }\n        out += frame->linesize[0];\n    }\n}\nstatic int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n    return buf_size;\n}\nstatic av_cold int cdxl_decode_end(AVCodecContext *avctx)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    av_freep(&c->new_video);\n    return 0;\n}\nAVCodec ff_cdxl_decoder = {\n    .name           = \"cdxl\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Commodore CDXL video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_CDXL,\n    .priv_data_size = sizeof(CDXLVideoContext),\n    .init           = cdxl_decode_init,\n    .close          = cdxl_decode_end,\n    .decode         = cdxl_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_2077.c",
        "project": "ffmpeg/ffmpeg",
        "url": "https://github.com/FFmpeg/FFmpeg/commit/1e42736b95065c69a7481d0cf55247024f54b660",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int usb_console_setup(struct console *co, char *options)\n\tint baud = 9600;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tstruct tty_struct *tty = NULL;\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t}\n\tif (baud == 0)\n\t\tbaud = 9600;\n\t\tcflag |= CS7;\n\t\tcflag |= CS8;\n\t\tcflag |= PARODD;\n\t\tcflag |= PARENB;\n\tco->cflag = cflag;\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t}\n\tserial = port->serial;\n\ttty_port_tty_set(&port->port, NULL);\n\tinfo->port = port;\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t}\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n/*\n * USB Serial Console driver\n *\n * Copyright (C) 2001 - 2002 Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * Thanks to Randy Dunlap for the original version of this code.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\n\n/*\n * ------------------------------------------------------------\n * USB Serial console driver\n *\n * Much of the code here is copied from drivers/char/serial.c\n * and implements a phony serial console in the same way that\n * serial.c does so that in case some software queries it,\n * it will get the same results.\n *\n * Things that are different from the way the serial port code\n * does things, is that we call the lower level usb-serial\n * driver code to initialize the device, and we set the initial\n * console speeds based on the command line arguments.\n * ------------------------------------------------------------\n */\n\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\n\n/*\n * The parsing of the command line works exactly like the\n * serial.c code, except that the specifier is \"ttyUSB\" instead\n * of \"ttyS\".\n */\nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\n\tif (count == 0)\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\t/* search for LF so we can insert CR if necessary */\n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* pass on to the driver specific version of this function if\n\t\t   it is available */\n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\t/* append CR after LF */\n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\n\nstatic struct tty_driver *usb_console_device(struct console *co, int *index)\n{\n\tstruct tty_driver **p = (struct tty_driver **)co->data;\n\n\tif (!*p)\n\t\treturn NULL;\n\n\t*index = co->index;\n\treturn *p;\n}\n\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n\nvoid usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}\n\nvoid usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t/*\n\t\t * Call register_console() if this is the first device plugged\n\t\t * in.  If we call it earlier, then the callback to\n\t\t * console_setup() will fail, as there is not a device seen by\n\t\t * the USB subsystem yet.\n\t\t */\n\t\t/*\n\t\t * Register console.\n\t\t * NOTES:\n\t\t * console_setup() is called (back) immediately (from\n\t\t * register_console). console_write() is called immediately\n\t\t * from register_console iff CON_PRINTBUFFER is set in flags.\n\t\t */\n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}\n\nvoid usb_serial_console_exit(void)\n{\n\tif (usbcons_info.port) {\n\t\tunregister_console(&usbcons);\n\t\tusbcons_info.port->port.console = 0;\n\t\tusbcons_info.port = NULL;\n\t}\n}\n\n\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_2567.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static char *get_rename_from_user(struct exfat_de_iter *iter)\n\tchar *rename = malloc(ENTRY_NAME_MAX + 2);\n\tif (!rename)\n\t\treturn NULL;\n\tmemset(rename, 0x1, ENTRY_NAME_MAX + 2);\n\tif (fgets(rename, ENTRY_NAME_MAX + 2, stdin)) {\n\t\tlen = strlen(rename);\n\t\trename[len - 1] = '\\0';\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (check_bad_char(rename[i])) {\n\t\t\t\tprintf(\"filename contain invalid character(%c)\\n\", rename[i]);\n\t\t\t}\n\t\t}\n\t\texfat_de_iter_flush(iter);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename, &filter);\n\t\tif (!err) {\n\t\t\tprintf(\"file(%s) already exists, retry to insert name\\n\", rename);\n\t\t}\n\t}\nstatic int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\tif (num) {\n\t\t\trename = get_rename_from_user(iter);\n\t}\nstatic int read_file_dentry_set(struct exfat_de_iter *iter,\n\tstruct exfat_inode *node = NULL;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t}\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t}\n\tif (file_de->file_num_ext < 2) {\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t}\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t}\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <string.h>\n#include <errno.h>\n#include <locale.h>\n#include \"exfat_ondisk.h\"\n#include \"libexfat.h\"\n#include \"repair.h\"\n#include \"exfat_fs.h\"\n#include \"exfat_dir.h\"\n#include \"fsck.h\"\nstruct fsck_user_input {\n\tstruct exfat_user_input\t\tei;\n\tenum fsck_ui_options\t\toptions;\n};\n#define EXFAT_MAX_UPCASE_CHARS\t0x10000\n#define FSCK_EXIT_NO_ERRORS\t\t0x00\n#define FSCK_EXIT_CORRECTED\t\t0x01\n#define FSCK_EXIT_NEED_REBOOT\t\t0x02\n#define FSCK_EXIT_ERRORS_LEFT\t\t0x04\n#define FSCK_EXIT_OPERATION_ERROR\t0x08\n#define FSCK_EXIT_SYNTAX_ERROR\t\t0x10\n#define FSCK_EXIT_USER_CANCEL\t\t0x20\n#define FSCK_EXIT_LIBRARY_ERROR\t\t0x80\nstruct exfat_stat {\n\tlong\t\tdir_count;\n\tlong\t\tfile_count;\n\tlong\t\terror_count;\n\tlong\t\tfixed_count;\n};\nstruct exfat_fsck exfat_fsck;\nstruct exfat_stat exfat_stat;\nstruct path_resolve_ctx path_resolve_ctx;\nstatic struct option opts[] = {\n\t{\"repair\",\tno_argument,\tNULL,\t'r' },\n\t{\"repair-yes\",\tno_argument,\tNULL,\t'y' },\n\t{\"repair-no\",\tno_argument,\tNULL,\t'n' },\n\t{\"repair-auto\",\tno_argument,\tNULL,\t'p' },\n\t{\"rescue\",\tno_argument,\tNULL,\t's' },\n\t{\"version\",\tno_argument,\tNULL,\t'V' },\n\t{\"verbose\",\tno_argument,\tNULL,\t'v' },\n\t{\"help\",\tno_argument,\tNULL,\t'h' },\n\t{\"?\",\t\tno_argument,\tNULL,\t'?' },\n\t{\"ignore-bad-fs\",\tno_argument,\tNULL,\t'b' },\n\t{NULL,\t\t0,\t\tNULL,\t 0  }\n};\n#define fsck_err(parent, inode, fmt, ...)\t\t\\\n({\t\t\t\t\t\t\t\\\n\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\tparent, inode);\t\t\t\\\n\t\texfat_err(\"ERROR: %s: \" fmt,\t\t\\\n\t\t\tpath_resolve_ctx.local_path,\t\\\n\t\t\t##__VA_ARGS__);\t\t\t\\\n})\n#define repair_file_ask(iter, inode, code, fmt, ...)\t\\\n({\t\t\t\t\t\t\t\\\n\t\tif (inode)\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\t\t\t    (iter)->parent, inode);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path(&path_resolve_ctx,\t\t\\\n\t\t\t\t     (iter)->parent);\t\t\t\\\n\t\texfat_repair_ask(&exfat_fsck, code,\t\t\t\\\n\t\t\t\t \"ERROR: %s: \" fmt \" at %#\" PRIx64,\t\\\n\t\t\t\t path_resolve_ctx.local_path,\t\t\\\n\t\t\t\t ##__VA_ARGS__,\t\t\t\t\\\n\t\t\t\t exfat_de_iter_device_offset(iter));\t\\\n})\nstatic int check_clus_chain(struct exfat_de_iter *de_iter,\n\t\t\t\tstruct exfat_inode *node)\n{\n\tstruct exfat *exfat = de_iter->exfat;\n\tstruct exfat_dentry *stream_de;\n\tclus_t clus, prev, next, new_clus;\n\tuint64_t count, max_count;\n\tint err;\n\tclus = node->first_clus;\n\tprev = EXFAT_EOF_CLUSTER;\n\tcount = 0;\n\tmax_count = DIV_ROUND_UP(node->size, exfat->clus_size);\n\tif (node->size == 0 && node->first_clus == EXFAT_FREE_CLUSTER) {\n\t\tif (node->attr & ATTR_SUBDIR) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\tER_DE_FIRST_CLUS,\n\t\t\t\t\t\"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t\tnode->size, node->first_clus))\n\t\t\t\tgoto allocate_cluster;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif ((node->size == 0 && node->first_clus != EXFAT_FREE_CLUSTER) ||\n\t    (node->size > 0 && !exfat_heap_clus(exfat, node->first_clus))) {\n\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t    ER_FILE_FIRST_CLUS,\n\t\t\t\t    \"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t    node->size, node->first_clus))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\twhile (clus != EXFAT_EOF_CLUSTER) {\n\t\tif (count >= max_count) {\n\t\t\tif (node->is_contiguous)\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_SMALLER_SIZE,\n\t\t\t\t\t    \"more clusters are allocated. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t    \"cluster is already allocated for the other file. truncated to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!exfat_bitmap_get(exfat->disk_bitmap, clus)) {\n\t\t\tif (!repair_file_ask(de_iter, node,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"cluster %#x is marked as free\",\n\t\t\t\t\t     clus))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next))\n\t\t\tgoto truncate_file;\n\t\tif (next == EXFAT_BAD_CLUSTER) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t    \"BAD cluster. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!node->is_contiguous) {\n\t\t\tif (next != EXFAT_EOF_CLUSTER &&\n\t\t\t    !exfat_heap_clus(exfat, next)) {\n\t\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t\t    \"broken cluster chain. truncate to %\"\n\t\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t\t    (count + 1) * exfat->clus_size)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev = clus;\n\t\t\t\t\texfat_bitmap_set(exfat->alloc_bitmap,\n\t\t\t\t\t\t\t clus);\n\t\t\t\t\tgoto truncate_file;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\t\tprev = clus;\n\t\tclus = next;\n\t}\n\tif (count < max_count) {\n\t\tif (repair_file_ask(de_iter, node, ER_FILE_LARGER_SIZE,\n\t\t\t\t    \"less clusters are allocated. truncates to %\"\n\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t    count * exfat->clus_size))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\nallocate_cluster:\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\terr = exfat_find_free_cluster(exfat, exfat->start_clu, &new_clus);\n\tif (err) {\n\t\texfat->start_clu = EXFAT_FIRST_CLUSTER;\n\t\texfat_err(\"failed to find a free cluster\\n\");\n\t\treturn -ENOSPC;\n\t}\n\texfat->start_clu = new_clus;\n\tif (exfat_set_fat(exfat, new_clus, EXFAT_EOF_CLUSTER))\n\t\treturn -EIO;\n\tif (exfat_write(exfat->blk_dev->dev_fd, exfat->zero_cluster,\n\t\t\texfat->clus_size, exfat_c2o(exfat, new_clus)) !=\n\t\t\t(ssize_t)exfat->clus_size) {\n\t\texfat_err(\"failed to fill new cluster with zeroes\\n\");\n\t\treturn -EIO;\n\t}\n\tcount = 1;\n\tstream_de->stream_start_clu = cpu_to_le32(new_clus);\n\tstream_de->stream_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->stream_valid_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\tnode->first_clus = new_clus;\n\tnode->size = count * exfat->clus_size;\n\tnode->is_contiguous = true;\n\texfat_bitmap_set(exfat->alloc_bitmap, new_clus);\n\treturn 1;\ntruncate_file:\n\tnode->size = count * exfat->clus_size;\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tnode->first_clus = EXFAT_FREE_CLUSTER;\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\tif (count * exfat->clus_size <\n\t    le64_to_cpu(stream_de->stream_valid_size))\n\t\tstream_de->stream_valid_size = cpu_to_le64(\n\t\t\t\t\t\t\t   count * exfat->clus_size);\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tstream_de->stream_start_clu = EXFAT_FREE_CLUSTER;\n\tstream_de->stream_size = cpu_to_le64(\n\t\t\t\t\t     count * exfat->clus_size);\n\tif (!node->is_contiguous && exfat_heap_clus(exfat, prev)) {\n\t\tif (exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER))\n\t\t\treturn -EIO;\n\t}\n\treturn 1;\n}\nstatic int root_check_clus_chain(struct exfat *exfat,\n\t\t\t\t struct exfat_inode *node,\n\t\t\t\t clus_t *clus_count)\n{\n\tclus_t clus, next, prev = EXFAT_EOF_CLUSTER;\n\tif (!exfat_heap_clus(exfat, node->first_clus))\n\t\tgoto out_trunc;\n\tclus = node->first_clus;\n\t*clus_count = 0;\n\tdo {\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is cyclic\"))\n\t\t\t\tgoto out_trunc;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next)) {\n\t\t\texfat_err(\"ERROR: failed to read the fat entry of root\");\n\t\t\tgoto out_trunc;\n\t\t}\n\t\tif (next != EXFAT_EOF_CLUSTER && !exfat_heap_clus(exfat, next)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is broken\")) {\n\t\t\t\tif (next != EXFAT_BAD_CLUSTER) {\n\t\t\t\t\tprev = clus;\n\t\t\t\t\t(*clus_count)++;\n\t\t\t\t}\n\t\t\t\tgoto out_trunc;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprev = clus;\n\t\tclus = next;\n\t\t(*clus_count)++;\n\t} while (clus != EXFAT_EOF_CLUSTER);\n\treturn 0;\nout_trunc:\n\tif (!exfat_heap_clus(exfat, prev)) {\n\t\texfat_err(\"ERROR: the start cluster of root is wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnode->size = *clus_count * exfat->clus_size;\n\treturn exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER);\n}\nstatic int boot_region_checksum(int dev_fd,\n\t\t\t\tint bs_offset, unsigned int sect_size)\n{\n\tvoid *sect;\n\tunsigned int i;\n\tuint32_t checksum;\n\tint ret = 0;\n\tsect = malloc(sect_size);\n\tif (!sect)\n\t\treturn -ENOMEM;\n\tchecksum = 0;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\t\tbs_offset * sect_size + i * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\texfat_err(\"failed to read boot region\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tboot_calc_checksum(sect, sect_size, i == 0, &checksum);\n\t}\n\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\tbs_offset * sect_size + 11 * sect_size) !=\n\t\t\t(ssize_t)sect_size) {\n\t\texfat_err(\"failed to read a boot checksum sector\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < sect_size/sizeof(checksum); i++) {\n\t\tif (le32_to_cpu(((__le32 *)sect)[i]) != checksum) {\n\t\t\texfat_err(\"checksum of boot region is not correct. %#x, but expected %#x\\n\",\n\t\t\t\tle32_to_cpu(((__le32 *)sect)[i]), checksum);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(sect);\n\treturn ret;\n}\nstatic int read_boot_region(struct exfat_blk_dev *bd, struct pbr **pbr,\n\t\t\t    int bs_offset, unsigned int sect_size,\n\t\t\t    bool verbose)\n{\n\tstruct pbr *bs;\n\tint ret = -EINVAL;\n\t*pbr = NULL;\n\tbs = (struct pbr *)malloc(sizeof(struct pbr));\n\tif (!bs) {\n\t\texfat_err(\"failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (exfat_read(bd->dev_fd, bs, sizeof(*bs),\n\t\t\tbs_offset * sect_size) != (ssize_t)sizeof(*bs)) {\n\t\texfat_err(\"failed to read a boot sector\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tif (memcmp(bs->bpb.oem_name, \"EXFAT   \", 8) != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"failed to find exfat file system\\n\");\n\t\tgoto err;\n\t}\n\tret = boot_region_checksum(bd->dev_fd, bs_offset, sect_size);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = -EINVAL;\n\tif (EXFAT_SECTOR_SIZE(bs) < 512 || EXFAT_SECTOR_SIZE(bs) > 4 * KB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too small or big sector size: %d\\n\",\n\t\t\t\t  EXFAT_SECTOR_SIZE(bs));\n\t\tgoto err;\n\t}\n\tif (EXFAT_CLUSTER_SIZE(bs) > 32 * MB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too big cluster size: %d\\n\",\n\t\t\t\t  EXFAT_CLUSTER_SIZE(bs));\n\t\tgoto err;\n\t}\n\tif (bs->bsx.fs_version[1] != 1 || bs->bsx.fs_version[0] != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported exfat version: %d.%d\\n\",\n\t\t\t\t  bs->bsx.fs_version[1], bs->bsx.fs_version[0]);\n\t\tgoto err;\n\t}\n\tif (bs->bsx.num_fats != 1) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported FAT count: %d\\n\",\n\t\t\t\t  bs->bsx.num_fats);\n\t\tgoto err;\n\t}\n\tif (le64_to_cpu(bs->bsx.vol_length) * EXFAT_SECTOR_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large sector count: %\" PRIu64 \", expected: %llu\\n\",\n\t\t\t\t  le64_to_cpu(bs->bsx.vol_length),\n\t\t\t\t  bd->num_sectors);\n\t\tgoto err;\n\t}\n\tif (le32_to_cpu(bs->bsx.clu_count) * EXFAT_CLUSTER_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large cluster count: %u, expected: %u\\n\",\n\t\t\t\t  le32_to_cpu(bs->bsx.clu_count),\n\t\t\t\t  bd->num_clusters);\n\t\tgoto err;\n\t}\n\t*pbr = bs;\n\treturn 0;\nerr:\n\tfree(bs);\n\treturn ret;\n}\nstatic int exfat_boot_region_check(struct exfat_blk_dev *blkdev,\n\t\t\t\t   struct pbr **bs,\n\t\t\t\t   bool ignore_bad_fs_name)\n{\n\tstruct pbr *boot_sect;\n\tunsigned int sect_size;\n\tint ret;\n\tboot_sect = malloc(sizeof(*boot_sect));\n\tif (boot_sect == NULL)\n\t\treturn -ENOMEM;\n\tif (exfat_read(blkdev->dev_fd, boot_sect,\n\t\t       sizeof(*boot_sect), 0) != (ssize_t)sizeof(*boot_sect)) {\n\t\texfat_err(\"failed to read Main boot sector\\n\");\n\t\tfree(boot_sect);\n\t\treturn -EIO;\n\t}\n\tif (memcmp(boot_sect->bpb.oem_name, \"EXFAT   \", 8) != 0 &&\n\t    !ignore_bad_fs_name) {\n\t\texfat_err(\"Bad fs_name in boot sector, which does not describe a valid exfat filesystem\\n\");\n\t\tfree(boot_sect);\n\t\treturn -ENOTSUP;\n\t}\n\tsect_size = 1 << boot_sect->bsx.sect_size_bits;\n\tfree(boot_sect);\n\tret = read_boot_region(blkdev, bs,\n\t\t\t       BOOT_SEC_IDX, sect_size, true);\n\tif (ret == -EINVAL &&\n\t    exfat_repair_ask(&exfat_fsck, ER_BS_BOOT_REGION,\n\t\t\t     \"boot region is corrupted. try to restore the region from backup\"\n\t\t\t\t)) {\n\t\tconst unsigned int sector_sizes[] = {512, 4096, 1024, 2048};\n\t\tunsigned int i;\n\t\tif (sect_size >= 512 && sect_size <= EXFAT_MAX_SECTOR_SIZE) {\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX, sect_size,\n\t\t\t\t\t       false);\n\t\t\tif (!ret)\n\t\t\t\tgoto restore;\n\t\t}\n\t\tfor (i = 0; i < sizeof(sector_sizes)/sizeof(sector_sizes[0]); i++) {\n\t\t\tif (sector_sizes[i] == sect_size)\n\t\t\t\tcontinue;\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX,\n\t\t\t\t\t       sector_sizes[i], false);\n\t\t\tif (!ret) {\n\t\t\t\tsect_size = sector_sizes[i];\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\texfat_err(\"backup boot region is also corrupted\\n\");\n\t}\n\treturn ret;\nrestore:\n\tret = restore_boot_region(blkdev, sect_size);\n\tif (ret) {\n\t\texfat_err(\"failed to restore boot region from backup\\n\");\n\t\tfree(*bs);\n\t\t*bs = NULL;\n\t}\n\treturn ret;\n}\nstatic int check_inode(struct exfat_de_iter *iter, struct exfat_inode *node)\n{\n\tstruct exfat *exfat = iter->exfat;\n\tstruct exfat_dentry *dentry;\n\tint ret = 0;\n\tuint16_t checksum;\n\tbool valid = true;\n\tret = check_clus_chain(iter, node);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (node->size > le32_to_cpu(exfat->bs->bsx.clu_count) *\n\t\t\t\t(uint64_t)exfat->clus_size) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"size %\" PRIu64 \" is greater than cluster heap\\n\",\n\t\t\tnode->size);\n\t\tvalid = false;\n\t}\n\tif (node->size == 0 && node->is_contiguous) {\n\t\tif (repair_file_ask(iter, node, ER_FILE_ZERO_NOFAT,\n\t\t\t\t\"empty, but has no Fat chain\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &dentry);\n\t\t\tdentry->stream_flags &= ~EXFAT_SF_CONTIGUOUS;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tvalid = false;\n\t}\n\tif ((node->attr & ATTR_SUBDIR) &&\n\t\t\tnode->size % exfat->clus_size != 0) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"directory size %\" PRIu64 \" is not divisible by %d\\n\",\n\t\t\tnode->size, exfat->clus_size);\n\t\tvalid = false;\n\t}\n\tchecksum = file_calc_checksum(iter);\n\texfat_de_iter_get(iter, 0, &dentry);\n\tif (checksum != le16_to_cpu(dentry->file_checksum)) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->file_checksum = cpu_to_le16(checksum);\n\t\tret = 1;\n\t}\n\treturn valid ? ret : -EINVAL;\n}\nstatic int check_bad_char(char w)\n{\n\treturn (w < 0x0020) || (w == '*') || (w == '?') || (w == '<') ||\n\t\t(w == '>') || (w == '|') || (w == '\"') || (w == ':') ||\n\t\t(w == '/') || (w == '\\\\');\n}\nstatic char *get_rename_from_user(struct exfat_de_iter *iter)\n{\n\tchar *rename = malloc(ENTRY_NAME_MAX + 2);\n\tif (!rename)\n\t\treturn NULL;\nretry:\n\tmemset(rename, 0x1, ENTRY_NAME_MAX + 2);\n\tprintf(\"New name: \");\n\tif (fgets(rename, ENTRY_NAME_MAX + 2, stdin)) {\n\t\tint i, len, err;\n\t\tstruct exfat_lookup_filter filter;\n\t\tlen = strlen(rename);\n\t\trename[len - 1] = '\\0';\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (check_bad_char(rename[i])) {\n\t\t\t\tprintf(\"filename contain invalid character(%c)\\n\", rename[i]);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\texfat_de_iter_flush(iter);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename, &filter);\n\t\tif (!err) {\n\t\t\tprintf(\"file(%s) already exists, retry to insert name\\n\", rename);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn rename;\n}\nstatic char *generate_rename(struct exfat_de_iter *iter)\n{\n\tchar *rename;\n\tif (iter->dot_name_num > DOT_NAME_NUM_MAX)\n\t\treturn NULL;\n\trename = malloc(ENTRY_NAME_MAX + 1);\n\tif (!rename)\n\t\treturn NULL;\n\twhile (1) {\n\t\tstruct exfat_lookup_filter filter;\n\t\tint err;\n\t\tsnprintf(rename, ENTRY_NAME_MAX + 1, \"FILE%07d.CHK\",\n\t\t\t iter->dot_name_num++);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename,\n\t\t\t\t\t&filter);\n\t\tif (!err)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\treturn rename;\n}\nconst __le16 MSDOS_DOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), 0, };\nconst __le16 MSDOS_DOTDOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), cpu_to_le16(46), 0, };\nstatic int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\t\t\t\t      struct exfat_dentry *dentry,\n\t\t\t\t      int strm_name_len)\n{\n\tchar *filename;\n\tchar error_msg[150];\n\tint num;\n\tif (!memcmp(dentry->name_unicode, MSDOS_DOT, strm_name_len * 2))\n\t\tfilename = \".\";\n\telse if (!memcmp(dentry->name_unicode, MSDOS_DOTDOT,\n\t\t\t strm_name_len * 2))\n\t\tfilename = \"..\";\n\telse\n\t\treturn 0;\n\tsprintf(error_msg, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", filename);\nask_again:\n\tnum = exfat_repair_ask(&exfat_fsck, ER_DE_DOT_NAME,\n\t\t\t       error_msg);\n\tif (num) {\n\t\t__le16 utf16_name[ENTRY_NAME_MAX];\n\t\tchar *rename = NULL;\n\t\t__u16 hash;\n\t\tstruct exfat_dentry *stream_de;\n\t\tint ret;\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\trename = get_rename_from_user(iter);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trename = generate_rename(iter);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", num);\n\t\t\tgoto ask_again;\n\t\t}\n\t\tif (!rename)\n\t\t\treturn -EINVAL;\n\t\texfat_info(\"%s filename is renamed to %s\\n\", filename, rename);\n\t\texfat_de_iter_get_dirty(iter, 2, &dentry);\n\t\tmemset(utf16_name, 0, sizeof(utf16_name));\n\t\tret = exfat_utf16_enc(rename, utf16_name, sizeof(utf16_name));\n\t\tfree(rename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret >>= 1;\n\t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);\n\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\tstream_de->stream_name_len = (__u8)ret;\n\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t}\n\treturn 0;\n}\nstatic int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tbool need_delete = false;\n\tuint16_t checksum;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\tif (file_de->file_num_ext < 2) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    file_de->file_num_ext))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_STREAM,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t\t\tfile_de->file_num_ext = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*skip_dentries = i + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t\t\t\tstream_de->stream_name_len);\n\t\tif (ret < 0) {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\tif (node->size < le64_to_cpu(stream_de->stream_valid_size)) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tif (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,\n\t\t\t\t    \"valid size %\" PRIu64 \" greater than size %\" PRIu64,\n\t\t\t\t    le64_to_cpu(stream_de->stream_valid_size),\n\t\t\t\t    node->size)) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_valid_size =\n\t\t\t\t\tstream_de->stream_size;\n\t\t} else {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\t*skip_dentries = (file_de->file_num_ext + 1);\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\tif (need_delete) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->type &= EXFAT_DELETE;\n\t}\n\tfor (i = 1; i < *skip_dentries; i++) {\n\t\texfat_de_iter_get(iter, i, &dentry);\n\t\tif (dentry->type == EXFAT_FILE)\n\t\t\tbreak;\n\t\tif (need_delete) {\n\t\t\texfat_de_iter_get_dirty(iter, i, &dentry);\n\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t}\n\t}\n\t*skip_dentries = i;\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn need_delete ? 1 : -EINVAL;\n}\nstatic int read_bitmap(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_BITMAP,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry;\n\tint retval;\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\tdentry = filter.out.dentry_set;\n\texfat_debug(\"start cluster %#x, size %#\" PRIx64 \"\\n\",\n\t\t\tle32_to_cpu(dentry->bitmap_start_clu),\n\t\t\tle64_to_cpu(dentry->bitmap_size));\n\tif (le64_to_cpu(dentry->bitmap_size) <\n\t\t\tDIV_ROUND_UP(exfat->clus_count, 8)) {\n\t\texfat_err(\"invalid size of allocation bitmap. 0x%\" PRIx64 \"\\n\",\n\t\t\t\tle64_to_cpu(dentry->bitmap_size));\n\t\treturn -EINVAL;\n\t}\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->bitmap_start_clu))) {\n\t\texfat_err(\"invalid start cluster of allocate bitmap. 0x%x\\n\",\n\t\t\t\tle32_to_cpu(dentry->bitmap_start_clu));\n\t\treturn -EINVAL;\n\t}\n\texfat->disk_bitmap_clus = le32_to_cpu(dentry->bitmap_start_clu);\n\texfat->disk_bitmap_size = DIV_ROUND_UP(exfat->clus_count, 8);\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le64_to_cpu(dentry->bitmap_start_clu),\n\t\t\t       DIV_ROUND_UP(exfat->disk_bitmap_size,\n\t\t\t\t\t    exfat->clus_size));\n\tfree(filter.out.dentry_set);\n\tif (exfat_read(exfat->blk_dev->dev_fd, exfat->disk_bitmap,\n\t\t\texfat->disk_bitmap_size,\n\t\t\texfat_c2o(exfat, exfat->disk_bitmap_clus)) !=\n\t\t\t(ssize_t)exfat->disk_bitmap_size)\n\t\treturn -EIO;\n\treturn 0;\n}\nstatic int read_upcase_table(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_UPCASE,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry = NULL;\n\t__le16 *upcase = NULL;\n\tint retval;\n\tssize_t size;\n\t__le32 checksum;\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\tdentry = filter.out.dentry_set;\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->upcase_start_clu))) {\n\t\texfat_err(\"invalid start cluster of upcase table. 0x%x\\n\",\n\t\t\tle32_to_cpu(dentry->upcase_start_clu));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = (ssize_t)le64_to_cpu(dentry->upcase_size);\n\tif (size > (ssize_t)(EXFAT_MAX_UPCASE_CHARS * sizeof(__le16)) ||\n\t\t\tsize == 0 || size % sizeof(__le16)) {\n\t\texfat_err(\"invalid size of upcase table. 0x%\" PRIx64 \"\\n\",\n\t\t\tle64_to_cpu(dentry->upcase_size));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tupcase = (__le16 *)malloc(size);\n\tif (!upcase) {\n\t\texfat_err(\"failed to allocate upcase table\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (exfat_read(exfat->blk_dev->dev_fd, upcase, size,\n\t\t\texfat_c2o(exfat,\n\t\t\tle32_to_cpu(dentry->upcase_start_clu))) != size) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tchecksum = 0;\n\tboot_calc_checksum((unsigned char *)upcase, size, false, &checksum);\n\tif (le32_to_cpu(dentry->upcase_checksum) != checksum) {\n\t\texfat_err(\"corrupted upcase table %#x (expected: %#x)\\n\",\n\t\t\tchecksum, le32_to_cpu(dentry->upcase_checksum));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le32_to_cpu(dentry->upcase_start_clu),\n\t\t\t       DIV_ROUND_UP(le64_to_cpu(dentry->upcase_size),\n\t\t\t\t\t    exfat->clus_size));\n\texfat->upcase_table = calloc(1,\n\t\t\t\t     sizeof(uint16_t) * EXFAT_UPCASE_TABLE_CHARS);\n\tif (!exfat->upcase_table) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\tdecompress_upcase_table(upcase, size / 2,\n\t\t\t\texfat->upcase_table, EXFAT_UPCASE_TABLE_CHARS);\nout:\n\tif (dentry)\n\t\tfree(dentry);\n\tif (upcase)\n\t\tfree(upcase);\n\treturn retval;\n}\nstatic int read_children(struct exfat_fsck *fsck, struct exfat_inode *dir)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *node = NULL;\n\tstruct exfat_dentry *dentry;\n\tstruct exfat_de_iter *de_iter;\n\tint dentry_count;\n\tint ret;\n\tde_iter = &fsck->de_iter;\n\tret = exfat_de_iter_init(de_iter, exfat, dir, fsck->buffer_desc);\n\tif (ret == EOF)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\twhile (1) {\n\t\tret = exfat_de_iter_get(de_iter, 0, &dentry);\n\t\tif (ret == EOF) {\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tfsck_err(dir->parent, dir,\n\t\t\t\t\"failed to get a dentry. %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t\tdentry_count = 1;\n\t\tswitch (dentry->type) {\n\t\tcase EXFAT_FILE:\n\t\t\tret = read_file(de_iter, &node, &dentry_count);\n\t\t\tif (ret < 0) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\tbreak;\n\t\t\t} else if (ret) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\texfat_stat.fixed_count++;\n\t\t\t}\n\t\t\tif (node) {\n\t\t\t\tif ((node->attr & ATTR_SUBDIR) && node->size) {\n\t\t\t\t\tnode->parent = dir;\n\t\t\t\t\tlist_add_tail(&node->sibling,\n\t\t\t\t\t\t      &dir->children);\n\t\t\t\t\tlist_add_tail(&node->list,\n\t\t\t\t\t\t      &exfat->dir_list);\n\t\t\t\t} else {\n\t\t\t\t\texfat_free_inode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXFAT_LAST:\n\t\t\tgoto out;\n\t\tcase EXFAT_VOLUME:\n\t\tcase EXFAT_BITMAP:\n\t\tcase EXFAT_UPCASE:\n\t\t\tif (dir == exfat->root)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (IS_EXFAT_DELETED(dentry->type))\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, NULL, ER_DE_UNKNOWN,\n\t\t\t\t\t    \"unknown entry type %#x at %07\" PRIx64,\n\t\t\t\t\t    dentry->type,\n\t\t\t\t\t    exfat_de_iter_file_offset(de_iter))) {\n\t\t\t\tstruct exfat_dentry *dentry;\n\t\t\t\texfat_de_iter_get_dirty(de_iter, 0, &dentry);\n\t\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\texfat_de_iter_advance(de_iter, dentry_count);\n\t}\nout:\n\texfat_de_iter_flush(de_iter);\n\treturn 0;\nerr:\n\texfat_free_children(dir, false);\n\tINIT_LIST_HEAD(&dir->children);\n\texfat_de_iter_flush(de_iter);\n\treturn ret;\n}\nstatic int write_bitmap(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\toff_t dev_offset;\n\tunsigned int i, bitmap_bytes, byte_offset, write_bytes;\n\tdev_offset = exfat_c2o(exfat, exfat->disk_bitmap_clus);\n\tbitmap_bytes = EXFAT_BITMAP_SIZE(le32_to_cpu(exfat->bs->bsx.clu_count));\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\tfor (i = 0; i < bitmap_bytes / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = alloc_b[i] | disk_b[i];\n\ti = 0;\n\twhile (i < bitmap_bytes / sizeof(bitmap_t)) {\n\t\tif (ohead_b[i] == disk_b[i]) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tbyte_offset = ((i * sizeof(bitmap_t)) / 512) * 512;\n\t\twrite_bytes = MIN(512, bitmap_bytes - byte_offset);\n\t\tif (exfat_write(exfat->blk_dev->dev_fd,\n\t\t\t\t(char *)ohead_b + byte_offset, write_bytes,\n\t\t\t\tdev_offset + byte_offset) != (ssize_t)write_bytes)\n\t\t\treturn -EIO;\n\t\ti = (byte_offset + write_bytes) / sizeof(bitmap_t);\n\t}\n\treturn 0;\n}\nstatic int exfat_root_dir_check(struct exfat *exfat)\n{\n\tstruct exfat_inode *root;\n\tclus_t clus_count = 0;\n\tint err;\n\troot = exfat_alloc_inode(ATTR_SUBDIR);\n\tif (!root)\n\t\treturn -ENOMEM;\n\texfat->root = root;\n\troot->first_clus = le32_to_cpu(exfat->bs->bsx.root_cluster);\n\tif (root_check_clus_chain(exfat, root, &clus_count)) {\n\t\texfat_err(\"failed to follow the cluster chain of root\\n\");\n\t\texfat_free_inode(root);\n\t\texfat->root = NULL;\n\t\treturn -EINVAL;\n\t}\n\troot->size = clus_count * exfat->clus_size;\n\texfat_stat.dir_count++;\n\texfat_debug(\"root directory: start cluster[0x%x] size[0x%\" PRIx64 \"]\\n\",\n\t\troot->first_clus, root->size);\n\terr = exfat_read_volume_label(exfat);\n\tif (err && err != EOF)\n\t\texfat_err(\"failed to read volume label\\n\");\n\terr = 0;\n\terr = read_bitmap(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read bitmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = read_upcase_table(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\treturn -EINVAL;\n\t}\n\troot->dev_offset = 0;\n\terr = exfat_build_file_dentry_set(exfat, \" \", ATTR_SUBDIR,\n\t\t\t\t\t  &root->dentry_set, &root->dentry_count);\n\tif (err) {\n\t\texfat_free_inode(root);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nstatic int rescue_orphan_clusters(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *lostfound;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\tstruct exfat_dentry *dset;\n\tclus_t clu_count, clu, s_clu, e_clu;\n\tint err, dcount;\n\tunsigned int i;\n\tchar name[] = \"FILE0000000.CHK\";\n\tstruct exfat_dentry_loc loc;\n\tstruct exfat_lookup_filter lf = {\n\t\t.in.type = EXFAT_INVAL,\n\t\t.in.filter = NULL,\n\t};\n\terr = read_lostfound(exfat, &lostfound);\n\tif (err) {\n\t\texfat_err(\"failed to find LOST+FOUND\\n\");\n\t\treturn err;\n\t}\n\terr = exfat_lookup_dentry_set(exfat, lostfound, &lf);\n\tif (err && err != EOF) {\n\t\texfat_err(\"failed to find the last empty slot in LOST+FOUND\\n\");\n\t\tgoto out;\n\t}\n\tloc.parent = lostfound;\n\tloc.file_offset = lf.out.file_offset;\n\tloc.dev_offset = lf.out.dev_offset;\n\terr = exfat_build_file_dentry_set(exfat, name, 0, &dset, &dcount);\n\tif (err) {\n\t\texfat_err(\"failed to create a temporary file in LOST+FOUNDn\");\n\t\tgoto out;\n\t}\n\tdset[1].dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\tclu_count = le32_to_cpu(exfat->bs->bsx.clu_count);\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\tfor (i = 0; i < EXFAT_BITMAP_SIZE(clu_count) / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = disk_b[i] & ~alloc_b[i];\n\tfor (clu = EXFAT_FIRST_CLUSTER; clu < clu_count + EXFAT_FIRST_CLUSTER &&\n\t     exfat_bitmap_find_one(exfat, exfat->ohead_bitmap, clu, &s_clu) == 0;) {\n\t\tif (exfat_bitmap_find_zero(exfat, exfat->ohead_bitmap, s_clu, &e_clu))\n\t\t\te_clu = clu_count + EXFAT_FIRST_CLUSTER;\n\t\tclu = e_clu;\n\t\tsnprintf(name, sizeof(name), \"FILE%07d.CHK\",\n\t\t\t (unsigned int)(loc.file_offset >> 5));\n\t\terr = exfat_update_file_dentry_set(exfat, dset, dcount,\n\t\t\t\t\t\t   name, s_clu, e_clu - s_clu);\n\t\tif (err)\n\t\t\tcontinue;\n\t\terr = exfat_add_dentry_set(exfat, &loc, dset, dcount, true);\n\t\tif (err)\n\t\t\tcontinue;\n\t}\n\tfree(dset);\n\terr = 0;\nout:\n\texfat_free_inode(lostfound);\n\treturn err;\n}\nint main(int argc, char * const argv[])\n{\n\tstruct fsck_user_input ui;\n\tstruct exfat_blk_dev bd;\n\tstruct pbr *bs = NULL;\n\tint c, ret, exit_code;\n\tbool version_only = false;\n\tmemset(&ui, 0, sizeof(ui));\n\tmemset(&bd, 0, sizeof(bd));\n\tprint_level = EXFAT_ERROR;\n\tif (!setlocale(LC_CTYPE, \"\"))\n\t\texfat_err(\"failed to init locale/codeset\\n\");\n\topterr = 0;\n\twhile ((c = getopt_long(argc, argv, \"arynpbsVvh\", opts, NULL)) != EOF) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_ASK;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_YES;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'p':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_AUTO;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tui.options |= FSCK_OPTS_IGNORE_BAD_FS_NAME;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tui.options |= FSCK_OPTS_RESCUE_CLUS;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tversion_only = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (print_level < EXFAT_DEBUG)\n\t\t\t\tprint_level++;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\tshow_version();\n\tif (optind != argc - 1)\n\t\tusage(argv[0]);\n\tif (version_only)\n\t\texit(FSCK_EXIT_SYNTAX_ERROR);\n\tif (ui.options & FSCK_OPTS_REPAIR_WRITE)\n\t\tui.ei.writeable = true;\n\telse {\n\t\tif (ui.options & (FSCK_OPTS_IGNORE_BAD_FS_NAME |\n\t\t\t\t  FSCK_OPTS_RESCUE_CLUS))\n\t\t\tusage(argv[0]);\n\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\tui.ei.writeable = false;\n\t}\n\texfat_fsck.options = ui.options;\n\tsnprintf(ui.ei.dev_name, sizeof(ui.ei.dev_name), \"%s\", argv[optind]);\n\tret = exfat_get_blk_dev_info(&ui.ei, &bd);\n\tif (ret < 0) {\n\t\texfat_err(\"failed to open %s. %d\\n\", ui.ei.dev_name, ret);\n\t\treturn FSCK_EXIT_OPERATION_ERROR;\n\t}\n\tret = exfat_boot_region_check(&bd, &bs,\n\t\t\t\t      ui.options & FSCK_OPTS_IGNORE_BAD_FS_NAME ?\n\t\t\t\t      true : false);\n\tif (ret)\n\t\tgoto err;\n\texfat_fsck.exfat = exfat_alloc_exfat(&bd, bs);\n\tif (!exfat_fsck.exfat) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\texfat_fsck.buffer_desc = exfat_alloc_buffer(2,\n\t\t\t\t\t\t    exfat_fsck.exfat->clus_size,\n\t\t\t\t\t\t    exfat_fsck.exfat->sect_size);\n\tif (!exfat_fsck.buffer_desc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif ((exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) &&\n\t    exfat_mark_volume_dirty(exfat_fsck.exfat, true)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\texfat_debug(\"verifying root directory...\\n\");\n\tret = exfat_root_dir_check(exfat_fsck.exfat);\n\tif (ret) {\n\t\texfat_err(\"failed to verify root directory.\\n\");\n\t\tgoto out;\n\t}\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\tret = exfat_create_file(exfat_fsck.exfat,\n\t\t\t\t\texfat_fsck.exfat->root,\n\t\t\t\t\t\"LOST+FOUND\",\n\t\t\t\t\tATTR_SUBDIR);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to create lost+found directory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (fsync(exfat_fsck.exfat->blk_dev->dev_fd) != 0) {\n\t\t\tret = -EIO;\n\t\t\texfat_err(\"failed to sync()\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\texfat_debug(\"verifying directory entries...\\n\");\n\tret = exfat_filesystem_check(&exfat_fsck);\n\tif (ret)\n\t\tgoto out;\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\trescue_orphan_clusters(&exfat_fsck);\n\t\texfat_fsck.dirty = true;\n\t\texfat_fsck.dirty_fat = true;\n\t}\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) {\n\t\tret = write_bitmap(&exfat_fsck);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to write bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (ui.ei.writeable && fsync(bd.dev_fd)) {\n\t\texfat_err(\"failed to sync\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE)\n\t\texfat_mark_volume_dirty(exfat_fsck.exfat, false);\nout:\n\texfat_show_info(&exfat_fsck, ui.ei.dev_name);\nerr:\n\tif (ret && ret != -EINVAL)\n\t\texit_code = FSCK_EXIT_OPERATION_ERROR;\n\telse if (ret == -EINVAL ||\n\t\t exfat_stat.error_count != exfat_stat.fixed_count)\n\t\texit_code = FSCK_EXIT_ERRORS_LEFT;\n\telse if (exfat_fsck.dirty)\n\t\texit_code = FSCK_EXIT_CORRECTED;\n\telse\n\t\texit_code = FSCK_EXIT_NO_ERRORS;\n\tif (exfat_fsck.buffer_desc)\n\t\texfat_free_buffer(exfat_fsck.buffer_desc, 2);\n\tif (exfat_fsck.exfat)\n\t\texfat_free_exfat(exfat_fsck.exfat);\n\tclose(bd.dev_fd);\n\treturn exit_code;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_12458.c",
        "project": "exfatprogs/exfatprogs",
        "url": "https://github.com/exfatprogs/exfatprogs/commit/22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int get_siz(Jpeg2000DecoderContext *s)\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\nstatic int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n    for (;;) {\n        if (bytestream2_get_bytes_left(&s->g) < 2) {\n        }\n        marker = bytestream2_get_be16u(&s->g);\n        oldpos = bytestream2_tell(&s->g);\n        if (marker == JPEG2000_SOD) {\n            if (!s->tile) {\n            }\n            if (s->curtileno < 0) {\n            }\n            tile = s->tile + s->curtileno;\n            tp = tile->tile_part + tile->tp_idx;\n            if (tp->tp_end < s->g.buffer) {\n            }\n            bytestream2_init(&tp->tpg, s->g.buffer, tp->tp_end - s->g.buffer);\n            bytestream2_skip(&s->g, tp->tp_end - s->g.buffer);\n        }\n        if (marker == JPEG2000_EOC)\n            break;\n        len = bytestream2_get_be16(&s->g);\n        if (len < 2 || bytestream2_get_bytes_left(&s->g) < len - 2)\n            return AVERROR_INVALIDDATA;\n            ret = get_siz(s);\n            if (!s->tile)\n                s->numXtiles = s->numYtiles = 0;\n            ret = get_coc(s, codsty, properties);\n            ret = get_cod(s, codsty, properties);\n            ret = get_qcc(s, len, qntsty, properties);\n            ret = get_qcd(s, len, qntsty, properties);\n            if (!(ret = get_sot(s, len))) {\n                av_assert1(s->curtileno >= 0);\n                codsty = s->tile[s->curtileno].codsty;\n                qntsty = s->tile[s->curtileno].qntsty;\n                properties = s->tile[s->curtileno].properties;\n            }\n            bytestream2_skip(&s->g, len - 2);\n            ret = get_tlm(s, len);\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%X\\n\",\n                   marker, bytestream2_tell(&s->g) - 4);\n            bytestream2_skip(&s->g, len - 2);\n        if (bytestream2_tell(&s->g) - oldpos != len || ret) {\n        }\n    }\nstatic int jp2_find_codestream(Jpeg2000DecoderContext *s)\n           bytestream2_get_bytes_left(&s->g) >= 8) {\n        atom_size = bytestream2_get_be32u(&s->g);\n        atom      = bytestream2_get_be32u(&s->g);\n        atom_end  = bytestream2_tell(&s->g) + atom_size - 8;\n        if (atom == JP2_CODESTREAM)\n            return 1;\n        if (bytestream2_get_bytes_left(&s->g) < atom_size || atom_end < atom_size)\n            return 0;\n            do {\n                atom2_size = bytestream2_get_be32u(&s->g);\n                atom2      = bytestream2_get_be32u(&s->g);\n                atom2_end  = bytestream2_tell(&s->g) + atom2_size - 8;\n                if (atom2_size < 8 || atom2_end > atom_end || atom2_end < atom2_size)\n                    break;\n                if (atom2 == JP2_CODESTREAM) {\n                } else if (atom2 == MKBETAG('c','o','l','r') && atom2_size >= 7) {\n                    int method = bytestream2_get_byteu(&s->g);\n                    bytestream2_skipu(&s->g, 2);\n                    if (method == 1) {\n                        s->colour_space = bytestream2_get_be32u(&s->g);\n                    }\n                } else if (atom2 == MKBETAG('p','c','l','r') && atom2_size >= 6) {\n                    colour_count = bytestream2_get_be16u(&s->g);\n                    colour_channels = bytestream2_get_byteu(&s->g);\n                    colour_depth[0] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[1] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[2] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                        avpriv_request_sample(s->avctx, \"Unknown palette\");\n                        bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n                    s->pal8 = 1;\n                    for (i = 0; i < colour_count; i++) {\n                        if (colour_depth[0] <= 8) {\n                            r = bytestream2_get_byteu(&s->g) << 8 - colour_depth[0];\n                        } else {\n                            r = bytestream2_get_be16u(&s->g) >> colour_depth[0] - 8;\n                        }\n                        if (colour_depth[1] <= 8) {\n                            g = bytestream2_get_byteu(&s->g) << 8 - colour_depth[1];\n                        } else {\n                            g = bytestream2_get_be16u(&s->g) >> colour_depth[1] - 8;\n                        }\n                        if (colour_depth[2] <= 8) {\n                            b = bytestream2_get_byteu(&s->g) << 8 - colour_depth[2];\n                        } else {\n                            b = bytestream2_get_be16u(&s->g) >> colour_depth[2] - 8;\n                        }\n                    }\n                } else if (atom2 == MKBETAG('c','d','e','f') && atom2_size >= 2) {\n                    int n = bytestream2_get_be16u(&s->g);\n                    for (; n>0; n--) {\n                        int cn   = bytestream2_get_be16(&s->g);\n                        int av_unused typ  = bytestream2_get_be16(&s->g);\n                        int asoc = bytestream2_get_be16(&s->g);\n                    }\n                }\n                bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n            } while (atom_end - atom2_end >= 8);\n        bytestream2_seek(&s->g, atom_end, SEEK_SET);\nstatic int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n                                 int *got_frame, AVPacket *avpkt)\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n    s->avctx     = avctx;\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n    s->curtileno = -1;\n    memset(s->cdef, -1, sizeof(s->cdef));\n    if (bytestream2_get_bytes_left(&s->g) < 2) {\n    }\n    if (bytestream2_get_bytes_left(&s->g) >= 12 &&\n       (bytestream2_get_be32u(&s->g) == 12) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_TYPE) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_VALUE)) {\n        if (!jp2_find_codestream(s)) {\n        }\n    } else {\n        bytestream2_seek(&s->g, 0, SEEK_SET);\n    }\n    while (bytestream2_get_bytes_left(&s->g) >= 3 && bytestream2_peek_be16(&s->g) != JPEG2000_SOC)\n        bytestream2_skip(&s->g, 1);\n    if (bytestream2_get_be16u(&s->g) != JPEG2000_SOC) {\n    }\n    if (ret = jpeg2000_read_main_headers(s))\n        goto end;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"thread.h\"\n#include \"jpeg2000.h\"\n#define JP2_SIG_TYPE    0x6A502020\n#define JP2_SIG_VALUE   0x0D0A870A\n#define JP2_CODESTREAM  0x6A703263\n#define JP2_HEADER      0x6A703268\n#define HAD_COC 0x01\n#define HAD_QCC 0x02\ntypedef struct Jpeg2000TilePart {\n    uint8_t tile_index;                 // Tile index who refers the tile-part\n    const uint8_t *tp_end;\n    GetByteContext tpg;                 // bit stream in tile-part\n} Jpeg2000TilePart;\ntypedef struct Jpeg2000Tile {\n    Jpeg2000Component   *comp;\n    uint8_t             properties[4];\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n    Jpeg2000TilePart    tile_part[4];\n    uint16_t tp_idx;                    // Tile-part index\n} Jpeg2000Tile;\ntypedef struct Jpeg2000DecoderContext {\n    AVClass         *class;\n    AVCodecContext  *avctx;\n    GetByteContext  g;\n    int             width, height;\n    int             image_offset_x, image_offset_y;\n    int             tile_offset_x, tile_offset_y;\n    uint8_t         cbps[4];    // bits per sample in particular components\n    uint8_t         sgnd[4];    // if a component is signed\n    uint8_t         properties[4];\n    int             cdx[4], cdy[4];\n    int             precision;\n    int             ncomponents;\n    int             colour_space;\n    uint32_t        palette[256];\n    int8_t          pal8;\n    int             cdef[4];\n    int             tile_width, tile_height;\n    unsigned        numXtiles, numYtiles;\n    int             maxtilelen;\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n    int             bit_index;\n    int             curtileno;\n    Jpeg2000Tile    *tile;\n    int             reduction_factor;\n} Jpeg2000DecoderContext;\nstatic int pix_fmt_match(enum AVPixelFormat pix_fmt, int components,\n                         int bpc, uint32_t log2_chroma_wh, int pal8)\n{\n    int match = 1;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    if (desc->nb_components != components) {\n        return 0;\n    }\n    switch (components) {\n    case 4:\n        match = match && desc->comp[3].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 14 & 3) == 0 &&\n                         (log2_chroma_wh >> 12 & 3) == 0;\n    case 3:\n        match = match && desc->comp[2].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 10 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  8 & 3) == desc->log2_chroma_h;\n    case 2:\n        match = match && desc->comp[1].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  6 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  4 & 3) == desc->log2_chroma_h;\n    case 1:\n        match = match && desc->comp[0].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  2 & 3) == 0 &&\n                         (log2_chroma_wh       & 3) == 0 &&\n                         (desc->flags & AV_PIX_FMT_FLAG_PAL) == pal8 * AV_PIX_FMT_FLAG_PAL;\n    }\n    return match;\n}\n#define RGB_PIXEL_FORMATS   AV_PIX_FMT_PAL8,AV_PIX_FMT_RGB24,AV_PIX_FMT_RGBA,AV_PIX_FMT_RGB48,AV_PIX_FMT_RGBA64\n#define GRAY_PIXEL_FORMATS  AV_PIX_FMT_GRAY8,AV_PIX_FMT_GRAY8A,AV_PIX_FMT_GRAY16\n#define YUV_PIXEL_FORMATS   AV_PIX_FMT_YUV410P,AV_PIX_FMT_YUV411P,AV_PIX_FMT_YUVA420P, \\\n                            AV_PIX_FMT_YUV420P,AV_PIX_FMT_YUV422P,AV_PIX_FMT_YUVA422P, \\\n                            AV_PIX_FMT_YUV440P,AV_PIX_FMT_YUV444P,AV_PIX_FMT_YUVA444P, \\\n                            AV_PIX_FMT_YUV420P9,AV_PIX_FMT_YUV422P9,AV_PIX_FMT_YUV444P9, \\\n                            AV_PIX_FMT_YUVA420P9,AV_PIX_FMT_YUVA422P9,AV_PIX_FMT_YUVA444P9, \\\n                            AV_PIX_FMT_YUV420P10,AV_PIX_FMT_YUV422P10,AV_PIX_FMT_YUV444P10, \\\n                            AV_PIX_FMT_YUVA420P10,AV_PIX_FMT_YUVA422P10,AV_PIX_FMT_YUVA444P10, \\\n                            AV_PIX_FMT_YUV420P12,AV_PIX_FMT_YUV422P12,AV_PIX_FMT_YUV444P12, \\\n                            AV_PIX_FMT_YUV420P14,AV_PIX_FMT_YUV422P14,AV_PIX_FMT_YUV444P14, \\\n                            AV_PIX_FMT_YUV420P16,AV_PIX_FMT_YUV422P16,AV_PIX_FMT_YUV444P16, \\\n                            AV_PIX_FMT_YUVA420P16,AV_PIX_FMT_YUVA422P16,AV_PIX_FMT_YUVA444P16\n#define XYZ_PIXEL_FORMATS   AV_PIX_FMT_XYZ12\nstatic const enum AVPixelFormat rgb_pix_fmts[]  = {RGB_PIXEL_FORMATS};\nstatic const enum AVPixelFormat gray_pix_fmts[] = {GRAY_PIXEL_FORMATS};\nstatic const enum AVPixelFormat yuv_pix_fmts[]  = {YUV_PIXEL_FORMATS};\nstatic const enum AVPixelFormat xyz_pix_fmts[]  = {XYZ_PIXEL_FORMATS};\nstatic const enum AVPixelFormat all_pix_fmts[]  = {RGB_PIXEL_FORMATS,\n                                                   GRAY_PIXEL_FORMATS,\n                                                   YUV_PIXEL_FORMATS,\n                                                   XYZ_PIXEL_FORMATS};\nstatic int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\nstatic int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n        return AVERROR_INVALIDDATA;\n    }\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n    c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n    c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {\n        avpriv_request_sample(s->avctx, \"cblk size > 64\");\n        return AVERROR_PATCHWELCOME;\n    }\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}\nstatic int get_qcx(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q)\n{\n    int i, x;\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n    x = bytestream2_get_byteu(&s->g); // Sqcd\n    q->nguardbits = x >> 5;\n    q->quantsty   = x & 0x1f;\n    if (q->quantsty == JPEG2000_QSTY_NONE) {\n        n -= 3;\n        if (bytestream2_get_bytes_left(&s->g) < n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream2_get_byteu(&s->g) >> 3;\n    } else if (q->quantsty == JPEG2000_QSTY_SI) {\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n            return AVERROR_INVALIDDATA;\n        x          = bytestream2_get_be16u(&s->g);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < JPEG2000_MAX_DECLEVELS * 3; i++) {\n            int curexpn = FFMAX(0, q->expn[0] - (i - 1) / 3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else {\n        n = (n - 3) >> 1;\n        if (bytestream2_get_bytes_left(&s->g) < 2 * n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++) {\n            x          = bytestream2_get_be16u(&s->g);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}\nstatic int get_sot(Jpeg2000DecoderContext *s, int n)\n{\n    Jpeg2000TilePart *tp;\n    uint16_t Isot;\n    uint32_t Psot;\n    uint8_t TPsot;\n    if (bytestream2_get_bytes_left(&s->g) < 8)\n        return AVERROR_INVALIDDATA;\n    s->curtileno = 0;\n    Isot = bytestream2_get_be16u(&s->g);        // Isot\n    if (Isot >= s->numXtiles * s->numYtiles)\n        return AVERROR_INVALIDDATA;\n    s->curtileno = Isot;\n    Psot  = bytestream2_get_be32u(&s->g);       // Psot\n    TPsot = bytestream2_get_byteu(&s->g);       // TPsot\n    bytestream2_get_byteu(&s->g);               // TNsot\n    if (Psot > bytestream2_get_bytes_left(&s->g) + n + 2) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Psot %d too big\\n\", Psot);\n        return AVERROR_INVALIDDATA;\n    }\n    if (TPsot >= FF_ARRAY_ELEMS(s->tile[Isot].tile_part)) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\", TPsot);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->tile[Isot].tp_idx = TPsot;\n    tp             = s->tile[Isot].tile_part + TPsot;\n    tp->tile_index = Isot;\n    tp->tp_end     = s->g.buffer + Psot - n - 2;\n    if (!TPsot) {\n        Jpeg2000Tile *tile = s->tile + s->curtileno;\n        memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(Jpeg2000CodingStyle));\n        memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(Jpeg2000QuantStyle));\n    }\n    return 0;\n}\nstatic int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno / s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; // global bandno\n        comp->coord_o[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);\n        comp->coord_o[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);\n        comp->coord_o[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);\n        comp->coord_o[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}\nstatic int jpeg2000_decode_packet(Jpeg2000DecoderContext *s,\n                                  Jpeg2000CodingStyle *codsty,\n                                  Jpeg2000ResLevel *rlevel, int precno,\n                                  int layno, uint8_t *expn, int numgbits)\n{\n    int bandno, cblkno, ret, nb_code_blocks;\n    if (!(ret = get_bits(s, 1))) {\n        jpeg2000_flush(s);\n        return 0;\n    } else if (ret < 0)\n        return ret;\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n        if (band->coord[0][0] == band->coord[0][1] ||\n            band->coord[1][0] == band->coord[1][1])\n            continue;\n        nb_code_blocks =  prec->nb_codeblocks_height *\n                          prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            int incl, newpasses, llen;\n            if (cblk->npasses)\n                incl = get_bits(s, 1);\n            else\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n            if (!incl)\n                continue;\n            else if (incl < 0)\n                return incl;\n            if (!cblk->npasses) {\n                int v = expn[bandno] + numgbits - 1 -\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n                if (v < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"nonzerobits %d invalid\\n\", v);\n                    return AVERROR_INVALIDDATA;\n                }\n                cblk->nonzerobits = v;\n            }\n            if ((newpasses = getnpasses(s)) < 0)\n                return newpasses;\n            if ((llen = getlblockinc(s)) < 0)\n                return llen;\n            cblk->lblock += llen;\n            if ((ret = get_bits(s, av_log2(newpasses) + cblk->lblock)) < 0)\n                return ret;\n            if (ret > sizeof(cblk->data)) {\n                avpriv_request_sample(s->avctx,\n                                      \"Block with lengthinc greater than %zu\",\n                                      sizeof(cblk->data));\n                return AVERROR_PATCHWELCOME;\n            }\n            cblk->lengthinc = ret;\n            cblk->npasses  += newpasses;\n        }\n    }\n    jpeg2000_flush(s);\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n            bytestream2_skip(&s->g, 2);\n        else\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found.\\n\");\n    }\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc\n                || sizeof(cblk->data) < cblk->length + cblk->lengthinc + 2\n            ) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Block length %d or lengthinc %d is too large\\n\",\n                       cblk->length, cblk->lengthinc);\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc);\n            cblk->length   += cblk->lengthinc;\n            cblk->lengthinc = 0;\n        }\n    }\n    return 0;\n}\nstatic int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int ret = 0;\n    int layno, reslevelno, compno, precno, ok_reslevel;\n    int x, y;\n    s->bit_index = 8;\n    switch (tile->codsty[0].prog_order) {\n    case JPEG2000_PGOD_RLCP:\n        avpriv_request_sample(s->avctx, \"Progression order RLCP\");\n    case JPEG2000_PGOD_LRCP:\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n            ok_reslevel = 1;\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n                ok_reslevel = 0;\n                for (compno = 0; compno < s->ncomponents; compno++) {\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n                    if (reslevelno < codsty->nreslevels) {\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n                                                reslevelno;\n                        ok_reslevel = 1;\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n                            if ((ret = jpeg2000_decode_packet(s,\n                                                              codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                    }\n                }\n            }\n        }\n        break;\n    case JPEG2000_PGOD_CPRL:\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n            s->g = tile->tile_part[compno].tpg;\n            for (y = 0; y < s->height; y += 256) {\n                for (x = 0; x < s->width; x += 256) {\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n                        uint16_t prcx, prcy;\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n                        // check if a precinct exists\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                        }\n                    }\n                }\n            }\n        }\n        break;\n    case JPEG2000_PGOD_RPCL:\n        avpriv_request_sample(s->avctx, \"Progression order RPCL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n    case JPEG2000_PGOD_PCRL:\n        avpriv_request_sample(s->avctx, \"Progression order PCRL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n    default:\n        break;\n    }\n    bytestream2_skip(&s->g, 2);\n    return ret;\n}\nstatic void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno, int bandno, int bpass_csty_symbol,\n                           int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y;\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++) {\n                if ((t1->flags[y+1][x+1] & JPEG2000_T1_SIG_NB)\n                && !(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                    int flags_mask = -1;\n                    if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                        flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                    if (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask, bandno))) {\n                        int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n                        if (bpass_csty_symbol)\n                             t1->data[y][x] = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ? -mask : mask;\n                        else\n                             t1->data[y][x] = (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ^ xorbit) ?\n                                               -mask : mask;\n                        ff_jpeg2000_set_significance(t1, x, y,\n                                                     t1->data[y][x] < 0);\n                    }\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;\n                }\n            }\n}\nstatic void decode_refpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno)\n{\n    int phalf, nhalf;\n    int y0, x, y;\n    phalf = 1 << (bpno - 1);\n    nhalf = -phalf;\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++)\n                if ((t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)) == JPEG2000_T1_SIG) {\n                    int ctxno = ff_jpeg2000_getrefctxno(t1->flags[y + 1][x + 1]);\n                    int r     = ff_mqc_decode(&t1->mqc,\n                                              t1->mqc.cx_states + ctxno)\n                                ? phalf : nhalf;\n                    t1->data[y][x]          += t1->data[y][x] < 0 ? -r : r;\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_REF;\n                }\n}\nstatic void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,\n                           int width, int height, int bpno, int bandno,\n                           int seg_symbols, int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y, runlen, dec;\n    for (y0 = 0; y0 < height; y0 += 4) {\n        for (x = 0; x < width; x++) {\n            if (y0 + 3 < height &&\n                !((t1->flags[y0 + 1][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 2][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 3][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 4][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)))) {\n                if (!ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL))\n                    continue;\n                runlen = ff_mqc_decode(&t1->mqc,\n                                       t1->mqc.cx_states + MQC_CX_UNI);\n                runlen = (runlen << 1) | ff_mqc_decode(&t1->mqc,\n                                                       t1->mqc.cx_states +\n                                                       MQC_CX_UNI);\n                dec = 1;\n            } else {\n                runlen = 0;\n                dec    = 0;\n            }\n            for (y = y0 + runlen; y < y0 + 4 && y < height; y++) {\n                if (!dec) {\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                        int flags_mask = -1;\n                        if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                            flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                        dec = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask,\n                                                                                             bandno));\n                    }\n                }\n                if (dec) {\n                    int xorbit;\n                    int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y + 1][x + 1],\n                                                        &xorbit);\n                    t1->data[y][x] = (ff_mqc_decode(&t1->mqc,\n                                                    t1->mqc.cx_states + ctxno) ^\n                                      xorbit)\n                                     ? -mask : mask;\n                    ff_jpeg2000_set_significance(t1, x, y, t1->data[y][x] < 0);\n                }\n                dec = 0;\n                t1->flags[y + 1][x + 1] &= ~JPEG2000_T1_VIS;\n            }\n        }\n    }\n    if (seg_symbols) {\n        int val;\n        val = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        if (val != 0xa)\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Segmentation symbol value incorrect\\n\");\n    }\n}\nstatic int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n    if (!cblk->length)\n        return 0;\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}\nstatic void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,\n                                 Jpeg2000Component *comp,\n                                 Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        float *datap = &comp->f_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = src[i] * band->f_stepsize;\n    }\n}\nstatic void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n                               Jpeg2000Component *comp,\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = (src[i] * band->i_stepsize + (1 << 14)) >> 15;\n    }\n}\nstatic const float f_ict_params[4] = {\n    1.402f,\n    0.34413f,\n    0.71414f,\n    1.772f\n};\nstatic const int   i_ict_params[4] = {\n     91881,\n     22553,\n     46802,\n    116130\n};\nstatic void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int i, csize = 1;\n    int32_t *src[3],  i0,  i1,  i2;\n    float   *srcf[3], i0f, i1f, i2f;\n    for (i = 1; i < 3; i++)\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n            return;\n        }\n    for (i = 0; i < 3; i++)\n        if (tile->codsty[0].transform == FF_DWT97)\n            srcf[i] = tile->comp[i].f_data;\n        else\n            src [i] = tile->comp[i].i_data;\n    for (i = 0; i < 2; i++)\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n    switch (tile->codsty[0].transform) {\n    case FF_DWT97:\n        for (i = 0; i < csize; i++) {\n            i0f = *srcf[0] + (f_ict_params[0] * *srcf[2]);\n            i1f = *srcf[0] - (f_ict_params[1] * *srcf[1])\n                           - (f_ict_params[2] * *srcf[2]);\n            i2f = *srcf[0] + (f_ict_params[3] * *srcf[1]);\n            *srcf[0]++ = i0f;\n            *srcf[1]++ = i1f;\n            *srcf[2]++ = i2f;\n        }\n        break;\n    case FF_DWT97_INT:\n        for (i = 0; i < csize; i++) {\n            i0 = *src[0] + (((i_ict_params[0] * *src[2]) + (1 << 15)) >> 16);\n            i1 = *src[0] - (((i_ict_params[1] * *src[1]) + (1 << 15)) >> 16)\n                         - (((i_ict_params[2] * *src[2]) + (1 << 15)) >> 16);\n            i2 = *src[0] + (((i_ict_params[3] * *src[1]) + (1 << 15)) >> 16);\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    case FF_DWT53:\n        for (i = 0; i < csize; i++) {\n            i1 = *src[0] - (*src[2] + *src[1] >> 2);\n            i0 = i1 + *src[2];\n            i2 = i1 + *src[1];\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    }\n}\nstatic int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                                AVFrame *picture)\n{\n    int compno, reslevelno, bandno;\n    int x, y;\n    uint8_t *line;\n    Jpeg2000T1Context t1;\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp     = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n                int nb_precincts, precno;\n                Jpeg2000Band *band = rlevel->band + bandno;\n                int cblkno = 0, bandpos;\n                bandpos = bandno + (reslevelno > 0);\n                if (band->coord[0][0] == band->coord[0][1] ||\n                    band->coord[1][0] == band->coord[1][1])\n                    continue;\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n                for (precno = 0; precno < nb_precincts; precno++) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                        int x, y;\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                        decode_cblk(s, codsty, &t1, cblk,\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n                                    bandpos);\n                        x = cblk->coord[0][0];\n                        y = cblk->coord[1][0];\n                        if (codsty->transform == FF_DWT97)\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n                        else\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n                   } \n                } \n            } \n        } \n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n    } \n    if (tile->codsty[0].mct)\n        mct_decode(s, tile);\n    if (s->cdef[0] < 0) {\n        for (x = 0; x < s->ncomponents; x++)\n            s->cdef[x] = x + 1;\n        if ((s->ncomponents & 1) == 0)\n            s->cdef[s->ncomponents-1] = 0;\n    }\n    if (s->precision <= 8) {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            line = picture->data[plane] + y * picture->linesize[plane];\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint8_t *dst;\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = line + x * pixelsize + compno*!planar;\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                line += picture->linesize[plane];\n            }\n        }\n    } else {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            uint16_t *linel;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint16_t *dst;\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = linel + (x * pixelsize + compno*!planar);\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (16 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (16 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                linel += picture->linesize[plane] >> 1;\n            }\n        }\n    }\n    return 0;\n}\nstatic int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n{\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n    for (;;) {\n        int len, ret = 0;\n        uint16_t marker;\n        int oldpos;\n        if (bytestream2_get_bytes_left(&s->g) < 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n            break;\n        }\n        marker = bytestream2_get_be16u(&s->g);\n        oldpos = bytestream2_tell(&s->g);\n        if (marker == JPEG2000_SOD) {\n            Jpeg2000Tile *tile;\n            Jpeg2000TilePart *tp;\n            if (!s->tile) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SIZ\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->curtileno < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SOT\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            tile = s->tile + s->curtileno;\n            tp = tile->tile_part + tile->tp_idx;\n            if (tp->tp_end < s->g.buffer) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid tpend\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_init(&tp->tpg, s->g.buffer, tp->tp_end - s->g.buffer);\n            bytestream2_skip(&s->g, tp->tp_end - s->g.buffer);\n            continue;\n        }\n        if (marker == JPEG2000_EOC)\n            break;\n        len = bytestream2_get_be16(&s->g);\n        if (len < 2 || bytestream2_get_bytes_left(&s->g) < len - 2)\n            return AVERROR_INVALIDDATA;\n        switch (marker) {\n        case JPEG2000_SIZ:\n            ret = get_siz(s);\n            if (!s->tile)\n                s->numXtiles = s->numYtiles = 0;\n            break;\n        case JPEG2000_COC:\n            ret = get_coc(s, codsty, properties);\n            break;\n        case JPEG2000_COD:\n            ret = get_cod(s, codsty, properties);\n            break;\n        case JPEG2000_QCC:\n            ret = get_qcc(s, len, qntsty, properties);\n            break;\n        case JPEG2000_QCD:\n            ret = get_qcd(s, len, qntsty, properties);\n            break;\n        case JPEG2000_SOT:\n            if (!(ret = get_sot(s, len))) {\n                av_assert1(s->curtileno >= 0);\n                codsty = s->tile[s->curtileno].codsty;\n                qntsty = s->tile[s->curtileno].qntsty;\n                properties = s->tile[s->curtileno].properties;\n            }\n            break;\n        case JPEG2000_COM:\n            // the comment is ignored\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        case JPEG2000_TLM:\n            // Tile-part lengths\n            ret = get_tlm(s, len);\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%X\\n\",\n                   marker, bytestream2_tell(&s->g) - 4);\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        }\n        if (bytestream2_tell(&s->g) - oldpos != len || ret) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"error during processing marker segment %.4x\\n\", marker);\n            return ret ? ret : -1;\n        }\n    }\n    return 0;\n}\nstatic int jp2_find_codestream(Jpeg2000DecoderContext *s)\n{\n    uint32_t atom_size, atom, atom_end;\n    int search_range = 10;\n    while (search_range\n           &&\n           bytestream2_get_bytes_left(&s->g) >= 8) {\n        atom_size = bytestream2_get_be32u(&s->g);\n        atom      = bytestream2_get_be32u(&s->g);\n        atom_end  = bytestream2_tell(&s->g) + atom_size - 8;\n        if (atom == JP2_CODESTREAM)\n            return 1;\n        if (bytestream2_get_bytes_left(&s->g) < atom_size || atom_end < atom_size)\n            return 0;\n        if (atom == JP2_HEADER &&\n                   atom_size >= 16) {\n            uint32_t atom2_size, atom2, atom2_end;\n            do {\n                atom2_size = bytestream2_get_be32u(&s->g);\n                atom2      = bytestream2_get_be32u(&s->g);\n                atom2_end  = bytestream2_tell(&s->g) + atom2_size - 8;\n                if (atom2_size < 8 || atom2_end > atom_end || atom2_end < atom2_size)\n                    break;\n                if (atom2 == JP2_CODESTREAM) {\n                    return 1;\n                } else if (atom2 == MKBETAG('c','o','l','r') && atom2_size >= 7) {\n                    int method = bytestream2_get_byteu(&s->g);\n                    bytestream2_skipu(&s->g, 2);\n                    if (method == 1) {\n                        s->colour_space = bytestream2_get_be32u(&s->g);\n                    }\n                } else if (atom2 == MKBETAG('p','c','l','r') && atom2_size >= 6) {\n                    int i, size, colour_count, colour_channels, colour_depth[3];\n                    uint32_t r, g, b;\n                    colour_count = bytestream2_get_be16u(&s->g);\n                    colour_channels = bytestream2_get_byteu(&s->g);\n                    // FIXME: Do not ignore channel_sign\n                    colour_depth[0] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[1] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[2] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    size = (colour_depth[0] + 7 >> 3) * colour_count +\n                           (colour_depth[1] + 7 >> 3) * colour_count +\n                           (colour_depth[2] + 7 >> 3) * colour_count;\n                    if (colour_count > 256   ||\n                        colour_channels != 3 ||\n                        colour_depth[0] > 16 ||\n                        colour_depth[1] > 16 ||\n                        colour_depth[2] > 16 ||\n                        atom2_size < size) {\n                        avpriv_request_sample(s->avctx, \"Unknown palette\");\n                        bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n                        continue;\n                    }\n                    s->pal8 = 1;\n                    for (i = 0; i < colour_count; i++) {\n                        if (colour_depth[0] <= 8) {\n                            r = bytestream2_get_byteu(&s->g) << 8 - colour_depth[0];\n                            r |= r >> colour_depth[0];\n                        } else {\n                            r = bytestream2_get_be16u(&s->g) >> colour_depth[0] - 8;\n                        }\n                        if (colour_depth[1] <= 8) {\n                            g = bytestream2_get_byteu(&s->g) << 8 - colour_depth[1];\n                            r |= r >> colour_depth[1];\n                        } else {\n                            g = bytestream2_get_be16u(&s->g) >> colour_depth[1] - 8;\n                        }\n                        if (colour_depth[2] <= 8) {\n                            b = bytestream2_get_byteu(&s->g) << 8 - colour_depth[2];\n                            r |= r >> colour_depth[2];\n                        } else {\n                            b = bytestream2_get_be16u(&s->g) >> colour_depth[2] - 8;\n                        }\n                        s->palette[i] = 0xffu << 24 | r << 16 | g << 8 | b;\n                    }\n                } else if (atom2 == MKBETAG('c','d','e','f') && atom2_size >= 2) {\n                    int n = bytestream2_get_be16u(&s->g);\n                    for (; n>0; n--) {\n                        int cn   = bytestream2_get_be16(&s->g);\n                        int av_unused typ  = bytestream2_get_be16(&s->g);\n                        int asoc = bytestream2_get_be16(&s->g);\n                        if (cn < 4 || asoc < 4)\n                            s->cdef[cn] = asoc;\n                    }\n                }\n                bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n            } while (atom_end - atom2_end >= 8);\n        } else {\n            search_range--;\n        }\n        bytestream2_seek(&s->g, atom_end, SEEK_SET);\n    }\n    return 0;\n}\nstatic int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n                                 int *got_frame, AVPacket *avpkt)\n{\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int tileno, ret;\n    s->avctx     = avctx;\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n    s->curtileno = -1;\n    memset(s->cdef, -1, sizeof(s->cdef));\n    if (bytestream2_get_bytes_left(&s->g) < 2) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    // check if the image is in jp2 format\n    if (bytestream2_get_bytes_left(&s->g) >= 12 &&\n       (bytestream2_get_be32u(&s->g) == 12) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_TYPE) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_VALUE)) {\n        if (!jp2_find_codestream(s)) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Could not find Jpeg2000 codestream atom.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    } else {\n        bytestream2_seek(&s->g, 0, SEEK_SET);\n    }\n    while (bytestream2_get_bytes_left(&s->g) >= 3 && bytestream2_peek_be16(&s->g) != JPEG2000_SOC)\n        bytestream2_skip(&s->g, 1);\n    if (bytestream2_get_be16u(&s->g) != JPEG2000_SOC) {\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if (ret = jpeg2000_read_main_headers(s))\n        goto end;\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        goto end;\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    picture->key_frame = 1;\n    if (ret = jpeg2000_read_bitstream_packets(s))\n        goto end;\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n            goto end;\n    jpeg2000_dec_cleanup(s);\n    *got_frame = 1;\n    if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        memcpy(picture->data[1], s->palette, 256 * sizeof(uint32_t));\n    return bytestream2_tell(&s->g);\nend:\n    jpeg2000_dec_cleanup(s);\n    return ret;\n}\n#define OFFSET(x) offsetof(Jpeg2000DecoderContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption options[] = {\n    { \"lowres\",  \"Lower the decoding resolution by a power of two\",\n        OFFSET(reduction_factor), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, JPEG2000_MAX_RESLEVELS - 1, VD },\n    { NULL },\n};\nstatic const AVProfile profiles[] = {\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0,  \"JPEG 2000 codestream restriction 0\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1,  \"JPEG 2000 codestream restriction 1\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION, \"JPEG 2000 no codestream restrictions\" },\n    { FF_PROFILE_JPEG2000_DCINEMA_2K,             \"JPEG 2000 digital cinema 2K\"          },\n    { FF_PROFILE_JPEG2000_DCINEMA_4K,             \"JPEG 2000 digital cinema 4K\"          },\n    { FF_PROFILE_UNKNOWN },\n};\nstatic const AVClass jpeg2000_class = {\n    .class_name = \"jpeg2000\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\nAVCodec ff_jpeg2000_decoder = {\n    .name             = \"jpeg2000\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"JPEG 2000\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_JPEG2000,\n    .capabilities     = CODEC_CAP_FRAME_THREADS,\n    .priv_data_size   = sizeof(Jpeg2000DecoderContext),\n    .init_static_data = jpeg2000_init_static_data,\n    .decode           = jpeg2000_decode_frame,\n    .priv_class       = &jpeg2000_class,\n    .max_lowres       = 5,\n    .profiles         = NULL_IF_CONFIG_SMALL(profiles)\n};\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_485.c",
        "project": "ffmpeg/ffmpeg",
        "url": "https://github.com/FFmpeg/FFmpeg/commit/fe448cd28d674c3eff3072552eae366d0b659ce9",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\n\t\tu8 *data, u16 size)\n\t\tpipe = usb_sndctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tpipe = usb_rcvctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\tif (!(requesttype & USB_DIR_IN))\n\t\tmemcpy(s->buf, data, size);\n\tret = usb_control_msg(s->udev, pipe, request, requesttype, value,\n\t\t\tindex, s->buf, size, 1000);\n\tairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\n\tif (ret < 0) {\n\t}\n\tif (requesttype & USB_DIR_IN)\n\t\tmemcpy(data, s->buf, size);\nstatic int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\tdev_dbg(s->dev, \"\\n\");\n\tif (!s->udev)\n\t\treturn -ENODEV;\n\tmutex_lock(&s->v4l2_lock);\n\ts->sequence = 0;\n\tset_bit(POWER_ON, &s->flags);\n\tret = airspy_alloc_stream_bufs(s);\n\tret = airspy_alloc_urbs(s);\n\tret = airspy_submit_urbs(s);\n\tret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\nstatic int airspy_probe(struct usb_interface *intf,\n\tu8 u8tmp, buf[BUF_SIZE];\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t}\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\nenum {\n\tCMD_INVALID                       = 0x00,\n\tCMD_RECEIVER_MODE                 = 0x01,\n\tCMD_SI5351C_WRITE                 = 0x02,\n\tCMD_SI5351C_READ                  = 0x03,\n\tCMD_R820T_WRITE                   = 0x04,\n\tCMD_R820T_READ                    = 0x05,\n\tCMD_SPIFLASH_ERASE                = 0x06,\n\tCMD_SPIFLASH_WRITE                = 0x07,\n\tCMD_SPIFLASH_READ                 = 0x08,\n\tCMD_BOARD_ID_READ                 = 0x09,\n\tCMD_VERSION_STRING_READ           = 0x0a,\n\tCMD_BOARD_PARTID_SERIALNO_READ    = 0x0b,\n\tCMD_SET_SAMPLE_RATE               = 0x0c,\n\tCMD_SET_FREQ                      = 0x0d,\n\tCMD_SET_LNA_GAIN                  = 0x0e,\n\tCMD_SET_MIXER_GAIN                = 0x0f,\n\tCMD_SET_VGA_GAIN                  = 0x10,\n\tCMD_SET_LNA_AGC                   = 0x11,\n\tCMD_SET_MIXER_AGC                 = 0x12,\n\tCMD_SET_PACKING                   = 0x13,\n};\n#define MAX_BULK_BUFS            (6)\n#define BULK_BUFFER_SIZE         (128 * 512)\nstatic const struct v4l2_frequency_band bands[] = {\n\t{\n\t\t.tuner = 0,\n\t\t.type = V4L2_TUNER_ADC,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   = 20000000,\n\t\t.rangehigh  = 20000000,\n\t},\n};\nstatic const struct v4l2_frequency_band bands_rf[] = {\n\t{\n\t\t.tuner = 1,\n\t\t.type = V4L2_TUNER_RF,\n\t\t.index = 0,\n\t\t.capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS,\n\t\t.rangelow   =   24000000,\n\t\t.rangehigh  = 1750000000,\n\t},\n};\nstruct airspy_format {\n\tchar\t*name;\n\tu32\tpixelformat;\n\tu32\tbuffersize;\n};\nstatic struct airspy_format formats[] = {\n\t{\n\t\t.name\t\t= \"Real U12LE\",\n\t\t.pixelformat\t= V4L2_SDR_FMT_RU12LE,\n\t\t.buffersize\t= BULK_BUFFER_SIZE,\n\t},\n};\nstatic const unsigned int NUM_FORMATS = ARRAY_SIZE(formats);\nstruct airspy_frame_buf {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\nstruct airspy {\n#define POWER_ON\t   1\n#define USB_STATE_URB_BUF  2\n\tunsigned long flags;\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct vb2_queue vb_queue;\n\tstruct list_head queued_bufs;\n\tspinlock_t queued_bufs_lock; \n\tunsigned sequence;\t     \n\tunsigned int vb_full;        \n\tstruct mutex v4l2_lock;      \n\tstruct mutex vb_queue_lock;  \n\tstruct urb     *urb_list[MAX_BULK_BUFS];\n\tint            buf_num;\n\tunsigned long  buf_size;\n\tu8             *buf_list[MAX_BULK_BUFS];\n\tdma_addr_t     dma_addr[MAX_BULK_BUFS];\n\tint            urbs_initialized;\n\tint            urbs_submitted;\n\t#define BUF_SIZE 128\n\tu8 buf[BUF_SIZE];\n\tunsigned int f_adc;\n\tunsigned int f_rf;\n\tu32 pixelformat;\n\tu32 buffersize;\n\tstruct v4l2_ctrl_handler hdl;\n\tstruct v4l2_ctrl *lna_gain_auto;\n\tstruct v4l2_ctrl *lna_gain;\n\tstruct v4l2_ctrl *mixer_gain_auto;\n\tstruct v4l2_ctrl *mixer_gain;\n\tstruct v4l2_ctrl *if_gain;\n\tunsigned long jiffies_next;\n\tunsigned int sample;\n\tunsigned int sample_measured;\n};\n#define airspy_dbg_usb_control_msg(_dev, _r, _t, _v, _i, _b, _l) { \\\n\tchar *_direction; \\\n\tif (_t & USB_DIR_IN) \\\n\t\t_direction = \"<<<\"; \\\n\telse \\\n\t\t_direction = \">>>\"; \\\n\tdev_dbg(_dev, \"%02x %02x %02x %02x %02x %02x %02x %02x %s %*ph\\n\", \\\n\t\t\t_t, _r, _v & 0xff, _v >> 8, _i & 0xff, _i >> 8, \\\n\t\t\t_l & 0xff, _l >> 8, _direction, _l, _b); \\\n}\nstatic int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\n\t\tu8 *data, u16 size)\n{\n\tint ret;\n\tunsigned int pipe;\n\tu8 requesttype;\n\tswitch (request) {\n\tcase CMD_RECEIVER_MODE:\n\tcase CMD_SET_FREQ:\n\t\tpipe = usb_sndctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\n\t\tbreak;\n\tcase CMD_BOARD_ID_READ:\n\tcase CMD_VERSION_STRING_READ:\n\tcase CMD_BOARD_PARTID_SERIALNO_READ:\n\tcase CMD_SET_LNA_GAIN:\n\tcase CMD_SET_MIXER_GAIN:\n\tcase CMD_SET_VGA_GAIN:\n\tcase CMD_SET_LNA_AGC:\n\tcase CMD_SET_MIXER_AGC:\n\t\tpipe = usb_rcvctrlpipe(s->udev, 0);\n\t\trequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(s->dev, \"Unknown command %02x\\n\", request);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tif (!(requesttype & USB_DIR_IN))\n\t\tmemcpy(s->buf, data, size);\n\tret = usb_control_msg(s->udev, pipe, request, requesttype, value,\n\t\t\tindex, s->buf, size, 1000);\n\tairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\n\t\t\tindex, s->buf, size);\n\tif (ret < 0) {\n\t\tdev_err(s->dev, \"usb_control_msg() failed %d request %02x\\n\",\n\t\t\t\tret, request);\n\t\tgoto err;\n\t}\n\tif (requesttype & USB_DIR_IN)\n\t\tmemcpy(data, s->buf, size);\n\treturn 0;\nerr:\n\treturn ret;\n}\nstatic void airspy_urb_complete(struct urb *urb)\n{\n\tstruct airspy *s = urb->context;\n\tstruct airspy_frame_buf *fbuf;\n\tdev_dbg_ratelimited(s->dev, \"status=%d length=%d/%d errors=%d\\n\",\n\t\t\turb->status, urb->actual_length,\n\t\t\turb->transfer_buffer_length, urb->error_count);\n\tswitch (urb->status) {\n\tcase 0:             \n\tcase -ETIMEDOUT:    \n\t\tbreak;\n\tcase -ECONNRESET:   \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:            \n\t\tdev_err_ratelimited(s->dev, \"URB failed %d\\n\", urb->status);\n\t\tbreak;\n\t}\n\tif (likely(urb->actual_length > 0)) {\n\t\tvoid *ptr;\n\t\tunsigned int len;\n\t\tfbuf = airspy_get_next_fill_buf(s);\n\t\tif (unlikely(fbuf == NULL)) {\n\t\t\ts->vb_full++;\n\t\t\tdev_notice_ratelimited(s->dev,\n\t\t\t\t\t\"videobuf is full, %d packets dropped\\n\",\n\t\t\t\t\ts->vb_full);\n\t\t\tgoto skip;\n\t\t}\n\t\tptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\n\t\tlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\n\t\t\t\turb->actual_length);\n\t\tvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\n\t\tfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tfbuf->vb.sequence = s->sequence++;\n\t\tvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\nskip:\n\tusb_submit_urb(urb, GFP_ATOMIC);\n}\nstatic int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct airspy *s = vb2_get_drv_priv(vq);\n\tint ret;\n\tdev_dbg(s->dev, \"\\n\");\n\tif (!s->udev)\n\t\treturn -ENODEV;\n\tmutex_lock(&s->v4l2_lock);\n\ts->sequence = 0;\n\tset_bit(POWER_ON, &s->flags);\n\tret = airspy_alloc_stream_bufs(s);\n\tif (ret)\n\t\tgoto err_clear_bit;\n\tret = airspy_alloc_urbs(s);\n\tif (ret)\n\t\tgoto err_free_stream_bufs;\n\tret = airspy_submit_urbs(s);\n\tif (ret)\n\t\tgoto err_free_urbs;\n\tret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\n\tif (ret)\n\t\tgoto err_kill_urbs;\n\tgoto exit_mutex_unlock;\nerr_kill_urbs:\n\tairspy_kill_urbs(s);\nerr_free_urbs:\n\tairspy_free_urbs(s);\nerr_free_stream_bufs:\n\tairspy_free_stream_bufs(s);\nerr_clear_bit:\n\tclear_bit(POWER_ON, &s->flags);\n\t{\n\t\tstruct airspy_frame_buf *buf, *tmp;\n\t\tlist_for_each_entry_safe(buf, tmp, &s->queued_bufs, list) {\n\t\t\tlist_del(&buf->list);\n\t\t\tvb2_buffer_done(&buf->vb.vb2_buf,\n\t\t\t\t\tVB2_BUF_STATE_QUEUED);\n\t\t}\n\t}\nexit_mutex_unlock:\n\tmutex_unlock(&s->v4l2_lock);\n\treturn ret;\n}\nstatic struct vb2_ops airspy_vb2_ops = {\n\t.queue_setup            = airspy_queue_setup,\n\t.buf_queue              = airspy_buf_queue,\n\t.start_streaming        = airspy_start_streaming,\n\t.stop_streaming         = airspy_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\nstatic const struct v4l2_ioctl_ops airspy_ioctl_ops = {\n\t.vidioc_querycap          = airspy_querycap,\n\t.vidioc_enum_fmt_sdr_cap  = airspy_enum_fmt_sdr_cap,\n\t.vidioc_g_fmt_sdr_cap     = airspy_g_fmt_sdr_cap,\n\t.vidioc_s_fmt_sdr_cap     = airspy_s_fmt_sdr_cap,\n\t.vidioc_try_fmt_sdr_cap   = airspy_try_fmt_sdr_cap,\n\t.vidioc_reqbufs           = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs       = vb2_ioctl_create_bufs,\n\t.vidioc_prepare_buf       = vb2_ioctl_prepare_buf,\n\t.vidioc_querybuf          = vb2_ioctl_querybuf,\n\t.vidioc_qbuf              = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf             = vb2_ioctl_dqbuf,\n\t.vidioc_streamon          = vb2_ioctl_streamon,\n\t.vidioc_streamoff         = vb2_ioctl_streamoff,\n\t.vidioc_g_tuner           = airspy_g_tuner,\n\t.vidioc_s_tuner           = airspy_s_tuner,\n\t.vidioc_g_frequency       = airspy_g_frequency,\n\t.vidioc_s_frequency       = airspy_s_frequency,\n\t.vidioc_enum_freq_bands   = airspy_enum_freq_bands,\n\t.vidioc_subscribe_event   = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_log_status        = v4l2_ctrl_log_status,\n};\nstatic const struct v4l2_file_operations airspy_fops = {\n\t.owner                    = THIS_MODULE,\n\t.open                     = v4l2_fh_open,\n\t.release                  = vb2_fop_release,\n\t.read                     = vb2_fop_read,\n\t.poll                     = vb2_fop_poll,\n\t.mmap                     = vb2_fop_mmap,\n\t.unlocked_ioctl           = video_ioctl2,\n};\nstatic struct video_device airspy_template = {\n\t.name                     = \"AirSpy SDR\",\n\t.release                  = video_device_release_empty,\n\t.fops                     = &airspy_fops,\n\t.ioctl_ops                = &airspy_ioctl_ops,\n};\nstatic const struct v4l2_ctrl_ops airspy_ctrl_ops = {\n\t.s_ctrl = airspy_s_ctrl,\n};\nstatic int airspy_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct airspy *s;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\n\t\tgoto err_free_mem;\n\t}\n\tbuf[BUF_SIZE - 1] = '\\0';\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\ts->vb_queue.drv_priv = s;\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\n\ts->vb_queue.ops = &airspy_vb2_ops;\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&s->vb_queue);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\ts->vdev = airspy_template;\n\ts->vdev.queue = &s->vb_queue;\n\ts->vdev.queue->lock = &s->vb_queue_lock;\n\tvideo_set_drvdata(&s->vdev, s);\n\ts->v4l2_dev.release = airspy_video_release;\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\n\tif (s->hdl.error) {\n\t\tret = s->hdl.error;\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\tv4l2_ctrl_handler_setup(&s->hdl);\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\n\ts->vdev.lock = &s->v4l2_lock;\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\tdev_info(s->dev, \"Registered as %s\\n\",\n\t\t\tvideo_device_node_name(&s->vdev));\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&s->hdl);\nerr_unregister_v4l2_dev:\n\tv4l2_device_unregister(&s->v4l2_dev);\nerr_free_mem:\n\tkfree(s);\n\treturn ret;\n}\nstatic struct usb_device_id airspy_id_table[] = {\n\t{ USB_DEVICE(0x1d50, 0x60a1) }, \n\t{ }\n};\nstatic struct usb_driver airspy_driver = {\n\t.name                     = KBUILD_MODNAME,\n\t.probe                    = airspy_probe,\n\t.disconnect               = airspy_disconnect,\n\t.id_table                 = airspy_id_table,\n};\nMODULE_AUTHOR(\"Antti Palosaari <crope@iki.fi>\");\nMODULE_DESCRIPTION(\"AirSpy SDR\");\nMODULE_LICENSE(\"GPL\");\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_1263.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void dccp_handle_ackvec_processing(struct sock *sk, struct sk_buff *skb)\n\tstruct dccp_ackvec *av = dccp_sk(sk)->dccps_hc_rx_ackvec;\nstatic void dccp_deliver_input_to_ccids(struct sock *sk, struct sk_buff *skb)\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tif (!(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tccid_hc_rx_packet_recv(dp->dccps_hc_rx_ccid, sk, skb);\n\tif (sk->sk_write_queue.qlen > 0 || !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tccid_hc_tx_packet_recv(dp->dccps_hc_tx_ccid, sk, skb);\nstatic int dccp_check_seqno(struct sock *sk, struct sk_buff *skb)\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tu64 lswl, lawl, seqno = DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\tackno = DCCP_SKB_CB(skb)->dccpd_ack_seq;\nstatic int __dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tswitch (dccp_hdr(skb)->dccph_type) {\n\t\tdccp_rcv_reset(sk, skb);\nstatic int dccp_rcv_respond_partopen_state_process(struct sock *sk,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   const struct dccp_hdr *dh,\n\t\t\t\t\t\t   const unsigned int len)\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu32 sample = dp->dccps_options_received.dccpor_timestamp_echo;\n\t\tif (sk->sk_state == DCCP_RESPOND)\n\t\t\tbreak;\n\t\tif (sk->sk_state == DCCP_PARTOPEN)\n\t\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tif (likely(sample)) {\n\t\t\tlong delta = dccp_timestamp() - sample;\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * delta);\n\t\t}\n\t\tdp->dccps_osr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_set_state(sk, DCCP_OPEN);\n\t\tif (dh->dccph_type == DCCP_PKT_DATAACK ||\n\t\t    dh->dccph_type == DCCP_PKT_DATA) {\n\t\t\t__dccp_rcv_established(sk, skb, dh, len);\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t}\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t\n\t}\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/dccp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include \"ackvec.h\"\n#include \"ccid.h\"\n#include \"dccp.h\"\nint sysctl_dccp_sync_ratelimit\t__read_mostly = HZ / 8;\nstatic void dccp_enqueue_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t__skb_pull(skb, dccp_hdr(skb)->dccph_doff * 4);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tskb_set_owner_r(skb, sk);\n\tsk->sk_data_ready(sk);\n}\nstatic void dccp_fin(struct sock *sk, struct sk_buff *skb)\n{\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsock_set_flag(sk, SOCK_DONE);\n\tdccp_enqueue_skb(sk, skb);\n}\nstatic int dccp_rcv_close(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\tswitch (sk->sk_state) {\n\tcase DCCP_CLOSING:\n\t\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tbreak;\n\tcase DCCP_REQUESTING:\n\tcase DCCP_ACTIVE_CLOSEREQ:\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_CLOSED);\n\t\tdccp_done(sk);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSE);\n\tcase DCCP_PASSIVE_CLOSE:\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\nstatic int dccp_rcv_closereq(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = 0;\n\tif (dccp_sk(sk)->dccps_role != DCCP_ROLE_CLIENT) {\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq, DCCP_PKT_SYNC);\n\t\treturn queued;\n\t}\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tdccp_send_close(sk, 0);\n\t\tdccp_set_state(sk, DCCP_CLOSING);\n\t\tbreak;\n\tcase DCCP_OPEN:\n\tcase DCCP_PARTOPEN:\n\t\tqueued = 1;\n\t\tdccp_fin(sk, skb);\n\t\tdccp_set_state(sk, DCCP_PASSIVE_CLOSEREQ);\n\tcase DCCP_PASSIVE_CLOSEREQ:\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t}\n\treturn queued;\n}\nstatic u16 dccp_reset_code_convert(const u8 code)\n{\n\tconst u16 error_code[] = {\n\t[DCCP_RESET_CODE_CLOSED]\t     = 0,\t\n\t[DCCP_RESET_CODE_UNSPECIFIED]\t     = 0,\t\n\t[DCCP_RESET_CODE_ABORTED]\t     = ECONNRESET,\n\t[DCCP_RESET_CODE_NO_CONNECTION]\t     = ECONNREFUSED,\n\t[DCCP_RESET_CODE_CONNECTION_REFUSED] = ECONNREFUSED,\n\t[DCCP_RESET_CODE_TOO_BUSY]\t     = EUSERS,\n\t[DCCP_RESET_CODE_AGGRESSION_PENALTY] = EDQUOT,\n\t[DCCP_RESET_CODE_PACKET_ERROR]\t     = ENOMSG,\n\t[DCCP_RESET_CODE_BAD_INIT_COOKIE]    = EBADR,\n\t[DCCP_RESET_CODE_BAD_SERVICE_CODE]   = EBADRQC,\n\t[DCCP_RESET_CODE_OPTION_ERROR]\t     = EILSEQ,\n\t[DCCP_RESET_CODE_MANDATORY_ERROR]    = EOPNOTSUPP,\n\t};\n\treturn code >= DCCP_MAX_RESET_CODES ? 0 : error_code[code];\n}\nstatic void dccp_rcv_reset(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 err = dccp_reset_code_convert(dccp_hdr_reset(skb)->dccph_reset_code);\n\tsk->sk_err = err;\n\tdccp_fin(sk, skb);\n\tif (err && !sock_flag(sk, SOCK_DEAD))\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\tdccp_time_wait(sk, DCCP_TIME_WAIT, 0);\n}\nstatic void dccp_handle_ackvec_processing(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_ackvec *av = dccp_sk(sk)->dccps_hc_rx_ackvec;\n\tif (av == NULL)\n\t\treturn;\n\tif (DCCP_SKB_CB(skb)->dccpd_ack_seq != DCCP_PKT_WITHOUT_ACK_SEQ)\n\t\tdccp_ackvec_clear_state(av, DCCP_SKB_CB(skb)->dccpd_ack_seq);\n\tdccp_ackvec_input(av, skb);\n}\nstatic void dccp_deliver_input_to_ccids(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tif (!(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tccid_hc_rx_packet_recv(dp->dccps_hc_rx_ccid, sk, skb);\n\tif (sk->sk_write_queue.qlen > 0 || !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tccid_hc_tx_packet_recv(dp->dccps_hc_tx_ccid, sk, skb);\n}\nstatic int dccp_check_seqno(struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh = dccp_hdr(skb);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu64 lswl, lawl, seqno = DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\tackno = DCCP_SKB_CB(skb)->dccpd_ack_seq;\n\tif (dh->dccph_type == DCCP_PKT_SYNC ||\n\t    dh->dccph_type == DCCP_PKT_SYNCACK) {\n\t\tif (between48(ackno, dp->dccps_awl, dp->dccps_awh) &&\n\t\t    dccp_delta_seqno(dp->dccps_swl, seqno) >= 0)\n\t\t\tdccp_update_gsr(sk, seqno);\n\t\telse\n\t\t\treturn -1;\n\t}\n\tlswl = dp->dccps_swl;\n\tlawl = dp->dccps_awl;\n\tif (dh->dccph_type == DCCP_PKT_CLOSEREQ ||\n\t    dh->dccph_type == DCCP_PKT_CLOSE ||\n\t    dh->dccph_type == DCCP_PKT_RESET) {\n\t\tlswl = ADD48(dp->dccps_gsr, 1);\n\t\tlawl = dp->dccps_gar;\n\t}\n\tif (between48(seqno, lswl, dp->dccps_swh) &&\n\t    (ackno == DCCP_PKT_WITHOUT_ACK_SEQ ||\n\t     between48(ackno, lawl, dp->dccps_awh))) {\n\t\tdccp_update_gsr(sk, seqno);\n\t\tif (dh->dccph_type != DCCP_PKT_SYNC &&\n\t\t    ackno != DCCP_PKT_WITHOUT_ACK_SEQ &&\n\t\t    after48(ackno, dp->dccps_gar))\n\t\t\tdp->dccps_gar = ackno;\n\t} else {\n\t\tunsigned long now = jiffies;\n\t\tif (time_before(now, (dp->dccps_rate_last +\n\t\t\t\t      sysctl_dccp_sync_ratelimit)))\n\t\t\treturn -1;\n\t\tDCCP_WARN(\"Step 6 failed for %s packet, \"\n\t\t\t  \"(LSWL(%llu) <= P.seqno(%llu) <= S.SWH(%llu)) and \"\n\t\t\t  \"(P.ackno %s or LAWL(%llu) <= P.ackno(%llu) <= S.AWH(%llu), \"\n\t\t\t  \"sending SYNC...\\n\",  dccp_packet_name(dh->dccph_type),\n\t\t\t  (unsigned long long) lswl, (unsigned long long) seqno,\n\t\t\t  (unsigned long long) dp->dccps_swh,\n\t\t\t  (ackno == DCCP_PKT_WITHOUT_ACK_SEQ) ? \"doesn't exist\"\n\t\t\t\t\t\t\t      : \"exists\",\n\t\t\t  (unsigned long long) lawl, (unsigned long long) ackno,\n\t\t\t  (unsigned long long) dp->dccps_awh);\n\t\tdp->dccps_rate_last = now;\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tseqno = dp->dccps_gsr;\n\t\tdccp_send_sync(sk, seqno, DCCP_PKT_SYNC);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nstatic int __dccp_rcv_established(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  const struct dccp_hdr *dh, const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tswitch (dccp_hdr(skb)->dccph_type) {\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_DATA:\n\t\tdccp_enqueue_skb(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_ACK:\n\t\tgoto discard;\n\tcase DCCP_PKT_RESET:\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\tcase DCCP_PKT_CLOSEREQ:\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_CLOSE:\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\tcase DCCP_PKT_REQUEST:\n\t\tif (dp->dccps_role != DCCP_ROLE_LISTEN)\n\t\t\tgoto send_sync;\n\t\tgoto check_seq;\n\tcase DCCP_PKT_RESPONSE:\n\t\tif (dp->dccps_role != DCCP_ROLE_CLIENT)\n\t\t\tgoto send_sync;\ncheck_seq:\n\t\tif (dccp_delta_seqno(dp->dccps_osr,\n\t\t\t\t     DCCP_SKB_CB(skb)->dccpd_seq) >= 0) {\nsend_sync:\n\t\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t\t       DCCP_PKT_SYNC);\n\t\t}\n\t\tbreak;\n\tcase DCCP_PKT_SYNC:\n\t\tdccp_send_sync(sk, DCCP_SKB_CB(skb)->dccpd_seq,\n\t\t\t       DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\tDCCP_INC_STATS(DCCP_MIB_INERRS);\ndiscard:\n\t__kfree_skb(skb);\n\treturn 0;\n}\nstatic int dccp_rcv_request_sent_state_process(struct sock *sk,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       const struct dccp_hdr *dh,\n\t\t\t\t\t       const unsigned int len)\n{\n\tif (dh->dccph_type == DCCP_PKT_RESPONSE) {\n\t\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\t\tstruct dccp_sock *dp = dccp_sk(sk);\n\t\tlong tstamp = dccp_timestamp();\n\t\tif (!between48(DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t       dp->dccps_awl, dp->dccps_awh)) {\n\t\t\tdccp_pr_debug(\"invalid ackno: S.AWL=%llu, \"\n\t\t\t\t      \"P.ackno=%llu, S.AWH=%llu\\n\",\n\t\t\t\t      (unsigned long long)dp->dccps_awl,\n\t\t\t   (unsigned long long)DCCP_SKB_CB(skb)->dccpd_ack_seq,\n\t\t\t\t      (unsigned long long)dp->dccps_awh);\n\t\t\tgoto out_invalid_packet;\n\t\t}\n\t\tif (dccp_parse_options(sk, NULL, skb))\n\t\t\treturn 1;\n\t\tif (likely(dp->dccps_options_received.dccpor_timestamp_echo))\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * (tstamp -\n\t\t\t    dp->dccps_options_received.dccpor_timestamp_echo));\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);\n\t\tWARN_ON(sk->sk_send_head == NULL);\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t\tdp->dccps_gsr = dp->dccps_isr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\tdccp_set_state(sk, DCCP_PARTOPEN);\n\t\tif (dccp_feat_activate_values(sk, &dp->dccps_featneg))\n\t\t\tgoto unable_to_proceed;\n\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t}\n\t\tif (sk->sk_write_pending || icsk->icsk_ack.pingpong ||\n\t\t    icsk->icsk_accept_queue.rskq_defer_accept) {\n\t\t\t__kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tdccp_send_ack(sk);\n\t\treturn -1;\n\t}\nout_invalid_packet:\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_PACKET_ERROR;\n\treturn 1;\nunable_to_proceed:\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = DCCP_RESET_CODE_ABORTED;\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tsk->sk_err = ECOMM;\n\treturn 1;\n}\nstatic int dccp_rcv_respond_partopen_state_process(struct sock *sk,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   const struct dccp_hdr *dh,\n\t\t\t\t\t\t   const unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tu32 sample = dp->dccps_options_received.dccpor_timestamp_echo;\n\tint queued = 0;\n\tswitch (dh->dccph_type) {\n\tcase DCCP_PKT_RESET:\n\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tbreak;\n\tcase DCCP_PKT_DATA:\n\t\tif (sk->sk_state == DCCP_RESPOND)\n\t\t\tbreak;\n\tcase DCCP_PKT_DATAACK:\n\tcase DCCP_PKT_ACK:\n\t\tif (sk->sk_state == DCCP_PARTOPEN)\n\t\t\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n\t\tif (likely(sample)) {\n\t\t\tlong delta = dccp_timestamp() - sample;\n\t\t\tdp->dccps_syn_rtt = dccp_sample_rtt(sk, 10 * delta);\n\t\t}\n\t\tdp->dccps_osr = DCCP_SKB_CB(skb)->dccpd_seq;\n\t\tdccp_set_state(sk, DCCP_OPEN);\n\t\tif (dh->dccph_type == DCCP_PKT_DATAACK ||\n\t\t    dh->dccph_type == DCCP_PKT_DATA) {\n\t\t\t__dccp_rcv_established(sk, skb, dh, len);\n\t\t\tqueued = 1; \n\t\t}\n\t\tbreak;\n\t}\n\treturn queued;\n}\nint dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n\t\t\t\t\t\t\t\t    skb) < 0)\n\t\t\t\treturn 1;\n\t\t\tgoto discard;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\tcase DCCP_PARTOPEN:\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dccp_rcv_state_process);\nu32 dccp_sample_rtt(struct sock *sk, long delta)\n{\n\tdelta -= dccp_sk(sk)->dccps_options_received.dccpor_elapsed_time * 10;\n\tif (unlikely(delta <= 0)) {\n\t\tDCCP_WARN(\"unusable RTT sample %ld, using min\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MIN;\n\t}\n\tif (unlikely(delta > DCCP_SANE_RTT_MAX)) {\n\t\tDCCP_WARN(\"RTT sample %ld too large, using max\\n\", delta);\n\t\treturn DCCP_SANE_RTT_MAX;\n\t}\n\treturn delta;\n}\n",
        "cwe": "CWE-415",
        "file_name": "vul_respovul_idx_1559.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static pj_bool_t mod_ua_on_rx_response(pjsip_rx_data *rdata)\n    dlg = NULL;\n    tsx = pjsip_rdata_get_tsx(rdata);\n    if (tsx) {\n\tdlg = pjsip_tsx_get_dlg(tsx);\n\tif (!dlg) {\n\t}\n\tdlg_set = (struct dlg_set*) dlg->dlg_set;\n    } else {\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, \n\t\t\t            rdata->msg_info.from->tag.ptr,\n\t\t\t            (unsigned)rdata->msg_info.from->tag.slen,\n\t\t\t            NULL);\n\tif (!dlg_set) {\n\t}\n    }\n    pj_assert(dlg_set && !pj_list_empty(&dlg_set->dlg_list));\n    if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD) {\n\tpj_str_t *to_tag = &rdata->msg_info.to->tag;\n\tdlg = dlg_set->dlg_list.next;\n\twhile (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\t    if (dlg->remote.info->tag.slen == 0)\n\t    if (pj_stricmp(to_tag, &dlg->remote.info->tag) == 0)\n\t    dlg = dlg->next;\n\t}\n    } else {\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <pjsip/sip_ua_layer.h>\n#include <pjsip/sip_module.h>\n#include <pjsip/sip_dialog.h>\n#include <pjsip/sip_endpoint.h>\n#include <pjsip/sip_errno.h>\n#include <pjsip/sip_transaction.h>\n#include <pj/os.h>\n#include <pj/hash.h>\n#include <pj/assert.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/log.h>\n#define THIS_FILE    \"sip_ua_layer.c\"\nstatic pj_status_t mod_ua_load(pjsip_endpoint *endpt);\nstatic pj_status_t mod_ua_unload(void);\nstatic pj_bool_t   mod_ua_on_rx_request(pjsip_rx_data *rdata);\nstatic pj_bool_t   mod_ua_on_rx_response(pjsip_rx_data *rdata);\nstatic void\t   mod_ua_on_tsx_state(pjsip_transaction*, pjsip_event*);\nextern long pjsip_dlg_lock_tls_id;\t\nstruct dlg_set_head\n{\n    PJ_DECL_LIST_MEMBER(pjsip_dialog);\n};\nstruct dlg_set\n{\n    pj_hash_entry_buf ht_entry;\n    struct dlg_set_head  dlg_list;\n};\nstatic struct user_agent\n{\n    pjsip_module\t mod;\n    pj_pool_t\t\t*pool;\n    pjsip_endpoint\t*endpt;\n    pj_mutex_t\t\t*mutex;\n    pj_hash_table_t\t*dlg_table;\n    pjsip_ua_init_param  param;\n    struct dlg_set\t free_dlgset_nodes;\n} mod_ua = \n{\n  {\n    NULL, NULL,\t\t    \n    { \"mod-ua\", 6 },\t    \n    -1,\t\t\t    \n    PJSIP_MOD_PRIORITY_UA_PROXY_LAYER,\t\n    &mod_ua_load,\t    \n    NULL,\t\t    \n    NULL,\t\t    \n    &mod_ua_unload,\t    \n    &mod_ua_on_rx_request,  \n    &mod_ua_on_rx_response, \n    NULL,\t\t    \n    NULL,\t\t    \n    &mod_ua_on_tsx_state,   \n  }\n};\nPJ_DEF(pj_status_t) pjsip_ua_init_module( pjsip_endpoint *endpt,\n\t\t\t\t\t  const pjsip_ua_init_param *prm)\n{\n    pj_status_t status;\n    PJ_ASSERT_RETURN(mod_ua.mod.id == -1, PJ_EINVALIDOP);\n    if (prm)\n\tpj_memcpy(&mod_ua.param, prm, sizeof(pjsip_ua_init_param));\n    status = pjsip_endpt_register_module(endpt, &mod_ua.mod);\n    return status;\n}\nPJ_DEF(pjsip_user_agent*) \nPJ_DEF(pjsip_endpoint*) \nPJ_DEF(pj_status_t) pjsip_ua_destroy(void)\n{\n    PJ_ASSERT_RETURN(mod_ua.mod.id != -1, PJ_EINVALIDOP);\n    return pjsip_endpt_unregister_module(mod_ua.endpt, &mod_ua.mod);\n}\nPJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t   pjsip_dialog *dlg )\n{\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&\n\t\t     dlg->local.tag_hval != 0, PJ_EBUG);\n    //PJ_ASSERT_RETURN(dlg->role==PJSIP_ROLE_UAC ||\n    //\t\t     (dlg->role==PJSIP_ROLE_UAS && dlg->remote.info->tag.slen\n    //\t\t      && dlg->remote.tag_hval != 0), PJ_EBUG);\n    pj_mutex_lock(mod_ua.mutex);\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\tstruct dlg_set *dlg_set;\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower( mod_ua.dlg_table,\n                                     dlg->local.info->tag.ptr, \n\t\t\t             (unsigned)dlg->local.info->tag.slen,\n\t\t\t             &dlg->local.tag_hval);\n\tif (dlg_set) {\n\t    pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\t    dlg->dlg_set = dlg_set;\n\t} else {\n\t    dlg_set = alloc_dlgset_node();\n\t    pj_list_init(&dlg_set->dlg_list);\n\t    pj_list_push_back(&dlg_set->dlg_list, dlg);\n\t    dlg->dlg_set = dlg_set;\n\t    pj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t\t         dlg->local.info->tag.ptr,\n                                 (unsigned)dlg->local.info->tag.slen,\n\t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                                 dlg_set);\n\t}\n    } else {\n\tstruct dlg_set *dlg_set;\n\tdlg_set = alloc_dlgset_node();\n\tpj_list_init(&dlg_set->dlg_list);\n\tpj_list_push_back(&dlg_set->dlg_list, dlg);\n\tdlg->dlg_set = dlg_set;\n\tpj_hash_set_np_lower(mod_ua.dlg_table, \n\t\t             dlg->local.info->tag.ptr,\n                             (unsigned)dlg->local.info->tag.slen,\n\t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n    }\n    pj_mutex_unlock(mod_ua.mutex);\n    return PJ_SUCCESS;\n}\nPJ_DEF(pj_status_t) pjsip_ua_unregister_dlg( pjsip_user_agent *ua,\n\t\t\t\t\t     pjsip_dialog *dlg )\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *d;\n    PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(dlg->dlg_set, PJ_EINVALIDOP);\n    pj_mutex_lock(mod_ua.mutex);\n    dlg_set = (struct dlg_set*) dlg->dlg_set;\n    d = dlg_set->dlg_list.next;\n    while (d != (pjsip_dialog*)&dlg_set->dlg_list && d != dlg) {\n\td = d->next;\n    }\n    if (d != dlg) {\n\tpj_assert(!\"Dialog is not registered!\");\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n    pj_list_erase(dlg);\n    if (pj_list_empty(&dlg_set->dlg_list)) {\n\tpj_hash_set_lower(NULL, mod_ua.dlg_table, dlg->local.info->tag.ptr,\n\t\t          (unsigned)dlg->local.info->tag.slen, \n\t\t\t  dlg->local.tag_hval, NULL);\n\tpj_list_push_back(&mod_ua.free_dlgset_nodes, dlg_set);\n    }\n    pj_mutex_unlock(mod_ua.mutex);\n    return PJ_SUCCESS;\n}\nPJ_DEF(pjsip_dialog*) \nPJ_DEF(pjsip_dialog*) \nPJ_DEF(pjsip_dialog*) \nPJ_DEF(unsigned) \nPJ_DEF(pjsip_dialog*) pjsip_ua_find_dialog(const pj_str_t *call_id,\n\t\t\t\t\t   const pj_str_t *local_tag,\n\t\t\t\t\t   const pj_str_t *remote_tag,\n\t\t\t\t\t   pj_bool_t lock_dialog)\n{\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n    PJ_ASSERT_RETURN(call_id && local_tag && remote_tag, NULL);\n    pj_mutex_lock(mod_ua.mutex);\n    dlg_set = (struct dlg_set*)\n    \t      pj_hash_get_lower(mod_ua.dlg_table, local_tag->ptr,\n                                (unsigned)local_tag->slen, NULL);\n    if (dlg_set == NULL) {\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\t\n\tif (pj_stricmp(&dlg->remote.info->tag, remote_tag) == 0)\n\t    break;\n\tdlg = dlg->next;\n    }\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\tpj_mutex_unlock(mod_ua.mutex);\n\treturn NULL;\n    }\n    if (pj_strcmp(&dlg->call_id->id, call_id)!=0) {\n\tPJ_LOG(6, (THIS_FILE, \"Dialog not found: local and remote tags \"\n\t\t              \"matched but not call id\"));\n        pj_mutex_unlock(mod_ua.mutex);\n        return NULL;\n    }\n    if (lock_dialog) {\n\tif (pjsip_dlg_try_inc_lock(dlg) != PJ_SUCCESS) {\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    pjsip_dlg_inc_lock(dlg);\n\t} else {\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t}\n    } else {\n\tpj_mutex_unlock(mod_ua.mutex);\n    }\n    return dlg;\n}\nstatic struct dlg_set *find_dlg_set_for_msg( pjsip_rx_data *rdata )\n{\n    if (rdata->msg_info.cseq->method.id == PJSIP_CANCEL_METHOD) {\n\tpjsip_dialog *dlg;\n\tpj_str_t key;\n\tpjsip_role_e role;\n\tpjsip_transaction *tsx;\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    role = PJSIP_ROLE_UAS;\n\telse\n\t    role = PJSIP_ROLE_UAC;\n\tpjsip_tsx_create_key(rdata->tp_info.pool, &key, role, \n\t\t\t     pjsip_get_invite_method(), rdata);\n\ttsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);\n\tif (tsx) {\n\t    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];\n\t    pj_grp_lock_dec_ref(tsx->grp_lock);\n\t    return dlg ? (struct dlg_set*) dlg->dlg_set : NULL;\n\t} else {\n\t    return NULL;\n\t}\n    } else {\n\tpj_str_t *tag;\n\tstruct dlg_set *dlg_set;\n\tif (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)\n\t    tag = &rdata->msg_info.to->tag;\n\telse\n\t    tag = &rdata->msg_info.from->tag;\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, tag->ptr, \n\t\t\t\t    (unsigned)tag->slen, NULL);\n\treturn dlg_set;\n    }\n}\nstatic pj_bool_t mod_ua_on_rx_request(pjsip_rx_data *rdata)\n{\n    struct dlg_set *dlg_set;\n    pj_str_t *from_tag;\n    pjsip_dialog *dlg;\n    pj_status_t status;\n    if (rdata->msg_info.to->tag.slen == 0 && \n\trdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)\n    {\n\treturn PJ_FALSE;\n    }\n    if (rdata->msg_info.msg->line.req.method.id == PJSIP_REGISTER_METHOD)\n\treturn PJ_FALSE;\nretry_on_deadlock:\n    pj_mutex_lock(mod_ua.mutex);\n    dlg_set = find_dlg_set_for_msg(rdata);\n    if (dlg_set == NULL) {\n\tpj_mutex_unlock(mod_ua.mutex);\n\tif (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Unable to find dialogset for %s, answering with 481\",\n\t\t      pjsip_rx_data_get_info(rdata)));\n\t    pjsip_endpt_respond_stateless( mod_ua.endpt, rdata, 481, NULL, \n\t\t\t\t\t   NULL, NULL );\n\t}\n\treturn PJ_TRUE;\n    }\n    from_tag = &rdata->msg_info.from->tag;\n    dlg = dlg_set->dlg_list.next;\n    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\tif (pj_stricmp(&dlg->remote.info->tag, from_tag) == 0)\n\t    break;\n\tdlg = dlg->next;\n    }\n    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\tpjsip_dialog *first_dlg = dlg_set->dlg_list.next;\n\tif (first_dlg->remote.info->tag.slen != 0) {\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s, answering with 481\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\t\tpjsip_endpt_respond_stateless(mod_ua.endpt, rdata,\n\t\t\t\t\t      PJSIP_SC_CALL_TSX_DOES_NOT_EXIST, \n\t\t\t\t\t      NULL, NULL, NULL);\n\t    } else {\n\t\tPJ_LOG(5,(THIS_FILE, \n\t\t          \"Unable to find dialog for %s\",\n\t\t          pjsip_rx_data_get_info(rdata)));\n\t    }\n\t    return PJ_TRUE;\n\t}\n\tdlg = first_dlg;\n    }\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for request\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n    pj_mutex_unlock(mod_ua.mutex);\n    pjsip_dlg_on_rx_request(dlg, rdata);\n    pjsip_dlg_dec_lock(dlg);\n    return PJ_TRUE;\n}\nstatic pj_bool_t mod_ua_on_rx_response(pjsip_rx_data *rdata)\n{\n    pjsip_transaction *tsx;\n    struct dlg_set *dlg_set;\n    pjsip_dialog *dlg;\n    pj_status_t status;\nretry_on_deadlock:\n    dlg = NULL;\n    pj_mutex_lock(mod_ua.mutex);\n    tsx = pjsip_rdata_get_tsx(rdata);\n    if (tsx) {\n\tdlg = pjsip_tsx_get_dlg(tsx);\n\tif (!dlg) {\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\tdlg_set = (struct dlg_set*) dlg->dlg_set;\n    } else {\n\tpjsip_cseq_hdr *cseq_hdr = rdata->msg_info.cseq;\n\tif (cseq_hdr->method.id != PJSIP_INVITE_METHOD ||\n\t    rdata->msg_info.msg->line.status.code / 100 != 2)\n\t{\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    return PJ_FALSE;\n\t}\n\tdlg_set = (struct dlg_set*)\n\t\t  pj_hash_get_lower(mod_ua.dlg_table, \n\t\t\t            rdata->msg_info.from->tag.ptr,\n\t\t\t            (unsigned)rdata->msg_info.from->tag.slen,\n\t\t\t            NULL);\n\tif (!dlg_set) {\n\t    pj_mutex_unlock(mod_ua.mutex);\n\t    PJ_LOG(4,(THIS_FILE, \n\t\t      \"Received strayed 2xx response (no dialog is found)\"\n\t\t      \" from %s:%d: %s\",\n\t\t      rdata->pkt_info.src_name, rdata->pkt_info.src_port,\n\t\t      pjsip_rx_data_get_info(rdata)));\n\t    return PJ_TRUE;\n\t}\n    }\n    pj_assert(dlg_set && !pj_list_empty(&dlg_set->dlg_list));\n    //This doesn't work when there is authentication challenge, since \n    //first_cseq evaluation will yield false.\n    //if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD &&\n    //\trdata->msg_info.cseq->cseq == dlg_set->dlg_list.next->local.first_cseq)\n    if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD) {\n\tint st_code = rdata->msg_info.msg->line.status.code;\n\tpj_str_t *to_tag = &rdata->msg_info.to->tag;\n\tdlg = dlg_set->dlg_list.next;\n\twhile (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {\n\t    if (dlg->remote.info->tag.slen == 0)\n\t\tbreak;\n\t    if (pj_stricmp(to_tag, &dlg->remote.info->tag) == 0)\n\t\tbreak;\n\t    dlg = dlg->next;\n\t}\n\tif (dlg == (pjsip_dialog*)&dlg_set->dlg_list &&\n\t    ((st_code/100==1 && st_code!=100) || st_code/100==2)) \n\t{\n\t    PJ_LOG(5,(THIS_FILE, \n\t\t      \"Received forked %s for existing dialog %s\",\n\t\t      pjsip_rx_data_get_info(rdata), \n\t\t      dlg_set->dlg_list.next->obj_name));\n\t    if (mod_ua.param.on_dlg_forked) {\n\t\tdlg = (*mod_ua.param.on_dlg_forked)(dlg_set->dlg_list.next, \n\t\t\t\t\t\t    rdata);\n\t\tif (dlg == NULL) {\n\t\t    pj_mutex_unlock(mod_ua.mutex);\n\t\t    return PJ_TRUE;\n\t\t}\n\t    } else {\n\t\tdlg = dlg_set->dlg_list.next;\n\t\tPJ_LOG(4,(THIS_FILE, \n\t\t\t  \"Unhandled forked %s from %s:%d, response will be \"\n\t\t\t  \"handed over to the first dialog\",\n\t\t\t  pjsip_rx_data_get_info(rdata),\n\t\t\t  rdata->pkt_info.src_name, rdata->pkt_info.src_port));\n\t    }\n\t} else if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {\n\t    dlg = dlg_set->dlg_list.next;\n\t}\n    } else {\n\tpj_assert(tsx != NULL);\n\tpj_assert(dlg != NULL);\n    }\n    pj_assert(dlg != NULL);\n    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;\n    PJ_LOG(6,(dlg->obj_name, \"UA layer acquiring dialog lock for response\"));\n    status = pjsip_dlg_try_inc_lock(dlg);\n    if (status != PJ_SUCCESS) {\n\tpj_mutex_unlock(mod_ua.mutex);\n\tpj_thread_sleep(0);\n\tgoto retry_on_deadlock;\n    }\n    pj_mutex_unlock(mod_ua.mutex);\n    pjsip_dlg_on_rx_response(dlg, rdata);\n    pjsip_dlg_dec_lock(dlg);\n    return PJ_TRUE;\n}\n#if PJ_LOG_MAX_LEVEL >= 3\nstatic void print_dialog( const char *title,\n\t\t\t  pjsip_dialog *dlg, char *buf, pj_size_t size)\n{\n    int len;\n    char userinfo[PJSIP_MAX_URL_SIZE];\n    len = pjsip_hdr_print_on(dlg->remote.info, userinfo, sizeof(userinfo));\n    if (len < 0)\n\tpj_ansi_strcpy(userinfo, \"<--uri too long-->\");\n    else\n\tuserinfo[len] = '\\0';\n    len = pj_ansi_snprintf(buf, size, \"%s[%s]  %s\",\n\t\t\t   title,\n\t\t\t   (dlg->state==PJSIP_DIALOG_STATE_NULL ? \" - \" :\n\t\t\t\t\t\t\t     \"est\"),\n\t\t      userinfo);\n    if (len < 1 || len >= (int)size) {\n\tpj_ansi_strcpy(buf, \"<--uri too long-->\");\n    } else\n\tbuf[len] = '\\0';\n}\n#endif\nPJ_DEF(void) pjsip_ua_dump(pj_bool_t detail)\n{\n#if PJ_LOG_MAX_LEVEL >= 3\n    pj_hash_iterator_t itbuf, *it;\n    char dlginfo[128];\n    pj_mutex_lock(mod_ua.mutex);\n    PJ_LOG(3, (THIS_FILE, \"Number of dialog sets: %u\", \n\t\t\t  pj_hash_count(mod_ua.dlg_table)));\n    if (detail && pj_hash_count(mod_ua.dlg_table)) {\n\tPJ_LOG(3, (THIS_FILE, \"Dumping dialog sets:\"));\n\tit = pj_hash_first(mod_ua.dlg_table, &itbuf);\n\tfor (; it != NULL; it = pj_hash_next(mod_ua.dlg_table, it))  {\n\t    struct dlg_set *dlg_set;\n\t    pjsip_dialog *dlg;\n\t    const char *title;\n\t    dlg_set = (struct dlg_set*) pj_hash_this(mod_ua.dlg_table, it);\n\t    if (!dlg_set || pj_list_empty(&dlg_set->dlg_list)) continue;\n\t    dlg = dlg_set->dlg_list.next;\n\t    if (dlg->role == PJSIP_ROLE_UAC)\n\t\ttitle = \"  [out] \";\n\t    else\n\t\ttitle = \"  [in]  \";\n\t    print_dialog(title, dlg, dlginfo, sizeof(dlginfo));\n\t    PJ_LOG(3,(THIS_FILE, \"%s\", dlginfo));\n\t    dlg = dlg->next;\n\t    while (dlg != (pjsip_dialog*) &dlg_set->dlg_list) {\n\t\tprint_dialog(\"    [forked] \", dlg, dlginfo, sizeof(dlginfo));\n\t\tdlg = dlg->next;\n\t    }\n\t}\n    }\n    pj_mutex_unlock(mod_ua.mutex);\n#endif\n}\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_7306.c",
        "project": "pjsip/pjproject",
        "url": "https://github.com/pjsip/pjproject/commit/db3235953baa56d2fb0e276ca510fefca751643f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```main(int argc, char *argv[])\n    char buf[10000];\n    optct = optionProcess(&tcpcapinfoOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n    for (i = 0; i < argc; i++) {\n        dbgx(1, \"processing:  %s\\n\", argv[i]);\n        if ((fd = open(argv[i], O_RDONLY)) < 0)\n            errx(-1, \"Error opening file %s: %s\", argv[i], strerror(errno));\n        if (fstat(fd, &statinfo) < 0)\n            errx(-1, \"Error getting file stat info %s: %s\", argv[i], strerror(errno));\n        if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))\n            errx(-1, \"File too small.  Unable to read pcap_file_header from %s\", argv[i]);\n        memcpy(&pcap_fh, &buf, sizeof(pcap_fh));\n        pkthdrlen = 16; \n            pkthdrlen = sizeof(pcap_patched_ph);\n            pkthdrlen = sizeof(pcap_patched_ph);\n        if (swapped == 1) {\n            pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);\n        }\n        dbgx(5, \"Packet header len: %d\", pkthdrlen);\n        if (pkthdrlen == 24) {\n        } else {\n        while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {\n            memset(&pcap_ph, 0, sizeof(pcap_ph));\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));\n                if (swapped == 1) {\n                    pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);\n                }\n                if (pcap_fh.snaplen < pcap_patched_ph.caplen) {\n                }\n                caplen = pcap_patched_ph.caplen;\n            } else {\n                memcpy(&readword, buf, 4);\n                pcap_ph.ts.tv_sec = readword;\n                memcpy(&readword, &buf[4], 4);\n                pcap_ph.ts.tv_usec = readword;\n                memcpy(&pcap_ph.caplen, &buf[8], 4);\n                memcpy(&pcap_ph.len, &buf[12], 4);\n                if (swapped == 1) {\n                    pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);\n                }\n                if (pcap_fh.snaplen < pcap_ph.caplen) {\n                }\n                caplen = pcap_ph.caplen;\n            }\n            if (last_sec > 0 && last_usec > 0) {\n            }\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n            } else {\n            }\n            if ((ret = read(fd, &buf, caplen)) != caplen) {\n                if (ret < 0) {\n                    printf(\"Error reading file: %s: %s\\n\", argv[i], strerror(errno));\n                } else {\n                close(fd);\n            }\n            printf(\"\\t%x\\t\", do_checksum_math((u_int16_t *)buf, caplen));\n        }\n    }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n02/26/2017 Version 4.2.0beta1\n    - Update git-clone instructions by Kyle McDonald (#277) \n    - Add protection against packet drift by Guillaume Scott (#268)\n    - Include Travis-CI build support by Ilya Shipitsin (#264) (#285)\n\n11/19/2016 Version 4.1.2\n    - Fix compilation with musl C library (#260)\n    - Support parallel builds (#259)\n    - Give user CFLAGS precedence (#256)\n    - Properly detect Brew install when Xcode is not available (#254)\n    - Increase max packet size to 65549 (#251)\n    - Handle IP headers with zero length (#247)\n\n01/11/2016 Version 4.1.1\n    - Improve --pps accuracy and performance (#236)\n    - Option --unique-ip accepts --duration (#227)\n    - RFC1624 incremental checksums (#225)\n    - Option --duration performance optimizations (#223)\n    - Correct company name in license (#217)\n    - Compile and mult-arch cross-compile on ARM (#211)\n    - Switch to wire speed after 30 minutes at 6 Gbps (#210)\n    - Tap device support for Linux and FreeBSD from Murat Demirten (#207)\n    - Handle loopback for linux cooked capture files from corentin-p1(Linux SLL) (#204)\n    - Master doesn't compile on OS X 10.11 (#203)\n    - Recognise tbd stubs from Dominyk Tiller (#202)\n    - Support for tcprewrite multiple IP CIDR (#199)\n    - Fix incorrect checksums after editing fragmented packets (#190)\n    - Option --loop=0 full wire wire speed after 1st pass (#172 #191)\n    - Big-endian tcpliveplay work-around from Brian Micek (#194)\n    - Build OS X using existing XCode SDK (#185)\n    - Update to autogen version 5.18.6 and libopts 46.0.16 (#182)\n    - netmap reports impossibly high capacity (#176)\n    - Duration feature from dexteradeus (#175)\n    - Stop sending and exit when limit is reached (#174)\n    - Extra packets sent with -L option (#173)\n    - Buffer overflow bug in tcpprep (#167)\n    - netmap optimizations (#93)\n\n12/17/2014 Version 4.1.0\n    - Do not build Quick TX modules on OS X (#164)\n    - Add a flag to customize netmap delay (#160)\n    - Fix some compile wwarnings (#159)\n    - Disabled QuickTX build by default (#157)\n    - Less verbose build (#154)\n    - Add a loop delay option (#125)\n    - CentOS 6.5 kernel panic on Quick TX init (#146)\n    - Fix libpcap not found on CentOS 7 (#145)\n    - Segfault in tcpliveplay on x86_64 (#132)\n    - Sometimes unable to interrupt with Ctrl-C (#129)\n\n10/08/2014 Version 4.1.0beta1\n    - Fix cross compiling (#140)\n    - Add Quick TX module for Linux (#136)\n\t- Better recovery for missing static libpcap libs (#128)\n\n09/05/2014 Version 4.0.5\n    - Fix build failure with latest netmap 11 (#123)\n    - Fix unable to use Zero Copy interfaces on PF_RING (#118)\n    - Corrected build for latest version of PF_RING (#81)\n    - Proper error message when vale is unconfigured (#113)\n    - Avoid a netmap module debug message (#110)\n    - Add missing header to distribution (#108)\n    - Make --netmap version agnostic (#106)\n    - Fix netmap hang in FreeBSD 11 (#103)\n    - Fix netmap hang if network cables unplugged (#96)\n    - Support for Vale Switch (#91)\n    - Prevent file retransmissions when selecting multiple files (#86)\n    - Fix max replay rate for all loops except first when omitting --mbps (#85)\n    - Add missing sanity check in libopt (#84)\n    - Seg fault on some IPv6 files when using -C option with tcprewrite (#83)\n    - Support for PF_RING DNA version of libpcap (#81)\n    - Fix segfault when using '-F pad' (#80)\n    - Disallow netmap on multiple interfaces (#79)\n    - Fix build for FreeBSD version 8.4 (#78)\n\n03/22/2014 Version 4.0.4\n    - Number of packets inaccurate when using --netmap method (#76)\n    - Unexpected packet counts with --loop and --cachefile enabled (#75)\n    - Improved error messages when interface is a file (#74)\n    - Missing interfaces with --listnics option (#67)\n    - Compile issue with netmap v10 and debugging (#66)\n    - Bad values with --stats and -t options (#65)\n\n02/04/2014 Version 4.0.3\n    - Fix build errors when ENABLE_VERBOSE is not set (#60)\n    - Build error on host without tcpdump (#59)\n\n01/17/2014 Version 4.0.2\n    - Fix hangs with --mbps command (#54)\n\n01/16/2014 Version 4.0.1\n    - Support for netmap version 10 API (#53)\n    - Remove deprecated \"absolute time\" for OS X (#52)\n    - Make dosleep() rentrant to support API concurrency (#51)\n    - Remove compiler warnings (#50)\n    - Fix slow netmap in Intel GigE \"igb\" server NICS (#49)\n\n01/05/2014 Version 4.0.0\n    - Implemented wiki page for 4.X - http://tcpreplay.appneta.com\n    - Support for ARM aarch64 (appneta #43)\n    - Add Juniper Encapsulated Ethernet DLT (appneta #42)\n    - Fixed seg fault on -K and --dualfile options (appneta #41)\n\n12/22/2013 Version 4.0.0beta2\n    - Restored -K option which somehow disappeared (appneta #35)\n    - Improve printing with small pcaps at high rates (appneta #34)\n    - Fixed build errors on BSD and Fedora 20 (appneta #32 #33)\n\n12/20/2013 Version 4.0.0beta1\n    - Compile and cross compile on ARM (appneta #26)\n    - Add flow statistics (appneta #23)\n    - Merge code cleanups from old 4.0alpha1 project (appneta #18)\n    - Deprecated file-cache option - use preload-pcap instead (appneta #17)\n    - Removed obsolete sleep-mode and sleep-accel options (appneta #16)\n    - Remove unreliable RDTSC option (appneta #16)\n    - Switch from BSD to GPLv3 license (appneta #5)\n    - Add --unique-ip option to tcpreplay (appneta #4)\n    - Removed sleep-accel option (appneta #2)\n    - Enhance accuracy and performance of --mbps option (appneta #2)\n    - Add netmap injector (appneta #1)\n    - Properly process IPv6 extension headers (#396)\n    - Update URL's to point to new tcpreplay website (#430)\n    - Improve & fix bugs in tcpcapinfo (#437)\n    - Fix statistics to be more industry standard (#443)\n    - Add --nofixcsum (#449)\n    - Fix compile failure under FreeBSD 9.0 (#450)\n    - Don't checksum packets before going through fragroute engine (#452)\n    - Add support for --maxsleep option to tcpreplay (#453)\n    - Fix segfault when rewriting multiple ports (#459)\n    - Fix bug with printing stats after CTRL-C (#482)\n    - Update autotools (#483)\n    - Don't recalculate UDP checksums if it's value is 0 (#490)\n    - Fix documentation of --efcs option to be 4, not 2 bytes (#495)\n    - Fix libdnet header detection under Debian distros (#499)\n    - Update GNU Autogen to 5.11.5 (#501)\n    - Fix --stats option for tcpreplay (#503)\n    - Add support for injecting directly via custom Linux kernel module (#505)\n    - Fix cidr code debugging (#506)\n    - Standardize on primary/secondary meaning of interfaces/tcpprep split (#507)\n\n08/15/2010 Version 3.4.5beta1\n    - First pass at fixing 'make test' on many little-endian systems (#429)\n    - Warn users when processing LINUX_SLL frames w/o an Ethernet source MAC (#434)\n    - Don't try to fragroute non-IPv4/v6 packets so we don't error out (#432)\n    - Initial Linux TX_RING sending support (#435)\n    - Update to GNU Autoconf 2.67 (#436)\n    - Add tcpcapinfo which dumps information about the pcap header/packets (#437)\n    - Add --dualfile support for replaying two files at the same time (#439)\n    - Fix bug where --tos=0 didn't do anything (#440)\n    - Fix crash when processing CIDR data (#441)\n\n04/04/2010 Version 3.4.4\n    - Set default timing method to either gtod or abstime (#404)\n    - Fix IPv6 parsing of CIDR's (#405)\n    - Add support for preloading the memory cache (#410)\n    - Generate more useful error when packets are too small (#411)\n    - Update to libopts/Autogen 5.9.9 (#412)\n    - Ship Win32Readme.txt file (#413)\n    - Update copyright notice to 2010 (#416)\n    - Dramatically enhance --portmap option (#417)\n    - Update autotools (#423)\n    - Add support for printing statistics periodically during the run (#424)\n    - Warn user when pcap snaplen < 65535 (#425)\n    - Add 802.1q processing support tcpprep (#428)\n\n06/25/2009: Version 3.4.3\n    - Link libnl when newer versions of libpcap require it (#397)\n    - Ship m4 directory (#398)\n    - Upgrade to latest autotools scripts (#400)\n    - Fix error message when running autogen.sh (#401)\n\n05/20/2009: Version 3.4.2\n    - Added extensive IPv6 support to tcprewrite & tcpreplay-edit (#11)\n    - Add IPv6 fragroute support (#388)\n    - Add IPv6 decoding support to tcpprep (#11)\n    - Fix compile time error in err.h (#390)\n    - Add --endpoints support in tcpreplay-edit (#393)\n\n02/18/2009: Version 3.4.1\n    - Sendpacket method did not match documentation (#361)\n    - Fix compile issue on systems without err.h (#363)\n    - Fix tcpprep --mac not processing non-IPv4 packets (#369)\n    - Always build tcpreplay w/ editing features as tcpreplay-edit (#372)\n    - Fix potential tcpbridge issues under OS X & *BSD (#373)\n    - Fix crash on 4 byte strictly aligned systems (#377)\n    - Add MTU truncation to tcprewrite/tcpreplay-edit (#379)\n\n01/15/2009: Version 3.4.0\n    - Add libdnet and remove libnet support for sending packets (#302)\n    - Fix numerous 802.11 decoder bugs (#325)\n    - Fix compile issue under Linux (#326)\n    - Fix Mbps/sec nonsense (#327)\n    - Fix tcprewrite crash when packets have no L3+ data (#328)\n    - Clean up err.c/err.h code and improve performance for non-debug builds (#331)\n    - Fix timesdiv() timer code (#332)\n    - Improve high-performance packet sending via multiple packets/interval (#334)\n    - Fix statistics report errors (#335)\n    - Fix BPF filters not being used in tcpbridge (#336)\n    - Improve tcpbridge performance (#337)\n    - Only use two libpcap handles for tcpbridge (#338)\n    - Fix autotools usage errors (#340)\n    - Clean up 'make test' results (#341)\n    - Update to AutoGen/AutoOpts 5.9.7 (#342)\n    - Fix compiler warnings from GCC 4.2 (#344)\n    - Fix numerous memory corruption bugs in libtcpedit DLT plugin code (#345)\n    - Add support for editing IPv4 TOS/DiffServ/ECN (#348)\n    - Update autotools to more recent versions (#349)\n    - Report injection method via -V (#352)\n    - Fix DLT_USER l2len check bug (#353)\n    - Replace man2html w/ groff (#354)\n    - Fix false pcap_inject() detection under Windows/Winpcap (#355)\n    - tcpbridge now builds under Win32/Cygwin\n    - libdnet is no longer an option for Win32/Cygwin (#57)\n    - tcpbridge now supports --listnics (#357)\n\n06/20/2008: Version 3.3.2\n    - Fix (again) tcpbridge --unidir assert error (#308)\n    - Fix tcpbridge bug where all packets that were sent were all zeros\n    - Fix tcpbridge not honoring --include/exclude flags (#311)\n    - Fix ip_in_cidr() debug messages (#312)\n    - Report packets which have timestamps which go backwards in time (#315)\n    - Clean up --sleep-accel code to use options struct (#316)\n    - Remove really old and out of date RPM .spec file (#317)\n    - Warn when sending on non-Ethernet interface (#318)\n    - Re-enable tcpreplay --listnics (#319)\n    - Fix sendpacket always reporting using PF_PACKET, even when it doesn't (#322)\n    - Fix major packet timing issue under old versions of glibc (#324)\n\n05/17/2008: Version 3.3.1\n    - Fix limitation of PF_PACKET only supporting Ethernet (#123)\n    - Fix (again) /dev/bpf detection in FreeBSD 8.0 (#292)\n    - Document building code from Subversion under Cygwin (#304)\n    - Fix --enable-force-* under Linux (#305)\n    - Fix tcpbridge --unidir assert error (#308)\n\n05/04/2008: Version 3.3.0\n    - Improve tcpreplay timing accuracy between packets (#41)\n    - Add tcprewrite fragroute support (#42)\n    - Fix tcprewrite --efcs option (#277)\n    - Updated Win32/Cygwin documentation (#280)\n    - Add dmalloc support (#282)\n    - Fix tcpprep broken handling of VLAN tagged frames (#290)\n    - Fix tcprewrite crash when cache file has NO_SEND packets (#291)\n    - Fix /dev/bpf detection in FreeBSD 8.0 (#292)\n    - Add tcprewrite --ttl editing option (#294)\n    - Fix autoconf AM_PROG_CC_C_O warning (#295)\n    - Add tcpprep --reverse option to split by matching client addresses (#297)\n    - Update version of autoconf to 1.10.1 (#298)\n    - Improved GNU Autogen detection and warnings (#299)\n    - Track EAGAIN errors separately from ENOBUFS (#301)\n    - Automatically detect Winpcap on Cygwin (#303)\n\n01/23/2008: Version 3.2.5\n    - Fix linker error with --enable-tcpreplay-edit and --enable-dynamic-link (#288)\n    - Fix compile errors with Sun Studio compiler (#286)\n\n01/16/2008: Version 3.2.4\n    - Fix crash in tcpreplay when --enable-tcpreplay-edit (#281)\n    - Display if --enable-tcpreplay-edit in -V (#283)\n\n11/01/2007: Version 3.2.3\n    - Fix compile issue under Linux and other OS's (#275)\n\n10/31/2007: Version 3.2.2\n    - Enable source MAC spoofing for OS X (#142, #151)\n        * Tcpreplay now requires OS X 10.5 (Leopard)\n    - Fix crash/memory access error with tcpreplay -N (#273)\n\n10/25/2007: Version 3.2.1\n    - Fix tcprewrite segfault in 'make test' under Linux (#200)\n    - Major performance improvement in tcpprep for large pcaps (#261)\n    - Fix strsignal already defined error under Cygwin/Windows (#199)\n    - Fix compile errors for older versions of GCC (#201)\n    - Remove flowreplay code (#262)\n    - Fix DLT rewrite code causing corrupted ethernet protocol type (#268)\n    - Try to fix inet_aton() issue under Solaris (#260)\n\n08/26/2007: Version 3.2\n    - Return a more useful error message when tcpprep fails (#187)\n    - Add Tomahawk test tool client/server detection algorithm (#186)\n    - Improved AutoGen support (#191)\n    - Improved documentation (#164, #198)\n    - Added Doxygen markup (#176)\n    - configure now honors --with-tcpdump flag (#192)\n    - configure now defaults to --enable-64bits which breaks backwards\n        compatibility in certain situations.  Use --disable-64bits if this\n        concerns you (#195)\n    - Use safe_free() to detect bugs earlier in development (#197)\n\n07/19/2007: Version 3.1.1\n    - Upgrade libopts tearoff to 29:0:4 so that everyone else in the world can\n      compile tcpreplay (#189)\n\n07/18/2007: Version 3.1.0\n    - Add tcprewrite --srcmap & --dstmap for rewriting only source or destination IP's (#185)\n    - ./configure now reports configuration at end (#155)\n    - Fix svn:keywords (#160)\n    - Optimize performance of dlt_en10mb plugin (#161)\n    - Performance improvements on strictly aligned systems (#162)\n    - Improve tcpprep error messages and handling (#163)\n    - Add support for warnings in libtcpedit (#165)\n    - Only use __attribute__((unused)) w/ GCC (#168)\n    - Fix compile issues under Solaris (#178)\n    - Gracefully handle systems w/o static libraries (#179)\n    - Fix segfault when using BPF filters (#182)\n    - Add additional DLT Plugins:\n        - 802.11 (#103)\n        - 802.11 w/ Radiotap (#177)\n\n05/01/2007: Version 3.0.1\n    - Stop tcpreplay causing OS X WiFi from disassociating (#167)\n    - --pnat incorrectly matched all IP addresses (#170)\n    - Fix serious memory leak in core common library (#175)\n    - Fix tcprewrite --enet-vlan on little endian systems (#174)\n    - Bad pcap timestamps were causing excessive delays (#169)\n    - Code cleanup (#173)\n\n04/20/2007: Version 3.0\n    - By default, no longer try to use libnet.  You must now specify --enable-libnet (#148)\n    - Improve documentation (#30)\n    - General code cleanup (#47)\n    - Warn when GNU Autogen version < 5.9 (#153)\n    - Remove support for pcap_snapshot_override which was never added to libpcap (#140)\n    - Fix support for C99/GCC 4.3 \"inline\".  Rely on -O3 for better performance. (#149)\n    - Prioritize 64 bit libraries over 32 bit counterparts (#150)\n\n04/14/2007: Version 3.0.RC1\n    - Fix tcpbridge and make it compile by default (#15)\n    - Fix tcprewrite crash on little-endian systems (#127)\n    - Gracefully handle broken pcap files where the snaplen < caplen (#130)\n        - Note: Fix was made in libpcap and will be part of 0.9.6\n    - Fix numerous bugs with the sendpacket code (#137)\n    - Add optional support for editing packets with tcpreplay (#61)\n    - Fix 'make test' on little endian systems (#64)\n    - tcprewrite -s is no longer endian dependent (#65)\n    - /docs cleaned up (#66)\n    - Fix detection/compile of libpcap.  Now support versions >= 0.7.2 (#80, #144)\n    - Add official support Cygwin/Win32 support (#110)\n    - Clean up libpcap version code (#111)\n    - Add support for interface alias names for Win32 (#113)\n    - Warn user on DLT miss-match (#125)\n    - Fix tcprewrite segfault with --fixlen=pad (#134)\n    - Add loop/cache support for better performance (#136)\n    - inline debugging code for better performance (#138)\n    - configure now supports selecting injection method (#139)\n    - Fix configure/compile errors under OpenBSD (#146)\n    - Add tcpbridge --verbose mode (#28)\n    - Fix compile issues under HP-UX & strictly aligned systems (#141)\n    - --enable-dynamic-link supports 64bit libraries (#143)\n\n\n03/22/2007: Version 3.0.beta13\n    - Fixed detection of IPv4 packets in libtcpedit on little-endian boxes (#115, #116)\n    - Fixed TCP/UDP checksum calculation on little-endian boxes (#126)\n    - Added --quiet flag to tcpreplay for Lothar (#109)\n    - The --seed flag should now generate the same IPs on both little-endian & big-endian boxes (#65)\n    - The --skipl2broadcast flag now works as documented (#112)\n    - Adding L2 header for DLT_RAW encapsulated packets now works (#16)\n    - Clean up documentation (#66, #75)\n    - Start initial support for Win32 port (#110, #111)\n    - Finish DLT plugin rewrite (#82)\n    - Fix compile on systems without tcpdump installed\n\n02/22/2007: Version 3.0.beta12\n    - Fix compile under RH ES 3.x (gcc 3.2.2) (#79)\n    - Fix compile on MIPS, ARM, HPPA, etc (#81, #88)\n    - Rewrite L2/DLT code in tcpedit/tcprewrite to be plugin based (#82)\n        - Create Ethernet Plugin (#99)\n        - Create User Plugin (#100)\n        - Create Cisco HDLC Plugin (#101)\n        - Create DLT_LINUX_SLL Plugin (#102)\n        - Create DLT_RAW Plugin (#104)\n        - Create DLT_NULL Plugin (#105)\n        - Create DLT_LOOP Plugin (#106)\n    - Properly decode ethernet frames when they are VLAN tagged (#84)\n    - Do not install man2html (#85)\n    - Add configure --disable-libopts-install option (#86)\n    - Enhance tcpreplay --oneatatime (#90)\n    - libtcpedit can now return warnings & errors (#92)\n    - Fix tcpprep --include/exclude (#96)\n    - Upgrade AutoGen tearoff (libopts) to latest version (5.9.0) (#97)\n    - Don't do L4 checksums for non-fragment offset == 0 (#107)\n\n08/07/2006: Version 3.0.beta11\n    - Fix distribution to ship missing src/tcpr.h (#73)\n    - Add support to tcprewrite to alter output file DLT (#74)\n    - Fix errors in 'make test' (little endian still broken) (#77)\n    - Tweak Autogen .def files documentation (#78)\n\n08/05/2006: Version 3.0.beta10\n    - tcpprep & tcprewrite no longer require root access (#3)\n    - Develop wrapper API for libnet, libpcap, BPF and PF_PACKET (#4, #24)\n    - Enhance do_sleep() to support looping for better accuracy (#6)\n    - Prefer inet_pton over older, deprecated routines (#26)\n    - Remove libnet as a requirement (#29)\n    - Optionally don't rewrite broadcast/multicast IP/MAC addresses (#38)\n    - Remove libnids dependancy for flowreplay  (#55)\n    - Fix build issues when libpcapnav is installed (#56)\n    - Fix truncate feature not putting correct packet length in IP header (#59)\n    - Internal error reporting fixes in libtcpedit (#60)\n    - Support --enable-debug when building under gcc 3.x (#62)\n    - tcpedit_stub.h wasn't being generated automatically from SVN (#63)\n    - Fix 'make doxygen' (#67)\n    - Fix some Makefile issues (#68)\n    - tcprewrite --endpoints should require a cache file (#70)\n    - Improve IP randomizer code to be more random (#71)\n\n07/17/2006: Version 3.0.beta9\n    - Fix compile issue for users not having AutoOpts installed (#54)\n    - Fix compile issue for users w/ AutoOpts 5.8.4 (upgrade to 5.8.4)\n\n07/16/2006: Version 3.0.beta8\n    - Fix -M running in MBps rather then Mbps\n    - Fix tcpbridge segfault/bus error reported by Steven Z. (Gerry)\n    - Improve tcpbridge man page\n    - Massive tcprewrite fixes & cleanup (#50)\n    - Much improved README document\n    - Reorganize packet editing code into a standalone module (tcpedit)\n          which has been librarized. (#5)\n    - Strict code cleanup (#27)\n    - Fix tcpprep from generating bad cache files (#48)\n    - Add MAC split mode for tcpprep (#1)\n    - Improve dbg() to list file/line (#32)\n    - Add tcpprep statistical reports (#2)\n    - Reorganize flowreplay code (#46)\n    - Fix conflicting speed_t for Debian (#33)\n    - Too many other things to document\n\n08/07/2005: Version 3.0.beta7\n    - New 'make doxygen' target builds pretty source code docs in\n          docs/web/doxygen/html\n    - Fix tcpprep auto/router mode which was sending all packets out the\n          secondary interface\n    - Fix endian issue on little-endian systems which made tcpprep think all\n          packets were not IP\n    - Improve debugability of tcpprep\n    - Fix UDP header offset bug in flowreplay\n\n06/28/2005: Version 3.0.beta6\n    - Fix rpm .spec file which was still based on tcpreplay 2.x (untested)\n    - Detect and manually include pcap-bpf.h which fixes compile problem\n    - Fix tcprewrite -S crash with only one MAC\n    - Fix tcpreplay using 2nd NIC split mode\n    - Fix tcpreplay packet counter initialization\n    - Fix tcpprep to properly handle missing -i and -c with -I and -P\n\n06/14/2005: Version 3.0.beta5\n    - Fix --decode flag\n    - Fix compile under AMD64/RHEL4 where libraries are in /usr/lib64\n    - tarball now ships with a full test subdir\n    - Fix compile of src/common/get.c under strictly aligned architectures\n    - Fix ./configure --enable-64bits flag\n    - Fix bug on little endian systems which prevented tcprewrite from\n      editing packets\n    - Fix tcprewrite linktype checks\n    - Add --pktlen for when the pcap snaplen lies to us\n    - Add --enable-dynamic-link for those who want to dynamically link their\n      libs\n\n06/05/2005: Version 3.0.beta4\n    - Really fix compile problems with dlt2desc with old versions of libpcap\n    - All libraries are now statically linked and full-path #includes.  This\n      should fix problems with people who have different versions of\n      libraries installed in different locations.\n    - Fix problems compiling on systems with libpcapnav\n    - Add support for libpcap 0.5 such as on OpenBSD\n    - Fix tcpprep --verbose\n    - Close STDIN prior to re-opening it for certain OS's\n\n05/04/2005: Version 3.0.beta3\n    - Fix autoconf problems with --with-libnet\n    - Fix compile problems with dlt2desc with old versions of libpcap\n    - Fix compile problem due to not shipping flowreplay_opts.h and\n      tcpbridge_opts.h\n\n04/19/2005: Version 3.0.beta2\n    - Significant improvements to FAQ and manual\n    - Use autoopts for flowreplay\n    - Be more cautious about memcpy's\n    - Fix numerous warnings during compile\n    - Allow overriding L2 protocol field for DLT_RAW\n    - tcpprep -I & -P now take the cache filename\n    - Lots of cleanup\n    - Added tcpbridge utility\n    - Fix tcpreplay --mbps which was being interpreted as bps\n    - Add --no-arg-comment feature for tcpprep\n    - Improve auto-tests and fix old broken ones\n    - Fix Makefile errors in the docs directory\n    - Upgrade libopts tear off to v5.7pre12 which fixes problems with\n      loading config files\n    - Add support for forcing the use of the local libopts tearoff code\n\n02/27/2005: Version 3.0.beta1\n    - Major code cleanups and rewriting\n      - Rip out all edit functions from tcpreplay and put into tcprewrite\n      - Improve tcpreplay performance by about 5% for raw sending\n      - Move around utility functions for greater code-reuse\n      - Move MAC Address funcs into mac.c\n      - Move global defines into defines.h\n      - Standardize use of structs and typedefs\n      - Start passing const's when we don't need to modify\n    - Start using GNU AutoOpts for arg/config file processing\n    - Start using automake and autoheader\n    - Major rewrite of configure.in\n    - Add support for printing which interface packets go out\n    - 64bit counters are optional via --enable-64bits\n    - Can now rewrite L2 data per outbound interface\n    - Add support for additional DLT types\n\n    - Non-Code changes\n      - I now own the full copyright for tcpreplay\n      - Removed the evil 4th clause from the BSD license\n      - Start updating the FAQ and split some content to make a manual\n      - Automatically generate man pages based via autogen\n\n    - New Applications:\n      - tcprewrite\n\n    - Removed Applications: (Ethereal has better utilities)\n      - capinfo\n      - pcapmerge\n\n    - Merge fixes from 2.x/stable branch:\n      - portmap.c endian bugs\n      - edit_packet.c handle corrupted pcap's where caplen < len\n      - configure now properly uses --with-libnet and --with-libpcap\n\n*** Fork 3.x Branch from v2.3.1 ***\n\nFile number 2:\n#include \"config.h\"\n#include \"defines.h\"\n#include \"common.h\"\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include <pcap.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <inttypes.h>\n#define __STDC_FORMAT_MACROS 1\n#include <inttypes.h>\n#include \"tcpcapinfo_opts.h\"\nstatic int do_checksum_math(u_int16_t *data, int len);\n#ifdef DEBUG\nint debug = 0;\n#endif\n#ifdef WORDS_BIGENDIAN\nchar is_swapped[] = \"little-endian\";\nchar is_not_swapped[] = \"big-endian\";\n#else\nchar is_not_swapped[] = \"little-endian\";\nchar is_swapped[] = \"big-endian\";\n#endif\n#define TCPDUMP_MAGIC           0xa1b2c3d4\n#define KUZNETZOV_TCPDUMP_MAGIC 0xa1b2cd34\nstruct pcap_timeval {\n    bpf_int32 tv_sec;           \n    bpf_int32 tv_usec;          \n};\nstruct pcap_sf_patched_pkthdr {\n    struct pcap_timeval ts;     \n    bpf_u_int32 caplen;         \n    bpf_u_int32 len;            \n    int         index;\n    unsigned short protocol;\n    unsigned char pkt_type;\n};\n#define FMESQUITA_TCPDUMP_MAGIC 0xa1b234cd\n#define NAVTEL_TCPDUMP_MAGIC    0xa12b3c4d\n#define NSEC_TCPDUMP_MAGIC      0xa1b23c4d\nint\nmain(int argc, char *argv[])\n{\n    int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig;\n    struct pcap_file_header pcap_fh;\n    struct pcap_pkthdr pcap_ph;\n    struct pcap_sf_patched_pkthdr pcap_patched_ph; \n    char buf[10000];\n    struct stat statinfo;\n    uint64_t pktcnt;\n    uint32_t readword;\n    int32_t last_sec, last_usec, caplen;\n    optct = optionProcess(&tcpcapinfoOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n#ifdef DEBUG\n    if (HAVE_OPT(DBUG))\n        debug = OPT_VALUE_DBUG;\n#endif\n    for (i = 0; i < argc; i++) {\n        dbgx(1, \"processing:  %s\\n\", argv[i]);\n        if ((fd = open(argv[i], O_RDONLY)) < 0)\n            errx(-1, \"Error opening file %s: %s\", argv[i], strerror(errno));\n        if (fstat(fd, &statinfo) < 0)\n            errx(-1, \"Error getting file stat info %s: %s\", argv[i], strerror(errno));\n        printf(\"file size   = %\"PRIu64\" bytes\\n\", (uint64_t)statinfo.st_size);\n        if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))\n            errx(-1, \"File too small.  Unable to read pcap_file_header from %s\", argv[i]);\n        dbgx(3, \"Read %d bytes for file header\", ret);\n        swapped = 0;\n        memcpy(&pcap_fh, &buf, sizeof(pcap_fh));\n        pkthdrlen = 16; \n        switch (pcap_fh.magic) {\n            case TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n            case SWAPLONG(TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n            case KUZNETZOV_TCPDUMP_MAGIC:\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n            case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n            case FMESQUITA_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n            case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n            case NAVTEL_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n            case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n            case NSEC_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n            case SWAPLONG(NSEC_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n            default:\n            printf(\"magic       = 0x%08\"PRIx32\" (unknown)\\n\", pcap_fh.magic);\n        }\n        if (swapped == 1) {\n            pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);\n            pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);\n            pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);\n            pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);\n            pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);\n            pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);\n        }\n        printf(\"version     = %hu.%hu\\n\", pcap_fh.version_major, pcap_fh.version_minor);\n        printf(\"thiszone    = 0x%08\"PRIx32\"\\n\", pcap_fh.thiszone);\n        printf(\"sigfigs     = 0x%08\"PRIx32\"\\n\", pcap_fh.sigfigs);\n        printf(\"snaplen     = %\"PRIu32\"\\n\", pcap_fh.snaplen);\n        printf(\"linktype    = 0x%08\"PRIx32\"\\n\", pcap_fh.linktype);\n        if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {\n            printf(\"Sorry, we only support file format version 2.4\\n\");\n            close(fd);\n            continue;\n        }\n        dbgx(5, \"Packet header len: %d\", pkthdrlen);\n        if (pkthdrlen == 24) {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n\");\n        } else {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n\");\n        }\n        pktcnt = 0;\n        last_sec = 0;\n        last_usec = 0;\n        while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {\n            pktcnt ++;\n            backwards = 0;\n            caplentoobig = 0;\n            dbgx(3, \"Read %d bytes for packet %\"PRIu64\" header\", ret, pktcnt);\n            memset(&pcap_ph, 0, sizeof(pcap_ph));\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);\n                    pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);\n                    pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);\n                    pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);\n                    pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);\n                    pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32\"\\t\\t%4\"PRIu32\"\\t%4hu\\t%4hhu\", \n                        pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen, \n                        pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec,\n                        pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type);\n                if (pcap_fh.snaplen < pcap_patched_ph.caplen) {\n                    caplentoobig = 1;\n                }\n                caplen = pcap_patched_ph.caplen;\n            } else {\n                memcpy(&readword, buf, 4);\n                pcap_ph.ts.tv_sec = readword;\n                memcpy(&readword, &buf[4], 4);\n                pcap_ph.ts.tv_usec = readword;\n                memcpy(&pcap_ph.caplen, &buf[8], 4);\n                memcpy(&pcap_ph.len, &buf[12], 4);\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);\n                    pcap_ph.len = SWAPLONG(pcap_ph.len);\n                    pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);\n                    pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32,\n                        pktcnt, pcap_ph.len, pcap_ph.caplen, \n                        (unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec);\n                if (pcap_fh.snaplen < pcap_ph.caplen) {\n                    caplentoobig = 1;\n                }\n                caplen = pcap_ph.caplen;\n            }\n            if (last_sec > 0 && last_usec > 0) {\n                if ((pcap_ph.ts.tv_sec == last_sec) ? \n                        (pcap_ph.ts.tv_usec < last_usec) : \n                        (pcap_ph.ts.tv_sec < last_sec)) {\n                    backwards = 1;\n                }\n            }\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                last_sec = pcap_patched_ph.ts.tv_sec;\n                last_usec = pcap_patched_ph.ts.tv_usec;\n            } else {\n                last_sec = pcap_ph.ts.tv_sec;\n                last_usec = pcap_ph.ts.tv_usec;\n            }\n            if ((ret = read(fd, &buf, caplen)) != caplen) {\n                if (ret < 0) {\n                    printf(\"Error reading file: %s: %s\\n\", argv[i], strerror(errno));\n                } else {\n                    printf(\"File truncated!  Unable to jump to next packet.\\n\");\n                }\n                close(fd);\n                continue;\n            }\n            printf(\"\\t%x\\t\", do_checksum_math((u_int16_t *)buf, caplen));\n            if (! backwards && ! caplentoobig) {\n                printf(\"OK\\n\");\n            } else if (backwards && ! caplentoobig) {\n                printf(\"BAD_TS\\n\");\n            } else if (caplentoobig && ! backwards) {\n                printf(\"TOOBIG\\n\");\n            } else if (backwards && caplentoobig) {\n                printf(\"BAD_TS|TOOBIG\");\n            } \n        }\n    }\n    exit(0);\n}\nstatic int\ndo_checksum_math(u_int16_t *data, int len)\n{\n    int sum = 0;\n    union {\n        u_int16_t s;\n        u_int8_t b[2];\n    } pad;\n    while (len > 1) {\n        sum += *data++;\n        len -= 2;\n    }\n    if (len == 1) {\n        pad.b[0] = *(u_int8_t *)data;\n        pad.b[1] = 0;\n        sum += pad.s;\n    }\n    return (sum);\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_1777.c",
        "project": "appneta/tcpreplay",
        "url": "https://github.com/appneta/tcpreplay/commit/d689d14dbcd768c028eab2fb378d849e543dcfe9",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\nstatic int\nbid_keyword(const char *p,  ssize_t len)\n\tstatic const char *keys_c[] = {\n\t\t\"content\", \"contents\", \"cksum\", NULL\n\tstatic const char *keys_df[] = {\n\t\t\"device\", \"flags\", NULL\n\tstatic const char *keys_g[] = {\n\t\t\"gid\", \"gname\", NULL\n\tstatic const char *keys_il[] = {\n\t\t\"ignore\", \"inode\", \"link\", NULL\n\tstatic const char *keys_m[] = {\n\t\t\"md5\", \"md5digest\", \"mode\", NULL\n\tstatic const char *keys_no[] = {\n\t\t\"nlink\", \"nochange\", \"optional\", NULL\n\tstatic const char *keys_r[] = {\n\t\t\"resdevice\", \"rmd160\", \"rmd160digest\", NULL\n\tstatic const char *keys_s[] = {\n\t\t\"sha1\", \"sha1digest\",\n\t\t\"sha256\", \"sha256digest\",\n\t\t\"sha384\", \"sha384digest\",\n\t\t\"sha512\", \"sha512digest\",\n\t\t\"size\", NULL\n\tstatic const char *keys_t[] = {\n\t\t\"tags\", \"time\", \"type\", NULL\n\tstatic const char *keys_u[] = {\n\t\t\"uid\", \"uname\",\tNULL\n\tcase 'c': keys = keys_c; break;\n\tcase 'd': case 'f': keys = keys_df; break;\n\tcase 'g': keys = keys_g; break;\n\tcase 'i': case 'l': keys = keys_il; break;\n\tcase 'm': keys = keys_m; break;\n\tcase 'n': case 'o': keys = keys_no; break;\n\tcase 'r': keys = keys_r; break;\n\tcase 's': keys = keys_s; break;\n\tcase 't': keys = keys_t; break;\n\tcase 'u': keys = keys_u; break;\n\tdefault: return (0);\n\tfor (i = 0; keys[i] != NULL; i++) {\n\t\tint l = bid_keycmp(p, keys[i], len);\n\t\tif (l > 0)\n\t\t\treturn (l);\n\t}\n\treturn (0);\nbid_keyword_list(const char *p,  ssize_t len, int unset, int last_is_path)\n\twhile (len > 0 && *p) {\n\t\twhile (len >0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t++p;\n\t\t\t--len;\n\t\t}\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t\tbreak;\n\t\tif (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r'))\n\t\t\tbreak;\n\t\tif (!blank && !last_is_path) \n\t\t\treturn (-1);\n\t\tif (last_is_path && len == 0)\n\t\t\t\treturn (keycnt);\n\t\tif (unset) {\n\t\t\tl = bid_keycmp(p, \"all\", len);\n\t\t}\n\t\tl = bid_keyword(p, len);\n\t\tif (l == 0)\n\t\t\treturn (-1);\n\t\tp += l;\n\t\tlen -= l;\n\t\tif (*p == '=') {\n\t\t\t++p;\n\t\t\t--len;\n\t\t\twhile (len > 0 && *p != ' ' && *p != '\\t') {\n\t\t\t\t++p;\n\t\t\t\t--len;\n\t\t\t}\n\t\t}\n\t}\nbid_entry(const char *p, ssize_t len, ssize_t nl, int *last_is_path)\n\tconst char *pp = p;\n\tconst char * const pp_end = pp + len;\n\tfor (;pp < pp_end; ++pp) {\n\t\tif (!safe_char[*(const unsigned char *)pp]) {\n\t\t\tif (*pp != ' ' && *pp != '\\t' && *pp != '\\r'\n\t\t\t    && *pp != '\\n')\n\t\t}\n\t}\n\tll = pp_end - pp;\n\tif (f == 0) {\n\t\tconst char *pb = p + len - nl;\n\t\tint name_len = 0;\n\t\tif (pb-2 >= p &&\n\t\t    pb[-1] == '\\\\' && (pb[-2] == ' ' || pb[-2] == '\\t'))\n\t\tif (pb-1 >= p && pb[-1] == '\\\\')\n\t\t\treturn (-1);\n\t\twhile (p <= --pb && *pb != ' ' && *pb != '\\t') {\n\t\t\tif (!safe_char[*(const unsigned char *)pb])\n\t\t\t\treturn (-1);\n\t\t\tname_len++;\n\t\t\tif (*pb == '/')\n\t\t\t\tslash = 1;\n\t\t}\n\t\tif (name_len == 0 || slash == 0)\n\t\t\treturn (-1);\n\t\tll = len - nl - name_len;\n\t\tpp = p;\n\t}\n\treturn (bid_keyword_list(pp, ll, 0, *last_is_path));\ndetect_form(struct archive_read *a, int *is_form_d)\n\tif (is_form_d != NULL)\n\t\t*is_form_d = 0;\n\tp = __archive_read_ahead(a, 1, &avail);\n\tif (p == NULL)\n\t\treturn (-1);\n\travail = avail;\n\tfor (;;) {\n\t\tlen = next_line(a, &p, &avail, &ravail, &nl);\n\t\tif (len <= 0 || nl == 0)\n\t\t\tbreak;\n\t\tif (!multiline) {\n\t\t\twhile (len > 0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t\t++p;\n\t\t\t\t--avail;\n\t\t\t\t--len;\n\t\t\t}\n\t\t\tif (p[0] == '#' || p[0] == '\\n' || p[0] == '\\r') {\n\t\t\t\tp += len;\n\t\t\t\tavail -= len;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bid_keyword_list(p, len, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (multiline == 1)\n\t\t\t\tdetected_bytes += len;\n\t\t\tif (p[len-nl-1] != '\\\\') {\n\t\t\t}\n\t\t\tp += len;\n\t\t\tavail -= len;\n\t\t}\n\t\tif (p[0] != '/') {\n\t\t\tkeywords = bid_entry(p, len, nl, &last_is_path);\n\t\t\tif (keywords >= 0) {\n\t\t\t\tdetected_bytes += len;\n\t\t\t\tif (form_D == 0) {\n\t\t\t\t\tif (last_is_path)\n\t\t\t\t\t\tform_D = 1;\n\t\t\t\t\telse if (keywords > 0)\n\t\t\t\t\t\tform_D = -1;\n\t\t\t\t} else if (form_D == 1) {\n\t\t\t\t\tif (!last_is_path && keywords > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!last_is_path && p[len-nl-1] == '\\\\')\n\t\t\t\t\tmultiline = 1;\n\t\t\t\telse {\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (bid_keyword_list(p+4, len-4, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (bid_keyword_list(p+6, len-6, 1, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else\n\t\tp += len;\n\t\tavail -= len;\n\t}\nread_mtree(struct archive_read *a, struct mtree *mtree)\n\t(void)detect_form(a, &is_form_d);\nread_header(struct archive_read *a, struct archive_entry *entry)\n\tif (mtree->fd >= 0) {\n\t}\n\tif (mtree->entries == NULL) {\n\t\tr = read_mtree(a, mtree);\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_read_support_format_mtree.c 201165 2009-12-29 05:52:13Z kientzle $\");\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#include <stddef.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_string.h\"\n#include \"archive_pack_dev.h\"\n#ifndef O_BINARY\n#define\tO_BINARY 0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC\t0\n#endif\n#define\tMTREE_HAS_DEVICE\t0x0001\n#define\tMTREE_HAS_FFLAGS\t0x0002\n#define\tMTREE_HAS_GID\t\t0x0004\n#define\tMTREE_HAS_GNAME\t\t0x0008\n#define\tMTREE_HAS_MTIME\t\t0x0010\n#define\tMTREE_HAS_NLINK\t\t0x0020\n#define\tMTREE_HAS_PERM\t\t0x0040\n#define\tMTREE_HAS_SIZE\t\t0x0080\n#define\tMTREE_HAS_TYPE\t\t0x0100\n#define\tMTREE_HAS_UID\t\t0x0200\n#define\tMTREE_HAS_UNAME\t\t0x0400\n#define\tMTREE_HAS_OPTIONAL\t0x0800\n#define\tMTREE_HAS_NOCHANGE\t0x1000 \nstruct mtree_option {\n\tstruct mtree_option *next;\n\tchar *value;\n};\nstruct mtree_entry {\n\tstruct mtree_entry *next;\n\tstruct mtree_option *options;\n\tchar *name;\n\tchar full;\n\tchar used;\n};\nstruct mtree {\n\tstruct archive_string\t line;\n\tsize_t\t\t\t buffsize;\n\tchar\t\t\t*buff;\n\tint64_t\t\t\t offset;\n\tint\t\t\t fd;\n\tint\t\t\t archive_format;\n\tconst char\t\t*archive_format_name;\n\tstruct mtree_entry\t*entries;\n\tstruct mtree_entry\t*this_entry;\n\tstruct archive_string\t current_dir;\n\tstruct archive_string\t contents_name;\n\tstruct archive_entry_linkresolver *resolver;\n\tint64_t\t\t\t cur_size;\n\tchar checkfs;\n};\nstatic int\tbid_keycmp(const char *, const char *, ssize_t);\nstatic int\tcleanup(struct archive_read *);\nstatic int\tdetect_form(struct archive_read *, int *);\nstatic int\tmtree_bid(struct archive_read *, int);\nstatic int\tparse_file(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic void\tparse_escapes(char *, struct mtree_entry *);\nstatic int\tparse_line(struct archive_read *, struct archive_entry *,\n\t\t    struct mtree *, struct mtree_entry *, int *);\nstatic int\tparse_keyword(struct archive_read *, struct mtree *,\n\t\t    struct archive_entry *, struct mtree_option *, int *);\nstatic int\tread_data(struct archive_read *a,\n\t\t    const void **buff, size_t *size, int64_t *offset);\nstatic ssize_t\treadline(struct archive_read *, struct mtree *, char **, ssize_t);\nstatic int\tskip(struct archive_read *a);\nstatic int\tread_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int64_t\tmtree_atol10(char **);\nstatic int64_t\tmtree_atol8(char **);\nstatic int64_t\tmtree_atol(char **);\nstatic ssize_t\nnext_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}\nstatic int\nbid_keyword(const char *p,  ssize_t len)\n{\n\tstatic const char *keys_c[] = {\n\t\t\"content\", \"contents\", \"cksum\", NULL\n\t};\n\tstatic const char *keys_df[] = {\n\t\t\"device\", \"flags\", NULL\n\t};\n\tstatic const char *keys_g[] = {\n\t\t\"gid\", \"gname\", NULL\n\t};\n\tstatic const char *keys_il[] = {\n\t\t\"ignore\", \"inode\", \"link\", NULL\n\t};\n\tstatic const char *keys_m[] = {\n\t\t\"md5\", \"md5digest\", \"mode\", NULL\n\t};\n\tstatic const char *keys_no[] = {\n\t\t\"nlink\", \"nochange\", \"optional\", NULL\n\t};\n\tstatic const char *keys_r[] = {\n\t\t\"resdevice\", \"rmd160\", \"rmd160digest\", NULL\n\t};\n\tstatic const char *keys_s[] = {\n\t\t\"sha1\", \"sha1digest\",\n\t\t\"sha256\", \"sha256digest\",\n\t\t\"sha384\", \"sha384digest\",\n\t\t\"sha512\", \"sha512digest\",\n\t\t\"size\", NULL\n\t};\n\tstatic const char *keys_t[] = {\n\t\t\"tags\", \"time\", \"type\", NULL\n\t};\n\tstatic const char *keys_u[] = {\n\t\t\"uid\", \"uname\",\tNULL\n\t};\n\tconst char **keys;\n\tint i;\n\tswitch (*p) {\n\tcase 'c': keys = keys_c; break;\n\tcase 'd': case 'f': keys = keys_df; break;\n\tcase 'g': keys = keys_g; break;\n\tcase 'i': case 'l': keys = keys_il; break;\n\tcase 'm': keys = keys_m; break;\n\tcase 'n': case 'o': keys = keys_no; break;\n\tcase 'r': keys = keys_r; break;\n\tcase 's': keys = keys_s; break;\n\tcase 't': keys = keys_t; break;\n\tcase 'u': keys = keys_u; break;\n\tdefault: return (0);\n\t}\n\tfor (i = 0; keys[i] != NULL; i++) {\n\t\tint l = bid_keycmp(p, keys[i], len);\n\t\tif (l > 0)\n\t\t\treturn (l);\n\t}\n\treturn (0);\n}\nstatic int\nbid_keyword_list(const char *p,  ssize_t len, int unset, int last_is_path)\n{\n\tint l;\n\tint keycnt = 0;\n\twhile (len > 0 && *p) {\n\t\tint blank = 0;\n\t\twhile (len >0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t++p;\n\t\t\t--len;\n\t\t\tblank = 1;\n\t\t}\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t\tbreak;\n\t\tif (p[0] == '\\\\' && (p[1] == '\\n' || p[1] == '\\r'))\n\t\t\tbreak;\n\t\tif (!blank && !last_is_path) \n\t\t\treturn (-1);\n\t\tif (last_is_path && len == 0)\n\t\t\t\treturn (keycnt);\n\t\tif (unset) {\n\t\t\tl = bid_keycmp(p, \"all\", len);\n\t\t\tif (l > 0)\n\t\t\t\treturn (1);\n\t\t}\n\t\tl = bid_keyword(p, len);\n\t\tif (l == 0)\n\t\t\treturn (-1);\n\t\tp += l;\n\t\tlen -= l;\n\t\tkeycnt++;\n\t\tif (*p == '=') {\n\t\t\tint value = 0;\n\t\t\t++p;\n\t\t\t--len;\n\t\t\twhile (len > 0 && *p != ' ' && *p != '\\t') {\n\t\t\t\t++p;\n\t\t\t\t--len;\n\t\t\t\tvalue = 1;\n\t\t\t}\n\t\t\tif (!unset && value == 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (keycnt);\n}\nstatic int\nbid_entry(const char *p, ssize_t len, ssize_t nl, int *last_is_path)\n{\n\tint f = 0;\n\tstatic const unsigned char safe_char[256] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, \n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t};\n\tssize_t ll;\n\tconst char *pp = p;\n\tconst char * const pp_end = pp + len;\n\t*last_is_path = 0;\n\tfor (;pp < pp_end; ++pp) {\n\t\tif (!safe_char[*(const unsigned char *)pp]) {\n\t\t\tif (*pp != ' ' && *pp != '\\t' && *pp != '\\r'\n\t\t\t    && *pp != '\\n')\n\t\t\t\tf = 0;\n\t\t\tbreak;\n\t\t}\n\t\tf = 1;\n\t}\n\tll = pp_end - pp;\n\tif (f == 0) {\n\t\tconst char *pb = p + len - nl;\n\t\tint name_len = 0;\n\t\tint slash;\n\t\tif (pb-2 >= p &&\n\t\t    pb[-1] == '\\\\' && (pb[-2] == ' ' || pb[-2] == '\\t'))\n\t\t\treturn (-1);\n\t\tif (pb-1 >= p && pb[-1] == '\\\\')\n\t\t\treturn (-1);\n\t\tslash = 0;\n\t\twhile (p <= --pb && *pb != ' ' && *pb != '\\t') {\n\t\t\tif (!safe_char[*(const unsigned char *)pb])\n\t\t\t\treturn (-1);\n\t\t\tname_len++;\n\t\t\tif (*pb == '/')\n\t\t\t\tslash = 1;\n\t\t}\n\t\tif (name_len == 0 || slash == 0)\n\t\t\treturn (-1);\n\t\tif (pb[1] == '/')\n\t\t\treturn (-1);\n\t\tll = len - nl - name_len;\n\t\tpp = p;\n\t\t*last_is_path = 1;\n\t}\n\treturn (bid_keyword_list(pp, ll, 0, *last_is_path));\n}\n#define MAX_BID_ENTRY\t3\nstatic int\ndetect_form(struct archive_read *a, int *is_form_d)\n{\n\tconst char *p;\n\tssize_t avail, ravail;\n\tssize_t detected_bytes = 0, len, nl;\n\tint entry_cnt = 0, multiline = 0;\n\tint form_D = 0;\n\tif (is_form_d != NULL)\n\t\t*is_form_d = 0;\n\tp = __archive_read_ahead(a, 1, &avail);\n\tif (p == NULL)\n\t\treturn (-1);\n\travail = avail;\n\tfor (;;) {\n\t\tlen = next_line(a, &p, &avail, &ravail, &nl);\n\t\tif (len <= 0 || nl == 0)\n\t\t\tbreak;\n\t\tif (!multiline) {\n\t\t\twhile (len > 0 && (*p == ' ' || *p == '\\t')) {\n\t\t\t\t++p;\n\t\t\t\t--avail;\n\t\t\t\t--len;\n\t\t\t}\n\t\t\tif (p[0] == '#' || p[0] == '\\n' || p[0] == '\\r') {\n\t\t\t\tp += len;\n\t\t\t\tavail -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bid_keyword_list(p, len, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (multiline == 1)\n\t\t\t\tdetected_bytes += len;\n\t\t\tif (p[len-nl-1] != '\\\\') {\n\t\t\t\tif (multiline == 1 &&\n\t\t\t\t    ++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\tbreak;\n\t\t\t\tmultiline = 0;\n\t\t\t}\n\t\t\tp += len;\n\t\t\tavail -= len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p[0] != '/') {\n\t\t\tint last_is_path, keywords;\n\t\t\tkeywords = bid_entry(p, len, nl, &last_is_path);\n\t\t\tif (keywords >= 0) {\n\t\t\t\tdetected_bytes += len;\n\t\t\t\tif (form_D == 0) {\n\t\t\t\t\tif (last_is_path)\n\t\t\t\t\t\tform_D = 1;\n\t\t\t\t\telse if (keywords > 0)\n\t\t\t\t\t\tform_D = -1;\n\t\t\t\t} else if (form_D == 1) {\n\t\t\t\t\tif (!last_is_path && keywords > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!last_is_path && p[len-nl-1] == '\\\\')\n\t\t\t\t\tmultiline = 1;\n\t\t\t\telse {\n\t\t\t\t\tif (++entry_cnt >= MAX_BID_ENTRY)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (bid_keyword_list(p+4, len-4, 0, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (bid_keyword_list(p+6, len-6, 1, 0) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (p[len-nl-1] == '\\\\')\n\t\t\t\tmultiline = 2;\n\t\t} else\n\t\t\tbreak;\n\t\tp += len;\n\t\tavail -= len;\n\t}\n\tif (entry_cnt >= MAX_BID_ENTRY || (entry_cnt > 0 && len == 0)) {\n\t\tif (is_form_d != NULL) {\n\t\t\tif (form_D == 1)\n\t\t\t\t*is_form_d = 1;\n\t\t}\n\t\treturn (32);\n\t}\n\treturn (0);\n}\nstatic int\nprocess_add_entry(struct archive_read *a, struct mtree *mtree,\n    struct mtree_option **global, const char *line, ssize_t line_len,\n    struct mtree_entry **last_entry, int is_form_d)\n{\n\tstruct mtree_entry *entry;\n\tstruct mtree_option *iter;\n\tconst char *next, *eq, *name, *end;\n\tsize_t name_len, len;\n\tint r, i;\n\tif ((entry = malloc(sizeof(*entry))) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tentry->next = NULL;\n\tentry->options = NULL;\n\tentry->name = NULL;\n\tentry->used = 0;\n\tentry->full = 0;\n\tif (*last_entry == NULL)\n\t\tmtree->entries = entry;\n\telse\n\t\t(*last_entry)->next = entry;\n\t*last_entry = entry;\n\tif (is_form_d) {\n\t\twhile (line_len > 0) {\n\t\t\tchar last_character = line[line_len - 1];\n\t\t\tif (last_character == '\\r'\n\t\t\t    || last_character == '\\n'\n\t\t\t    || last_character == '\\t'\n\t\t\t    || last_character == ' ') {\n\t\t\t\tline_len--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tname = line;\n\t\tfor (i = 0; i < line_len; i++) {\n\t\t\tif (line[i] == '\\r'\n\t\t\t    || line[i] == '\\n'\n\t\t\t    || line[i] == '\\t'\n\t\t\t    || line[i] == ' ') {\n\t\t\t\tname = line + i + 1;\n\t\t\t}\n\t\t}\n\t\tname_len = line + line_len - name;\n\t\tend = name;\n\t} else {\n\t\tname_len = strcspn(line, \" \\t\\r\\n\");\n\t\tname = line;\n\t\tline += name_len;\n\t\tend = line + line_len;\n\t}\n\tif ((entry->name = malloc(name_len + 1)) == NULL) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't allocate memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tmemcpy(entry->name, name, name_len);\n\tentry->name[name_len] = '\\0';\n\tparse_escapes(entry->name, entry);\n\tfor (iter = *global; iter != NULL; iter = iter->next) {\n\t\tr = add_option(a, &entry->options, iter->value,\n\t\t    strlen(iter->value));\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\tfor (;;) {\n\t\tnext = line + strspn(line, \" \\t\\r\\n\");\n\t\tif (*next == '\\0')\n\t\t\treturn (ARCHIVE_OK);\n\t\tif (next >= end)\n\t\t\treturn (ARCHIVE_OK);\n\t\tline = next;\n\t\tnext = line + strcspn(line, \" \\t\\r\\n\");\n\t\teq = strchr(line, '=');\n\t\tif (eq == NULL || eq > next)\n\t\t\tlen = next - line;\n\t\telse\n\t\t\tlen = eq - line;\n\t\tremove_option(&entry->options, line, len);\n\t\tr = add_option(a, &entry->options, line, next - line);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tline = next;\n\t}\n}\nstatic int\nread_mtree(struct archive_read *a, struct mtree *mtree)\n{\n\tssize_t len;\n\tuintmax_t counter;\n\tchar *p;\n\tstruct mtree_option *global;\n\tstruct mtree_entry *last_entry;\n\tint r, is_form_d;\n\tmtree->archive_format = ARCHIVE_FORMAT_MTREE;\n\tmtree->archive_format_name = \"mtree\";\n\tglobal = NULL;\n\tlast_entry = NULL;\n\t(void)detect_form(a, &is_form_d);\n\tfor (counter = 1; ; ++counter) {\n\t\tlen = readline(a, mtree, &p, 65536);\n\t\tif (len == 0) {\n\t\t\tmtree->this_entry = mtree->entries;\n\t\t\tfree_options(global);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tif (len < 0) {\n\t\t\tfree_options(global);\n\t\t\treturn ((int)len);\n\t\t}\n\t\twhile (*p == ' ' || *p == '\\t') {\n\t\t\t++p;\n\t\t\t--len;\n\t\t}\n\t\tif (*p == '#')\n\t\t\tcontinue;\n\t\tif (*p == '\\r' || *p == '\\n' || *p == '\\0')\n\t\t\tcontinue;\n\t\tif (*p != '/') {\n\t\t\tr = process_add_entry(a, mtree, &global, p, len,\n\t\t\t    &last_entry, is_form_d);\n\t\t} else if (strncmp(p, \"/set\", 4) == 0) {\n\t\t\tif (p[4] != ' ' && p[4] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_set(a, &global, p);\n\t\t} else if (strncmp(p, \"/unset\", 6) == 0) {\n\t\t\tif (p[6] != ' ' && p[6] != '\\t')\n\t\t\t\tbreak;\n\t\t\tr = process_global_unset(a, &global, p);\n\t\t} else\n\t\t\tbreak;\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tfree_options(global);\n\t\t\treturn r;\n\t\t}\n\t}\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Can't parse line %ju\", counter);\n\tfree_options(global);\n\treturn (ARCHIVE_FATAL);\n}\nstatic int\nread_header(struct archive_read *a, struct archive_entry *entry)\n{\n\tstruct mtree *mtree;\n\tchar *p;\n\tint r, use_next;\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd >= 0) {\n\t\tclose(mtree->fd);\n\t\tmtree->fd = -1;\n\t}\n\tif (mtree->entries == NULL) {\n\t\tmtree->resolver = archive_entry_linkresolver_new();\n\t\tif (mtree->resolver == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tarchive_entry_linkresolver_set_strategy(mtree->resolver,\n\t\t    ARCHIVE_FORMAT_MTREE);\n\t\tr = read_mtree(a, mtree);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\ta->archive.archive_format = mtree->archive_format;\n\ta->archive.archive_format_name = mtree->archive_format_name;\n\tfor (;;) {\n\t\tif (mtree->this_entry == NULL)\n\t\t\treturn (ARCHIVE_EOF);\n\t\tif (strcmp(mtree->this_entry->name, \"..\") == 0) {\n\t\t\tmtree->this_entry->used = 1;\n\t\t\tif (archive_strlen(&mtree->current_dir) > 0) {\n\t\t\t\tp = mtree->current_dir.s\n\t\t\t\t    + mtree->current_dir.length - 1;\n\t\t\t\twhile (p >= mtree->current_dir.s && *p != '/')\n\t\t\t\t\t--p;\n\t\t\t\tif (p >= mtree->current_dir.s)\n\t\t\t\t\t--p;\n\t\t\t\tmtree->current_dir.length\n\t\t\t\t    = p - mtree->current_dir.s + 1;\n\t\t\t}\n\t\t}\n\t\tif (!mtree->this_entry->used) {\n\t\t\tuse_next = 0;\n\t\t\tr = parse_file(a, entry, mtree, mtree->this_entry,\n\t\t\t\t&use_next);\n\t\t\tif (use_next == 0)\n\t\t\t\treturn (r);\n\t\t}\n\t\tmtree->this_entry = mtree->this_entry->next;\n\t}\n}\nstatic int\nparse_file(struct archive_read *a, struct archive_entry *entry,\n    struct mtree *mtree, struct mtree_entry *mentry, int *use_next)\n{\n\tconst char *path;\n\tstruct stat st_storage, *st;\n\tstruct mtree_entry *mp;\n\tstruct archive_entry *sparse_entry;\n\tint r = ARCHIVE_OK, r1, parsed_kws;\n\tmentry->used = 1;\n\tarchive_entry_set_filetype(entry, AE_IFREG);\n\tarchive_entry_set_size(entry, 0);\n\tarchive_string_empty(&mtree->contents_name);\n\tparsed_kws = 0;\n\tr = parse_line(a, entry, mtree, mentry, &parsed_kws);\n\tif (mentry->full) {\n\t\tarchive_entry_copy_pathname(entry, mentry->name);\n\t\tfor (mp = mentry->next; mp != NULL; mp = mp->next) {\n\t\t\tif (mp->full && !mp->used\n\t\t\t    && strcmp(mentry->name, mp->name) == 0) {\n\t\t\t\tmp->used = 1;\n\t\t\t\tr1 = parse_line(a, entry, mtree, mp,\n\t\t\t\t    &parsed_kws);\n\t\t\t\tif (r1 < r)\n\t\t\t\t\tr = r1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsize_t n = archive_strlen(&mtree->current_dir);\n\t\tif (n > 0)\n\t\t\tarchive_strcat(&mtree->current_dir, \"/\");\n\t\tarchive_strcat(&mtree->current_dir, mentry->name);\n\t\tarchive_entry_copy_pathname(entry, mtree->current_dir.s);\n\t\tif (archive_entry_filetype(entry) != AE_IFDIR)\n\t\t\tmtree->current_dir.length = n;\n\t}\n\tif (mtree->checkfs) {\n\t\tmtree->fd = -1;\n\t\tif (archive_strlen(&mtree->contents_name) > 0)\n\t\t\tpath = mtree->contents_name.s;\n\t\telse\n\t\t\tpath = archive_entry_pathname(entry);\n\t\tif (archive_entry_filetype(entry) == AE_IFREG ||\n\t\t\t\tarchive_entry_filetype(entry) == AE_IFDIR) {\n\t\t\tmtree->fd = open(path, O_RDONLY | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(mtree->fd);\n\t\t\tif (mtree->fd == -1 &&\n\t\t\t\t(errno != ENOENT ||\n\t\t\t\t archive_strlen(&mtree->contents_name) > 0)) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Can't open %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tst = &st_storage;\n\t\tif (mtree->fd >= 0) {\n\t\t\tif (fstat(mtree->fd, st) == -1) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t\"Could not fstat %s\", path);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tst = NULL;\n\t\t\t}\n\t\t} else if (lstat(path, st) == -1) {\n\t\t\tst = NULL;\n\t\t}\n\t\tif (st != NULL) {\n\t\t\tif (((st->st_mode & S_IFMT) == S_IFREG &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFREG)\n#ifdef S_IFLNK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFLNK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFLNK)\n#endif\n#ifdef S_IFSOCK\n\t\t\t  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFSOCK)\n#endif\n#ifdef S_IFCHR\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFCHR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFCHR)\n#endif\n#ifdef S_IFBLK\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFBLK &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFBLK)\n#endif\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFDIR &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFDIR)\n#ifdef S_IFIFO\n\t\t\t  ||((st->st_mode & S_IFMT) == S_IFIFO &&\n\t\t\t      archive_entry_filetype(entry) == AE_IFIFO)\n#endif\n\t\t\t) {\n\t\t\t} else {\n\t\t\t\tif (mtree->fd >= 0)\n\t\t\t\t\tclose(mtree->fd);\n\t\t\t\tmtree->fd = -1;\n\t\t\t\tif (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t\t\t*use_next = 1;\n\t\t\t\t} else if (r == ARCHIVE_OK) {\n\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t    \"mtree specification has different\"\n\t\t\t\t\t    \" type for %s\",\n\t\t\t\t\t    archive_entry_pathname(entry));\n\t\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t\t}\n\t\t\t\treturn (r);\n\t\t\t}\n\t\t}\n\t\tif (st != NULL) {\n\t\t\tif (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||\n\t\t\t\t(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&\n\t\t\t\t(archive_entry_filetype(entry) == AE_IFCHR ||\n\t\t\t\t archive_entry_filetype(entry) == AE_IFBLK))\n\t\t\t\tarchive_entry_set_rdev(entry, st->st_rdev);\n\t\t\tif ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_gid(entry, st->st_gid);\n\t\t\tif ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))\n\t\t\t\t== 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_uid(entry, st->st_uid);\n\t\t\tif ((parsed_kws & MTREE_HAS_MTIME) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtimespec.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtim.tv_nsec);\n#elif HAVE_STRUCT_STAT_ST_MTIME_N\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_n);\n#elif HAVE_STRUCT_STAT_ST_UMTIME\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_umtime*1000);\n#elif HAVE_STRUCT_STAT_ST_MTIME_USEC\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime,\n\t\t\t\t\t\tst->st_mtime_usec*1000);\n#else\n\t\t\t\tarchive_entry_set_mtime(entry, st->st_mtime, 0);\n#endif\n\t\t\t}\n\t\t\tif ((parsed_kws & MTREE_HAS_NLINK) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_nlink(entry, st->st_nlink);\n\t\t\tif ((parsed_kws & MTREE_HAS_PERM) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_perm(entry, st->st_mode);\n\t\t\tif ((parsed_kws & MTREE_HAS_SIZE) == 0 ||\n\t\t\t    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)\n\t\t\t\tarchive_entry_set_size(entry, st->st_size);\n\t\t\tarchive_entry_set_ino(entry, st->st_ino);\n\t\t\tarchive_entry_set_dev(entry, st->st_dev);\n\t\t\tarchive_entry_linkify(mtree->resolver, &entry,\n\t\t\t\t&sparse_entry);\n\t\t} else if (parsed_kws & MTREE_HAS_OPTIONAL) {\n\t\t\t*use_next = 1;\n\t\t\treturn ARCHIVE_OK;\n\t\t}\n\t}\n\tmtree->cur_size = archive_entry_size(entry);\n\tmtree->offset = 0;\n\treturn r;\n}\nstatic char *\nla_strsep(char **sp, const char *sep)\n{\n\tchar *p, *s;\n\tif (sp == NULL || *sp == NULL || **sp == '\\0')\n\t\treturn(NULL);\n\ts = *sp;\n\tp = s + strcspn(s, sep);\n\tif (*p != '\\0')\n\t\t*p++ = '\\0';\n\t*sp = p;\n\treturn(s);\n}\nstatic int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}\nstatic int\nparse_keyword(struct archive_read *a, struct mtree *mtree,\n    struct archive_entry *entry, struct mtree_option *opt, int *parsed_kws)\n{\n\tchar *val, *key;\n\tkey = opt->value;\n\tif (*key == '\\0')\n\t\treturn (ARCHIVE_OK);\n\tif (strcmp(key, \"nochange\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_NOCHANGE;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"optional\") == 0) {\n\t\t*parsed_kws |= MTREE_HAS_OPTIONAL;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tif (strcmp(key, \"ignore\") == 0) {\n\t\treturn (ARCHIVE_OK);\n\t}\n\tval = strchr(key, '=');\n\tif (val == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed attribute \\\"%s\\\" (%d)\", key, key[0]);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\t*val = '\\0';\n\t++val;\n\tswitch (key[0]) {\n\tcase 'c':\n\t\tif (strcmp(key, \"content\") == 0\n\t\t    || strcmp(key, \"contents\") == 0) {\n\t\t\tparse_escapes(val, NULL);\n\t\t\tarchive_strcpy(&mtree->contents_name, val);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"cksum\") == 0)\n\t\t\tbreak;\n\tcase 'd':\n\t\tif (strcmp(key, \"device\") == 0) {\n\t\t\tint r;\n\t\t\tdev_t dev;\n\t\t\t*parsed_kws |= MTREE_HAS_DEVICE;\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_rdev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\tcase 'f':\n\t\tif (strcmp(key, \"flags\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_FFLAGS;\n\t\t\tarchive_entry_copy_fflags_text(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'g':\n\t\tif (strcmp(key, \"gid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GID;\n\t\t\tarchive_entry_set_gid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"gname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_GNAME;\n\t\t\tarchive_entry_copy_gname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'i':\n\t\tif (strcmp(key, \"inode\") == 0) {\n\t\t\tarchive_entry_set_ino(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'l':\n\t\tif (strcmp(key, \"link\") == 0) {\n\t\t\tarchive_entry_copy_symlink(entry, val);\n\t\t\tbreak;\n\t\t}\n\tcase 'm':\n\t\tif (strcmp(key, \"md5\") == 0 || strcmp(key, \"md5digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"mode\") == 0) {\n\t\t\tif (val[0] >= '0' && val[0] <= '9') {\n\t\t\t\t*parsed_kws |= MTREE_HAS_PERM;\n\t\t\t\tarchive_entry_set_perm(entry,\n\t\t\t\t    (mode_t)mtree_atol8(&val));\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Symbolic mode \\\"%s\\\" unsupported\", val);\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase 'n':\n\t\tif (strcmp(key, \"nlink\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_NLINK;\n\t\t\tarchive_entry_set_nlink(entry,\n\t\t\t\t(unsigned int)mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 'r':\n\t\tif (strcmp(key, \"resdevice\") == 0) {\n\t\t\tint r;\n\t\t\tdev_t dev;\n\t\t\tr = parse_device(&dev, &a->archive, val);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tarchive_entry_set_dev(entry, dev);\n\t\t\treturn r;\n\t\t}\n\t\tif (strcmp(key, \"rmd160\") == 0 ||\n\t\t    strcmp(key, \"rmd160digest\") == 0)\n\t\t\tbreak;\n\tcase 's':\n\t\tif (strcmp(key, \"sha1\") == 0 || strcmp(key, \"sha1digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha256\") == 0 ||\n\t\t    strcmp(key, \"sha256digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha384\") == 0 ||\n\t\t    strcmp(key, \"sha384digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"sha512\") == 0 ||\n\t\t    strcmp(key, \"sha512digest\") == 0)\n\t\t\tbreak;\n\t\tif (strcmp(key, \"size\") == 0) {\n\t\t\tarchive_entry_set_size(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\tcase 't':\n\t\tif (strcmp(key, \"tags\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"time\") == 0) {\n\t\t\tint64_t m;\n\t\t\tint64_t my_time_t_max = get_time_t_max();\n\t\t\tint64_t my_time_t_min = get_time_t_min();\n\t\t\tlong ns = 0;\n\t\t\t*parsed_kws |= MTREE_HAS_MTIME;\n\t\t\tm = mtree_atol10(&val);\n\t\t\tif (*val == '.') {\n\t\t\t\t++val;\n\t\t\t\tns = (long)mtree_atol10(&val);\n\t\t\t} else\n\t\t\t\tns = 0;\n\t\t\tif (m > my_time_t_max)\n\t\t\t\tm = my_time_t_max;\n\t\t\telse if (m < my_time_t_min)\n\t\t\t\tm = my_time_t_min;\n\t\t\tarchive_entry_set_mtime(entry, (time_t)m, ns);\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"type\") == 0) {\n\t\t\tswitch (val[0]) {\n\t\t\tcase 'b':\n\t\t\t\tif (strcmp(val, \"block\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry, AE_IFBLK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'c':\n\t\t\t\tif (strcmp(val, \"char\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFCHR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'd':\n\t\t\t\tif (strcmp(val, \"dir\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFDIR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'f':\n\t\t\t\tif (strcmp(val, \"fifo\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFIFO);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strcmp(val, \"file\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFREG);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'l':\n\t\t\t\tif (strcmp(val, \"link\") == 0) {\n\t\t\t\t\tarchive_entry_set_filetype(entry,\n\t\t\t\t\t\tAE_IFLNK);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Unrecognized file type \\\"%s\\\"; \"\n\t\t\t\t    \"assuming \\\"file\\\"\", val);\n\t\t\t\tarchive_entry_set_filetype(entry, AE_IFREG);\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\t*parsed_kws |= MTREE_HAS_TYPE;\n\t\t\tbreak;\n\t\t}\n\tcase 'u':\n\t\tif (strcmp(key, \"uid\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UID;\n\t\t\tarchive_entry_set_uid(entry, mtree_atol10(&val));\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(key, \"uname\") == 0) {\n\t\t\t*parsed_kws |= MTREE_HAS_UNAME;\n\t\t\tarchive_entry_copy_uname(entry, val);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unrecognized key %s=%s\", key, val);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\nstatic int\nread_data(struct archive_read *a, const void **buff, size_t *size,\n    int64_t *offset)\n{\n\tsize_t bytes_to_read;\n\tssize_t bytes_read;\n\tstruct mtree *mtree;\n\tmtree = (struct mtree *)(a->format->data);\n\tif (mtree->fd < 0) {\n\t\t*buff = NULL;\n\t\t*offset = 0;\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tif (mtree->buff == NULL) {\n\t\tmtree->buffsize = 64 * 1024;\n\t\tmtree->buff = malloc(mtree->buffsize);\n\t\tif (mtree->buff == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\t*buff = mtree->buff;\n\t*offset = mtree->offset;\n\tif ((int64_t)mtree->buffsize > mtree->cur_size - mtree->offset)\n\t\tbytes_to_read = (size_t)(mtree->cur_size - mtree->offset);\n\telse\n\t\tbytes_to_read = mtree->buffsize;\n\tbytes_read = read(mtree->fd, mtree->buff, bytes_to_read);\n\tif (bytes_read < 0) {\n\t\tarchive_set_error(&a->archive, errno, \"Can't read\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (bytes_read == 0) {\n\t\t*size = 0;\n\t\treturn (ARCHIVE_EOF);\n\t}\n\tmtree->offset += bytes_read;\n\t*size = bytes_read;\n\treturn (ARCHIVE_OK);\n}\nstatic void\nparse_escapes(char *src, struct mtree_entry *mentry)\n{\n\tchar *dest = src;\n\tchar c;\n\tif (mentry != NULL && strcmp(src, \".\") == 0)\n\t\tmentry->full = 1;\n\twhile (*src != '\\0') {\n\t\tc = *src++;\n\t\tif (c == '/' && mentry != NULL)\n\t\t\tmentry->full = 1;\n\t\tif (c == '\\\\') {\n\t\t\tswitch (src[0]) {\n\t\t\tcase '0':\n\t\t\t\tif (src[1] < '0' || src[1] > '7') {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tif (src[1] >= '0' && src[1] <= '7' &&\n\t\t\t\t    src[2] >= '0' && src[2] <= '7') {\n\t\t\t\t\tc = (src[0] - '0') << 6;\n\t\t\t\t\tc |= (src[1] - '0') << 3;\n\t\t\t\t\tc |= (src[2] - '0');\n\t\t\t\t\tsrc += 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tc = '\\a';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tc = ' ';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tc = '\\v';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*dest++ = c;\n\t}\n\t*dest = '\\0';\n}\nstatic int64_t\nmtree_atol8(char **p)\n{\n\tint64_t\tl, limit, last_digit_limit;\n\tint digit, base;\n\tbase = 8;\n\tlimit = INT64_MAX / base;\n\tlast_digit_limit = INT64_MAX % base;\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l>limit || (l == limit && digit > last_digit_limit)) {\n\t\t\tl = INT64_MAX; \n\t\t\tbreak;\n\t\t}\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (l);\n}\nstatic int64_t\nmtree_atol10(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\tbase = 10;\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\tl = 0;\n\tdigit = **p - '0';\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = *++(*p) - '0';\n\t}\n\treturn (sign < 0) ? -l : l;\n}\nstatic int\nparsehex(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\telse if (c >= 'a' && c <= 'f')\n\t\treturn c - 'a';\n\telse if (c >= 'A' && c <= 'F')\n\t\treturn c - 'A';\n\telse\n\t\treturn -1;\n}\nstatic int64_t\nmtree_atol16(char **p)\n{\n\tint64_t l, limit, last_digit_limit;\n\tint base, digit, sign;\n\tbase = 16;\n\tif (**p == '-') {\n\t\tsign = -1;\n\t\tlimit = ((uint64_t)(INT64_MAX) + 1) / base;\n\t\tlast_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;\n\t\t++(*p);\n\t} else {\n\t\tsign = 1;\n\t\tlimit = INT64_MAX / base;\n\t\tlast_digit_limit = INT64_MAX % base;\n\t}\n\tl = 0;\n\tdigit = parsehex(**p);\n\twhile (digit >= 0 && digit < base) {\n\t\tif (l > limit || (l == limit && digit > last_digit_limit))\n\t\t\treturn (sign < 0) ? INT64_MIN : INT64_MAX;\n\t\tl = (l * base) + digit;\n\t\tdigit = parsehex(*++(*p));\n\t}\n\treturn (sign < 0) ? -l : l;\n}\nstatic int64_t\nmtree_atol(char **p)\n{\n\tif (**p != '0')\n\t\treturn mtree_atol10(p);\n\tif ((*p)[1] == 'x' || (*p)[1] == 'X') {\n\t\t*p += 2;\n\t\treturn mtree_atol16(p);\n\t}\n\treturn mtree_atol8(p);\n}\nstatic ssize_t\nreadline(struct archive_read *a, struct mtree *mtree, char **start,\n    ssize_t limit)\n{\n\tssize_t bytes_read;\n\tssize_t total_size = 0;\n\tssize_t find_off = 0;\n\tconst void *t;\n\tvoid *nl;\n\tchar *u;\n\tfor (;;) {\n\t\tt = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (t == NULL)\n\t\t\treturn (0);\n\t\tif (bytes_read < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tnl = memchr(t, '\\n', bytes_read);\n\t\tif (nl != NULL) {\n\t\t\tbytes_read = ((const char *)nl) - ((const char *)t) + 1;\n\t\t}\n\t\tif (total_size + bytes_read + 1 > limit) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Line too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (archive_string_ensure(&mtree->line,\n\t\t\ttotal_size + bytes_read + 1) == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate working buffer\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(mtree->line.s + total_size, t, bytes_read);\n\t\t__archive_read_consume(a, bytes_read);\n\t\ttotal_size += bytes_read;\n\t\tmtree->line.s[total_size] = '\\0';\n\t\tfor (u = mtree->line.s + find_off; *u; ++u) {\n\t\t\tif (u[0] == '\\n') {\n\t\t\t\t*start = mtree->line.s;\n\t\t\t\treturn total_size;\n\t\t\t} else if (u[0] == '#') {\n\t\t\t\tif (nl == NULL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (u[0] == '\\\\') {\n\t\t\t\tif (u[1] == '\\n') {\n\t\t\t\t\ttotal_size -= 2;\n\t\t\t\t\tmtree->line.s[total_size] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (u[1] != '\\0') {\n\t\t\t\t\t++u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind_off = u - mtree->line.s;\n\t}\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1287.c",
        "project": "libarchive/libarchive",
        "url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static BOOL update_gdi_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyphIndex)\n\tif (!context || !glyphIndex || !context->cache)\n\t\treturn FALSE;\n\tif (glyphIndex->bkRight > glyphIndex->bkLeft)\n\t\tbkWidth = glyphIndex->bkRight - glyphIndex->bkLeft + 1;\n\tif (glyphIndex->opRight > glyphIndex->opLeft)\n\t\topWidth = glyphIndex->opRight - glyphIndex->opLeft + 1;\n\tif (glyphIndex->bkBottom > glyphIndex->bkTop)\n\t\tbkHeight = glyphIndex->bkBottom - glyphIndex->bkTop + 1;\n\tif (glyphIndex->opBottom > glyphIndex->opTop)\n\t\topHeight = glyphIndex->opBottom - glyphIndex->opTop + 1;\n\t    context, glyphIndex->data, glyphIndex->cbData, glyphIndex->cacheId, glyphIndex->ulCharInc,\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <stdio.h>\n#include <winpr/crt.h>\n#include <freerdp/freerdp.h>\n#include <winpr/stream.h>\n#include <freerdp/log.h>\n#include <freerdp/cache/glyph.h>\n#include \"glyph.h\"\n#define TAG FREERDP_TAG(\"cache.glyph\")\nstatic rdpGlyph* glyph_cache_get(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index);\nstatic BOOL glyph_cache_put(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index, rdpGlyph* entry);\nstatic const void* glyph_cache_fragment_get(rdpGlyphCache* glyph, UINT32 index, UINT32* count);\nstatic BOOL glyph_cache_fragment_put(rdpGlyphCache* glyph, UINT32 index, UINT32 count,\n                                     const void* entry);\nstatic BOOL update_process_glyph(rdpContext* context, const BYTE* data, UINT32 cacheIndex, INT32* x,\n                                 INT32* y, UINT32 cacheId, UINT32 flAccel, BOOL fOpRedundant,\n                                 const RDP_RECT* bound)\n{\n\tINT32 sx = 0, sy = 0;\n\tINT32 dx, dy;\n\trdpGlyph* glyph;\n\trdpGlyphCache* glyph_cache;\n\tif (!context || !data || !x || !y || !context->graphics || !context->cache ||\n\t    !context->cache->glyph)\n\t\treturn FALSE;\n\tglyph_cache = context->cache->glyph;\n\tglyph = glyph_cache_get(glyph_cache, cacheId, cacheIndex);\n\tif (!glyph)\n\t\treturn FALSE;\n\tdx = glyph->x + *x;\n\tdy = glyph->y + *y;\n\tif (dx < bound->x)\n\t{\n\t\tsx = bound->x - dx;\n\t\tdx = bound->x;\n\t}\n\tif (dy < bound->y)\n\t{\n\t\tsy = bound->y - dy;\n\t\tdy = bound->y;\n\t}\n\tif ((dx <= (bound->x + bound->width)) && (dy <= (bound->y + bound->height)))\n\t{\n\t\tINT32 dw = glyph->cx - sx;\n\t\tINT32 dh = glyph->cy - sy;\n\t\tif ((dw + dx) > (bound->x + bound->width))\n\t\t\tdw = (bound->x + bound->width) - (dw + dx);\n\t\tif ((dh + dy) > (bound->y + bound->height))\n\t\t\tdh = (bound->y + bound->height) - (dh + dy);\n\t\tif ((dh > 0) && (dw > 0))\n\t\t{\n\t\t\tif (!glyph->Draw(context, glyph, dx, dy, dw, dh, sx, sy, fOpRedundant))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (flAccel & SO_CHAR_INC_EQUAL_BM_BASE)\n\t\t*x += glyph->cx;\n\treturn TRUE;\n}\nstatic BOOL update_process_glyph_fragments(rdpContext* context, const BYTE* data, UINT32 length,\n                                           UINT32 cacheId, UINT32 ulCharInc, UINT32 flAccel,\n                                           UINT32 bgcolor, UINT32 fgcolor, INT32 x, INT32 y,\n                                           INT32 bkX, INT32 bkY, INT32 bkWidth, INT32 bkHeight,\n                                           INT32 opX, INT32 opY, INT32 opWidth, INT32 opHeight,\n                                           BOOL fOpRedundant)\n{\n\tUINT32 n;\n\tUINT32 id;\n\tUINT32 size;\n\tUINT32 index = 0;\n\tBYTE* fragments;\n\trdpGraphics* graphics;\n\trdpGlyphCache* glyph_cache;\n\trdpGlyph* glyph;\n\tRDP_RECT bound;\n\tif (!context || !data || !context->graphics || !context->cache || !context->cache->glyph)\n\t\treturn FALSE;\n\tgraphics = context->graphics;\n\tglyph_cache = context->cache->glyph;\n\tglyph = graphics->Glyph_Prototype;\n\tif (!glyph)\n\t\treturn FALSE;\n\tif (opX < 0)\n\t{\n\t\topWidth += opX;\n\t\topX = 0;\n\t}\n\tif (opY < 0)\n\t{\n\t\topHeight += opY;\n\t\topY = 0;\n\t}\n\tif (opWidth < 0)\n\t\topWidth = 0;\n\tif (opHeight < 0)\n\t\topHeight = 0;\n\tif (bkX < 0)\n\t{\n\t\tbkWidth += bkX;\n\t\tbkX = 0;\n\t}\n\tif (bkY < 0)\n\t{\n\t\tbkHeight += bkY;\n\t\tbkY = 0;\n\t}\n\tif (bkWidth < 0)\n\t\tbkWidth = 0;\n\tif (bkHeight < 0)\n\t\tbkHeight = 0;\n\tif (opX + opWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\topWidth = context->settings->DesktopWidth - opX;\n\t}\n\tif (bkX + bkWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\tbkWidth = context->settings->DesktopWidth - bkX;\n\t}\n\tbound.x = bkX;\n\tbound.y = bkY;\n\tbound.width = bkWidth;\n\tbound.height = bkHeight;\n\tif (!glyph->BeginDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor, fOpRedundant))\n\t\treturn FALSE;\n\tif (!IFCALLRESULT(TRUE, glyph->SetBounds, context, bkX, bkY, bkWidth, bkHeight))\n\t\treturn FALSE;\n\twhile (index < length)\n\t{\n\t\tconst UINT32 op = data[index++];\n\t\tswitch (op)\n\t\t{\n\t\t\tcase GLYPH_FRAGMENT_USE:\n\t\t\t\tif (index + 1 >= length)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tid = data[index++];\n\t\t\t\tfragments = (BYTE*)glyph_cache_fragment_get(glyph_cache, id, &size);\n\t\t\t\tif (fragments == NULL)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tfor (n = 0; n < size;)\n\t\t\t\t{\n\t\t\t\t\tconst UINT32 fop = fragments[n++];\n\t\t\t\t\tn = update_glyph_offset(fragments, size, n, &x, &y, ulCharInc, flAccel);\n\t\t\t\t\tif (!update_process_glyph(context, fragments, fop, &x, &y, cacheId, flAccel,\n\t\t\t\t\t                          fOpRedundant, &bound))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GLYPH_FRAGMENT_ADD:\n\t\t\t\tif (index + 2 > length)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tid = data[index++];\n\t\t\t\tsize = data[index++];\n\t\t\t\tglyph_cache_fragment_put(glyph_cache, id, size, data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tindex = update_glyph_offset(data, length, index, &x, &y, ulCharInc, flAccel);\n\t\t\t\tif (!update_process_glyph(context, data, op, &x, &y, cacheId, flAccel, fOpRedundant,\n\t\t\t\t                          &bound))\n\t\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn glyph->EndDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor);\n}\nstatic BOOL update_gdi_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyphIndex)\n{\n\tINT32 bkWidth = 0, bkHeight = 0, opWidth = 0, opHeight = 0;\n\tif (!context || !glyphIndex || !context->cache)\n\t\treturn FALSE;\n\tif (glyphIndex->bkRight > glyphIndex->bkLeft)\n\t\tbkWidth = glyphIndex->bkRight - glyphIndex->bkLeft + 1;\n\tif (glyphIndex->opRight > glyphIndex->opLeft)\n\t\topWidth = glyphIndex->opRight - glyphIndex->opLeft + 1;\n\tif (glyphIndex->bkBottom > glyphIndex->bkTop)\n\t\tbkHeight = glyphIndex->bkBottom - glyphIndex->bkTop + 1;\n\tif (glyphIndex->opBottom > glyphIndex->opTop)\n\t\topHeight = glyphIndex->opBottom - glyphIndex->opTop + 1;\n\treturn update_process_glyph_fragments(\n\t    context, glyphIndex->data, glyphIndex->cbData, glyphIndex->cacheId, glyphIndex->ulCharInc,\n\t    glyphIndex->flAccel, glyphIndex->backColor, glyphIndex->foreColor, glyphIndex->x,\n\t    glyphIndex->y, glyphIndex->bkLeft, glyphIndex->bkTop, bkWidth, bkHeight, glyphIndex->opLeft,\n\t    glyphIndex->opTop, opWidth, opHeight, glyphIndex->fOpRedundant);\n}\nstatic BOOL update_gdi_fast_index(rdpContext* context, const FAST_INDEX_ORDER* fastIndex)\n{\n\tINT32 x, y;\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\tif (!context || !fastIndex || !context->cache)\n\t\treturn FALSE;\n\topLeft = fastIndex->opLeft;\n\topTop = fastIndex->opTop;\n\topRight = fastIndex->opRight;\n\topBottom = fastIndex->opBottom;\n\tx = fastIndex->x;\n\ty = fastIndex->y;\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastIndex->bkBottom;\n\t\tif (flags & 0x02)\n\t\t\topRight = fastIndex->bkRight;\n\t\tif (flags & 0x04)\n\t\t\topTop = fastIndex->bkTop;\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastIndex->bkLeft;\n\t}\n\tif (opLeft == 0)\n\t\topLeft = fastIndex->bkLeft;\n\tif (opRight == 0)\n\t\topRight = fastIndex->bkRight;\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\tif (x == -32768)\n\t\tx = fastIndex->bkLeft;\n\tif (y == -32768)\n\t\ty = fastIndex->bkTop;\n\tif (fastIndex->bkRight > fastIndex->bkLeft)\n\t\tbkWidth = fastIndex->bkRight - fastIndex->bkLeft + 1;\n\tif (fastIndex->bkBottom > fastIndex->bkTop)\n\t\tbkHeight = fastIndex->bkBottom - fastIndex->bkTop + 1;\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\treturn update_process_glyph_fragments(\n\t    context, fastIndex->data, fastIndex->cbData, fastIndex->cacheId, fastIndex->ulCharInc,\n\t    fastIndex->flAccel, fastIndex->backColor, fastIndex->foreColor, x, y, fastIndex->bkLeft,\n\t    fastIndex->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\nstatic BOOL update_gdi_fast_glyph(rdpContext* context, const FAST_GLYPH_ORDER* fastGlyph)\n{\n\tINT32 x, y;\n\tBYTE text_data[4] = { 0 };\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\trdpCache* cache;\n\tif (!context || !fastGlyph || !context->cache)\n\t\treturn FALSE;\n\tcache = context->cache;\n\topLeft = fastGlyph->opLeft;\n\topTop = fastGlyph->opTop;\n\topRight = fastGlyph->opRight;\n\topBottom = fastGlyph->opBottom;\n\tx = fastGlyph->x;\n\ty = fastGlyph->y;\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastGlyph->bkBottom;\n\t\tif (flags & 0x02)\n\t\t\topRight = fastGlyph->bkRight;\n\t\tif (flags & 0x04)\n\t\t\topTop = fastGlyph->bkTop;\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastGlyph->bkLeft;\n\t}\n\tif (opLeft == 0)\n\t\topLeft = fastGlyph->bkLeft;\n\tif (opRight == 0)\n\t\topRight = fastGlyph->bkRight;\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\tif (x == -32768)\n\t\tx = fastGlyph->bkLeft;\n\tif (y == -32768)\n\t\ty = fastGlyph->bkTop;\n\tif ((fastGlyph->cbData > 1) && (fastGlyph->glyphData.aj))\n\t{\n\t\trdpGlyph* glyph;\n\t\tconst GLYPH_DATA_V2* glyphData = &fastGlyph->glyphData;\n\t\tglyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,\n\t\t                    glyphData->cb, glyphData->aj);\n\t\tif (!glyph)\n\t\t\treturn FALSE;\n\t\tif (!glyph_cache_put(cache->glyph, fastGlyph->cacheId, fastGlyph->data[0], glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\ttext_data[0] = fastGlyph->data[0];\n\ttext_data[1] = 0;\n\tif (fastGlyph->bkRight > fastGlyph->bkLeft)\n\t\tbkWidth = fastGlyph->bkRight - fastGlyph->bkLeft + 1;\n\tif (fastGlyph->bkBottom > fastGlyph->bkTop)\n\t\tbkHeight = fastGlyph->bkBottom - fastGlyph->bkTop + 1;\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\treturn update_process_glyph_fragments(\n\t    context, text_data, sizeof(text_data), fastGlyph->cacheId, fastGlyph->ulCharInc,\n\t    fastGlyph->flAccel, fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft,\n\t    fastGlyph->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\nBOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_4695.c",
        "project": "freerdp/freerdp",
        "url": "https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\tif (tmp)\n\t\tif (name)\n\t\t\tif (xml)\n\t\t\t\tif (xml->func)\n\t\t\t\t\telse\n\t\t\t\t\t\txmlrpc_error_code = -7;\n\t\t\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: First eligible function returned XMLRPC_STOP\");\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\txmlrpc_error_code = -6;\n\t\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Method has no registered function\");\n\t\t\t\t}\n\t\t\telse\n\t\t\t\txmlrpc_error_code = -4;\n\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Unknown routine called\");\n\t\t\t}\n\t\telse\n\t\t\txmlrpc_error_code = -3;\n\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Missing methodRequest or methodName.\");\n\t\t}\n\telse\n\t\txmlrpc_error_code = -2;\n\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Invalid document end at line 1\");\nvoid xmlrpc_generic_error(int code, const char *string)\n\tmowgli_string_t *s = mowgli_string_create();\n\tif (xmlrpc.encode)\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n\", xmlrpc.encode);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n\");\n\ts->append(s, buf, strlen(buf));\n\tss = \" <fault>\\r\\n  <value>\\r\\n   <struct>\\r\\n    <member>\\r\\n     <name>faultCode</name>\\r\\n     <value><int>\";\n\ts->append(s, ss, strlen(ss));\n\tsnprintf(buf, sizeof buf, \"%d\", code);\n\ts->append(s, buf, strlen(buf));\n\tss = \"</int></value>\\r\\n    </member>\\r\\n    <member>\\r\\n     <name>faultString</name>\\r\\n     <value><string>\";\n\ts->append(s, ss, strlen(ss));\n\txmlrpc_append_char_encode(s, string);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <mowgli.h>\n#include \"atheme.h\"\n#include \"xmlrpclib.h\"\nstatic int xmlrpc_error_code;\ntypedef struct XMLRPCCmd_ XMLRPCCmd;\nstruct XMLRPCCmd_ {\n\tXMLRPCMethodFunc func;\n\tchar *name;\n\tint core;\n\tchar *mod_name;\n\tXMLRPCCmd *next;\n};\nmowgli_patricia_t *XMLRPCCMD = NULL;\nstruct xmlrpc_settings {\n\tchar *(*setbuffer)(char *buffer, int len);\n\tchar *encode;\n\tint httpheader;\n\tchar *inttagstart;\n\tchar *inttagend;\n} xmlrpc;\nstatic char *xmlrpc_parse(char *buffer);\nstatic char *xmlrpc_method(char *buffer);\nstatic int xmlrpc_split_buf(char *buffer, char ***argv);\nstatic void xmlrpc_append_char_encode(mowgli_string_t *s, const char *s1);\nstatic XMLRPCCmd *createXMLCommand(const char *name, XMLRPCMethodFunc func);\nstatic int addXMLCommand(XMLRPCCmd * xml);\nstatic char *xmlrpc_write_header(int length);\nvoid xmlrpc_process(char *buffer, void *userdata)\n{\n\tint retVal = 0;\n\tXMLRPCCmd *current = NULL;\n\tXMLRPCCmd *xml;\n\tchar *tmp;\n\tint ac;\n\tchar **av = NULL;\n\tchar *name = NULL;\n\txmlrpc_error_code = 0;\n\tif (!buffer)\n\t{\n\t\txmlrpc_error_code = -1;\n\t\treturn;\n\t}\n\ttmp = xmlrpc_parse(buffer);\n\tif (tmp)\n\t{\n\t\tname = xmlrpc_method(tmp);\n\t\tif (name)\n\t\t{\n\t\t\txml = mowgli_patricia_retrieve(XMLRPCCMD, name);\n\t\t\tif (xml)\n\t\t\t{\n\t\t\t\tac = xmlrpc_split_buf(tmp, &av);\n\t\t\t\tif (xml->func)\n\t\t\t\t{\n\t\t\t\t\tretVal = xml->func(userdata, ac, av);\n\t\t\t\t\tif (retVal == XMLRPC_CONT)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent = xml->next;\n\t\t\t\t\t\twhile (current && current->func && retVal == XMLRPC_CONT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tretVal = current->func(userdata, ac, av);\n\t\t\t\t\t\t\tcurrent = current->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\n\t\t\t\t\t\txmlrpc_error_code = -7;\n\t\t\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: First eligible function returned XMLRPC_STOP\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\txmlrpc_error_code = -6;\n\t\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Method has no registered function\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txmlrpc_error_code = -4;\n\t\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Unknown routine called\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\txmlrpc_error_code = -3;\n\t\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Missing methodRequest or methodName.\");\n\t\t}\n\t}\n\telse\n\t{\n\t\txmlrpc_error_code = -2;\n\t\txmlrpc_generic_error(xmlrpc_error_code, \"XMLRPC error: Invalid document end at line 1\");\n\t}\n\tfree(av);\n\tfree(tmp);\n\tfree(name);\n}\nvoid xmlrpc_generic_error(int code, const char *string)\n{\n\tchar buf[1024];\n\tconst char *ss;\n\tmowgli_string_t *s = mowgli_string_create();\n\tchar *s2;\n\tint len;\n\tif (xmlrpc.encode)\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n\", xmlrpc.encode);\n\t}\n\telse\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n\");\n\t}\n\ts->append(s, buf, strlen(buf));\n\tss = \" <fault>\\r\\n  <value>\\r\\n   <struct>\\r\\n    <member>\\r\\n     <name>faultCode</name>\\r\\n     <value><int>\";\n\ts->append(s, ss, strlen(ss));\n\tsnprintf(buf, sizeof buf, \"%d\", code);\n\ts->append(s, buf, strlen(buf));\n\tss = \"</int></value>\\r\\n    </member>\\r\\n    <member>\\r\\n     <name>faultString</name>\\r\\n     <value><string>\";\n\ts->append(s, ss, strlen(ss));\n\txmlrpc_append_char_encode(s, string);\n\tss = \"</string></value>\\r\\n    </member>\\r\\n   </struct>\\r\\n  </value>\\r\\n </fault>\\r\\n</methodResponse>\",\n\ts->append(s, ss, strlen(ss));\n\tlen = s->pos;\n\tif (xmlrpc.httpheader)\n\t{\n\t\tchar *header = xmlrpc_write_header(len);\n\t\ts2 = smalloc(strlen(header) + len + 1);\n\t\tstrcpy(s2, header);\n\t\tmemcpy(s2 + strlen(header), s->str, len);\n\t\txmlrpc.setbuffer(s2, len + strlen(header));\n\t\tfree(header);\n\t\tfree(s2);\n\t}\n\telse\n\t\txmlrpc.setbuffer(s->str, len);\n\ts->destroy(s);\n}\nvoid xmlrpc_send(int argc, ...)\n{\n\tva_list va;\n\tint idx = 0;\n\tint len;\n\tchar buf[1024];\n\tconst char *ss;\n\tmowgli_string_t *s = mowgli_string_create();\n\tchar *s2;\n\tchar *header;\n\tif (xmlrpc.encode)\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\", xmlrpc.encode);\n\t}\n\telse\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\");\n\t}\n\ts->append(s, buf, strlen(buf));\n\tva_start(va, argc);\n\tfor (idx = 0; idx < argc; idx++)\n\t{\n\t\tss = \" <param>\\r\\n  <value>\\r\\n   \";\n\t\ts->append(s, ss, strlen(ss));\n\t\tss = va_arg(va, const char *);\n\t\ts->append(s, ss, strlen(ss));\n\t\tss = \"\\r\\n  </value>\\r\\n </param>\\r\\n\";\n\t\ts->append(s, ss, strlen(ss));\n\t}\n\tva_end(va);\n\tss = \"</params>\\r\\n</methodResponse>\";\n\ts->append(s, ss, strlen(ss));\n\tlen = s->pos;\n\tif (xmlrpc.httpheader)\n\t{\n\t\theader = xmlrpc_write_header(len);\n\t\ts2 = smalloc(strlen(header) + len + 1);\n\t\tstrcpy(s2, header);\n\t\tmemcpy(s2 + strlen(header), s->str, len);\n\t\txmlrpc.setbuffer(s2, len + strlen(header));\n\t\tfree(header);\n\t\tfree(s2);\n\t\txmlrpc.httpheader = 1;\n\t}\n\telse\n\t{\n\t\txmlrpc.setbuffer(s->str, len);\n\t}\n\tif (xmlrpc.encode)\n\t{\n\t\tfree(xmlrpc.encode);\n\t\txmlrpc.encode = NULL;\n\t}\n\ts->destroy(s);\n}\nvoid xmlrpc_send_string(const char *value)\n{\n\tint len;\n\tchar buf[1024];\n\tconst char *ss;\n\tmowgli_string_t *s = mowgli_string_create();\n\tchar *s2;\n\tchar *header;\n\tif (xmlrpc.encode)\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\", xmlrpc.encode);\n\t}\n\telse\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n<params>\\r\\n\");\n\t}\n\ts->append(s, buf, strlen(buf));\n\tss = \" <param>\\r\\n  <value>\\r\\n   <string>\";\n\ts->append(s, ss, strlen(ss));\n\txmlrpc_append_char_encode(s, value);\n\tss = \"</string>\\r\\n  </value>\\r\\n </param>\\r\\n\";\n\ts->append(s, ss, strlen(ss));\n\tss = \"</params>\\r\\n</methodResponse>\";\n\ts->append(s, ss, strlen(ss));\n\tlen = s->pos;\n\tif (xmlrpc.httpheader)\n\t{\n\t\theader = xmlrpc_write_header(len);\n\t\ts2 = smalloc(strlen(header) + len + 1);\n\t\tstrcpy(s2, header);\n\t\tmemcpy(s2 + strlen(header), s->str, len);\n\t\txmlrpc.setbuffer(s2, len + strlen(header));\n\t\tfree(header);\n\t\tfree(s2);\n\t\txmlrpc.httpheader = 1;\n\t}\n\telse\n\t{\n\t\txmlrpc.setbuffer(s->str, len);\n\t}\n\tif (xmlrpc.encode)\n\t{\n\t\tfree(xmlrpc.encode);\n\t\txmlrpc.encode = NULL;\n\t}\n\ts->destroy(s);\n}\nchar *xmlrpc_normalizeBuffer(const char *buf)\n{\n\tchar *newbuf;\n\tint i, len, j = 0;\n\tlen = strlen(buf);\n\tnewbuf = (char *)smalloc(sizeof(char) * len + 1);\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tswitch (buf[i])\n\t\t{\n\t\t  case 1:\n\t\t\t  break;\n\t\t  case 2:\n\t\t\t  break;\n\t\t  case 3:\n\t\t\t  if (isdigit((unsigned char)buf[i + 1]))\n\t\t\t  {\n\t\t\t\t  i++;\n\t\t\t\t  if (isdigit((unsigned char)buf[i + 1]))\n\t\t\t\t  {\n\t\t\t\t\t  i++;\n\t\t\t\t  }\n\t\t\t\t  if (buf[i + 1] == ',')\n\t\t\t\t  {\n\t\t\t\t\t  i++;\n\t\t\t\t\t  if (isdigit((unsigned char)buf[i + 1]))\n\t\t\t\t\t  {\n\t\t\t\t\t\t  i++;\n\t\t\t\t\t  }\n\t\t\t\t\t  if (isdigit((unsigned char)buf[i + 1]))\n\t\t\t\t\t  {\n\t\t\t\t\t\t  i++;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  break;\n\t\t  case 9:\n\t\t\t  break;\n\t\t  case 10:\n\t\t\t  break;\n\t\t  case 13:\n\t\t\t  break;\n\t\t  case 22:\n\t\t\t  break;\n\t\t  case 31:\n\t\t\t  break;\n\t\t  default:\n\t\t\t  if (buf[i] > 31)\n\t\t\t  {\n\t\t\t\tnewbuf[j] = buf[i];\n\t\t\t\tj++;\n\t\t\t  }\n\t\t}\n\t}\n\tnewbuf[j] = 0;\n\treturn (newbuf);\n}\nvoid xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\ts->append_char(s, 0);\n\tstrncpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1164.c",
        "project": "atheme/atheme",
        "url": "https://github.com/atheme/atheme/commit/87580d767868360d2fed503980129504da84b63e",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static pdf_object *pdf_add_raw_jpeg(struct pdf_doc *pdf,\n                                    const char *jpeg_file)\n    if (stat(jpeg_file, &buf) < 0) {\n    }\n    len = buf.st_size;\n    if ((fp = fopen(jpeg_file, \"rb\")) == NULL) {\n    }\n    jpeg_data = malloc(len);\n    if (!jpeg_data) {\n    }\n    if (fread(jpeg_data, len, 1, fp) != 1) {\n    }\n    if (jpeg_size(jpeg_data, len, &width, &height) < 0) {\n    }\n    final_data = malloc(len + 1024);\n    if (!final_data) {\n    }\n    written = sprintf(final_data,\n                      \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n\"\n                      flexarray_size(&pdf->objects), width, height, (int)len);\n    memcpy(&final_data[written], jpeg_data, len);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define _POSIX_SOURCE \n#include <sys/types.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include \"pdfgen.h\"\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n#define PDF_RGB_R(c) ((((c) >> 16) & 0xff) / 255.0)\n#define PDF_RGB_G(c) ((((c) >>  8) & 0xff) / 255.0)\n#define PDF_RGB_B(c) ((((c) >>  0) & 0xff) / 255.0)\n#if defined(_MSC_VER)\n#if _MSC_VER < 1900\n#define inline __inline\n#endif\n#endif // _MSC_VER\ntypedef struct pdf_object pdf_object;\nenum {\n    OBJ_none, \n    OBJ_info,\n    OBJ_stream,\n    OBJ_font,\n    OBJ_page,\n    OBJ_bookmark,\n    OBJ_outline,\n    OBJ_catalog,\n    OBJ_pages,\n    OBJ_image,\n    OBJ_count,\n};\nstruct flexarray {\n    void ***bins;\n    int item_count;\n    int bin_count;\n};\nstruct pdf_object {\n    int type; \n    int index; \n    int offset; \n    struct pdf_object *prev; \n    struct pdf_object *next; \n    union {\n        struct {\n            struct pdf_object *page;\n            char name[64];\n            struct pdf_object *parent;\n            struct flexarray children;\n        } bookmark;\n        struct {\n            char *text;\n            int len;\n        } stream;\n        struct {\n            int width;\n            int height;\n            struct flexarray children;\n        } page;\n        struct pdf_info info;\n        struct {\n            char name[64];\n            int index;\n        } font;\n    };\n};\nstruct pdf_doc {\n    char errstr[128];\n    int errval;\n    struct flexarray objects;\n    int width;\n    int height;\n    struct pdf_object *current_font;\n    struct pdf_object *last_objects[OBJ_count];\n    struct pdf_object *first_objects[OBJ_count];\n};\n#define MIN_SHIFT 10\n#define MIN_OFFSET ((1 << MIN_SHIFT) - 1)\nstatic int bin_offset[] = {\n    (1 << (MIN_SHIFT + 0)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 1)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 2)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 3)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 4)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 5)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 6)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 7)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 8)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 9)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 10)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 11)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 12)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 13)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 14)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 15)) - 1 - MIN_OFFSET,\n};\nstatic int pdf_set_err(struct pdf_doc *doc, int errval,\n                       const char *buffer, ...)\n__attribute__ ((format(printf, 3, 4)));\nstruct pdf_doc *pdf_create(int width, int height, struct pdf_info *info)\n{\n    struct pdf_doc *pdf;\n    struct pdf_object *obj;\n    pdf = calloc(1, sizeof(struct pdf_doc));\n    pdf->width = width;\n    pdf->height = height;\n    pdf_add_object(pdf, OBJ_none);\n    obj = pdf_add_object(pdf, OBJ_info);\n    if (info)\n        obj->info = *info;\n    if (!obj->info.date[0]) {\n        time_t now = time(NULL);\n        struct tm tm;\n#ifdef _WIN32\n        struct tm *tmp;\n        tmp = localtime(&now);\n        tm = *tmp;\n#else\n        localtime_r(&now, &tm);\n#endif\n        strftime(obj->info.date, sizeof(obj->info.date),\n                 \"%Y%m%d%H%M%SZ\", &tm);\n    }\n    if (!obj->info.creator[0])\n        strcpy(obj->info.creator, \"pdfgen\");\n    if (!obj->info.producer[0])\n        strcpy(obj->info.producer, \"pdfgen\");\n    if (!obj->info.title[0])\n        strcpy(obj->info.title, \"pdfgen\");\n    if (!obj->info.author[0])\n        strcpy(obj->info.author, \"pdfgen\");\n    if (!obj->info.subject[0])\n        strcpy(obj->info.subject, \"pdfgen\");\n    pdf_add_object(pdf, OBJ_pages);\n    pdf_add_object(pdf, OBJ_catalog);\n    pdf_set_font(pdf, \"Times-Roman\");\n    return pdf;\n}\nstatic int pdf_save_object(struct pdf_doc *pdf, FILE *fp, int index)\n{\n    struct pdf_object *object = pdf_get_object(pdf, index);\n    if (object->type == OBJ_none)\n        return -ENOENT;\n    object->offset = ftell(fp);\n    fprintf(fp, \"%d 0 obj\\r\\n\", index);\n    switch (object->type) {\n    case OBJ_stream:\n    case OBJ_image: {\n        int len = object->stream.len ? object->stream.len :\n                  strlen(object->stream.text);\n        fwrite(object->stream.text, len, 1, fp);\n        break;\n    }\n    case OBJ_info: {\n        struct pdf_info *info = &object->info;\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Creator (%s)\\r\\n\"\n                \"  /Producer (%s)\\r\\n\"\n                \"  /Title (%s)\\r\\n\"\n                \"  /Author (%s)\\r\\n\"\n                \"  /Subject (%s)\\r\\n\"\n                \"  /CreationDate (D:%s)\\r\\n\"\n                \">>\\r\\n\",\n                info->creator, info->producer, info->title,\n                info->author, info->subject, info->date);\n        break;\n    }\n    case OBJ_page: {\n        int i;\n        struct pdf_object *font;\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n        struct pdf_object *image = pdf_find_first_object(pdf, OBJ_image);\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Page\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\", pages->index);\n        fprintf(fp, \"/MediaBox [0 0 %d %d]\\r\\n\",\n                object->page.width, object->page.height);\n        fprintf(fp, \"/Resources <<\\r\\n\");\n        fprintf(fp, \"  /Font <<\\r\\n\");\n        for (font = pdf_find_first_object(pdf, OBJ_font); font; font = font->next)\n            fprintf(fp, \"    /F%d %d 0 R\\r\\n\",\n                    font->font.index, font->index);\n        fprintf(fp, \"  >>\\r\\n\");\n        if (image) {\n            fprintf(fp, \"  /XObject <<\");\n            for (; image; image = image->next)\n                fprintf(fp, \"/Image%d %d 0 R \", image->index, image->index);\n            fprintf(fp, \">>\\r\\n\");\n        }\n        fprintf(fp, \">>\\r\\n\");\n        fprintf(fp, \"/Contents [\\r\\n\");\n        for (i = 0; i < flexarray_size(&object->page.children); i++) {\n            struct pdf_object *child = flexarray_get(&object->page.children, i);\n            fprintf(fp, \"%d 0 R\\r\\n\", child->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n    case OBJ_bookmark: {\n        struct pdf_object *parent, *other;\n        parent = object->bookmark.parent;\n        if (!parent)\n            parent = pdf_find_first_object(pdf, OBJ_outline);\n        if (!object->bookmark.page)\n            break;\n        fprintf(fp, \"<<\\r\\n\"\n                \"/A << /Type /Action\\r\\n\"\n                \"      /S /GoTo\\r\\n\"\n                \"      /D [%d 0 R /XYZ 0 %d null]\\r\\n\"\n                \"   >>\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\"\n                \"/Title (%s)\\r\\n\",\n                object->bookmark.page->index,\n                pdf->height,\n                parent->index,\n                object->bookmark.name);\n        int nchildren = flexarray_size(&object->bookmark.children);\n        if (nchildren > 0) {\n            struct pdf_object *f, *l;\n            f = flexarray_get(&object->bookmark.children, 0);\n            l = flexarray_get(&object->bookmark.children, nchildren - 1);\n            fprintf(fp, \"/First %d 0 R\\r\\n\", f->index);\n            fprintf(fp, \"/Last %d 0 R\\r\\n\", l->index);\n        }\n        // Find the previous bookmark with the same parent\n        for (other = object->prev;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->prev)\n            ;\n        if (other)\n            fprintf(fp, \"/Prev %d 0 R\\r\\n\", other->index);\n        // Find the next bookmark with the same parent\n        for (other = object->next;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->next)\n            ;\n        if (other)\n            fprintf(fp, \"/Next %d 0 R\\r\\n\", other->index);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n    case OBJ_outline: {\n        struct pdf_object *first, *last, *cur;\n        first = pdf_find_first_object(pdf, OBJ_bookmark);\n        last = pdf_find_last_object(pdf, OBJ_bookmark);\n        if (first && last) {\n            int count = 0;\n            cur = first;\n            while (cur) {\n                if (!cur->bookmark.parent)\n                    count++;\n                cur = cur->next;\n            }\n            fprintf(fp, \"<<\\r\\n\"\n                    \"/Count %d\\r\\n\"\n                    \"/Type /Outlines\\r\\n\"\n                    \"/First %d 0 R\\r\\n\"\n                    \"/Last %d 0 R\\r\\n\"\n                    \">>\\r\\n\",\n                    count, first->index, last->index);\n        }\n        break;\n    }\n    case OBJ_font:\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Type /Font\\r\\n\"\n                \"  /Subtype /Type1\\r\\n\"\n                \"  /BaseFont /%s\\r\\n\"\n                \"  /Encoding /WinAnsiEncoding\\r\\n\"\n                \">>\\r\\n\", object->font.name);\n        break;\n    case OBJ_pages: {\n        struct pdf_object *page;\n        int npages = 0;\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Pages\\r\\n\"\n                \"/Kids [ \");\n        for (page = pdf_find_first_object(pdf, OBJ_page);\n                page;\n                page = page->next) {\n            npages++;\n            fprintf(fp, \"%d 0 R \", page->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \"/Count %d\\r\\n\", npages);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n    case OBJ_catalog: {\n        struct pdf_object *outline = pdf_find_first_object(pdf, OBJ_outline);\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Catalog\\r\\n\");\n        if (outline)\n            fprintf(fp,\n                    \"/Outlines %d 0 R\\r\\n\"\n                    \"/PageMode /UseOutlines\\r\\n\", outline->index);\n        fprintf(fp, \"/Pages %d 0 R\\r\\n\"\n                \">>\\r\\n\",\n                pages->index);\n        break;\n    }\n    default:\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PDF object type %d\",\n                           object->type);\n    }\n    fprintf(fp, \"endobj\\r\\n\");\n    return 0;\n}\nint pdf_save(struct pdf_doc *pdf, const char *filename)\n{\n    FILE *fp;\n    int i;\n    struct pdf_object *obj;\n    int xref_offset;\n    int xref_count = 0;\n    if (filename == NULL)\n        fp = stdout;\n    else if ((fp = fopen(filename, \"wb\")) == NULL)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s': %s\",\n                           filename, strerror(errno));\n    fprintf(fp, \"%%PDF-1.2\\r\\n\");\n    fprintf(fp, \"%c%c%c%c%c\\r\\n\", 0x25, 0xc7, 0xec, 0x8f, 0xa2);\n    for (i = 0; i < flexarray_size(&pdf->objects); i++)\n        if (pdf_save_object(pdf, fp, i) >= 0)\n            xref_count++;\n    xref_offset = ftell(fp);\n    fprintf(fp, \"xref\\r\\n\");\n    fprintf(fp, \"0 %d\\r\\n\", xref_count + 1);\n    fprintf(fp, \"0000000000 65535 f\\r\\n\");\n    for (i = 0; i < flexarray_size(&pdf->objects); i++) {\n        obj = pdf_get_object(pdf, i);\n        if (obj->type != OBJ_none)\n            fprintf(fp, \"%10.10d 00000 n\\r\\n\",\n                    obj->offset);\n    }\n    fprintf(fp, \"trailer\\r\\n\"\n            \"<<\\r\\n\"\n            \"/Size %d\\r\\n\", xref_count + 1);\n    obj = pdf_find_first_object(pdf, OBJ_catalog);\n    fprintf(fp, \"/Root %d 0 R\\r\\n\", obj->index);\n    obj = pdf_find_first_object(pdf, OBJ_info);\n    fprintf(fp, \"/Info %d 0 R\\r\\n\", obj->index);\n    fprintf(fp, \"/ID [<%16.16x> <%16.16x>]\\r\\n\", 0x123, 0x123);\n    fprintf(fp, \">>\\r\\n\"\n            \"startxref\\r\\n\");\n    fprintf(fp, \"%d\\r\\n\", xref_offset);\n    fprintf(fp, \"%%%%EOF\\r\\n\");\n    fclose(fp);\n    return 0;\n}\nstatic int pdf_add_stream(struct pdf_doc *pdf, struct pdf_object *page,\n                          char *buffer)\n{\n    struct pdf_object *obj;\n    int len;\n    char prefix[128];\n    char suffix[128];\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL, \"Invalid pdf page\");\n    len = strlen(buffer);\n    while (len >= 1 && (buffer[len - 1] == '\\r' ||\n                        buffer[len - 1] == '\\n')) {\n        buffer[len - 1] = '\\0';\n        len--;\n    }\n    sprintf(prefix, \"<< /Length %d >>stream\\r\\n\", len);\n    sprintf(suffix, \"\\r\\nendstream\\r\\n\");\n    len += strlen(prefix) + strlen(suffix);\n    obj = pdf_add_object(pdf, OBJ_stream);\n    if (!obj)\n        return pdf->errval;\n    obj->stream.text = malloc(len + 1);\n    if (!obj->stream.text) {\n        obj->type = OBJ_none;\n        return pdf_set_err(pdf, -ENOMEM, \"Insufficient memory for text (%d bytes)\",\n                           len + 1);\n    }\n    obj->stream.text[0] = '\\0';\n    strcat(obj->stream.text, prefix);\n    strcat(obj->stream.text, buffer);\n    strcat(obj->stream.text, suffix);\n    obj->stream.len = 0;\n    return flexarray_append(&page->page.children, obj);\n}\nint pdf_add_bookmark(struct pdf_doc *pdf, struct pdf_object *page,\n                     int parent, const char *name)\n{\n    struct pdf_object *obj;\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL,\n                           \"Unable to add bookmark, no pages available\");\n    if (!pdf_find_first_object(pdf, OBJ_outline))\n        if (!pdf_add_object(pdf, OBJ_outline))\n            return pdf->errval;\n    obj = pdf_add_object(pdf, OBJ_bookmark);\n    if (!obj)\n        return pdf->errval;\n    strncpy(obj->bookmark.name, name, sizeof(obj->bookmark.name));\n    obj->bookmark.name[sizeof(obj->bookmark.name) - 1] = '\\0';\n    obj->bookmark.page = page;\n    if (parent >= 0) {\n        struct pdf_object *parent_obj = pdf_get_object(pdf, parent);\n        if (!parent_obj)\n            return pdf_set_err(pdf, -EINVAL,\n                               \"Invalid parent ID %d supplied\", parent);\n        obj->bookmark.parent = parent_obj;\n        flexarray_append(&parent_obj->bookmark.children, obj);\n    }\n    return obj->index;\n}\nstruct dstr {\n    char *data;\n    int alloc_len;\n    int used_len;\n};\nstatic int dstr_printf(struct dstr *str, const char *fmt, ...)\n__attribute__((format(printf,2,3)));\nint pdf_add_text(struct pdf_doc *pdf, struct pdf_object *page,\n                 const char *text, int size, int xoff, int yoff,\n                 uint32_t colour)\n{\n    int i, ret;\n    int len = text ? strlen(text) : 0;\n    struct dstr str = {0, 0, 0};\n    if (!len)\n        return 0;\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%d %d TD \", xoff, yoff);\n    dstr_printf(&str, \"/F%d %d Tf \",\n                pdf->current_font->font.index, size);\n    dstr_printf(&str, \"%f %f %f rg \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_append(&str, \"(\");\n    for (i = 0; i < len; ) {\n        uint32_t code;\n        int code_len;\n        code_len = utf8_to_utf32(&text[i], len - i, &code);\n        if (code_len < 0) {\n            dstr_free(&str);\n            return pdf_set_err(pdf, -EINVAL, \"Invalid UTF-8 encoding\");\n        }\n        if (code > 255) {\n            char buf[5] = {0};\n            switch (code) {\n            case 0x160:\n                buf[0] = (char)0x8a;\n                break;\n            case 0x161:\n                buf[0] = (char)0x9a;\n                break;\n            case 0x17d:\n                buf[0] = (char)0x8e;\n                break;\n            case 0x17e:\n                buf[0] = (char)0x9e;\n                break;\n            case 0x20ac:\n                strcpy(buf, \"\\\\200\");\n                break;\n            default:\n                dstr_free(&str);\n                return pdf_set_err(pdf, -EINVAL, \"Unsupported UTF-8 character: 0x%x 0o%o\", code, code);\n            }\n            dstr_append(&str, buf);\n        } else if (strchr(\"()\\\\\", code)) {\n            char buf[3];\n            buf[0] = '\\\\';\n            buf[1] = code;\n            buf[2] = '\\0';\n            dstr_append(&str, buf);\n        } else if (strrchr(\"\\n\\r\\t\\b\\f\", code)) {\n            ;\n        } else {\n            char buf[2];\n            buf[0] = code;\n            buf[1] = '\\0';\n            dstr_append(&str, buf);\n        }\n        i += code_len;\n    }\n    dstr_append(&str, \") Tj \");\n    dstr_append(&str, \"ET\");\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\nstatic const uint16_t helvetica_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\nstatic const uint16_t helvetica_bold_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\nstatic uint16_t helvetica_bold_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\nstatic uint16_t helvetica_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\nstatic uint16_t symbol_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 713, 500, 549, 833, 778, 439,\n    333, 333, 500, 549, 250, 549, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 549, 549, 549, 444,\n    549, 722, 667, 722, 612, 611, 763, 603,\n    722, 333, 631, 722, 686, 889, 722, 722,\n    768, 741, 556, 592, 611, 690, 439, 768,\n    645, 795, 611, 333, 863, 333, 658, 500,\n    500, 631, 549, 549, 494, 439, 521, 411,\n    603, 329, 603, 549, 549, 576, 521, 549,\n    549, 521, 549, 603, 439, 576, 713, 686,\n    493, 686, 494, 480, 200, 480, 549, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    750, 620, 247, 549, 167, 713, 500, 753,\n    753, 753, 753, 1042, 987, 603, 987, 603,\n    400, 549, 411, 549, 549, 713, 494, 460,\n    549, 549, 549, 549, 1000, 603, 1000, 658,\n    823, 686, 795, 987, 768, 768, 823, 768,\n    768, 713, 713, 713, 713, 713, 713, 713,\n    768, 713, 790, 790, 890, 823, 549, 250,\n    713, 603, 603, 1042, 987, 603, 987, 603,\n    494, 329, 790, 790, 786, 713, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 494,\n    0, 329, 274, 686, 686, 686, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 0\n};\nstatic uint16_t times_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 408, 500, 500, 833, 778, 180,\n    333, 333, 500, 564, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 564, 564, 564, 444,\n    921, 722, 667, 667, 722, 611, 556, 722,\n    722, 333, 389, 722, 611, 889, 722, 722,\n    556, 722, 667, 556, 611, 722, 722, 944,\n    722, 722, 611, 333, 278, 333, 469, 500,\n    333, 444, 500, 444, 500, 444, 333, 500,\n    500, 278, 278, 500, 278, 778, 500, 500,\n    500, 500, 333, 389, 278, 500, 500, 722,\n    500, 500, 444, 480, 200, 480, 541, 350,\n    500, 350, 333, 500, 444, 1000, 500, 500,\n    333, 1000, 556, 333, 889, 350, 611, 350,\n    350, 333, 333, 444, 444, 350, 500, 1000,\n    333, 980, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 200, 500,\n    333, 760, 276, 500, 564, 333, 760, 333,\n    400, 564, 300, 300, 333, 500, 453, 250,\n    333, 300, 310, 500, 750, 750, 750, 444,\n    722, 722, 722, 722, 722, 722, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 722, 722, 722, 722, 722, 722, 564,\n    722, 722, 722, 722, 722, 722, 556, 500,\n    444, 444, 444, 444, 444, 444, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 564,\n    500, 500, 500, 500, 500, 500, 500, 500\n};\nstatic uint16_t times_bold_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 555, 500, 500, 1000, 833, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    930, 722, 667, 722, 722, 667, 611, 778,\n    778, 389, 500, 778, 667, 944, 722, 778,\n    611, 778, 722, 556, 667, 722, 722, 1000,\n    722, 722, 667, 333, 278, 333, 581, 500,\n    333, 500, 556, 444, 556, 444, 333, 500,\n    556, 278, 333, 556, 278, 833, 556, 500,\n    556, 556, 444, 389, 333, 556, 500, 722,\n    500, 500, 444, 394, 220, 394, 520, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 1000, 350, 667, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 220, 500,\n    333, 747, 300, 500, 570, 333, 747, 333,\n    400, 570, 300, 300, 333, 556, 540, 250,\n    333, 300, 330, 500, 750, 750, 750, 500,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 778, 778, 778, 778, 778, 570,\n    778, 722, 722, 722, 722, 722, 611, 556,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 500, 556, 500\n} ;\nstatic uint16_t times_bold_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 389, 555, 500, 500, 833, 778, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    832, 667, 667, 667, 722, 667, 667, 722,\n    778, 389, 500, 667, 611, 889, 722, 722,\n    611, 722, 667, 556, 611, 722, 667, 889,\n    667, 611, 611, 333, 278, 333, 570, 500,\n    333, 500, 500, 444, 500, 444, 333, 500,\n    556, 278, 278, 500, 278, 778, 556, 500,\n    500, 500, 389, 389, 278, 556, 444, 667,\n    500, 444, 389, 348, 220, 348, 570, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 944, 350, 611, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 389, 611,\n    250, 389, 500, 500, 500, 500, 220, 500,\n    333, 747, 266, 500, 606, 333, 747, 333,\n    400, 570, 300, 300, 333, 576, 500, 250,\n    333, 300, 300, 500, 750, 750, 750, 500,\n    667, 667, 667, 667, 667, 667, 944, 667,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 722, 722, 722, 722, 722, 570,\n    722, 722, 722, 722, 722, 611, 611, 500,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 444, 500, 444\n};\nstatic uint16_t times_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 420, 500, 500, 833, 778, 214,\n    333, 333, 500, 675, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 675, 675, 675, 500,\n    920, 611, 611, 667, 722, 611, 611, 722,\n    722, 333, 444, 667, 556, 833, 667, 722,\n    611, 722, 611, 500, 556, 722, 611, 833,\n    611, 556, 556, 389, 278, 389, 422, 500,\n    333, 500, 500, 444, 500, 444, 278, 500,\n    500, 278, 278, 444, 278, 722, 500, 500,\n    500, 500, 389, 389, 278, 500, 444, 667,\n    444, 444, 389, 400, 275, 400, 541, 350,\n    500, 350, 333, 500, 556, 889, 500, 500,\n    333, 1000, 500, 333, 944, 350, 556, 350,\n    350, 333, 333, 556, 556, 350, 500, 889,\n    333, 980, 389, 333, 667, 350, 389, 556,\n    250, 389, 500, 500, 500, 500, 275, 500,\n    333, 760, 276, 500, 675, 333, 760, 333,\n    400, 675, 300, 300, 333, 500, 523, 250,\n    333, 300, 310, 500, 750, 750, 750, 500,\n    611, 611, 611, 611, 611, 611, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 667, 722, 722, 722, 722, 722, 675,\n    722, 722, 722, 722, 722, 556, 611, 500,\n    500, 500, 500, 500, 500, 500, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 675,\n    500, 500, 500, 500, 500, 444, 500, 444\n};\nstatic uint16_t zapfdingbats_widths[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    278, 974, 961, 974, 980, 719, 789, 790,\n    791, 690, 960, 939, 549, 855, 911, 933,\n    911, 945, 974, 755, 846, 762, 761, 571,\n    677, 763, 760, 759, 754, 494, 552, 537,\n    577, 692, 786, 788, 788, 790, 793, 794,\n    816, 823, 789, 841, 823, 833, 816, 831,\n    923, 744, 723, 749, 790, 792, 695, 776,\n    768, 792, 759, 707, 708, 682, 701, 826,\n    815, 789, 789, 707, 687, 696, 689, 786,\n    787, 713, 791, 785, 791, 873, 761, 762,\n    762, 759, 759, 892, 892, 788, 784, 438,\n    138, 277, 415, 392, 392, 668, 668, 0,\n    390, 390, 317, 317, 276, 276, 509, 509,\n    410, 410, 234, 234, 334, 334, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 732, 544, 544, 910, 667, 760, 760,\n    776, 595, 694, 626, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 894, 838, 1016, 458,\n    748, 924, 748, 918, 927, 928, 928, 834,\n    873, 828, 924, 924, 917, 930, 931, 463,\n    883, 836, 836, 867, 867, 696, 696, 874,\n    0, 874, 760, 946, 771, 865, 771, 888,\n    967, 888, 831, 873, 927, 970, 918, 0\n};\nstatic uint16_t courier_widths[256] = {\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n};\nstatic const uint16_t *find_font_widths(const char *font_name)\n{\n    if (strcmp(font_name, \"Helvetica\") == 0)\n        return helvetica_widths;\n    if (strcmp(font_name, \"Helvetica-Bold\") == 0)\n        return helvetica_bold_widths;\n    if (strcmp(font_name, \"Helvetica-BoldOblique\") == 0)\n        return helvetica_bold_oblique_widths;\n    if (strcmp(font_name, \"Helvetica-Oblique\") == 0)\n        return helvetica_oblique_widths;\n    if (strcmp(font_name, \"Courier\") == 0 ||\n            strcmp(font_name, \"Courier-Bold\") == 0 ||\n            strcmp(font_name, \"Courier-BoldOblique\") == 0 ||\n            strcmp(font_name, \"Courier-Oblique\") == 0)\n        return courier_widths;\n    if (strcmp(font_name, \"Times-Roman\") == 0)\n        return times_widths;\n    if (strcmp(font_name, \"Times-Bold\") == 0)\n        return times_bold_widths;\n    if (strcmp(font_name, \"Times-Italic\") == 0)\n        return times_italic_widths;\n    if (strcmp(font_name, \"Times-BoldItalic\") == 0)\n        return times_bold_italic_widths;\n    if (strcmp(font_name, \"Symbol\") == 0)\n        return symbol_widths;\n    if (strcmp(font_name, \"ZapfDingbats\") == 0)\n        return zapfdingbats_widths;\n    return NULL;\n}\nint pdf_add_text_wrap(struct pdf_doc *pdf, struct pdf_object *page,\n                      const char *text, int size, int xoff, int yoff,\n                      uint32_t colour, int wrap_width)\n{\n    const char *start = text;\n    const char *last_best = text;\n    const char *end = text;\n    char line[512];\n    const uint16_t *widths;\n    int orig_yoff = yoff;\n    widths = find_font_widths(pdf->current_font->font.name);\n    if (!widths)\n        return pdf_set_err(pdf, -EINVAL, \"Unable to determine width for font '%s'\",\n                           pdf->current_font->font.name);\n    while (start && *start) {\n        const char *new_end = find_word_break(end + 1);\n        int line_width;\n        int output = 0;\n        end = new_end;\n        line_width = pdf_text_pixel_width(start, end - start, size, widths);\n        if (line_width >= wrap_width) {\n            if (last_best == start) {\n                int i;\n                for (i = end - start - 1; i > 0; i--)\n                    if (pdf_text_pixel_width(start, i, size, widths) < wrap_width)\n                        break;\n                end = start + i;\n            } else\n                end = last_best;\n            output = 1;\n        }\n        if (*end == '\\0')\n            output = 1;\n        if (*end == '\\n' || *end == '\\r')\n            output = 1;\n        if (output) {\n            int len = end - start;\n            strncpy(line, start, len);\n            line[len] = '\\0';\n            pdf_add_text(pdf, page, line, size, xoff, yoff, colour);\n            if (*end == ' ')\n                end++;\n            start = last_best = end;\n            yoff -= size;\n        } else\n            last_best = end;\n    }\n    return orig_yoff - yoff;\n}\nint pdf_add_circle(struct pdf_doc *pdf, struct pdf_object *page,\n                   int x, int y, int radius, int width, uint32_t colour, bool filled)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n    dstr_append(&str, \"BT \");\n    if (filled)\n        dstr_printf(&str, \"%f %f %f rg \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    else\n        dstr_printf(&str, \"%f %f %f RG \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", width);\n    dstr_printf(&str, \"%d %d m \", x + radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y + radius, x, y + radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y + radius, x - radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y - radius, x, y - radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y - radius, x + radius, y);\n    if (filled)\n        dstr_append(&str, \"f \");\n    else\n        dstr_append(&str, \"S \");\n    dstr_append(&str, \"ET\");\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_128a_encoding[] = {\n    {0x212222, ' '},\n    {0x222122, '!'},\n    {0x222221, '\"'},\n    {0x121223, '#'},\n    {0x121322, '$'},\n    {0x131222, '%'},\n    {0x122213, '&'},\n    {0x122312, '\\''},\n    {0x132212, '('},\n    {0x221213, ')'},\n    {0x221312, '*'},\n    {0x231212, '+'},\n    {0x112232, ','},\n    {0x122132, '-'},\n    {0x122231, '.'},\n    {0x113222, '/'},\n    {0x123122, '0'},\n    {0x123221, '1'},\n    {0x223211, '2'},\n    {0x221132, '3'},\n    {0x221231, '4'},\n    {0x213212, '5'},\n    {0x223112, '6'},\n    {0x312131, '7'},\n    {0x311222, '8'},\n    {0x321122, '9'},\n    {0x321221, ':'},\n    {0x312212, ';'},\n    {0x322112, '<'},\n    {0x322211, '='},\n    {0x212123, '>'},\n    {0x212321, '?'},\n    {0x232121, '@'},\n    {0x111323, 'A'},\n    {0x131123, 'B'},\n    {0x131321, 'C'},\n    {0x112313, 'D'},\n    {0x132113, 'E'},\n    {0x132311, 'F'},\n    {0x211313, 'G'},\n    {0x231113, 'H'},\n    {0x231311, 'I'},\n    {0x112133, 'J'},\n    {0x112331, 'K'},\n    {0x132131, 'L'},\n    {0x113123, 'M'},\n    {0x113321, 'N'},\n    {0x133121, 'O'},\n    {0x313121, 'P'},\n    {0x211331, 'Q'},\n    {0x231131, 'R'},\n    {0x213113, 'S'},\n    {0x213311, 'T'},\n    {0x213131, 'U'},\n    {0x311123, 'V'},\n    {0x311321, 'W'},\n    {0x331121, 'X'},\n    {0x312113, 'Y'},\n    {0x312311, 'Z'},\n    {0x332111, '['},\n    {0x314111, '\\\\'},\n    {0x221411, ']'},\n    {0x431111, '^'},\n    {0x111224, '_'},\n    {0x111422, '`'},\n    {0x121124, 'a'},\n    {0x121421, 'b'},\n    {0x141122, 'c'},\n    {0x141221, 'd'},\n    {0x112214, 'e'},\n    {0x112412, 'f'},\n    {0x122114, 'g'},\n    {0x122411, 'h'},\n    {0x142112, 'i'},\n    {0x142211, 'j'},\n    {0x241211, 'k'},\n    {0x221114, 'l'},\n    {0x413111, 'm'},\n    {0x241112, 'n'},\n    {0x134111, 'o'},\n    {0x111242, 'p'},\n    {0x121142, 'q'},\n    {0x121241, 'r'},\n    {0x114212, 's'},\n    {0x124112, 't'},\n    {0x124211, 'u'},\n    {0x411212, 'v'},\n    {0x421112, 'w'},\n    {0x421211, 'x'},\n    {0x212141, 'y'},\n    {0x214121, 'z'},\n    {0x412121, '{'},\n    {0x111143, '|'},\n    {0x111341, '}'},\n    {0x131141, '~'},\n    {0x114113, '\\0'},\n    {0x114311, '\\0'},\n    {0x411113, '\\0'},\n    {0x411311, '\\0'},\n    {0x113141, '\\0'},\n    {0x114131, '\\0'},\n    {0x311141, '\\0'},\n    {0x411131, '\\0'},\n    {0x211412, '\\0'},\n    {0x211214, '\\0'},\n    {0x211232, '\\0'},\n    {0x2331112, '\\0'},\n};\nstatic int pdf_add_barcode_128a(struct pdf_doc *pdf, struct pdf_object *page,\n                                int x, int y, int width, int height,\n                                const char *string, uint32_t colour)\n{\n    const char *s;\n    int len = strlen(string) + 3;\n    int char_width = width / len;\n    int checksum, i;\n    for (s = string; *s; s++)\n        if (find_128_encoding(*s) < 0)\n            return pdf_set_err(pdf, -EINVAL, \"Invalid barcode character 0x%x\", *s);\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 104,\n                            6);\n    checksum = 104;\n    for (i = 1, s = string; *s; s++, i++) {\n        int index = find_128_encoding(*s);\n        x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, index,\n                                6);\n        checksum += index * i;\n    }\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour,\n                            checksum % 103, 6);\n    pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 106,\n                        7);\n    return 0;\n}\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_39_encoding[] = {\n    {0x012110, '1'},\n    {0x102110, '2'},\n    {0x002111, '3'},\n    {0x112010, '4'},\n    {0x012011, '5'},\n    {0x102011, '6'},\n    {0x112100, '7'},\n    {0x012101, '8'},\n    {0x102101, '9'},\n    {0x112001, '0'},\n    {0x011210, 'A'},\n    {0x101210, 'B'},\n    {0x001211, 'C'},\n    {0x110210, 'D'},\n    {0x010211, 'E'},\n    {0x100211, 'F'},\n    {0x111200, 'G'},\n    {0x011201, 'H'},\n    {0x101201, 'I'},\n    {0x110201, 'J'},\n    {0x011120, 'K'},\n    {0x101120, 'L'},\n    {0x001121, 'M'},\n    {0x110120, 'N'},\n    {0x010121, 'O'},\n    {0x100121, 'P'},\n    {0x111020, 'Q'},\n    {0x011021, 'R'},\n    {0x101021, 'S'},\n    {0x110021, 'T'},\n    {0x021110, 'U'},\n    {0x120110, 'V'},\n    {0x020111, 'W'},\n    {0x121010, 'X'},\n    {0x021011, 'Y'},\n    {0x120011, 'Z'},\n    {0x121100, '-'},\n    {0x021101, '.'},\n    {0x120101, ' '},\n    {0x121001, '*'}, // 'stop' character\n};\nstatic int pdf_barcode_39_ch(struct pdf_doc *pdf, struct pdf_object *page, int x, int y, int char_width, int height, uint32_t colour, char ch)\n{\n    int nw = char_width / 12;\n    int ww = char_width / 4;\n    int i;\n    uint32_t code;\n    if (nw <= 1 || ww <= 1)\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient width for each character\");\n    for (i = 0; i < ARRAY_SIZE(code_39_encoding); i++) {\n        if (code_39_encoding[i].ch == ch) {\n            code = code_39_encoding[i].code;\n            break;\n        }\n    }\n    if (i == ARRAY_SIZE(code_39_encoding))\n        return pdf_set_err(pdf, -EINVAL, \"Invalid Code 39 character %c 0x%x\", ch, ch);\n    for (i = 5; i >= 0; i--) {\n        int pattern = (code >> i * 4) & 0xf;\n        if (pattern == 0) { // wide\n            if (pdf_add_filled_rectangle(pdf, page, x, y, ww - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += ww;\n        }\n        if (pattern == 1) { // narrow\n            if (pdf_add_filled_rectangle(pdf, page, x, y, nw - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += nw;\n        }\n        if (pattern == 2) { // space\n            x += nw;\n        }\n    }\n    return x;\n}\nstatic pdf_object *pdf_add_raw_rgb24(struct pdf_doc *pdf,\n                                     uint8_t *data, int width, int height)\n{\n    struct pdf_object *obj;\n    char line[1024];\n    int len;\n    uint8_t *final_data;\n    const char *endstream = \">\\r\\nendstream\\r\\n\";\n    int i;\n    sprintf(line,\n            \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n/Subtype /Image\\r\\n\"\n            \"/ColorSpace /DeviceRGB\\r\\n/Height %d\\r\\n/Width %d\\r\\n\"\n            \"/BitsPerComponent 8\\r\\n/Filter /ASCIIHexDecode\\r\\n\"\n            \"/Length %d\\r\\n>>stream\\r\\n\",\n            flexarray_size(&pdf->objects), height, width, width * height * 3 * 2 + 1);\n    len = strlen(line) + width * height * 3 * 2 + strlen(endstream) + 1;\n    final_data = malloc(len);\n    if (!final_data) {\n        pdf_set_err(pdf, -ENOMEM, \"Unable to allocate %d bytes memory for image\",\n                    len);\n        return NULL;\n    }\n    strcpy((char *)final_data, line);\n    uint8_t *pos = &final_data[strlen(line)];\n    for (i = 0; i < width * height * 3; i++) {\n        *pos++ = \"0123456789ABCDEF\"[(data[i] >> 4) & 0xf];\n        *pos++ = \"0123456789ABCDEF\"[data[i] & 0xf];\n    }\n    strcpy((char *)pos, endstream);\n    pos += strlen(endstream);\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = (char *)final_data;\n    obj->stream.len = pos - final_data;\n    return obj;\n}\nstatic int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n    return -1;\n}\nstatic pdf_object *pdf_add_raw_jpeg(struct pdf_doc *pdf,\n                                    const char *jpeg_file)\n{\n    struct stat buf;\n    off_t len;\n    char *final_data;\n    uint8_t *jpeg_data;\n    int written = 0;\n    FILE *fp;\n    struct pdf_object *obj;\n    int width, height;\n    if (stat(jpeg_file, &buf) < 0) {\n        pdf_set_err(pdf, -errno, \"Unable to access %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n    len = buf.st_size;\n    if ((fp = fopen(jpeg_file, \"rb\")) == NULL) {\n        pdf_set_err(pdf, -errno, \"Unable to open %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n    jpeg_data = malloc(len);\n    if (!jpeg_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate: %zd\", len);\n        fclose(fp);\n        return NULL;\n    }\n    if (fread(jpeg_data, len, 1, fp) != 1) {\n        pdf_set_err(pdf, -errno, \"Unable to read full jpeg data\");\n        free(jpeg_data);\n        fclose(fp);\n        return NULL;\n    }\n    fclose(fp);\n    if (jpeg_size(jpeg_data, len, &width, &height) < 0) {\n        free(jpeg_data);\n        pdf_set_err(pdf, -EINVAL, \"Unable to determine jpeg width/height from %s\",\n                    jpeg_file);\n        return NULL;\n    }\n    final_data = malloc(len + 1024);\n    if (!final_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate jpeg data %zd\", len + 1024);\n        free(jpeg_data);\n        return NULL;\n    }\n    written = sprintf(final_data,\n                      \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n\"\n                      \"/Subtype /Image\\r\\n/ColorSpace /DeviceRGB\\r\\n\"\n                      \"/Width %d\\r\\n/Height %d\\r\\n\"\n                      \"/BitsPerComponent 8\\r\\n/Filter /DCTDecode\\r\\n\"\n                      \"/Length %d\\r\\n>>stream\\r\\n\",\n                      flexarray_size(&pdf->objects), width, height, (int)len);\n    memcpy(&final_data[written], jpeg_data, len);\n    written += len;\n    written += sprintf(&final_data[written], \"\\r\\nendstream\\r\\n\");\n    free(jpeg_data);\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = final_data;\n    obj->stream.len = written;\n    return obj;\n}\nint pdf_add_ppm(struct pdf_doc *pdf, struct pdf_object *page,\n                int x, int y, int display_width, int display_height,\n                const char *ppm_file)\n{\n    struct pdf_object *obj;\n    uint8_t *data;\n    FILE *fp;\n    char line[1024];\n    unsigned width, height, size;\n    fp = fopen(ppm_file, \"rb\");\n    if (!fp)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s'\", ppm_file);\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PPM file\");\n    }\n    if (strncmp(line, \"P6\", 2) != 0) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Only binary PPM files supported\");\n    }\n    do {\n        if (!fgets(line, sizeof(line) - 1, fp)) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        if (line[0] == '#')\n            continue;\n        if (sscanf(line, \"%u %u\\n\", &width, &height) != 2) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        break;\n    } while (1);\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"No byte-size line in PPM file\");\n    }\n    if (width > INT_MAX || height > INT_MAX) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid width/height in PPM file: %ux%u\", width, height);\n    }\n    size = width * height * 3;\n    data = malloc(size);\n    if (!data) {\n        fclose(fp);\n        return pdf_set_err(pdf, -ENOMEM, \"Unable to allocate memory for RGB data\");\n    }\n    if (fread(data, 1, size, fp) != size) {\n        free(data);\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient RGB data available\");\n    }\n    fclose(fp);\n    obj = pdf_add_raw_rgb24(pdf, data, width, height);\n    free(data);\n    if (!obj)\n        return pdf->errval;\n    return pdf_add_image(pdf, page, obj, x, y, display_width, display_height);\n}\n",
        "cwe": "CWE-125",
        "file_name": "vul_respovul_idx_2863.c",
        "project": "andrerenaud/pdfgen",
        "url": "https://github.com/AndreRenaud/PDFGen/commit/ee58aff6918b8bbc3be29b9e3089485ea46ff956",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int ide_dvd_read_structure(IDEState *s, int format,\n                                  const uint8_t *packet, uint8_t *buf)\n                total_sectors = s->nb_sectors >> 2;\n                if (total_sectors == 0) {\n                }\n                buf[4] = 1;   \n                buf[5] = 0xf; \n                buf[6] = 1;   \n                buf[7] = 0;   \n                stl_be_p(buf + 8, 0); \n                stl_be_p(buf + 12, total_sectors - 1); \nstatic void cmd_read_dvd_structure(IDEState *s, uint8_t* buf)\n    int media = buf[1];\n    int format = buf[7];\n    max_len = lduw_be_p(buf + 8);\n    if (format < 0xff) {\n        if (media_is_cd(s)) {\n        } else if (!media_present(s)) {\n        }\n    }\n    memset(buf, 0, max_len > IDE_DMA_BUF_SECTORS * BDRV_SECTOR_SIZE + 4 ?\n           IDE_DMA_BUF_SECTORS * BDRV_SECTOR_SIZE + 4 : max_len);\n            if (media == 0) {\n                ret = ide_dvd_read_structure(s, format, buf, buf);\n            }\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"qemu/osdep.h\"\n#include \"hw/ide/internal.h\"\n#include \"hw/scsi/scsi.h\"\n#include \"sysemu/block-backend.h\"\n#include \"trace.h\"\n#define ATAPI_SECTOR_BITS (2 + BDRV_SECTOR_BITS)\n#define ATAPI_SECTOR_SIZE (1 << ATAPI_SECTOR_BITS)\nstatic void ide_atapi_cmd_read_dma_cb(void *opaque, int ret);\nstatic void lba_to_msf(uint8_t *buf, int lba)\n{\n    lba += 150;\n    buf[0] = (lba / 75) / 60;\n    buf[1] = (lba / 75) % 60;\n    buf[2] = lba % 75;\n}\nstatic void cd_data_to_raw(uint8_t *buf, int lba)\n{\n    buf[0] = 0x00;\n    memset(buf + 1, 0xff, 10);\n    buf[11] = 0x00;\n    buf += 12;\n    lba_to_msf(buf, lba);\n    buf[3] = 0x01; \n    buf += 4;\n    buf += 2048;\n    memset(buf, 0, 288);\n}\nstatic int\ncd_read_sector_sync(IDEState *s)\n{\n    int ret;\n    block_acct_start(blk_get_stats(s->blk), &s->acct,\n                     ATAPI_SECTOR_SIZE, BLOCK_ACCT_READ);\n    trace_cd_read_sector_sync(s->lba);\n    switch (s->cd_sector_size) {\n    case 2048:\n        ret = blk_pread(s->blk, (int64_t)s->lba << ATAPI_SECTOR_BITS,\n                        s->io_buffer, ATAPI_SECTOR_SIZE);\n        break;\n    case 2352:\n        ret = blk_pread(s->blk, (int64_t)s->lba << ATAPI_SECTOR_BITS,\n                        s->io_buffer + 16, ATAPI_SECTOR_SIZE);\n        if (ret >= 0) {\n            cd_data_to_raw(s->io_buffer, s->lba);\n        }\n        break;\n    default:\n        block_acct_invalid(blk_get_stats(s->blk), BLOCK_ACCT_READ);\n        return -EIO;\n    }\n    if (ret < 0) {\n        block_acct_failed(blk_get_stats(s->blk), &s->acct);\n    } else {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n        s->lba++;\n        s->io_buffer_index = 0;\n    }\n    return ret;\n}\nstatic int cd_read_sector(IDEState *s)\n{\n    void *buf;\n    if (s->cd_sector_size != 2048 && s->cd_sector_size != 2352) {\n        block_acct_invalid(blk_get_stats(s->blk), BLOCK_ACCT_READ);\n        return -EINVAL;\n    }\n    buf = (s->cd_sector_size == 2352) ? s->io_buffer + 16 : s->io_buffer;\n    qemu_iovec_init_buf(&s->qiov, buf, ATAPI_SECTOR_SIZE);\n    trace_cd_read_sector(s->lba);\n    block_acct_start(blk_get_stats(s->blk), &s->acct,\n                     ATAPI_SECTOR_SIZE, BLOCK_ACCT_READ);\n    ide_buffered_readv(s, (int64_t)s->lba << 2, &s->qiov, 4,\n                       cd_read_sector_cb, s);\n    s->status |= BUSY_STAT;\n    return 0;\n}\nvoid ide_atapi_cmd_ok(IDEState *s)\n{\n    s->error = 0;\n    s->status = READY_STAT | SEEK_STAT;\n    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n    ide_transfer_stop(s);\n    ide_set_irq(s->bus);\n}\nvoid ide_atapi_cmd_error(IDEState *s, int sense_key, int asc)\n{\n    trace_ide_atapi_cmd_error(s, sense_key, asc);\n    s->error = sense_key << 4;\n    s->status = READY_STAT | ERR_STAT;\n    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n    s->sense_key = sense_key;\n    s->asc = asc;\n    ide_transfer_stop(s);\n    ide_set_irq(s->bus);\n}\nvoid ide_atapi_io_error(IDEState *s, int ret)\n{\n    if (ret == -ENOMEDIUM) {\n        ide_atapi_cmd_error(s, NOT_READY,\n                            ASC_MEDIUM_NOT_PRESENT);\n    } else {\n        ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                            ASC_LOGICAL_BLOCK_OOR);\n    }\n}\nstatic uint16_t atapi_byte_count_limit(IDEState *s)\n{\n    uint16_t bcl;\n    bcl = s->lcyl | (s->hcyl << 8);\n    if (bcl == 0xffff) {\n        return 0xfffe;\n    }\n    return bcl;\n}\nvoid ide_atapi_cmd_reply_end(IDEState *s)\n{\n    int byte_count_limit, size, ret;\n    while (s->packet_transfer_size > 0) {\n        trace_ide_atapi_cmd_reply_end(s, s->packet_transfer_size,\n                                      s->elementary_transfer_size,\n                                      s->io_buffer_index);\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n            if (!s->elementary_transfer_size) {\n                ret = cd_read_sector(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                }\n                return;\n            } else {\n                ret = cd_read_sector_sync(s);\n                if (ret < 0) {\n                    ide_atapi_io_error(s, ret);\n                    return;\n                }\n            }\n        }\n        if (s->elementary_transfer_size > 0) {\n            size = s->cd_sector_size - s->io_buffer_index;\n            if (size > s->elementary_transfer_size)\n                size = s->elementary_transfer_size;\n        } else {\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n            ide_set_irq(s->bus);\n            byte_count_limit = atapi_byte_count_limit(s);\n            trace_ide_atapi_cmd_reply_end_bcl(s, byte_count_limit);\n            size = s->packet_transfer_size;\n            if (size > byte_count_limit) {\n                if (byte_count_limit & 1)\n                    byte_count_limit--;\n                size = byte_count_limit;\n            }\n            s->lcyl = size;\n            s->hcyl = size >> 8;\n            s->elementary_transfer_size = size;\n            if (s->lba != -1) {\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n                    size = (s->cd_sector_size - s->io_buffer_index);\n            }\n            trace_ide_atapi_cmd_reply_end_new(s, s->status);\n        }\n        s->packet_transfer_size -= size;\n        s->elementary_transfer_size -= size;\n        s->io_buffer_index += size;\n        assert(size <= s->io_buffer_total_len);\n        assert(s->io_buffer_index <= s->io_buffer_total_len);\n        if (!ide_transfer_start_norecurse(s,\n                                          s->io_buffer + s->io_buffer_index - size,\n                                          size, ide_atapi_cmd_reply_end)) {\n            return;\n        }\n    }\n    trace_ide_atapi_cmd_reply_end_eot(s, s->status);\n    ide_atapi_cmd_ok(s);\n    ide_set_irq(s->bus);\n}\nstatic void ide_atapi_cmd_read_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int data_offset, n;\n    if (ret < 0) {\n        if (ide_handle_rw_error(s, -ret, ide_dma_cmd_to_retry(s->dma_cmd))) {\n            if (s->bus->error_status) {\n                s->bus->dma->aiocb = NULL;\n                return;\n            }\n            goto eot;\n        }\n    }\n    if (s->io_buffer_size > 0) {\n        if (s->lba != -1) {\n            if (s->cd_sector_size == 2352) {\n                n = 1;\n                cd_data_to_raw(s->io_buffer, s->lba);\n            } else {\n                n = s->io_buffer_size >> 11;\n            }\n            s->lba += n;\n        }\n        s->packet_transfer_size -= s->io_buffer_size;\n        if (s->bus->dma->ops->rw_buf(s->bus->dma, 1) == 0)\n            goto eot;\n    }\n    if (s->packet_transfer_size <= 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n    s->io_buffer_index = 0;\n    if (s->cd_sector_size == 2352) {\n        n = 1;\n        s->io_buffer_size = s->cd_sector_size;\n        data_offset = 16;\n    } else {\n        n = s->packet_transfer_size >> 11;\n        if (n > (IDE_DMA_BUF_SECTORS / 4))\n            n = (IDE_DMA_BUF_SECTORS / 4);\n        s->io_buffer_size = n * 2048;\n        data_offset = 0;\n    }\n    trace_ide_atapi_cmd_read_dma_cb_aio(s, s->lba, n);\n    qemu_iovec_init_buf(&s->bus->dma->qiov, s->io_buffer + data_offset,\n                        n * ATAPI_SECTOR_SIZE);\n    s->bus->dma->aiocb = ide_buffered_readv(s, (int64_t)s->lba << 2,\n                                            &s->bus->dma->qiov, n * 4,\n                                            ide_atapi_cmd_read_dma_cb, s);\n    return;\neot:\n    if (ret < 0) {\n        block_acct_failed(blk_get_stats(s->blk), &s->acct);\n    } else {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, false);\n}\nstatic int ide_dvd_read_structure(IDEState *s, int format,\n                                  const uint8_t *packet, uint8_t *buf)\n{\n    switch (format) {\n        case 0x0: \n            {\n                int layer = packet[6];\n                uint64_t total_sectors;\n                if (layer != 0)\n                    return -ASC_INV_FIELD_IN_CMD_PACKET;\n                total_sectors = s->nb_sectors >> 2;\n                if (total_sectors == 0) {\n                    return -ASC_MEDIUM_NOT_PRESENT;\n                }\n                buf[4] = 1;   \n                buf[5] = 0xf; \n                buf[6] = 1;   \n                buf[7] = 0;   \n                stl_be_p(buf + 8, 0); \n                stl_be_p(buf + 12, total_sectors - 1); \n                stl_be_p(buf + 16, total_sectors - 1); \n                stw_be_p(buf, 2048 + 2);\n                return (2048 + 4);\n            }\n        case 0x01: \n            buf[4] = 0; \n            buf[5] = 0; \n            stw_be_p(buf, 4 + 2);\n            return (4 + 4);\n        case 0x03: \n            return -ASC_INV_FIELD_IN_CMD_PACKET;\n        case 0x04: \n            stw_be_p(buf, 2048 + 2);\n            return (2048 + 4);\n        case 0xff:\n            buf[4] = 0x00; \n            buf[5] = 0x40; \n            stw_be_p(buf + 6, 2048 + 4);\n            buf[8] = 0x01; \n            buf[9] = 0x40; \n            stw_be_p(buf + 10, 4 + 4);\n            buf[12] = 0x03; \n            buf[13] = 0x40; \n            stw_be_p(buf + 14, 188 + 4);\n            buf[16] = 0x04; \n            buf[17] = 0x40; \n            stw_be_p(buf + 18, 2048 + 4);\n            stw_be_p(buf, 16 + 2);\n            return (16 + 4);\n        default: \n            return -ASC_INV_FIELD_IN_CMD_PACKET;\n    }\n}\nstatic void cmd_get_event_status_notification(IDEState *s,\n                                              uint8_t *buf)\n{\n    const uint8_t *packet = buf;\n    struct {\n        uint8_t opcode;\n        uint8_t polled;        \n        uint8_t reserved2[2];\n        uint8_t class;\n        uint8_t reserved3[2];\n        uint16_t len;\n        uint8_t control;\n    } QEMU_PACKED *gesn_cdb;\n    struct {\n        uint16_t len;\n        uint8_t notification_class;\n        uint8_t supported_events;\n    } QEMU_PACKED *gesn_event_header;\n    unsigned int max_len, used_len;\n    gesn_cdb = (void *)packet;\n    gesn_event_header = (void *)buf;\n    max_len = be16_to_cpu(gesn_cdb->len);\n    if (!(gesn_cdb->polled & 0x01)) { \n        ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n        return;\n    }\n    gesn_event_header->supported_events = 1 << GESN_MEDIA;\n    gesn_event_header->notification_class = 0;\n    if (gesn_cdb->class & (1 << GESN_MEDIA)) {\n        gesn_event_header->notification_class |= GESN_MEDIA;\n        used_len = event_status_media(s, buf);\n    } else {\n        gesn_event_header->notification_class = 0x80; \n        used_len = sizeof(*gesn_event_header);\n    }\n    gesn_event_header->len = cpu_to_be16(used_len\n                                         - sizeof(*gesn_event_header));\n    ide_atapi_cmd_reply(s, used_len, max_len);\n}\nstatic void cmd_inquiry(IDEState *s, uint8_t *buf)\n{\n    uint8_t page_code = buf[2];\n    int max_len = buf[4];\n    unsigned idx = 0;\n    unsigned size_idx;\n    unsigned preamble_len;\n    if (buf[1] & 0x01) {\n        preamble_len = 4;\n        size_idx = 3;\n        buf[idx++] = 0x05;      \n        buf[idx++] = page_code; \n        buf[idx++] = 0x00;      \n        idx++;                  \n        switch (page_code) {\n        case 0x00:\n            buf[idx++] = 0x00; \n            buf[idx++] = 0x83; \n            break;\n        case 0x83:\n            if (idx + 24 > max_len) {\n                ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                                    ASC_DATA_PHASE_ERROR);\n                return;\n            }\n            buf[idx++] = 0x02; \n            buf[idx++] = 0x00; \n            buf[idx++] = 0x00;\n            buf[idx++] = 20;   \n            padstr8(buf + idx, 20, s->drive_serial_str);\n            idx += 20;\n            if (idx + 72 > max_len) {\n                goto out;\n            }\n            buf[idx++] = 0x02; \n            buf[idx++] = 0x01; \n            buf[idx++] = 0x00;\n            buf[idx++] = 68;\n            padstr8(buf + idx, 8, \"ATA\"); \n            idx += 8;\n            padstr8(buf + idx, 40, s->drive_model_str);\n            idx += 40;\n            padstr8(buf + idx, 20, s->drive_serial_str);\n            idx += 20;\n            if (s->wwn && (idx + 12 <= max_len)) {\n                buf[idx++] = 0x01; \n                buf[idx++] = 0x03; \n                buf[idx++] = 0x00;\n                buf[idx++] = 0x08;\n                stq_be_p(&buf[idx], s->wwn);\n                idx += 8;\n            }\n            break;\n        default:\n            ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                                ASC_INV_FIELD_IN_CMD_PACKET);\n            return;\n        }\n    } else {\n        preamble_len = 5;\n        size_idx = 4;\n        buf[0] = 0x05; \n        buf[1] = 0x80; \n        buf[2] = 0x00; \n        buf[3] = 0x21; \n        buf[5] = 0;    \n        buf[6] = 0;    \n        buf[7] = 0;    \n        padstr8(buf + 8, 8, \"QEMU\");\n        padstr8(buf + 16, 16, \"QEMU DVD-ROM\");\n        padstr8(buf + 32, 4, s->version);\n        idx = 36;\n    }\n out:\n    buf[size_idx] = idx - preamble_len;\n    ide_atapi_cmd_reply(s, idx, max_len);\n}\nstatic void cmd_get_configuration(IDEState *s, uint8_t *buf)\n{\n    uint32_t len;\n    uint8_t index = 0;\n    int max_len;\n    if (buf[2] != 0 || buf[3] != 0) {\n        ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n        return;\n    }\n    max_len = lduw_be_p(buf + 7);\n    if (max_len > BDRV_SECTOR_SIZE) {\n        max_len = BDRV_SECTOR_SIZE;\n    }\n    memset(buf, 0, max_len);\n    if (media_is_dvd(s)) {\n        stw_be_p(buf + 6, MMC_PROFILE_DVD_ROM);\n    } else if (media_is_cd(s)) {\n        stw_be_p(buf + 6, MMC_PROFILE_CD_ROM);\n    }\n    buf[10] = 0x02 | 0x01; \n    len = 12; \n    len += ide_atapi_set_profile(buf, &index, MMC_PROFILE_DVD_ROM);\n    len += ide_atapi_set_profile(buf, &index, MMC_PROFILE_CD_ROM);\n    stl_be_p(buf, len - 4); \n    ide_atapi_cmd_reply(s, len, max_len);\n}\nstatic void cmd_mode_sense(IDEState *s, uint8_t *buf)\n{\n    int action, code;\n    int max_len;\n    max_len = lduw_be_p(buf + 7);\n    action = buf[2] >> 6;\n    code = buf[2] & 0x3f;\n    switch(action) {\n    case 0: \n        switch(code) {\n        case MODE_PAGE_R_W_ERROR: \n            stw_be_p(&buf[0], 16 - 2);\n            buf[2] = 0x70;\n            buf[3] = 0;\n            buf[4] = 0;\n            buf[5] = 0;\n            buf[6] = 0;\n            buf[7] = 0;\n            buf[8] = MODE_PAGE_R_W_ERROR;\n            buf[9] = 16 - 10;\n            buf[10] = 0x00;\n            buf[11] = 0x05;\n            buf[12] = 0x00;\n            buf[13] = 0x00;\n            buf[14] = 0x00;\n            buf[15] = 0x00;\n            ide_atapi_cmd_reply(s, 16, max_len);\n            break;\n        case MODE_PAGE_AUDIO_CTL:\n            stw_be_p(&buf[0], 24 - 2);\n            buf[2] = 0x70;\n            buf[3] = 0;\n            buf[4] = 0;\n            buf[5] = 0;\n            buf[6] = 0;\n            buf[7] = 0;\n            buf[8] = MODE_PAGE_AUDIO_CTL;\n            buf[9] = 24 - 10;\n            buf[17] = 0;\n            buf[19] = 0;\n            buf[21] = 0;\n            buf[23] = 0;\n            ide_atapi_cmd_reply(s, 24, max_len);\n            break;\n        case MODE_PAGE_CAPABILITIES:\n            stw_be_p(&buf[0], 30 - 2);\n            buf[2] = 0x70;\n            buf[3] = 0;\n            buf[4] = 0;\n            buf[5] = 0;\n            buf[6] = 0;\n            buf[7] = 0;\n            buf[8] = MODE_PAGE_CAPABILITIES;\n            buf[9] = 30 - 10;\n            buf[10] = 0x3b; \n            buf[11] = 0x00;\n            buf[12] = 0x71;\n            buf[13] = 3 << 5;\n            buf[14] = (1 << 0) | (1 << 3) | (1 << 5);\n            if (s->tray_locked) {\n                buf[14] |= 1 << 1;\n            }\n            buf[15] = 0x00; \n            stw_be_p(&buf[16], 704); \n            buf[18] = 0; \n            buf[19] = 2;\n            stw_be_p(&buf[20], 512); \n            stw_be_p(&buf[22], 704); \n            buf[24] = 0;\n            buf[25] = 0;\n            buf[26] = 0;\n            buf[27] = 0;\n            buf[28] = 0;\n            buf[29] = 0;\n            ide_atapi_cmd_reply(s, 30, max_len);\n            break;\n        default:\n            goto error_cmd;\n        }\n        break;\n    case 1: \n        goto error_cmd;\n    case 2: \n        goto error_cmd;\n    default:\n    case 3: \n        ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                            ASC_SAVING_PARAMETERS_NOT_SUPPORTED);\n        break;\n    }\n    return;\nerror_cmd:\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET);\n}\nstatic void cmd_read_toc_pma_atip(IDEState *s, uint8_t* buf)\n{\n    int format, msf, start_track, len;\n    int max_len;\n    uint64_t total_sectors = s->nb_sectors >> 2;\n    max_len = lduw_be_p(buf + 7);\n    format = buf[9] >> 6;\n    msf = (buf[1] >> 1) & 1;\n    start_track = buf[6];\n    switch(format) {\n    case 0:\n        len = cdrom_read_toc(total_sectors, buf, msf, start_track);\n        if (len < 0)\n            goto error_cmd;\n        ide_atapi_cmd_reply(s, len, max_len);\n        break;\n    case 1:\n        memset(buf, 0, 12);\n        buf[1] = 0x0a;\n        buf[2] = 0x01;\n        buf[3] = 0x01;\n        ide_atapi_cmd_reply(s, 12, max_len);\n        break;\n    case 2:\n        len = cdrom_read_toc_raw(total_sectors, buf, msf, start_track);\n        if (len < 0)\n            goto error_cmd;\n        ide_atapi_cmd_reply(s, len, max_len);\n        break;\n    default:\n    error_cmd:\n        ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n    }\n}\nstatic void cmd_read_dvd_structure(IDEState *s, uint8_t* buf)\n{\n    int max_len;\n    int media = buf[1];\n    int format = buf[7];\n    int ret;\n    max_len = lduw_be_p(buf + 8);\n    if (format < 0xff) {\n        if (media_is_cd(s)) {\n            ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                                ASC_INCOMPATIBLE_FORMAT);\n            return;\n        } else if (!media_present(s)) {\n            ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                                ASC_INV_FIELD_IN_CMD_PACKET);\n            return;\n        }\n    }\n    memset(buf, 0, max_len > IDE_DMA_BUF_SECTORS * BDRV_SECTOR_SIZE + 4 ?\n           IDE_DMA_BUF_SECTORS * BDRV_SECTOR_SIZE + 4 : max_len);\n    switch (format) {\n        case 0x00 ... 0x7f:\n        case 0xff:\n            if (media == 0) {\n                ret = ide_dvd_read_structure(s, format, buf, buf);\n                if (ret < 0) {\n                    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, -ret);\n                } else {\n                    ide_atapi_cmd_reply(s, ret, max_len);\n                }\n                break;\n            }\n        case 0x80: \n        case 0x81: \n        case 0x82: \n        case 0x83: \n        case 0x90: \n        case 0xc0: \n        default:\n            ide_atapi_cmd_error(s, ILLEGAL_REQUEST,\n                                ASC_INV_FIELD_IN_CMD_PACKET);\n            break;\n    }\n}\nenum {\n    ALLOW_UA = 0x01,\n    CHECK_READY = 0x02,\n    NONDATA = 0x04,\n    CONDDATA = 0x08,\n};\nstatic const struct AtapiCmd {\n    void (*handler)(IDEState *s, uint8_t *buf);\n    int flags;\n} atapi_cmd_table[0x100] = {\n    [ 0x00 ] = { cmd_test_unit_ready,               CHECK_READY | NONDATA },\n    [ 0x03 ] = { cmd_request_sense,                 ALLOW_UA },\n    [ 0x12 ] = { cmd_inquiry,                       ALLOW_UA },\n    [ 0x1b ] = { cmd_start_stop_unit,               NONDATA }, \n    [ 0x1e ] = { cmd_prevent_allow_medium_removal,  NONDATA },\n    [ 0x25 ] = { cmd_read_cdvd_capacity,            CHECK_READY },\n    [ 0x28 ] = { cmd_read,                CHECK_READY },\n    [ 0x2b ] = { cmd_seek,                          CHECK_READY | NONDATA },\n    [ 0x43 ] = { cmd_read_toc_pma_atip,             CHECK_READY },\n    [ 0x46 ] = { cmd_get_configuration,             ALLOW_UA },\n    [ 0x4a ] = { cmd_get_event_status_notification, ALLOW_UA },\n    [ 0x51 ] = { cmd_read_disc_information,         CHECK_READY },\n    [ 0x5a ] = { cmd_mode_sense,          0 },\n    [ 0xa8 ] = { cmd_read,                CHECK_READY },\n    [ 0xad ] = { cmd_read_dvd_structure,            CHECK_READY },\n    [ 0xbb ] = { cmd_set_speed,                     NONDATA },\n    [ 0xbd ] = { cmd_mechanism_status,              0 },\n    [ 0xbe ] = { cmd_read_cd,                       CHECK_READY | CONDDATA },\n};\nvoid ide_atapi_cmd(IDEState *s)\n{\n    uint8_t *buf = s->io_buffer;\n    const struct AtapiCmd *cmd = &atapi_cmd_table[s->io_buffer[0]];\n    trace_ide_atapi_cmd(s, s->io_buffer[0]);\n    if (trace_event_get_state_backends(TRACE_IDE_ATAPI_CMD_PACKET)) {\n        char *ppacket = g_malloc(ATAPI_PACKET_SIZE * 3 + 1);\n        int i;\n        for (i = 0; i < ATAPI_PACKET_SIZE; i++) {\n            sprintf(ppacket + (i * 3), \"%02x \", buf[i]);\n        }\n        trace_ide_atapi_cmd_packet(s, s->lcyl | (s->hcyl << 8), ppacket);\n        g_free(ppacket);\n    }\n    if (s->sense_key == UNIT_ATTENTION && !(cmd->flags & ALLOW_UA)) {\n        ide_atapi_cmd_check_status(s);\n        return;\n    }\n    if (!(cmd->flags & ALLOW_UA) &&\n        !s->tray_open && blk_is_inserted(s->blk) && s->cdrom_changed) {\n        if (s->cdrom_changed == 1) {\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n            s->cdrom_changed = 2;\n        } else {\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n            s->cdrom_changed = 0;\n        }\n        return;\n    }\n    if ((cmd->flags & CHECK_READY) &&\n        (!media_present(s) || !blk_is_inserted(s->blk)))\n    {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        return;\n    }\n    if (cmd->handler && !(cmd->flags & (NONDATA | CONDDATA))) {\n        if (!validate_bcl(s)) {\n            return;\n        }\n    }\n    if (cmd->handler) {\n        cmd->handler(s, buf);\n        return;\n    }\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_5319.c",
        "project": "qemu/qemu",
        "url": "https://github.com/qemu/qemu/commit/813212288970c39b1800f63e83ac6e96588095c6",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```GF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n\tif (!orig) return NULL;\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/nodes_x3d.h>\n#ifndef GPAC_DISABLE_VRML\nGF_EXPORT\n#if 0\nGF_Err gf_sg_proto_set_in_graph(GF_Proto *proto, GF_SceneGraph *inScene, Bool set_in)\n{\n\tu32 i;\n\tGF_Proto *tmp;\n\tGF_List *removeFrom;\n\tGF_List *insertIn;\n\tif (set_in) {\n\t\tremoveFrom = proto->parent_graph->unregistered_protos;\n\t\tinsertIn = proto->parent_graph->protos;\n\t} else {\n\t\tinsertIn = proto->parent_graph->unregistered_protos;\n\t\tremoveFrom = proto->parent_graph->protos;\n\t}\n\tgf_list_del_item(removeFrom, proto);\n\ti=0;\n\twhile ((tmp = (GF_Proto*)gf_list_enum(insertIn, &i))) {\n\t\tif (tmp==proto) return GF_OK;\n\t\tif (!set_in) continue;\n\t\tif (tmp->ID==proto->ID) return GF_BAD_PARAM;\n\t\tif (!stricmp(tmp->Name, proto->Name)) return GF_BAD_PARAM;\n\t}\n\treturn gf_list_add(insertIn, proto);\n}\n#endif\nGF_EXPORT\nGF_Err gf_sg_proto_del(GF_Proto *proto)\n{\n\ts32 i;\n\tif (!proto) return GF_OK;\n\ti = gf_list_del_item(proto->parent_graph->protos, proto);\n\tif (i<0) {\n\t\tgf_list_del_item(proto->parent_graph->unregistered_protos, proto);\n\t}\n\tif (proto->userpriv && proto->OnDelete) proto->OnDelete(proto->userpriv);\n\twhile (gf_list_count(proto->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(proto->node_code, 0);\n\t\tgf_node_unregister(node, NULL);\n\t\tgf_list_rem(proto->node_code, 0);\n\t}\n\tgf_list_del(proto->node_code);\n\twhile (gf_list_count(proto->proto_fields)) {\n\t\tGF_ProtoFieldInterface *field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, 0);\n\t\tif (field->userpriv && field->OnDelete) field->OnDelete(field->userpriv);\n\t\tif (field->FieldType==GF_SG_VRML_SFNODE) {\n\t\t\tif (field->def_sfnode_value)\n\t\t\t\tgf_node_unregister(field->def_sfnode_value, NULL);\n\t\t}\n\t\telse if (field->FieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (field->def_mfnode_value)\n\t\t\t\tgf_node_unregister_children(NULL, field->def_mfnode_value);\n\t\t}\n\t\telse if (field->def_value)\n\t\t\tgf_sg_vrml_field_pointer_del(field->def_value, field->FieldType);\n\t\tif (field->FieldName) gf_free(field->FieldName);\n\t\tif (field->qp_max_value) gf_free(field->qp_max_value);\n\t\tif (field->qp_min_value) gf_free(field->qp_min_value);\n\t\tgf_free(field);\n\t\tgf_list_rem(proto->proto_fields, 0);\n\t}\n\tgf_list_del(proto->proto_fields);\n\twhile (gf_list_count(proto->instances)) {\n\t\tGF_ProtoInstance *p = (GF_ProtoInstance *)gf_list_get(proto->instances, 0);\n\t\tgf_list_rem(proto->instances, 0);\n\t\tp->proto_interface = NULL;\n\t}\n\tgf_sg_del(proto->sub_graph);\n\tif (proto->Name) gf_free(proto->Name);\n\tgf_sg_mfurl_del(proto->ExternProto);\n\tgf_list_del(proto->instances);\n\tgf_free(proto);\n\treturn GF_OK;\n}\nGF_EXPORT\n#if 0\nvoid gf_sg_proto_set_private(GF_Proto *p, void *ptr, void (*OnDelete)(void *ptr) )\n{\n\tif (p) {\n\t\tp->userpriv = ptr;\n\t\tp->OnDelete = OnDelete;\n\t}\n}\nvoid *gf_sg_proto_get_private(GF_Proto *p)\n{\n\treturn p ? p->userpriv : NULL;\n}\n#endif\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_new(GF_Proto *proto, u32 fieldType, u32 eventType, char *fieldName)\n{\n\tGF_ProtoFieldInterface *tmp;\n\tif (fieldName) {\n\t\ttmp = gf_sg_proto_field_find_by_name(proto, fieldName);\n\t\tif (tmp) return NULL;\n\t}\n\tGF_SAFEALLOC(tmp, GF_ProtoFieldInterface)\n\tif (!tmp) return NULL;\n\ttmp->FieldType = fieldType;\n\ttmp->EventType = eventType;\n\tif ( fieldType == GF_SG_VRML_SFNODE) {\n\t\ttmp->def_sfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_sfnode_value;\n\t} else if ( fieldType == GF_SG_VRML_MFNODE) {\n\t\ttmp->def_mfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_mfnode_value;\n\t} else {\n\t\ttmp->def_value = gf_sg_vrml_field_pointer_new(fieldType);\n\t}\n\tif (fieldName) tmp->FieldName = gf_strdup(fieldName);\n\ttmp->ALL_index = gf_list_count(proto->proto_fields);\n\ttmp->OUT_index = tmp->DEF_index = tmp->IN_index = (u32) -1;\n\tswitch (eventType) {\n\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\tcase GF_SG_EVENT_FIELD:\n\t\ttmp->DEF_index = proto->NumDef;\n\t\tproto->NumDef ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_IN:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_OUT:\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\t\tbreak;\n\t}\n\tgf_list_add(proto->proto_fields, tmp);\n\treturn tmp;\n}\n#if 0 //unused\nvoid gf_sg_proto_field_set_private(GF_ProtoFieldInterface *field, void *ptr, void (*OnDelete)(void *ptr))\n{\n\tif (field) {\n\t\tfield->userpriv = ptr;\n\t\tfield->OnDelete = OnDelete;\n\t}\n}\nvoid *gf_sg_proto_field_get_private(GF_ProtoFieldInterface *field)\n{\n\treturn field ? field->userpriv : NULL;\n}\n#endif\nGF_EXPORT\nGF_Err gf_sg_proto_get_field(GF_Proto *proto, GF_Node *node, GF_FieldInfo *info)\n{\n\tGF_ProtoFieldInterface *proto_field;\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\tif (!proto && !node) return GF_BAD_PARAM;\n\tif (proto) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, info->fieldIndex);\n\t\tif (!proto_field) return GF_BAD_PARAM;\n\t\tinfo->fieldType = proto_field->FieldType;\n\t\tinfo->eventType = proto_field->EventType;\n\t\tinfo->fieldIndex = proto_field->ALL_index;\n\t\tinfo->NDTtype = NDT_SFWorldNode;\n\t\tinfo->far_ptr = proto_field->def_value;\n\t\tinfo->name = proto_field->FieldName;\n\t\treturn GF_OK;\n\t}\n\tif (node->sgprivate->tag!=TAG_ProtoNode) return GF_BAD_PARAM;\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, info->fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->on_event_in = field->on_event_in;\n\tif (gf_sg_vrml_get_sf_type(field->FieldType) == GF_SG_VRML_SFNODE) {\n\t\tinfo->far_ptr = &field->field_pointer;\n\t} else {\n\t\tinfo->far_ptr = field->field_pointer;\n\t}\n\tif (inst->proto_interface) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(inst->proto_interface->proto_fields, info->fieldIndex);\n\t\tinfo->name = proto_field->FieldName;\n\t} else {\n\t\tinfo->name = \"ProtoFieldDeleted\";\n\t}\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\nGF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n{\n\tu32 i, count, id;\n\tchar *szNodeName;\n\tBool is_script;\n\tGF_Node *node, *child;\n\tGF_ChildNodeItem *list, *last;\n\tGF_Route *r1;\n#ifndef GPAC_DISABLE_BIFS\n#endif\n\tGF_ProtoInstance *proto;\n\tGF_FieldInfo field_orig, field;\n\tif (!orig) return NULL;\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tid = gf_sg_get_next_available_node_id(inScene);\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t\tstrcat(szNodeName, inst_id_suffix);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n\tif (id) {\n\t\tnode = szNodeName ? gf_sg_find_node_by_name(inScene, szNodeName) : gf_sg_find_node(inScene, id);\n\t\tif (node) {\n\t\t\tgf_node_register(node, cloned_parent);\n\t\t\tif (szNodeName) gf_free(szNodeName);\n\t\t\treturn node;\n\t\t}\n\t}\n\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\tGF_Proto *proto_node = ((GF_ProtoInstance *)orig)->proto_interface;\n\t\tnode = gf_sg_proto_create_node(inScene, proto_node, (GF_ProtoInstance *) orig);\n\t} else {\n\t\tnode = gf_node_new(inScene, orig->sgprivate->tag);\n\t}\n\tcount = gf_node_get_field_count(orig);\n\tis_script = 0;\n\tif (orig->sgprivate->tag==TAG_MPEG4_Script) is_script = 1;\n#ifndef GPAC_DISABLE_X3D\n\telse if (orig->sgprivate->tag==TAG_X3D_Script) is_script = 1;\n#endif\n\tif (is_script) gf_sg_script_prepare_clone(node, orig);\n\tif (id) {\n\t\tgf_node_set_id(node, id, szNodeName);\n\t\tif (szNodeName) gf_free(szNodeName);\n\t}\n\tgf_node_register(node, cloned_parent);\n\tfor (i=0; i<count; i++) {\n\t\tgf_node_get_field(orig, i, &field_orig);\n\t\tgf_node_get_field(node, i, &field);\n\t\tassert(field.eventType==field_orig.eventType);\n\t\tassert(field.fieldType==field_orig.fieldType);\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tchild = gf_node_clone(inScene, (* ((GF_Node **) field_orig.far_ptr)), node, inst_id_suffix, 1);\n\t\t\t*((GF_Node **) field.far_ptr) = child;\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tlast = NULL;\n\t\t\tlist = *( (GF_ChildNodeItem **) field_orig.far_ptr);\n\t\t\twhile (list) {\n\t\t\t\tchild = gf_node_clone(inScene, list->node, node, inst_id_suffix, 1);\n\t\t\t\tgf_node_list_add_child_last((GF_ChildNodeItem **) field.far_ptr, child, &last);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFTIME:\n\t\t\tgf_sg_vrml_field_copy(field.far_ptr, field_orig.far_ptr, field.fieldType);\n\t\t\tif (!inScene->GetSceneTime) break;\n\t\t\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\t\t\tif (gf_sg_proto_field_is_sftime_offset(orig, &field_orig))\n\t\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t} else if (!stricmp(field.name, \"startTime\") || !stricmp(field_orig.name, \"startTime\") ) {\n\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_sg_vrml_field_clone(field.far_ptr, field_orig.far_ptr, field.fieldType, inScene);\n\t\t\tbreak;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_BIFS\n\tif (node->sgprivate->tag == TAG_MPEG4_Conditional)\n\t\tBIFS_SetupConditionalClone(node, orig);\n\telse\n#endif\n\t\tif (node->sgprivate->tag != TAG_ProtoNode) gf_node_init(node);\n\tif (!inScene->pOwningProto) return node;\n\tproto = inScene->pOwningProto;\n\ti=0;\n\twhile ((r1 = (GF_Route*)gf_list_enum(proto->proto_interface->sub_graph->Routes, &i))) {\n\t\tGF_Route *r2 = NULL;\n\t\tif (!r1->IS_route) continue;\n\t\tif (r1->FromNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, node, r1->FromField.fieldIndex, (GF_Node *) proto, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t}\n\t\telse if (r1->ToNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, (GF_Node *) proto, r1->FromField.fieldIndex, node, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t\tgf_sg_route_activate(r2);\n\t\t}\n\t}\n\tif (is_script) gf_list_add(proto->scripts_to_load, node);\n\tif (node->sgprivate->tag == TAG_ProtoNode) {\n\t\tnode->sgprivate->UserCallback = NULL;\n\t\tnode->sgprivate->UserPrivate = NULL;\n\t\tgf_sg_proto_instantiate((GF_ProtoInstance *)node);\n\t}\n\treturn node;\n}\nvoid gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)\n{\n\tGF_Node *node, *orig;\n\tGF_Route *route, *r2;\n\tu32 i, count;\n\tGF_Proto *proto = proto_node->proto_interface;\n\tGF_Proto *owner = proto;\n\tif (!proto) return;\n\tif (owner->ExternProto.count) {\n\t\tGF_ProtoFieldInterface *pfi;\n\t\tGF_SceneGraph *extern_lib;\n\t\tif (!owner->parent_graph->GetExternProtoLib) return;\n\t\textern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);\n\t\tif (!extern_lib) return;\n\t\tif (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {\n\t\t\tproto_node->sgprivate->flags |= GF_SG_NODE_DIRTY;\n\t\t\t// take default values\n\t\t\tcount = gf_list_count(owner->proto_fields);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t\t}\n\t\t\t}\n\t\t\towner->parent_graph->NodeCallback(owner->parent_graph->userpriv, GF_SG_CALLBACK_INIT, (GF_Node *) proto_node, NULL);\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED | GF_SG_PROTO_HARDCODED;\n\t\t\treturn;\n\t\t}\n\t\tif (!gf_list_count(extern_lib->protos)) return;\n\t\tproto = NULL;\n\t\tif (owner->ExternProto.vals[0].url) {\n\t\t\tu32 ID = (u32) -1;\n\t\t\tchar *szName = strrchr(owner->ExternProto.vals[0].url, '#');\n\t\t\tif (szName) {\n\t\t\t\tszName++;\n\t\t\t\tif (sscanf(szName, \"%u\", &ID)) ID = (u32) -1;\n\t\t\t}\n\t\t\tif (owner->Name) szName = owner->Name;\n\t\t\tproto = gf_sg_find_proto(extern_lib, ID, szName);\n\t\t}\n\t\tif (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);\n\t\tif (!proto) proto = find_proto_by_interface(extern_lib, owner);\n\t\tif (proto && !is_same_proto(owner, proto)) {\n\t\t\tproto = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\\n\", owner->Name));\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED;\n\t\t\treturn;\n\t\t}\n\t\tcount = gf_list_count(owner->proto_fields);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t} else {\n\t\t\t\t//pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t}\n\t\t}\n\t\tgf_list_del_item(owner->instances, proto_node);\n\t\tgf_list_add(proto->instances, proto_node);\n\t}\n\tproto_node->proto_interface = proto;\n\ti=0;\n\twhile ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {\n\t\tnode = gf_node_clone(proto_node->sgprivate->scenegraph, orig, NULL, \"\", 1);\n\t\tassert(node);\n\t\tif (i==1) proto_node->RenderingNode = node;\n\t\tgf_list_add(proto_node->node_code, node);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {\n\t\tif (route->IS_route) continue;\n\t\tr2 = gf_sg_route_new(proto_node->sgprivate->scenegraph,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->FromNode) ),\n\t\t                     route->FromField.fieldIndex,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->ToNode) ),\n\t\t                     route->ToField.fieldIndex);\n\t\tif (route->ID) gf_sg_route_set_id(r2, route->ID);\n\t\tif (route->name) gf_sg_route_set_name(r2, route->name);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) continue;\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tgf_sg_route_activate(route);\n\t}\n\twhile (gf_list_count(proto_node->scripts_to_load)) {\n\t\tnode = (GF_Node*)gf_list_get(proto_node->scripts_to_load, 0);\n\t\tgf_list_rem(proto_node->scripts_to_load, 0);\n\t\tgf_sg_script_load(node);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route || !route->ToNode) continue;\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tif (route->ToNode->sgprivate->tag==TAG_MPEG4_Script)\n\t\t\tgf_sg_route_activate(route);\n#ifndef GPAC_DISABLE_X3D\n\t\telse if (route->ToNode->sgprivate->tag==TAG_X3D_Script)\n\t\t\tgf_sg_route_activate(route);\n#endif\n\t}\n#if 0\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) {\n\t\t\troute->lastActivateTime = 0;\n\t\t}\n\t}\n#endif\n\tproto_node->flags |= GF_SG_PROTO_LOADED;\n}\nGF_Node *gf_sg_proto_create_node(GF_SceneGraph *scene, GF_Proto *proto, GF_ProtoInstance *from_inst)\n{\n\tu32 i;\n\tGF_ProtoField *inst, *from_field;\n\tGF_ProtoFieldInterface *field;\n\tGF_ProtoInstance *proto_node;\n\tif (!proto) return NULL;\n\tGF_SAFEALLOC(proto_node, GF_ProtoInstance)\n\tif (!proto_node) return NULL;\n\tgf_node_setup((GF_Node *)proto_node, TAG_ProtoNode);\n\tproto_node->node_code = gf_list_new();\n\tproto_node->fields = gf_list_new();\n\tproto_node->scripts_to_load = gf_list_new();\n\tproto_node->proto_interface = proto;\n\tgf_list_add(proto->instances, proto_node);\n\tproto_node->proto_name = gf_strdup(proto->Name);\n\tproto_node->sgprivate->scenegraph = gf_sg_new_subscene(scene);\n\tproto_node->sgprivate->scenegraph->pOwningProto = proto_node;\n\ti=0;\n\twhile ((field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tGF_SAFEALLOC(inst, GF_ProtoField);\n\t\tif (!inst) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] Failed to allocate proto instance field\\n]\"));\n\t\t\tcontinue;\n\t\t}\n\t\tinst->EventType = field->EventType;\n\t\tinst->FieldType = field->FieldType;\n\t\tinst->field_pointer = gf_sg_vrml_field_pointer_new(inst->FieldType);\n\t\tif (gf_sg_vrml_get_sf_type(inst->FieldType) != GF_SG_VRML_SFNODE) {\n\t\t\tif (from_inst) {\n\t\t\t\tfrom_field = (GF_ProtoField *)gf_list_get(from_inst->fields, i-1);\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, from_field->field_pointer, inst->FieldType);\n\t\t\t\tinst->has_been_accessed = from_field->has_been_accessed;\n\t\t\t} else {\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, field->def_value, inst->FieldType);\n\t\t\t}\n\t\t}\n\t\tgf_list_add(proto_node->fields, inst);\n\t}\n\treturn (GF_Node *) proto_node;\n}\nGF_EXPORT\nGF_EXPORT\nvoid gf_sg_proto_del_instance(GF_ProtoInstance *inst)\n{\n\tGF_SceneGraph *sg;\n\twhile (gf_list_count(inst->fields)) {\n\t\tGF_ProtoField *field = (GF_ProtoField *)gf_list_get(inst->fields, 0);\n\t\tgf_list_rem(inst->fields, 0);\n\t\tif (field->field_pointer) {\n\t\t\tif ( (field->FieldType!=GF_SG_VRML_SFNODE) && (field->FieldType!=GF_SG_VRML_MFNODE)) {\n\t\t\t\tgf_sg_vrml_field_pointer_del(field->field_pointer, field->FieldType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (field->FieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_node_unregister((GF_Node *) field->field_pointer, (GF_Node *) inst);\n\t\t\t\t} else {\n\t\t\t\t\tGF_ChildNodeItem *list = (GF_ChildNodeItem *)field->field_pointer;\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tGF_ChildNodeItem *cur = list;\n\t\t\t\t\t\tgf_node_unregister(list->node, (GF_Node *) inst);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t\tgf_free(cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(field);\n\t}\n\tgf_list_del(inst->fields);\n\twhile (gf_list_count(inst->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(inst->node_code, 0);\n\t\tgf_node_unregister(node, (GF_Node*) inst);\n\t\tgf_list_rem(inst->node_code, 0);\n\t}\n\tsg = inst->sgprivate->scenegraph;\n\tgf_sg_reset(sg);\n\tsg->pOwningProto = NULL;\n\tgf_free((char *) inst->proto_name);\n\tgf_list_del(inst->node_code);\n\tassert(!gf_list_count(inst->scripts_to_load));\n\tgf_list_del(inst->scripts_to_load);\n\tif (inst->proto_interface && inst->proto_interface->instances) gf_list_del_item(inst->proto_interface->instances, inst);\n\tgf_node_free((GF_Node *)inst);\n\tgf_sg_del(sg);\n}\nGF_EXPORT\nGF_Err gf_sg_proto_field_set_ised(GF_Proto *proto, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tfield.fieldIndex = protoFieldIndex;\n\te = gf_sg_proto_get_field(proto, NULL, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = NULL;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = NULL;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = NULL;\n\t\t\t\tr2->graph =  proto->sub_graph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(proto->sub_graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = NULL;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = proto->sub_graph;\n\treturn gf_list_add(proto->sub_graph->Routes, r);\n}\nGF_EXPORT\nGF_Err gf_sg_proto_instance_set_ised(GF_Node *protoinst, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tif (!protoinst) return GF_BAD_PARAM;\n\tif (protoinst->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\te = gf_node_get_field(protoinst, protoFieldIndex, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = protoinst;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = protoinst;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = protoinst;\n\t\t\t\tr2->graph =  node->sgprivate->scenegraph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(r->graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = protoinst;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = node->sgprivate->scenegraph;\n\tgf_sg_route_activate(r);\n\treturn gf_list_add(r->graph->Routes, r);\n}\nGF_Err gf_sg_proto_get_field_index(GF_ProtoInstance *proto, u32 index, u32 code_mode, u32 *all_index)\n{\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_interface->proto_fields, &i))) {\n\t\tassert(proto_field);\n\t\tswitch (code_mode) {\n\t\tcase GF_SG_FIELD_CODING_IN:\n\t\t\tif (proto_field->IN_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_OUT:\n\t\t\tif (proto_field->OUT_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DEF:\n\t\t\tif (proto_field->DEF_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_ALL:\n\t\t\tif (proto_field->ALL_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DYN:\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\nGF_EXPORT\nGF_EXPORT\nvoid gf_sg_proto_propagate_event(GF_Node *node, u32 fieldIndex, GF_Node *from_node)\n{\n\tu32 i;\n\tGF_Route *r;\n\tif (!node) return;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return;\n\tif (!node->sgprivate->interact || !node->sgprivate->interact->routes) return;\n\tif (from_node->sgprivate->scenegraph == node->sgprivate->scenegraph) return;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif ((r->FromNode == node) && (r->FromField.fieldIndex == fieldIndex) && (r->ToNode != from_node) ) {\n\t\t\tif (gf_sg_route_activate(r))\n\t\t\t\tgf_node_changed(r->ToNode, &r->ToField);\n\t\t}\n\t}\n}\nBool gf_sg_proto_get_aq_info(GF_Node *Node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits)\n{\n\tGF_Proto *proto;\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\tproto = ((GF_ProtoInstance *)Node)->proto_interface;\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (proto_field->ALL_index!=FieldIndex) continue;\n\t\t*QType = proto_field->QP_Type;\n\t\t*AType = proto_field->Anim_Type;\n\t\t*b_min = FIX_MIN;\n\t\t*b_max = FIX_MAX;\n\t\tif (proto_field->hasMinMax) {\n\t\t\tswitch (gf_sg_vrml_get_sf_type(proto_field->FieldType)) {\n\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t*b_min = (SFFloat) * ( (SFInt32 *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFInt32 *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t*b_min = (SFFloat) * ( (SFTime *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFTime *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (proto_field->qp_min_value)\n\t\t\t\t\t*b_min = (SFFloat) * ( (SFFloat *) proto_field->qp_min_value);\n\t\t\t\tif (proto_field->qp_max_value)\n\t\t\t\t\t*b_max = (SFFloat) * ( (SFFloat *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*QT13_bits = proto_field->NumBits;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nBool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\n#if 0 //unused\nGF_Node *gf_node_get_proto_parent(GF_Node *node)\n{\n\tif (!node) return NULL;\n\tif (node->sgprivate->scenegraph->pOwningProto) {\n\t\tGF_Node *the_node = (GF_Node *) node->sgprivate->scenegraph->pOwningProto;\n\t\tif (the_node != node) return the_node;\n\t}\n\treturn NULL;\n}\nBool gf_node_is_proto_root(GF_Node *node)\n{\n\tif (!node) return 0;\n\tif (!node->sgprivate->scenegraph->pOwningProto) return 0;\n\tif (gf_list_find(node->sgprivate->scenegraph->pOwningProto->node_code, node)>=0) return 1;\n\treturn 0;\n}\n#endif\nGF_EXPORT\n#endif\t\n",
        "cwe": "CWE-121",
        "file_name": "vul_respovul_idx_10715.c",
        "project": "gpac/gpac",
        "url": "https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t\t   gpa_t addr, int len, void *data)\n\tif (s->status_latched) {\n\t} else if (s->count_latched) {\n\t} else {\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) \"pit: \" fmt\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"i8254.h\"\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\tif (!ps->pit_timer.period)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&ps->pit_timer.timer);\n\telapsed = ps->pit_timer.period - ktime_to_ns(remaining);\n\telapsed = mod_64(elapsed, ps->pit_timer.period);\n\treturn elapsed;\n}\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\nstatic struct kvm_timer_ops kpit_ops = {\n\t.is_periodic = kpit_is_periodic,\n};\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tmutex_lock(&pit_state->lock);\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tint ret;\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->pit_timer.timer,\n\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->pit_timer.reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\tkvm_pit_reset(pit);\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = __kvm_io_bus_register_dev(&kvm->pio_bus, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = __kvm_io_bus_register_dev(&kvm->pio_bus,\n\t\t\t\t\t\t&pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\treturn pit;\nfail_unregister:\n\t__kvm_io_bus_unregister_dev(&kvm->pio_bus, &pit->dev);\nfail:\n\tif (pit->irq_source_id >= 0)\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\tkfree(pit);\n\treturn NULL;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_914.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```GF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n\tif (!orig) return NULL;\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tid = gf_sg_get_next_available_node_id(inScene);\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t\tstrcat(szNodeName, inst_id_suffix);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n\tif (id) {\n\t\tnode = szNodeName ? gf_sg_find_node_by_name(inScene, szNodeName) : gf_sg_find_node(inScene, id);\n\t}\n\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\tGF_Proto *proto_node = ((GF_ProtoInstance *)orig)->proto_interface;\n\t\tnode = gf_sg_proto_create_node(inScene, proto_node, (GF_ProtoInstance *) orig);\n\t} else {\n\t\tnode = gf_node_new(inScene, orig->sgprivate->tag);\n\t}\n\tcount = gf_node_get_field_count(orig);\n\tif (orig->sgprivate->tag==TAG_MPEG4_Script) is_script = 1;\n\telse if (orig->sgprivate->tag==TAG_X3D_Script) is_script = 1;\n\tif (is_script) gf_sg_script_prepare_clone(node, orig);\n\tif (id) {\n\t\tgf_node_set_id(node, id, szNodeName);\n\t\tif (szNodeName) gf_free(szNodeName);\n\t}\n\tgf_node_register(node, cloned_parent);\n\tfor (i=0; i<count; i++) {\n\t\tgf_node_get_field(orig, i, &field_orig);\n\t\tgf_node_get_field(node, i, &field);\n\t\tassert(field.eventType==field_orig.eventType);\n\t\tassert(field.fieldType==field_orig.fieldType);\n\t\t\tchild = gf_node_clone(inScene, (* ((GF_Node **) field_orig.far_ptr)), node, inst_id_suffix, 1);\n\t\t\t*((GF_Node **) field.far_ptr) = child;\n\t\t\tlist = *( (GF_ChildNodeItem **) field_orig.far_ptr);\n\t\t\twhile (list) {\n\t\t\t\tchild = gf_node_clone(inScene, list->node, node, inst_id_suffix, 1);\n\t\t\t\tgf_node_list_add_child_last((GF_ChildNodeItem **) field.far_ptr, child, &last);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t\tgf_sg_vrml_field_copy(field.far_ptr, field_orig.far_ptr, field.fieldType);\n\t\t\tif (!inScene->GetSceneTime) break;\n\t\t\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\t\t\tif (gf_sg_proto_field_is_sftime_offset(orig, &field_orig))\n\t\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t} else if (!stricmp(field.name, \"startTime\") || !stricmp(field_orig.name, \"startTime\") ) {\n\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t}\n\t\t\tgf_sg_vrml_field_clone(field.far_ptr, field_orig.far_ptr, field.fieldType, inScene);\n\t}\n\tif (node->sgprivate->tag == TAG_MPEG4_Conditional)\n\t\tBIFS_SetupConditionalClone(node, orig);\n\telse\n\t\tif (node->sgprivate->tag != TAG_ProtoNode) gf_node_init(node);\n\tif (!inScene->pOwningProto) return node;\n\tproto = inScene->pOwningProto;\n\twhile ((r1 = (GF_Route*)gf_list_enum(proto->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r1->IS_route) continue;\n\t\tif (r1->FromNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, node, r1->FromField.fieldIndex, (GF_Node *) proto, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t}\n\t\telse if (r1->ToNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, (GF_Node *) proto, r1->FromField.fieldIndex, node, r1->ToField.fieldIndex);\n\t\t}\n\t}\n\tif (is_script) gf_list_add(proto->scripts_to_load, node);\n\tif (node->sgprivate->tag == TAG_ProtoNode) {\n\t\tgf_sg_proto_instantiate((GF_ProtoInstance *)node);\n\t}\n\treturn node;\nvoid gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)\n\tGF_Proto *proto = proto_node->proto_interface;\n\tGF_Proto *owner = proto;\n\tif (!proto) return;\n\tif (owner->ExternProto.count) {\n\t\tif (!owner->parent_graph->GetExternProtoLib) return;\n\t\textern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);\n\t\tif (!extern_lib) return;\n\t\tif (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {\n\t\t\treturn;\n\t\t}\n\t\tif (!gf_list_count(extern_lib->protos)) return;\n\t\tproto = NULL;\n\t\tif (owner->ExternProto.vals[0].url) {\n\t\t\tu32 ID = (u32) -1;\n\t\t\tchar *szName = strrchr(owner->ExternProto.vals[0].url, '#');\n\t\t\tif (szName) {\n\t\t\t\tszName++;\n\t\t\t\tif (sscanf(szName, \"%u\", &ID)) ID = (u32) -1;\n\t\t\t}\n\t\t\tif (owner->Name) szName = owner->Name;\n\t\t\tproto = gf_sg_find_proto(extern_lib, ID, szName);\n\t\t}\n\t\tif (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);\n\t\tif (!proto) proto = find_proto_by_interface(extern_lib, owner);\n\t\tif (proto && !is_same_proto(owner, proto)) {\n\t\t\tproto = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\\n\", owner->Name));\n\t\t}\n\t\tif (!proto) {\n\t\t}\n\t\tcount = gf_list_count(owner->proto_fields);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t} else {\n\t\t}\n\t\tgf_list_del_item(owner->instances, proto_node);\n\t\tgf_list_add(proto->instances, proto_node);\n\t}\n\tproto_node->proto_interface = proto;\n\ti=0;\n\twhile ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {\n\t\tif (i==1) proto_node->RenderingNode = node;\n\t\tgf_list_add(proto_node->node_code, node);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/nodes_x3d.h>\n#ifndef GPAC_DISABLE_VRML\nGF_EXPORT\n#if 0\nGF_Err gf_sg_proto_set_in_graph(GF_Proto *proto, GF_SceneGraph *inScene, Bool set_in)\n{\n\tu32 i;\n\tGF_Proto *tmp;\n\tGF_List *removeFrom;\n\tGF_List *insertIn;\n\tif (set_in) {\n\t\tremoveFrom = proto->parent_graph->unregistered_protos;\n\t\tinsertIn = proto->parent_graph->protos;\n\t} else {\n\t\tinsertIn = proto->parent_graph->unregistered_protos;\n\t\tremoveFrom = proto->parent_graph->protos;\n\t}\n\tgf_list_del_item(removeFrom, proto);\n\ti=0;\n\twhile ((tmp = (GF_Proto*)gf_list_enum(insertIn, &i))) {\n\t\tif (tmp==proto) return GF_OK;\n\t\tif (!set_in) continue;\n\t\tif (tmp->ID==proto->ID) return GF_BAD_PARAM;\n\t\tif (!stricmp(tmp->Name, proto->Name)) return GF_BAD_PARAM;\n\t}\n\treturn gf_list_add(insertIn, proto);\n}\n#endif\nGF_EXPORT\nGF_Err gf_sg_proto_del(GF_Proto *proto)\n{\n\ts32 i;\n\tif (!proto) return GF_OK;\n\ti = gf_list_del_item(proto->parent_graph->protos, proto);\n\tif (i<0) {\n\t\tgf_list_del_item(proto->parent_graph->unregistered_protos, proto);\n\t}\n\tif (proto->userpriv && proto->OnDelete) proto->OnDelete(proto->userpriv);\n\twhile (gf_list_count(proto->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(proto->node_code, 0);\n\t\tgf_node_unregister(node, NULL);\n\t\tgf_list_rem(proto->node_code, 0);\n\t}\n\tgf_list_del(proto->node_code);\n\twhile (gf_list_count(proto->proto_fields)) {\n\t\tGF_ProtoFieldInterface *field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, 0);\n\t\tif (field->userpriv && field->OnDelete) field->OnDelete(field->userpriv);\n\t\tif (field->FieldType==GF_SG_VRML_SFNODE) {\n\t\t\tif (field->def_sfnode_value)\n\t\t\t\tgf_node_unregister(field->def_sfnode_value, NULL);\n\t\t}\n\t\telse if (field->FieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (field->def_mfnode_value)\n\t\t\t\tgf_node_unregister_children(NULL, field->def_mfnode_value);\n\t\t}\n\t\telse if (field->def_value)\n\t\t\tgf_sg_vrml_field_pointer_del(field->def_value, field->FieldType);\n\t\tif (field->FieldName) gf_free(field->FieldName);\n\t\tif (field->qp_max_value) gf_free(field->qp_max_value);\n\t\tif (field->qp_min_value) gf_free(field->qp_min_value);\n\t\tgf_free(field);\n\t\tgf_list_rem(proto->proto_fields, 0);\n\t}\n\tgf_list_del(proto->proto_fields);\n\twhile (gf_list_count(proto->instances)) {\n\t\tGF_ProtoInstance *p = (GF_ProtoInstance *)gf_list_get(proto->instances, 0);\n\t\tgf_list_rem(proto->instances, 0);\n\t\tp->proto_interface = NULL;\n\t}\n\tgf_sg_del(proto->sub_graph);\n\tif (proto->Name) gf_free(proto->Name);\n\tgf_sg_mfurl_del(proto->ExternProto);\n\tgf_list_del(proto->instances);\n\tgf_free(proto);\n\treturn GF_OK;\n}\nGF_EXPORT\n#if 0\nvoid gf_sg_proto_set_private(GF_Proto *p, void *ptr, void (*OnDelete)(void *ptr) )\n{\n\tif (p) {\n\t\tp->userpriv = ptr;\n\t\tp->OnDelete = OnDelete;\n\t}\n}\nvoid *gf_sg_proto_get_private(GF_Proto *p)\n{\n\treturn p ? p->userpriv : NULL;\n}\n#endif\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_new(GF_Proto *proto, u32 fieldType, u32 eventType, char *fieldName)\n{\n\tGF_ProtoFieldInterface *tmp;\n\tif (fieldName) {\n\t\ttmp = gf_sg_proto_field_find_by_name(proto, fieldName);\n\t\tif (tmp) return NULL;\n\t}\n\tGF_SAFEALLOC(tmp, GF_ProtoFieldInterface)\n\tif (!tmp) return NULL;\n\ttmp->FieldType = fieldType;\n\ttmp->EventType = eventType;\n\tif ( fieldType == GF_SG_VRML_SFNODE) {\n\t\ttmp->def_sfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_sfnode_value;\n\t} else if ( fieldType == GF_SG_VRML_MFNODE) {\n\t\ttmp->def_mfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_mfnode_value;\n\t} else {\n\t\ttmp->def_value = gf_sg_vrml_field_pointer_new(fieldType);\n\t}\n\tif (fieldName) tmp->FieldName = gf_strdup(fieldName);\n\ttmp->ALL_index = gf_list_count(proto->proto_fields);\n\ttmp->OUT_index = tmp->DEF_index = tmp->IN_index = (u32) -1;\n\tswitch (eventType) {\n\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\tcase GF_SG_EVENT_FIELD:\n\t\ttmp->DEF_index = proto->NumDef;\n\t\tproto->NumDef ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_IN:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_OUT:\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\t\tbreak;\n\t}\n\tgf_list_add(proto->proto_fields, tmp);\n\treturn tmp;\n}\n#if 0 //unused\nvoid gf_sg_proto_field_set_private(GF_ProtoFieldInterface *field, void *ptr, void (*OnDelete)(void *ptr))\n{\n\tif (field) {\n\t\tfield->userpriv = ptr;\n\t\tfield->OnDelete = OnDelete;\n\t}\n}\nvoid *gf_sg_proto_field_get_private(GF_ProtoFieldInterface *field)\n{\n\treturn field ? field->userpriv : NULL;\n}\n#endif\nGF_EXPORT\nGF_Err gf_sg_proto_get_field(GF_Proto *proto, GF_Node *node, GF_FieldInfo *info)\n{\n\tGF_ProtoFieldInterface *proto_field;\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\tif (!proto && !node) return GF_BAD_PARAM;\n\tif (proto) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, info->fieldIndex);\n\t\tif (!proto_field) return GF_BAD_PARAM;\n\t\tinfo->fieldType = proto_field->FieldType;\n\t\tinfo->eventType = proto_field->EventType;\n\t\tinfo->fieldIndex = proto_field->ALL_index;\n\t\tinfo->NDTtype = NDT_SFWorldNode;\n\t\tinfo->far_ptr = proto_field->def_value;\n\t\tinfo->name = proto_field->FieldName;\n\t\treturn GF_OK;\n\t}\n\tif (node->sgprivate->tag!=TAG_ProtoNode) return GF_BAD_PARAM;\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, info->fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->on_event_in = field->on_event_in;\n\tif (gf_sg_vrml_get_sf_type(field->FieldType) == GF_SG_VRML_SFNODE) {\n\t\tinfo->far_ptr = &field->field_pointer;\n\t} else {\n\t\tinfo->far_ptr = field->field_pointer;\n\t}\n\tif (inst->proto_interface) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(inst->proto_interface->proto_fields, info->fieldIndex);\n\t\tinfo->name = proto_field->FieldName;\n\t} else {\n\t\tinfo->name = \"ProtoFieldDeleted\";\n\t}\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\nGF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n{\n\tu32 i, count, id;\n\tchar *szNodeName;\n\tBool is_script;\n\tGF_Node *node, *child;\n\tGF_ChildNodeItem *list, *last;\n\tGF_Route *r1;\n#ifndef GPAC_DISABLE_BIFS\n#endif\n\tGF_ProtoInstance *proto;\n\tGF_FieldInfo field_orig, field;\n\tif (!orig) return NULL;\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tid = gf_sg_get_next_available_node_id(inScene);\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t\tstrcat(szNodeName, inst_id_suffix);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n\tif (id) {\n\t\tnode = szNodeName ? gf_sg_find_node_by_name(inScene, szNodeName) : gf_sg_find_node(inScene, id);\n\t\tif (node) {\n\t\t\tgf_node_register(node, cloned_parent);\n\t\t\tif (szNodeName) gf_free(szNodeName);\n\t\t\treturn node;\n\t\t}\n\t}\n\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\tGF_Proto *proto_node = ((GF_ProtoInstance *)orig)->proto_interface;\n\t\tnode = gf_sg_proto_create_node(inScene, proto_node, (GF_ProtoInstance *) orig);\n\t} else {\n\t\tnode = gf_node_new(inScene, orig->sgprivate->tag);\n\t}\n\tcount = gf_node_get_field_count(orig);\n\tis_script = 0;\n\tif (orig->sgprivate->tag==TAG_MPEG4_Script) is_script = 1;\n#ifndef GPAC_DISABLE_X3D\n\telse if (orig->sgprivate->tag==TAG_X3D_Script) is_script = 1;\n#endif\n\tif (is_script) gf_sg_script_prepare_clone(node, orig);\n\tif (id) {\n\t\tgf_node_set_id(node, id, szNodeName);\n\t\tif (szNodeName) gf_free(szNodeName);\n\t}\n\tgf_node_register(node, cloned_parent);\n\tfor (i=0; i<count; i++) {\n\t\tgf_node_get_field(orig, i, &field_orig);\n\t\tgf_node_get_field(node, i, &field);\n\t\tassert(field.eventType==field_orig.eventType);\n\t\tassert(field.fieldType==field_orig.fieldType);\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tchild = gf_node_clone(inScene, (* ((GF_Node **) field_orig.far_ptr)), node, inst_id_suffix, 1);\n\t\t\t*((GF_Node **) field.far_ptr) = child;\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tlast = NULL;\n\t\t\tlist = *( (GF_ChildNodeItem **) field_orig.far_ptr);\n\t\t\twhile (list) {\n\t\t\t\tchild = gf_node_clone(inScene, list->node, node, inst_id_suffix, 1);\n\t\t\t\tgf_node_list_add_child_last((GF_ChildNodeItem **) field.far_ptr, child, &last);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFTIME:\n\t\t\tgf_sg_vrml_field_copy(field.far_ptr, field_orig.far_ptr, field.fieldType);\n\t\t\tif (!inScene->GetSceneTime) break;\n\t\t\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\t\t\tif (gf_sg_proto_field_is_sftime_offset(orig, &field_orig))\n\t\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t} else if (!stricmp(field.name, \"startTime\") || !stricmp(field_orig.name, \"startTime\") ) {\n\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_sg_vrml_field_clone(field.far_ptr, field_orig.far_ptr, field.fieldType, inScene);\n\t\t\tbreak;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_BIFS\n\tif (node->sgprivate->tag == TAG_MPEG4_Conditional)\n\t\tBIFS_SetupConditionalClone(node, orig);\n\telse\n#endif\n\t\tif (node->sgprivate->tag != TAG_ProtoNode) gf_node_init(node);\n\tif (!inScene->pOwningProto) return node;\n\tproto = inScene->pOwningProto;\n\ti=0;\n\twhile ((r1 = (GF_Route*)gf_list_enum(proto->proto_interface->sub_graph->Routes, &i))) {\n\t\tGF_Route *r2 = NULL;\n\t\tif (!r1->IS_route) continue;\n\t\tif (r1->FromNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, node, r1->FromField.fieldIndex, (GF_Node *) proto, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t}\n\t\telse if (r1->ToNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, (GF_Node *) proto, r1->FromField.fieldIndex, node, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t\tgf_sg_route_activate(r2);\n\t\t}\n\t}\n\tif (is_script) gf_list_add(proto->scripts_to_load, node);\n\tif (node->sgprivate->tag == TAG_ProtoNode) {\n\t\tnode->sgprivate->UserCallback = NULL;\n\t\tnode->sgprivate->UserPrivate = NULL;\n\t\tgf_sg_proto_instantiate((GF_ProtoInstance *)node);\n\t}\n\treturn node;\n}\nvoid gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)\n{\n\tGF_Node *node, *orig;\n\tGF_Route *route, *r2;\n\tu32 i, count;\n\tGF_Proto *proto = proto_node->proto_interface;\n\tGF_Proto *owner = proto;\n\tif (!proto) return;\n\tif (owner->ExternProto.count) {\n\t\tGF_ProtoFieldInterface *pfi;\n\t\tGF_SceneGraph *extern_lib;\n\t\tif (!owner->parent_graph->GetExternProtoLib) return;\n\t\textern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);\n\t\tif (!extern_lib) return;\n\t\tif (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {\n\t\t\tproto_node->sgprivate->flags |= GF_SG_NODE_DIRTY;\n\t\t\t// take default values\n\t\t\tcount = gf_list_count(owner->proto_fields);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t\t}\n\t\t\t}\n\t\t\towner->parent_graph->NodeCallback(owner->parent_graph->userpriv, GF_SG_CALLBACK_INIT, (GF_Node *) proto_node, NULL);\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED | GF_SG_PROTO_HARDCODED;\n\t\t\treturn;\n\t\t}\n\t\tif (!gf_list_count(extern_lib->protos)) return;\n\t\tproto = NULL;\n\t\tif (owner->ExternProto.vals[0].url) {\n\t\t\tu32 ID = (u32) -1;\n\t\t\tchar *szName = strrchr(owner->ExternProto.vals[0].url, '#');\n\t\t\tif (szName) {\n\t\t\t\tszName++;\n\t\t\t\tif (sscanf(szName, \"%u\", &ID)) ID = (u32) -1;\n\t\t\t}\n\t\t\tif (owner->Name) szName = owner->Name;\n\t\t\tproto = gf_sg_find_proto(extern_lib, ID, szName);\n\t\t}\n\t\tif (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);\n\t\tif (!proto) proto = find_proto_by_interface(extern_lib, owner);\n\t\tif (proto && !is_same_proto(owner, proto)) {\n\t\t\tproto = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\\n\", owner->Name));\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED;\n\t\t\treturn;\n\t\t}\n\t\tcount = gf_list_count(owner->proto_fields);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t} else {\n\t\t\t\t//pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t}\n\t\t}\n\t\tgf_list_del_item(owner->instances, proto_node);\n\t\tgf_list_add(proto->instances, proto_node);\n\t}\n\tproto_node->proto_interface = proto;\n\ti=0;\n\twhile ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {\n\t\tnode = gf_node_clone(proto_node->sgprivate->scenegraph, orig, NULL, \"\", 1);\n\t\tassert(node);\n\t\tif (i==1) proto_node->RenderingNode = node;\n\t\tgf_list_add(proto_node->node_code, node);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {\n\t\tif (route->IS_route) continue;\n\t\tr2 = gf_sg_route_new(proto_node->sgprivate->scenegraph,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->FromNode) ),\n\t\t                     route->FromField.fieldIndex,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->ToNode) ),\n\t\t                     route->ToField.fieldIndex);\n\t\tif (route->ID) gf_sg_route_set_id(r2, route->ID);\n\t\tif (route->name) gf_sg_route_set_name(r2, route->name);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) continue;\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tgf_sg_route_activate(route);\n\t}\n\twhile (gf_list_count(proto_node->scripts_to_load)) {\n\t\tnode = (GF_Node*)gf_list_get(proto_node->scripts_to_load, 0);\n\t\tgf_list_rem(proto_node->scripts_to_load, 0);\n\t\tgf_sg_script_load(node);\n\t}\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route || !route->ToNode) continue;\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tif (route->ToNode->sgprivate->tag==TAG_MPEG4_Script)\n\t\t\tgf_sg_route_activate(route);\n#ifndef GPAC_DISABLE_X3D\n\t\telse if (route->ToNode->sgprivate->tag==TAG_X3D_Script)\n\t\t\tgf_sg_route_activate(route);\n#endif\n\t}\n#if 0\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) {\n\t\t\troute->lastActivateTime = 0;\n\t\t}\n\t}\n#endif\n\tproto_node->flags |= GF_SG_PROTO_LOADED;\n}\nGF_Node *gf_sg_proto_create_node(GF_SceneGraph *scene, GF_Proto *proto, GF_ProtoInstance *from_inst)\n{\n\tu32 i;\n\tGF_ProtoField *inst, *from_field;\n\tGF_ProtoFieldInterface *field;\n\tGF_ProtoInstance *proto_node;\n\tif (!proto) return NULL;\n\tGF_SAFEALLOC(proto_node, GF_ProtoInstance)\n\tif (!proto_node) return NULL;\n\tgf_node_setup((GF_Node *)proto_node, TAG_ProtoNode);\n\tproto_node->node_code = gf_list_new();\n\tproto_node->fields = gf_list_new();\n\tproto_node->scripts_to_load = gf_list_new();\n\tproto_node->proto_interface = proto;\n\tgf_list_add(proto->instances, proto_node);\n\tproto_node->proto_name = gf_strdup(proto->Name);\n\tproto_node->sgprivate->scenegraph = gf_sg_new_subscene(scene);\n\tproto_node->sgprivate->scenegraph->pOwningProto = proto_node;\n\ti=0;\n\twhile ((field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tGF_SAFEALLOC(inst, GF_ProtoField);\n\t\tif (!inst) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] Failed to allocate proto instance field\\n]\"));\n\t\t\tcontinue;\n\t\t}\n\t\tinst->EventType = field->EventType;\n\t\tinst->FieldType = field->FieldType;\n\t\tinst->field_pointer = gf_sg_vrml_field_pointer_new(inst->FieldType);\n\t\tif (gf_sg_vrml_get_sf_type(inst->FieldType) != GF_SG_VRML_SFNODE) {\n\t\t\tif (from_inst) {\n\t\t\t\tfrom_field = (GF_ProtoField *)gf_list_get(from_inst->fields, i-1);\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, from_field->field_pointer, inst->FieldType);\n\t\t\t\tinst->has_been_accessed = from_field->has_been_accessed;\n\t\t\t} else {\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, field->def_value, inst->FieldType);\n\t\t\t}\n\t\t}\n\t\tgf_list_add(proto_node->fields, inst);\n\t}\n\treturn (GF_Node *) proto_node;\n}\nGF_EXPORT\nGF_EXPORT\nvoid gf_sg_proto_del_instance(GF_ProtoInstance *inst)\n{\n\tGF_SceneGraph *sg;\n\twhile (gf_list_count(inst->fields)) {\n\t\tGF_ProtoField *field = (GF_ProtoField *)gf_list_get(inst->fields, 0);\n\t\tgf_list_rem(inst->fields, 0);\n\t\tif (field->field_pointer) {\n\t\t\tif ( (field->FieldType!=GF_SG_VRML_SFNODE) && (field->FieldType!=GF_SG_VRML_MFNODE)) {\n\t\t\t\tgf_sg_vrml_field_pointer_del(field->field_pointer, field->FieldType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (field->FieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_node_unregister((GF_Node *) field->field_pointer, (GF_Node *) inst);\n\t\t\t\t} else {\n\t\t\t\t\tGF_ChildNodeItem *list = (GF_ChildNodeItem *)field->field_pointer;\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tGF_ChildNodeItem *cur = list;\n\t\t\t\t\t\tgf_node_unregister(list->node, (GF_Node *) inst);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t\tgf_free(cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(field);\n\t}\n\tgf_list_del(inst->fields);\n\twhile (gf_list_count(inst->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(inst->node_code, 0);\n\t\tgf_node_unregister(node, (GF_Node*) inst);\n\t\tgf_list_rem(inst->node_code, 0);\n\t}\n\tsg = inst->sgprivate->scenegraph;\n\tgf_sg_reset(sg);\n\tsg->pOwningProto = NULL;\n\tgf_free((char *) inst->proto_name);\n\tgf_list_del(inst->node_code);\n\tassert(!gf_list_count(inst->scripts_to_load));\n\tgf_list_del(inst->scripts_to_load);\n\tif (inst->proto_interface && inst->proto_interface->instances) gf_list_del_item(inst->proto_interface->instances, inst);\n\tgf_node_free((GF_Node *)inst);\n\tgf_sg_del(sg);\n}\nGF_EXPORT\nGF_Err gf_sg_proto_field_set_ised(GF_Proto *proto, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tfield.fieldIndex = protoFieldIndex;\n\te = gf_sg_proto_get_field(proto, NULL, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = NULL;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = NULL;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = NULL;\n\t\t\t\tr2->graph =  proto->sub_graph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(proto->sub_graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = NULL;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = proto->sub_graph;\n\treturn gf_list_add(proto->sub_graph->Routes, r);\n}\nGF_EXPORT\nGF_Err gf_sg_proto_instance_set_ised(GF_Node *protoinst, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tif (!protoinst) return GF_BAD_PARAM;\n\tif (protoinst->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\te = gf_node_get_field(protoinst, protoFieldIndex, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = protoinst;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = protoinst;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = protoinst;\n\t\t\t\tr2->graph =  node->sgprivate->scenegraph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(r->graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = protoinst;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = node->sgprivate->scenegraph;\n\tgf_sg_route_activate(r);\n\treturn gf_list_add(r->graph->Routes, r);\n}\nGF_Err gf_sg_proto_get_field_index(GF_ProtoInstance *proto, u32 index, u32 code_mode, u32 *all_index)\n{\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_interface->proto_fields, &i))) {\n\t\tassert(proto_field);\n\t\tswitch (code_mode) {\n\t\tcase GF_SG_FIELD_CODING_IN:\n\t\t\tif (proto_field->IN_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_OUT:\n\t\t\tif (proto_field->OUT_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DEF:\n\t\t\tif (proto_field->DEF_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_ALL:\n\t\t\tif (proto_field->ALL_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DYN:\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\nGF_EXPORT\nGF_EXPORT\nvoid gf_sg_proto_propagate_event(GF_Node *node, u32 fieldIndex, GF_Node *from_node)\n{\n\tu32 i;\n\tGF_Route *r;\n\tif (!node) return;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return;\n\tif (!node->sgprivate->interact || !node->sgprivate->interact->routes) return;\n\tif (from_node->sgprivate->scenegraph == node->sgprivate->scenegraph) return;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif ((r->FromNode == node) && (r->FromField.fieldIndex == fieldIndex) && (r->ToNode != from_node) ) {\n\t\t\tif (gf_sg_route_activate(r))\n\t\t\t\tgf_node_changed(r->ToNode, &r->ToField);\n\t\t}\n\t}\n}\nBool gf_sg_proto_get_aq_info(GF_Node *Node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits)\n{\n\tGF_Proto *proto;\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\tproto = ((GF_ProtoInstance *)Node)->proto_interface;\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (proto_field->ALL_index!=FieldIndex) continue;\n\t\t*QType = proto_field->QP_Type;\n\t\t*AType = proto_field->Anim_Type;\n\t\t*b_min = FIX_MIN;\n\t\t*b_max = FIX_MAX;\n\t\tif (proto_field->hasMinMax) {\n\t\t\tswitch (gf_sg_vrml_get_sf_type(proto_field->FieldType)) {\n\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t*b_min = (SFFloat) * ( (SFInt32 *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFInt32 *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t*b_min = (SFFloat) * ( (SFTime *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFTime *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (proto_field->qp_min_value)\n\t\t\t\t\t*b_min = (SFFloat) * ( (SFFloat *) proto_field->qp_min_value);\n\t\t\t\tif (proto_field->qp_max_value)\n\t\t\t\t\t*b_max = (SFFloat) * ( (SFFloat *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*QT13_bits = proto_field->NumBits;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\nBool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) {\n\t\t\tif (r->ToNode==node) continue;\n\t\t\treturn gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\t}\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}\nGF_EXPORT\nGF_EXPORT\nGF_EXPORT\n#if 0 //unused\nGF_Node *gf_node_get_proto_parent(GF_Node *node)\n{\n\tif (!node) return NULL;\n\tif (node->sgprivate->scenegraph->pOwningProto) {\n\t\tGF_Node *the_node = (GF_Node *) node->sgprivate->scenegraph->pOwningProto;\n\t\tif (the_node != node) return the_node;\n\t}\n\treturn NULL;\n}\nBool gf_node_is_proto_root(GF_Node *node)\n{\n\tif (!node) return 0;\n\tif (!node->sgprivate->scenegraph->pOwningProto) return 0;\n\tif (gf_list_find(node->sgprivate->scenegraph->pOwningProto->node_code, node)>=0) return 1;\n\treturn 0;\n}\n#endif\nGF_EXPORT\n#endif\t\n",
        "cwe": "CWE-121",
        "file_name": "safe_respovul_idx_10715.c",
        "project": "gpac/gpac",
        "url": "https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```nvme_fc_parse_traddr(struct nvmet_fc_traddr *traddr, char *buf, size_t blen)\n\tif (strnlen(buf, blen) == NVME_FC_TRADDR_MAXLENGTH &&\n\t\t\t!strncmp(buf, \"nn-0x\", NVME_FC_TRADDR_OXNNLEN) &&\n\t\t\t!strncmp(&buf[NVME_FC_TRADDR_MAX_PN_OFFSET],\n\t} else if ((strnlen(buf, blen) == NVME_FC_TRADDR_MINLENGTH &&\n\t\t\t!strncmp(buf, \"nn-\", NVME_FC_TRADDR_NNLEN) &&\n\t\t\t!strncmp(&buf[NVME_FC_TRADDR_MIN_PN_OFFSET],\n\t\t\t\t\"pn-\", NVME_FC_TRADDR_NNLEN))) {\n\t\tnnoffset = NVME_FC_TRADDR_NNLEN;\n\t\tpnoffset = NVME_FC_TRADDR_MIN_PN_OFFSET + NVME_FC_TRADDR_NNLEN;\n\tret = nvme_fc_parse_traddr(&traddr, port->disc_addr.traddr,\n\t\t\tsizeof(port->disc_addr.traddr));\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/blk-mq.h>\n#include <linux/parser.h>\n#include <linux/random.h>\n#include <uapi/scsi/fc/fc_fs.h>\n#include <uapi/scsi/fc/fc_els.h>\n#include \"nvmet.h\"\n#include <linux/nvme-fc-driver.h>\n#include <linux/nvme-fc.h>\n#define NVMET_LS_CTX_COUNT\t\t4\n#define NVME_FC_MAX_LS_BUFFER_SIZE\t\t2048\nstruct nvmet_fc_tgtport;\nstruct nvmet_fc_tgt_assoc;\nstruct nvmet_fc_ls_iod {\n\tstruct nvmefc_tgt_ls_req\t*lsreq;\n\tstruct nvmefc_tgt_fcp_req\t*fcpreq;\t\n\tstruct list_head\t\tls_list;\t\n\tstruct nvmet_fc_tgtport\t\t*tgtport;\n\tstruct nvmet_fc_tgt_assoc\t*assoc;\n\tu8\t\t\t\t*rqstbuf;\n\tu8\t\t\t\t*rspbuf;\n\tu16\t\t\t\trqstdatalen;\n\tdma_addr_t\t\t\trspdma;\n\tstruct scatterlist\t\tsg[2];\n\tstruct work_struct\t\twork;\n} __aligned(sizeof(unsigned long long));\n#define NVMET_FC_MAX_SEQ_LENGTH\t\t(256 * 1024)\n#define NVMET_FC_MAX_XFR_SGENTS\t\t(NVMET_FC_MAX_SEQ_LENGTH / PAGE_SIZE)\nenum nvmet_fcp_datadir {\n\tNVMET_FCP_NODATA,\n\tNVMET_FCP_WRITE,\n\tNVMET_FCP_READ,\n\tNVMET_FCP_ABORTED,\n};\nstruct nvmet_fc_fcp_iod {\n\tstruct nvmefc_tgt_fcp_req\t*fcpreq;\n\tstruct nvme_fc_cmd_iu\t\tcmdiubuf;\n\tstruct nvme_fc_ersp_iu\t\trspiubuf;\n\tdma_addr_t\t\t\trspdma;\n\tstruct scatterlist\t\t*data_sg;\n\tint\t\t\t\tdata_sg_cnt;\n\tu32\t\t\t\ttotal_length;\n\tu32\t\t\t\toffset;\n\tenum nvmet_fcp_datadir\t\tio_dir;\n\tbool\t\t\t\tactive;\n\tbool\t\t\t\tabort;\n\tbool\t\t\t\taborted;\n\tbool\t\t\t\twritedataactive;\n\tspinlock_t\t\t\tflock;\n\tstruct nvmet_req\t\treq;\n\tstruct work_struct\t\twork;\n\tstruct work_struct\t\tdone_work;\n\tstruct nvmet_fc_tgtport\t\t*tgtport;\n\tstruct nvmet_fc_tgt_queue\t*queue;\n\tstruct list_head\t\tfcp_list;\t\n};\nstruct nvmet_fc_tgtport {\n\tstruct nvmet_fc_target_port\tfc_target_port;\n\tstruct list_head\t\ttgt_list; \n\tstruct device\t\t\t*dev;\t\n\tstruct nvmet_fc_target_template\t*ops;\n\tstruct nvmet_fc_ls_iod\t\t*iod;\n\tspinlock_t\t\t\tlock;\n\tstruct list_head\t\tls_list;\n\tstruct list_head\t\tls_busylist;\n\tstruct list_head\t\tassoc_list;\n\tstruct ida\t\t\tassoc_cnt;\n\tstruct nvmet_port\t\t*port;\n\tstruct kref\t\t\tref;\n\tu32\t\t\t\tmax_sg_cnt;\n};\nstruct nvmet_fc_defer_fcp_req {\n\tstruct list_head\t\treq_list;\n\tstruct nvmefc_tgt_fcp_req\t*fcp_req;\n};\nstruct nvmet_fc_tgt_queue {\n\tbool\t\t\t\tninetypercent;\n\tu16\t\t\t\tqid;\n\tu16\t\t\t\tsqsize;\n\tu16\t\t\t\tersp_ratio;\n\t__le16\t\t\t\tsqhd;\n\tint\t\t\t\tcpu;\n\tatomic_t\t\t\tconnected;\n\tatomic_t\t\t\tsqtail;\n\tatomic_t\t\t\tzrspcnt;\n\tatomic_t\t\t\trsn;\n\tspinlock_t\t\t\tqlock;\n\tstruct nvmet_port\t\t*port;\n\tstruct nvmet_cq\t\t\tnvme_cq;\n\tstruct nvmet_sq\t\t\tnvme_sq;\n\tstruct nvmet_fc_tgt_assoc\t*assoc;\n\tstruct nvmet_fc_fcp_iod\t\t*fod;\t\t\n\tstruct list_head\t\tfod_list;\n\tstruct list_head\t\tpending_cmd_list;\n\tstruct list_head\t\tavail_defer_list;\n\tstruct workqueue_struct\t\t*work_q;\n\tstruct kref\t\t\tref;\n} __aligned(sizeof(unsigned long long));\nstruct nvmet_fc_tgt_assoc {\n\tu64\t\t\t\tassociation_id;\n\tu32\t\t\t\ta_id;\n\tstruct nvmet_fc_tgtport\t\t*tgtport;\n\tstruct list_head\t\ta_list;\n\tstruct nvmet_fc_tgt_queue\t*queues[NVMET_NR_QUEUES + 1];\n\tstruct kref\t\t\tref;\n};\n#define BYTES_FOR_QID\t\t\tsizeof(u16)\n#define BYTES_FOR_QID_SHIFT\t\t(BYTES_FOR_QID * 8)\n#define NVMET_FC_QUEUEID_MASK\t\t((u64)((1 << BYTES_FOR_QID_SHIFT) - 1))\nstatic inline u64\nnvmet_fc_getassociationid(u64 connectionid)\n{\n\treturn connectionid & ~NVMET_FC_QUEUEID_MASK;\n}\nstatic inline u16\nnvmet_fc_getqueueid(u64 connectionid)\n{\n\treturn (u16)(connectionid & NVMET_FC_QUEUEID_MASK);\n}\nstatic void nvmet_fc_handle_ls_rqst_work(struct work_struct *work);\nstatic void nvmet_fc_handle_fcp_rqst_work(struct work_struct *work);\nstatic void nvmet_fc_fcp_rqst_op_done_work(struct work_struct *work);\nstatic void nvmet_fc_tgt_a_put(struct nvmet_fc_tgt_assoc *assoc);\nstatic int nvmet_fc_tgt_a_get(struct nvmet_fc_tgt_assoc *assoc);\nstatic void nvmet_fc_tgt_q_put(struct nvmet_fc_tgt_queue *queue);\nstatic int nvmet_fc_tgt_q_get(struct nvmet_fc_tgt_queue *queue);\nstatic void nvmet_fc_tgtport_put(struct nvmet_fc_tgtport *tgtport);\nstatic int nvmet_fc_tgtport_get(struct nvmet_fc_tgtport *tgtport);\nstatic void nvmet_fc_handle_fcp_rqst(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\t\tstruct nvmet_fc_fcp_iod *fod);\nstatic int\nnvmet_fc_alloc_ls_iodlist(struct nvmet_fc_tgtport *tgtport)\n{\n\tstruct nvmet_fc_ls_iod *iod;\n\tint i;\n\tiod = kcalloc(NVMET_LS_CTX_COUNT, sizeof(struct nvmet_fc_ls_iod),\n\t\t\tGFP_KERNEL);\n\tif (!iod)\n\t\treturn -ENOMEM;\n\ttgtport->iod = iod;\n\tfor (i = 0; i < NVMET_LS_CTX_COUNT; iod++, i++) {\n\t\tINIT_WORK(&iod->work, nvmet_fc_handle_ls_rqst_work);\n\t\tiod->tgtport = tgtport;\n\t\tlist_add_tail(&iod->ls_list, &tgtport->ls_list);\n\t\tiod->rqstbuf = kcalloc(2, NVME_FC_MAX_LS_BUFFER_SIZE,\n\t\t\tGFP_KERNEL);\n\t\tif (!iod->rqstbuf)\n\t\t\tgoto out_fail;\n\t\tiod->rspbuf = iod->rqstbuf + NVME_FC_MAX_LS_BUFFER_SIZE;\n\t\tiod->rspdma = fc_dma_map_single(tgtport->dev, iod->rspbuf,\n\t\t\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (fc_dma_mapping_error(tgtport->dev, iod->rspdma))\n\t\t\tgoto out_fail;\n\t}\n\treturn 0;\nout_fail:\n\tkfree(iod->rqstbuf);\n\tlist_del(&iod->ls_list);\n\tfor (iod--, i--; i >= 0; iod--, i--) {\n\t\tfc_dma_unmap_single(tgtport->dev, iod->rspdma,\n\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE, DMA_TO_DEVICE);\n\t\tkfree(iod->rqstbuf);\n\t\tlist_del(&iod->ls_list);\n\t}\n\tkfree(iod);\n\treturn -EFAULT;\n}\nstatic void\nnvmet_fc_free_fcp_iod(struct nvmet_fc_tgt_queue *queue,\n\t\t\tstruct nvmet_fc_fcp_iod *fod)\n{\n\tstruct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;\n\tstruct nvmet_fc_tgtport *tgtport = fod->tgtport;\n\tstruct nvmet_fc_defer_fcp_req *deferfcp;\n\tunsigned long flags;\n\tfc_dma_sync_single_for_cpu(tgtport->dev, fod->rspdma,\n\t\t\t\tsizeof(fod->rspiubuf), DMA_TO_DEVICE);\n\tfcpreq->nvmet_fc_private = NULL;\n\tfod->active = false;\n\tfod->abort = false;\n\tfod->aborted = false;\n\tfod->writedataactive = false;\n\tfod->fcpreq = NULL;\n\ttgtport->ops->fcp_req_release(&tgtport->fc_target_port, fcpreq);\n\tspin_lock_irqsave(&queue->qlock, flags);\n\tdeferfcp = list_first_entry_or_null(&queue->pending_cmd_list,\n\t\t\t\tstruct nvmet_fc_defer_fcp_req, req_list);\n\tif (!deferfcp) {\n\t\tlist_add_tail(&fod->fcp_list, &fod->queue->fod_list);\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\tnvmet_fc_tgt_q_put(queue);\n\t\treturn;\n\t}\n\tlist_del(&deferfcp->req_list);\n\tfcpreq = deferfcp->fcp_req;\n\tlist_add_tail(&deferfcp->req_list, &queue->avail_defer_list);\n\tspin_unlock_irqrestore(&queue->qlock, flags);\n\tmemcpy(&fod->cmdiubuf, fcpreq->rspaddr, fcpreq->rsplen);\n\tfcpreq->rspaddr = NULL;\n\tfcpreq->rsplen  = 0;\n\tfcpreq->nvmet_fc_private = fod;\n\tfod->fcpreq = fcpreq;\n\tfod->active = true;\n\ttgtport->ops->defer_rcv(&tgtport->fc_target_port, fcpreq);\n\tnvmet_fc_queue_fcp_req(tgtport, queue, fcpreq);\n}\nstatic struct nvmet_fc_tgt_queue *\nnvmet_fc_alloc_target_queue(struct nvmet_fc_tgt_assoc *assoc,\n\t\t\tu16 qid, u16 sqsize)\n{\n\tstruct nvmet_fc_tgt_queue *queue;\n\tunsigned long flags;\n\tint ret;\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\tqueue = kzalloc((sizeof(*queue) +\n\t\t\t\t(sizeof(struct nvmet_fc_fcp_iod) * sqsize)),\n\t\t\t\tGFP_KERNEL);\n\tif (!queue)\n\t\treturn NULL;\n\tif (!nvmet_fc_tgt_a_get(assoc))\n\t\tgoto out_free_queue;\n\tqueue->work_q = alloc_workqueue(\"ntfc%d.%d.%d\", 0, 0,\n\t\t\t\tassoc->tgtport->fc_target_port.port_num,\n\t\t\t\tassoc->a_id, qid);\n\tif (!queue->work_q)\n\t\tgoto out_a_put;\n\tqueue->fod = (struct nvmet_fc_fcp_iod *)&queue[1];\n\tqueue->qid = qid;\n\tqueue->sqsize = sqsize;\n\tqueue->assoc = assoc;\n\tqueue->port = assoc->tgtport->port;\n\tqueue->cpu = nvmet_fc_queue_to_cpu(assoc->tgtport, qid);\n\tINIT_LIST_HEAD(&queue->fod_list);\n\tINIT_LIST_HEAD(&queue->avail_defer_list);\n\tINIT_LIST_HEAD(&queue->pending_cmd_list);\n\tatomic_set(&queue->connected, 0);\n\tatomic_set(&queue->sqtail, 0);\n\tatomic_set(&queue->rsn, 1);\n\tatomic_set(&queue->zrspcnt, 0);\n\tspin_lock_init(&queue->qlock);\n\tkref_init(&queue->ref);\n\tnvmet_fc_prep_fcp_iodlist(assoc->tgtport, queue);\n\tret = nvmet_sq_init(&queue->nvme_sq);\n\tif (ret)\n\t\tgoto out_fail_iodlist;\n\tWARN_ON(assoc->queues[qid]);\n\tspin_lock_irqsave(&assoc->tgtport->lock, flags);\n\tassoc->queues[qid] = queue;\n\tspin_unlock_irqrestore(&assoc->tgtport->lock, flags);\n\treturn queue;\nout_fail_iodlist:\n\tnvmet_fc_destroy_fcp_iodlist(assoc->tgtport, queue);\n\tdestroy_workqueue(queue->work_q);\nout_a_put:\n\tnvmet_fc_tgt_a_put(assoc);\nout_free_queue:\n\tkfree(queue);\n\treturn NULL;\n}\nstatic int\nnvmet_fc_tgt_q_get(struct nvmet_fc_tgt_queue *queue)\n{\n\treturn kref_get_unless_zero(&queue->ref);\n}\nstatic void\nnvmet_fc_delete_target_queue(struct nvmet_fc_tgt_queue *queue)\n{\n\tstruct nvmet_fc_tgtport *tgtport = queue->assoc->tgtport;\n\tstruct nvmet_fc_fcp_iod *fod = queue->fod;\n\tstruct nvmet_fc_defer_fcp_req *deferfcp, *tempptr;\n\tunsigned long flags;\n\tint i, writedataactive;\n\tbool disconnect;\n\tdisconnect = atomic_xchg(&queue->connected, 0);\n\tspin_lock_irqsave(&queue->qlock, flags);\n\tfor (i = 0; i < queue->sqsize; fod++, i++) {\n\t\tif (fod->active) {\n\t\t\tspin_lock(&fod->flock);\n\t\t\tfod->abort = true;\n\t\t\twritedataactive = fod->writedataactive;\n\t\t\tspin_unlock(&fod->flock);\n\t\t\tif (writedataactive) {\n\t\t\t\tspin_lock(&fod->flock);\n\t\t\t\tfod->aborted = true;\n\t\t\t\tspin_unlock(&fod->flock);\n\t\t\t\ttgtport->ops->fcp_abort(\n\t\t\t\t\t&tgtport->fc_target_port, fod->fcpreq);\n\t\t\t}\n\t\t}\n\t}\n\tlist_for_each_entry_safe(deferfcp, tempptr, &queue->avail_defer_list,\n\t\t\t\treq_list) {\n\t\tlist_del(&deferfcp->req_list);\n\t\tkfree(deferfcp);\n\t}\n\tfor (;;) {\n\t\tdeferfcp = list_first_entry_or_null(&queue->pending_cmd_list,\n\t\t\t\tstruct nvmet_fc_defer_fcp_req, req_list);\n\t\tif (!deferfcp)\n\t\t\tbreak;\n\t\tlist_del(&deferfcp->req_list);\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\ttgtport->ops->defer_rcv(&tgtport->fc_target_port,\n\t\t\t\tdeferfcp->fcp_req);\n\t\ttgtport->ops->fcp_abort(&tgtport->fc_target_port,\n\t\t\t\tdeferfcp->fcp_req);\n\t\ttgtport->ops->fcp_req_release(&tgtport->fc_target_port,\n\t\t\t\tdeferfcp->fcp_req);\n\t\tkfree(deferfcp);\n\t\tspin_lock_irqsave(&queue->qlock, flags);\n\t}\n\tspin_unlock_irqrestore(&queue->qlock, flags);\n\tflush_workqueue(queue->work_q);\n\tif (disconnect)\n\t\tnvmet_sq_destroy(&queue->nvme_sq);\n\tnvmet_fc_tgt_q_put(queue);\n}\nstatic struct nvmet_fc_tgt_queue *\nnvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}\nstatic struct nvmet_fc_tgt_assoc *\nnvmet_fc_alloc_target_assoc(struct nvmet_fc_tgtport *tgtport)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc, *tmpassoc;\n\tunsigned long flags;\n\tu64 ran;\n\tint idx;\n\tbool needrandom = true;\n\tassoc = kzalloc(sizeof(*assoc), GFP_KERNEL);\n\tif (!assoc)\n\t\treturn NULL;\n\tidx = ida_simple_get(&tgtport->assoc_cnt, 0, 0, GFP_KERNEL);\n\tif (idx < 0)\n\t\tgoto out_free_assoc;\n\tif (!nvmet_fc_tgtport_get(tgtport))\n\t\tgoto out_ida_put;\n\tassoc->tgtport = tgtport;\n\tassoc->a_id = idx;\n\tINIT_LIST_HEAD(&assoc->a_list);\n\tkref_init(&assoc->ref);\n\twhile (needrandom) {\n\t\tget_random_bytes(&ran, sizeof(ran) - BYTES_FOR_QID);\n\t\tran = ran << BYTES_FOR_QID_SHIFT;\n\t\tspin_lock_irqsave(&tgtport->lock, flags);\n\t\tneedrandom = false;\n\t\tlist_for_each_entry(tmpassoc, &tgtport->assoc_list, a_list)\n\t\t\tif (ran == tmpassoc->association_id) {\n\t\t\t\tneedrandom = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!needrandom) {\n\t\t\tassoc->association_id = ran;\n\t\t\tlist_add_tail(&assoc->a_list, &tgtport->assoc_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t}\n\treturn assoc;\nout_ida_put:\n\tida_simple_remove(&tgtport->assoc_cnt, idx);\nout_free_assoc:\n\tkfree(assoc);\n\treturn NULL;\n}\nint\nnvmet_fc_register_targetport(struct nvmet_fc_port_info *pinfo,\n\t\t\tstruct nvmet_fc_target_template *template,\n\t\t\tstruct device *dev,\n\t\t\tstruct nvmet_fc_target_port **portptr)\n{\n\tstruct nvmet_fc_tgtport *newrec;\n\tunsigned long flags;\n\tint ret, idx;\n\tif (!template->xmt_ls_rsp || !template->fcp_op ||\n\t    !template->fcp_abort ||\n\t    !template->fcp_req_release || !template->targetport_delete ||\n\t    !template->max_hw_queues || !template->max_sgl_segments ||\n\t    !template->max_dif_sgl_segments || !template->dma_boundary) {\n\t\tret = -EINVAL;\n\t\tgoto out_regtgt_failed;\n\t}\n\tnewrec = kzalloc((sizeof(*newrec) + template->target_priv_sz),\n\t\t\t GFP_KERNEL);\n\tif (!newrec) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regtgt_failed;\n\t}\n\tidx = ida_simple_get(&nvmet_fc_tgtport_cnt, 0, 0, GFP_KERNEL);\n\tif (idx < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_fail_kfree;\n\t}\n\tif (!get_device(dev) && dev) {\n\t\tret = -ENODEV;\n\t\tgoto out_ida_put;\n\t}\n\tnewrec->fc_target_port.node_name = pinfo->node_name;\n\tnewrec->fc_target_port.port_name = pinfo->port_name;\n\tnewrec->fc_target_port.private = &newrec[1];\n\tnewrec->fc_target_port.port_id = pinfo->port_id;\n\tnewrec->fc_target_port.port_num = idx;\n\tINIT_LIST_HEAD(&newrec->tgt_list);\n\tnewrec->dev = dev;\n\tnewrec->ops = template;\n\tspin_lock_init(&newrec->lock);\n\tINIT_LIST_HEAD(&newrec->ls_list);\n\tINIT_LIST_HEAD(&newrec->ls_busylist);\n\tINIT_LIST_HEAD(&newrec->assoc_list);\n\tkref_init(&newrec->ref);\n\tida_init(&newrec->assoc_cnt);\n\tnewrec->max_sg_cnt = min_t(u32, NVMET_FC_MAX_XFR_SGENTS,\n\t\t\t\t\ttemplate->max_sgl_segments);\n\tret = nvmet_fc_alloc_ls_iodlist(newrec);\n\tif (ret) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_newrec;\n\t}\n\tspin_lock_irqsave(&nvmet_fc_tgtlock, flags);\n\tlist_add_tail(&newrec->tgt_list, &nvmet_fc_target_list);\n\tspin_unlock_irqrestore(&nvmet_fc_tgtlock, flags);\n\t*portptr = &newrec->fc_target_port;\n\treturn 0;\nout_free_newrec:\n\tput_device(dev);\nout_ida_put:\n\tida_simple_remove(&nvmet_fc_tgtport_cnt, idx);\nout_fail_kfree:\n\tkfree(newrec);\nout_regtgt_failed:\n\t*portptr = NULL;\n\treturn ret;\n}\nstatic void\nnvmet_fc_delete_ctrl(struct nvmet_ctrl *ctrl)\n{\n\tstruct nvmet_fc_tgtport *tgtport, *next;\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tunsigned long flags;\n\tbool found_ctrl = false;\n\tspin_lock_irqsave(&nvmet_fc_tgtlock, flags);\n\tlist_for_each_entry_safe(tgtport, next, &nvmet_fc_target_list,\n\t\t\ttgt_list) {\n\t\tif (!nvmet_fc_tgtport_get(tgtport))\n\t\t\tcontinue;\n\t\tspin_unlock_irqrestore(&nvmet_fc_tgtlock, flags);\n\t\tspin_lock_irqsave(&tgtport->lock, flags);\n\t\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\t\tqueue = assoc->queues[0];\n\t\t\tif (queue && queue->nvme_sq.ctrl == ctrl) {\n\t\t\t\tif (nvmet_fc_tgt_a_get(assoc))\n\t\t\t\t\tfound_ctrl = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\tnvmet_fc_tgtport_put(tgtport);\n\t\tif (found_ctrl) {\n\t\t\tnvmet_fc_delete_target_assoc(assoc);\n\t\t\tnvmet_fc_tgt_a_put(assoc);\n\t\t\treturn;\n\t\t}\n\t\tspin_lock_irqsave(&nvmet_fc_tgtlock, flags);\n\t}\n\tspin_unlock_irqrestore(&nvmet_fc_tgtlock, flags);\n}\nEXPORT_SYMBOL_GPL(nvmet_fc_unregister_targetport);\nenum {\n\tVERR_NO_ERROR\t\t= 0,\n\tVERR_CR_ASSOC_LEN\t= 1,\n\tVERR_CR_ASSOC_RQST_LEN\t= 2,\n\tVERR_CR_ASSOC_CMD\t= 3,\n\tVERR_CR_ASSOC_CMD_LEN\t= 4,\n\tVERR_ERSP_RATIO\t\t= 5,\n\tVERR_ASSOC_ALLOC_FAIL\t= 6,\n\tVERR_QUEUE_ALLOC_FAIL\t= 7,\n\tVERR_CR_CONN_LEN\t= 8,\n\tVERR_CR_CONN_RQST_LEN\t= 9,\n\tVERR_ASSOC_ID\t\t= 10,\n\tVERR_ASSOC_ID_LEN\t= 11,\n\tVERR_NO_ASSOC\t\t= 12,\n\tVERR_CONN_ID\t\t= 13,\n\tVERR_CONN_ID_LEN\t= 14,\n\tVERR_NO_CONN\t\t= 15,\n\tVERR_CR_CONN_CMD\t= 16,\n\tVERR_CR_CONN_CMD_LEN\t= 17,\n\tVERR_DISCONN_LEN\t= 18,\n\tVERR_DISCONN_RQST_LEN\t= 19,\n\tVERR_DISCONN_CMD\t= 20,\n\tVERR_DISCONN_CMD_LEN\t= 21,\n\tVERR_DISCONN_SCOPE\t= 22,\n\tVERR_RS_LEN\t\t= 23,\n\tVERR_RS_RQST_LEN\t= 24,\n\tVERR_RS_CMD\t\t= 25,\n\tVERR_RS_CMD_LEN\t\t= 26,\n\tVERR_RS_RCTL\t\t= 27,\n\tVERR_RS_RO\t\t= 28,\n};\nstatic char *validation_errors[] = {\n\t\"OK\",\n\t\"Bad CR_ASSOC Length\",\n\t\"Bad CR_ASSOC Rqst Length\",\n\t\"Not CR_ASSOC Cmd\",\n\t\"Bad CR_ASSOC Cmd Length\",\n\t\"Bad Ersp Ratio\",\n\t\"Association Allocation Failed\",\n\t\"Queue Allocation Failed\",\n\t\"Bad CR_CONN Length\",\n\t\"Bad CR_CONN Rqst Length\",\n\t\"Not Association ID\",\n\t\"Bad Association ID Length\",\n\t\"No Association\",\n\t\"Not Connection ID\",\n\t\"Bad Connection ID Length\",\n\t\"No Connection\",\n\t\"Not CR_CONN Cmd\",\n\t\"Bad CR_CONN Cmd Length\",\n\t\"Bad DISCONN Length\",\n\t\"Bad DISCONN Rqst Length\",\n\t\"Not DISCONN Cmd\",\n\t\"Bad DISCONN Cmd Length\",\n\t\"Bad Disconnect Scope\",\n\t\"Bad RS Length\",\n\t\"Bad RS Rqst Length\",\n\t\"Not RS Cmd\",\n\t\"Bad RS Cmd Length\",\n\t\"Bad RS R_CTL\",\n\t\"Bad RS Relative Offset\",\n};\nstatic void\nnvmet_fc_ls_create_association(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_ls_iod *iod)\n{\n\tstruct fcnvme_ls_cr_assoc_rqst *rqst =\n\t\t\t\t(struct fcnvme_ls_cr_assoc_rqst *)iod->rqstbuf;\n\tstruct fcnvme_ls_cr_assoc_acc *acc =\n\t\t\t\t(struct fcnvme_ls_cr_assoc_acc *)iod->rspbuf;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tint ret = 0;\n\tmemset(acc, 0, sizeof(*acc));\n\tif (iod->rqstdatalen < FCNVME_LSDESC_CRA_RQST_MINLEN)\n\t\tret = VERR_CR_ASSOC_LEN;\n\telse if (be32_to_cpu(rqst->desc_list_len) <\n\t\t\tFCNVME_LSDESC_CRA_RQST_MIN_LISTLEN)\n\t\tret = VERR_CR_ASSOC_RQST_LEN;\n\telse if (rqst->assoc_cmd.desc_tag !=\n\t\t\tcpu_to_be32(FCNVME_LSDESC_CREATE_ASSOC_CMD))\n\t\tret = VERR_CR_ASSOC_CMD;\n\telse if (be32_to_cpu(rqst->assoc_cmd.desc_len) <\n\t\t\tFCNVME_LSDESC_CRA_CMD_DESC_MIN_DESCLEN)\n\t\tret = VERR_CR_ASSOC_CMD_LEN;\n\telse if (!rqst->assoc_cmd.ersp_ratio ||\n\t\t (be16_to_cpu(rqst->assoc_cmd.ersp_ratio) >=\n\t\t\t\tbe16_to_cpu(rqst->assoc_cmd.sqsize)))\n\t\tret = VERR_ERSP_RATIO;\n\telse {\n\t\tiod->assoc = nvmet_fc_alloc_target_assoc(tgtport);\n\t\tif (!iod->assoc)\n\t\t\tret = VERR_ASSOC_ALLOC_FAIL;\n\t\telse {\n\t\t\tqueue = nvmet_fc_alloc_target_queue(iod->assoc, 0,\n\t\t\t\t\tbe16_to_cpu(rqst->assoc_cmd.sqsize));\n\t\t\tif (!queue)\n\t\t\t\tret = VERR_QUEUE_ALLOC_FAIL;\n\t\t}\n\t}\n\tif (ret) {\n\t\tdev_err(tgtport->dev,\n\t\t\t\"Create Association LS failed: %s\\n\",\n\t\t\tvalidation_errors[ret]);\n\t\tiod->lsreq->rsplen = nvmet_fc_format_rjt(acc,\n\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE, rqst->w0.ls_cmd,\n\t\t\t\tFCNVME_RJT_RC_LOGIC,\n\t\t\t\tFCNVME_RJT_EXP_NONE, 0);\n\t\treturn;\n\t}\n\tqueue->ersp_ratio = be16_to_cpu(rqst->assoc_cmd.ersp_ratio);\n\tatomic_set(&queue->connected, 1);\n\tqueue->sqhd = 0;\t\n\tiod->lsreq->rsplen = sizeof(*acc);\n\tnvmet_fc_format_rsp_hdr(acc, FCNVME_LS_ACC,\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_ls_cr_assoc_acc)),\n\t\t\tFCNVME_LS_CREATE_ASSOCIATION);\n\tacc->associd.desc_tag = cpu_to_be32(FCNVME_LSDESC_ASSOC_ID);\n\tacc->associd.desc_len =\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_assoc_id));\n\tacc->associd.association_id =\n\t\t\tcpu_to_be64(nvmet_fc_makeconnid(iod->assoc, 0));\n\tacc->connectid.desc_tag = cpu_to_be32(FCNVME_LSDESC_CONN_ID);\n\tacc->connectid.desc_len =\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_conn_id));\n\tacc->connectid.connection_id = acc->associd.association_id;\n}\nstatic void\nnvmet_fc_ls_create_connection(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_ls_iod *iod)\n{\n\tstruct fcnvme_ls_cr_conn_rqst *rqst =\n\t\t\t\t(struct fcnvme_ls_cr_conn_rqst *)iod->rqstbuf;\n\tstruct fcnvme_ls_cr_conn_acc *acc =\n\t\t\t\t(struct fcnvme_ls_cr_conn_acc *)iod->rspbuf;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tint ret = 0;\n\tmemset(acc, 0, sizeof(*acc));\n\tif (iod->rqstdatalen < sizeof(struct fcnvme_ls_cr_conn_rqst))\n\t\tret = VERR_CR_CONN_LEN;\n\telse if (rqst->desc_list_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_ls_cr_conn_rqst)))\n\t\tret = VERR_CR_CONN_RQST_LEN;\n\telse if (rqst->associd.desc_tag != cpu_to_be32(FCNVME_LSDESC_ASSOC_ID))\n\t\tret = VERR_ASSOC_ID;\n\telse if (rqst->associd.desc_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_assoc_id)))\n\t\tret = VERR_ASSOC_ID_LEN;\n\telse if (rqst->connect_cmd.desc_tag !=\n\t\t\tcpu_to_be32(FCNVME_LSDESC_CREATE_CONN_CMD))\n\t\tret = VERR_CR_CONN_CMD;\n\telse if (rqst->connect_cmd.desc_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_cr_conn_cmd)))\n\t\tret = VERR_CR_CONN_CMD_LEN;\n\telse if (!rqst->connect_cmd.ersp_ratio ||\n\t\t (be16_to_cpu(rqst->connect_cmd.ersp_ratio) >=\n\t\t\t\tbe16_to_cpu(rqst->connect_cmd.sqsize)))\n\t\tret = VERR_ERSP_RATIO;\n\telse {\n\t\tiod->assoc = nvmet_fc_find_target_assoc(tgtport,\n\t\t\t\tbe64_to_cpu(rqst->associd.association_id));\n\t\tif (!iod->assoc)\n\t\t\tret = VERR_NO_ASSOC;\n\t\telse {\n\t\t\tqueue = nvmet_fc_alloc_target_queue(iod->assoc,\n\t\t\t\t\tbe16_to_cpu(rqst->connect_cmd.qid),\n\t\t\t\t\tbe16_to_cpu(rqst->connect_cmd.sqsize));\n\t\t\tif (!queue)\n\t\t\t\tret = VERR_QUEUE_ALLOC_FAIL;\n\t\t\tnvmet_fc_tgt_a_put(iod->assoc);\n\t\t}\n\t}\n\tif (ret) {\n\t\tdev_err(tgtport->dev,\n\t\t\t\"Create Connection LS failed: %s\\n\",\n\t\t\tvalidation_errors[ret]);\n\t\tiod->lsreq->rsplen = nvmet_fc_format_rjt(acc,\n\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE, rqst->w0.ls_cmd,\n\t\t\t\t(ret == VERR_NO_ASSOC) ?\n\t\t\t\t\tFCNVME_RJT_RC_INV_ASSOC :\n\t\t\t\t\tFCNVME_RJT_RC_LOGIC,\n\t\t\t\tFCNVME_RJT_EXP_NONE, 0);\n\t\treturn;\n\t}\n\tqueue->ersp_ratio = be16_to_cpu(rqst->connect_cmd.ersp_ratio);\n\tatomic_set(&queue->connected, 1);\n\tqueue->sqhd = 0;\t\n\tiod->lsreq->rsplen = sizeof(*acc);\n\tnvmet_fc_format_rsp_hdr(acc, FCNVME_LS_ACC,\n\t\t\tfcnvme_lsdesc_len(sizeof(struct fcnvme_ls_cr_conn_acc)),\n\t\t\tFCNVME_LS_CREATE_CONNECTION);\n\tacc->connectid.desc_tag = cpu_to_be32(FCNVME_LSDESC_CONN_ID);\n\tacc->connectid.desc_len =\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_conn_id));\n\tacc->connectid.connection_id =\n\t\t\tcpu_to_be64(nvmet_fc_makeconnid(iod->assoc,\n\t\t\t\tbe16_to_cpu(rqst->connect_cmd.qid)));\n}\nstatic void\nnvmet_fc_ls_disconnect(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_ls_iod *iod)\n{\n\tstruct fcnvme_ls_disconnect_rqst *rqst =\n\t\t\t(struct fcnvme_ls_disconnect_rqst *)iod->rqstbuf;\n\tstruct fcnvme_ls_disconnect_acc *acc =\n\t\t\t(struct fcnvme_ls_disconnect_acc *)iod->rspbuf;\n\tstruct nvmet_fc_tgt_queue *queue = NULL;\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tint ret = 0;\n\tbool del_assoc = false;\n\tmemset(acc, 0, sizeof(*acc));\n\tif (iod->rqstdatalen < sizeof(struct fcnvme_ls_disconnect_rqst))\n\t\tret = VERR_DISCONN_LEN;\n\telse if (rqst->desc_list_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_ls_disconnect_rqst)))\n\t\tret = VERR_DISCONN_RQST_LEN;\n\telse if (rqst->associd.desc_tag != cpu_to_be32(FCNVME_LSDESC_ASSOC_ID))\n\t\tret = VERR_ASSOC_ID;\n\telse if (rqst->associd.desc_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_assoc_id)))\n\t\tret = VERR_ASSOC_ID_LEN;\n\telse if (rqst->discon_cmd.desc_tag !=\n\t\t\tcpu_to_be32(FCNVME_LSDESC_DISCONN_CMD))\n\t\tret = VERR_DISCONN_CMD;\n\telse if (rqst->discon_cmd.desc_len !=\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_lsdesc_disconn_cmd)))\n\t\tret = VERR_DISCONN_CMD_LEN;\n\telse if ((rqst->discon_cmd.scope != FCNVME_DISCONN_ASSOCIATION) &&\n\t\t\t(rqst->discon_cmd.scope != FCNVME_DISCONN_CONNECTION))\n\t\tret = VERR_DISCONN_SCOPE;\n\telse {\n\t\tassoc = nvmet_fc_find_target_assoc(tgtport,\n\t\t\t\tbe64_to_cpu(rqst->associd.association_id));\n\t\tiod->assoc = assoc;\n\t\tif (assoc) {\n\t\t\tif (rqst->discon_cmd.scope ==\n\t\t\t\t\tFCNVME_DISCONN_CONNECTION) {\n\t\t\t\tqueue = nvmet_fc_find_target_queue(tgtport,\n\t\t\t\t\t\tbe64_to_cpu(\n\t\t\t\t\t\t\trqst->discon_cmd.id));\n\t\t\t\tif (!queue) {\n\t\t\t\t\tnvmet_fc_tgt_a_put(assoc);\n\t\t\t\t\tret = VERR_NO_CONN;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tret = VERR_NO_ASSOC;\n\t}\n\tif (ret) {\n\t\tdev_err(tgtport->dev,\n\t\t\t\"Disconnect LS failed: %s\\n\",\n\t\t\tvalidation_errors[ret]);\n\t\tiod->lsreq->rsplen = nvmet_fc_format_rjt(acc,\n\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE, rqst->w0.ls_cmd,\n\t\t\t\t(ret == VERR_NO_ASSOC) ?\n\t\t\t\t\tFCNVME_RJT_RC_INV_ASSOC :\n\t\t\t\t\t(ret == VERR_NO_CONN) ?\n\t\t\t\t\t\tFCNVME_RJT_RC_INV_CONN :\n\t\t\t\t\t\tFCNVME_RJT_RC_LOGIC,\n\t\t\t\tFCNVME_RJT_EXP_NONE, 0);\n\t\treturn;\n\t}\n\tiod->lsreq->rsplen = sizeof(*acc);\n\tnvmet_fc_format_rsp_hdr(acc, FCNVME_LS_ACC,\n\t\t\tfcnvme_lsdesc_len(\n\t\t\t\tsizeof(struct fcnvme_ls_disconnect_acc)),\n\t\t\tFCNVME_LS_DISCONNECT);\n\tif (queue) {\n\t\tint qid = queue->qid;\n\t\tnvmet_fc_delete_target_queue(queue);\n\t\tnvmet_fc_tgt_q_put(queue);\n\t\tif (!qid)\n\t\t\tdel_assoc = true;\n\t}\n\tnvmet_fc_tgt_a_put(iod->assoc);\n\tif (del_assoc)\n\t\tnvmet_fc_delete_target_assoc(iod->assoc);\n}\nstatic void nvmet_fc_fcp_nvme_cmd_done(struct nvmet_req *nvme_req);\nstatic struct nvmet_fabrics_ops nvmet_fc_tgt_fcp_ops;\nstatic void\nnvmet_fc_handle_ls_rqst(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_ls_iod *iod)\n{\n\tstruct fcnvme_ls_rqst_w0 *w0 =\n\t\t\t(struct fcnvme_ls_rqst_w0 *)iod->rqstbuf;\n\tiod->lsreq->nvmet_fc_private = iod;\n\tiod->lsreq->rspbuf = iod->rspbuf;\n\tiod->lsreq->rspdma = iod->rspdma;\n\tiod->lsreq->done = nvmet_fc_xmt_ls_rsp_done;\n\tiod->lsreq->rsplen = 0;\n\tiod->assoc = NULL;\n\tswitch (w0->ls_cmd) {\n\tcase FCNVME_LS_CREATE_ASSOCIATION:\n\t\tnvmet_fc_ls_create_association(tgtport, iod);\n\t\tbreak;\n\tcase FCNVME_LS_CREATE_CONNECTION:\n\t\tnvmet_fc_ls_create_connection(tgtport, iod);\n\t\tbreak;\n\tcase FCNVME_LS_DISCONNECT:\n\t\tnvmet_fc_ls_disconnect(tgtport, iod);\n\t\tbreak;\n\tdefault:\n\t\tiod->lsreq->rsplen = nvmet_fc_format_rjt(iod->rspbuf,\n\t\t\t\tNVME_FC_MAX_LS_BUFFER_SIZE, w0->ls_cmd,\n\t\t\t\tFCNVME_RJT_RC_INVAL, FCNVME_RJT_EXP_NONE, 0);\n\t}\n\tnvmet_fc_xmt_ls_rsp(tgtport, iod);\n}\nEXPORT_SYMBOL_GPL(nvmet_fc_rcv_ls_req);\nstatic void\nnvmet_fc_prep_fcp_rsp(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tstruct nvmet_fc_fcp_iod *fod)\n{\n\tstruct nvme_fc_ersp_iu *ersp = &fod->rspiubuf;\n\tstruct nvme_common_command *sqe = &fod->cmdiubuf.sqe.common;\n\tstruct nvme_completion *cqe = &ersp->cqe;\n\tu32 *cqewd = (u32 *)cqe;\n\tbool send_ersp = false;\n\tu32 rsn, rspcnt, xfr_length;\n\tif (fod->fcpreq->op == NVMET_FCOP_READDATA_RSP)\n\t\txfr_length = fod->total_length;\n\telse\n\t\txfr_length = fod->offset;\n\trspcnt = atomic_inc_return(&fod->queue->zrspcnt);\n\tif (!(rspcnt % fod->queue->ersp_ratio) ||\n\t    sqe->opcode == nvme_fabrics_command ||\n\t    xfr_length != fod->total_length ||\n\t    (le16_to_cpu(cqe->status) & 0xFFFE) || cqewd[0] || cqewd[1] ||\n\t    (sqe->flags & (NVME_CMD_FUSE_FIRST | NVME_CMD_FUSE_SECOND)) ||\n\t    queue_90percent_full(fod->queue, le16_to_cpu(cqe->sq_head)))\n\t\tsend_ersp = true;\n\tfod->fcpreq->rspaddr = ersp;\n\tfod->fcpreq->rspdma = fod->rspdma;\n\tif (!send_ersp) {\n\t\tmemset(ersp, 0, NVME_FC_SIZEOF_ZEROS_RSP);\n\t\tfod->fcpreq->rsplen = NVME_FC_SIZEOF_ZEROS_RSP;\n\t} else {\n\t\tersp->iu_len = cpu_to_be16(sizeof(*ersp)/sizeof(u32));\n\t\trsn = atomic_inc_return(&fod->queue->rsn);\n\t\tersp->rsn = cpu_to_be32(rsn);\n\t\tersp->xfrd_len = cpu_to_be32(xfr_length);\n\t\tfod->fcpreq->rsplen = sizeof(*ersp);\n\t}\n\tfc_dma_sync_single_for_device(tgtport->dev, fod->rspdma,\n\t\t\t\t  sizeof(fod->rspiubuf), DMA_TO_DEVICE);\n}\nstatic void nvmet_fc_xmt_fcp_op_done(struct nvmefc_tgt_fcp_req *fcpreq);\nstatic void\nnvmet_fc_transfer_fcp_data(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tstruct nvmet_fc_fcp_iod *fod, u8 op)\n{\n\tstruct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;\n\tunsigned long flags;\n\tu32 tlen;\n\tint ret;\n\tfcpreq->op = op;\n\tfcpreq->offset = fod->offset;\n\tfcpreq->timeout = NVME_FC_TGTOP_TIMEOUT_SEC;\n\ttlen = min_t(u32, tgtport->max_sg_cnt * PAGE_SIZE,\n\t\t\t(fod->total_length - fod->offset));\n\tfcpreq->transfer_length = tlen;\n\tfcpreq->transferred_length = 0;\n\tfcpreq->fcp_error = 0;\n\tfcpreq->rsplen = 0;\n\tfcpreq->sg = &fod->data_sg[fod->offset / PAGE_SIZE];\n\tfcpreq->sg_cnt = DIV_ROUND_UP(tlen, PAGE_SIZE);\n\tif ((op == NVMET_FCOP_READDATA) &&\n\t    ((fod->offset + fcpreq->transfer_length) == fod->total_length) &&\n\t    (tgtport->ops->target_features & NVMET_FCTGTFEAT_READDATA_RSP)) {\n\t\tfcpreq->op = NVMET_FCOP_READDATA_RSP;\n\t\tnvmet_fc_prep_fcp_rsp(tgtport, fod);\n\t}\n\tret = tgtport->ops->fcp_op(&tgtport->fc_target_port, fod->fcpreq);\n\tif (ret) {\n\t\tfod->abort = true;\n\t\tif (op == NVMET_FCOP_WRITEDATA) {\n\t\t\tspin_lock_irqsave(&fod->flock, flags);\n\t\t\tfod->writedataactive = false;\n\t\t\tspin_unlock_irqrestore(&fod->flock, flags);\n\t\t\tnvmet_req_complete(&fod->req, NVME_SC_INTERNAL);\n\t\t} else  {\n\t\t\tfcpreq->fcp_error = ret;\n\t\t\tfcpreq->transferred_length = 0;\n\t\t\tnvmet_fc_xmt_fcp_op_done(fod->fcpreq);\n\t\t}\n\t}\n}\nstatic void\nnvmet_fc_fod_op_done(struct nvmet_fc_fcp_iod *fod)\n{\n\tstruct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;\n\tstruct nvmet_fc_tgtport *tgtport = fod->tgtport;\n\tunsigned long flags;\n\tbool abort;\n\tspin_lock_irqsave(&fod->flock, flags);\n\tabort = fod->abort;\n\tfod->writedataactive = false;\n\tspin_unlock_irqrestore(&fod->flock, flags);\n\tswitch (fcpreq->op) {\n\tcase NVMET_FCOP_WRITEDATA:\n\t\tif (__nvmet_fc_fod_op_abort(fod, abort))\n\t\t\treturn;\n\t\tif (fcpreq->fcp_error ||\n\t\t    fcpreq->transferred_length != fcpreq->transfer_length) {\n\t\t\tspin_lock(&fod->flock);\n\t\t\tfod->abort = true;\n\t\t\tspin_unlock(&fod->flock);\n\t\t\tnvmet_req_complete(&fod->req, NVME_SC_INTERNAL);\n\t\t\treturn;\n\t\t}\n\t\tfod->offset += fcpreq->transferred_length;\n\t\tif (fod->offset != fod->total_length) {\n\t\t\tspin_lock_irqsave(&fod->flock, flags);\n\t\t\tfod->writedataactive = true;\n\t\t\tspin_unlock_irqrestore(&fod->flock, flags);\n\t\t\tnvmet_fc_transfer_fcp_data(tgtport, fod,\n\t\t\t\t\t\tNVMET_FCOP_WRITEDATA);\n\t\t\treturn;\n\t\t}\n\t\tfod->req.execute(&fod->req);\n\t\tbreak;\n\tcase NVMET_FCOP_READDATA:\n\tcase NVMET_FCOP_READDATA_RSP:\n\t\tif (__nvmet_fc_fod_op_abort(fod, abort))\n\t\t\treturn;\n\t\tif (fcpreq->fcp_error ||\n\t\t    fcpreq->transferred_length != fcpreq->transfer_length) {\n\t\t\tnvmet_fc_abort_op(tgtport, fod);\n\t\t\treturn;\n\t\t}\n\t\tif (fcpreq->op == NVMET_FCOP_READDATA_RSP) {\n\t\t\tnvmet_fc_free_tgt_pgs(fod);\n\t\t\tnvmet_fc_free_fcp_iod(fod->queue, fod);\n\t\t\treturn;\n\t\t}\n\t\tfod->offset += fcpreq->transferred_length;\n\t\tif (fod->offset != fod->total_length) {\n\t\t\tnvmet_fc_transfer_fcp_data(tgtport, fod,\n\t\t\t\t\t\tNVMET_FCOP_READDATA);\n\t\t\treturn;\n\t\t}\n\t\tnvmet_fc_free_tgt_pgs(fod);\n\t\tnvmet_fc_xmt_fcp_rsp(tgtport, fod);\n\t\tbreak;\n\tcase NVMET_FCOP_RSP:\n\t\tif (__nvmet_fc_fod_op_abort(fod, abort))\n\t\t\treturn;\n\t\tnvmet_fc_free_fcp_iod(fod->queue, fod);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nstatic void\n__nvmet_fc_fcp_nvme_cmd_done(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_fcp_iod *fod, int status)\n{\n\tstruct nvme_common_command *sqe = &fod->cmdiubuf.sqe.common;\n\tstruct nvme_completion *cqe = &fod->rspiubuf.cqe;\n\tunsigned long flags;\n\tbool abort;\n\tspin_lock_irqsave(&fod->flock, flags);\n\tabort = fod->abort;\n\tspin_unlock_irqrestore(&fod->flock, flags);\n\tif (!status)\n\t\tfod->queue->sqhd = cqe->sq_head;\n\tif (abort) {\n\t\tnvmet_fc_abort_op(tgtport, fod);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tmemset(cqe, 0, sizeof(*cqe));\n\t\tcqe->sq_head = fod->queue->sqhd;\t\n\t\tcqe->sq_id = cpu_to_le16(fod->queue->qid);\n\t\tcqe->command_id = sqe->command_id;\n\t\tcqe->status = cpu_to_le16(status);\n\t} else {\n\t\tif ((fod->io_dir == NVMET_FCP_READ) && (fod->data_sg_cnt)) {\n\t\t\tnvmet_fc_transfer_fcp_data(tgtport, fod,\n\t\t\t\t\t\tNVMET_FCOP_READDATA);\n\t\t\treturn;\n\t\t}\n\t}\n\tnvmet_fc_free_tgt_pgs(fod);\n\tnvmet_fc_xmt_fcp_rsp(tgtport, fod);\n}\nstatic void\nnvmet_fc_handle_fcp_rqst(struct nvmet_fc_tgtport *tgtport,\n\t\t\tstruct nvmet_fc_fcp_iod *fod)\n{\n\tstruct nvme_fc_cmd_iu *cmdiu = &fod->cmdiubuf;\n\tint ret;\n\tfod->fcpreq->done = nvmet_fc_xmt_fcp_op_done;\n\tfod->total_length = be32_to_cpu(cmdiu->data_len);\n\tif (cmdiu->flags & FCNVME_CMD_FLAGS_WRITE) {\n\t\tfod->io_dir = NVMET_FCP_WRITE;\n\t\tif (!nvme_is_write(&cmdiu->sqe))\n\t\t\tgoto transport_error;\n\t} else if (cmdiu->flags & FCNVME_CMD_FLAGS_READ) {\n\t\tfod->io_dir = NVMET_FCP_READ;\n\t\tif (nvme_is_write(&cmdiu->sqe))\n\t\t\tgoto transport_error;\n\t} else {\n\t\tfod->io_dir = NVMET_FCP_NODATA;\n\t\tif (fod->total_length)\n\t\t\tgoto transport_error;\n\t}\n\tfod->req.cmd = &fod->cmdiubuf.sqe;\n\tfod->req.rsp = &fod->rspiubuf.cqe;\n\tfod->req.port = fod->queue->port;\n\tfod->req.execute = NULL;\n\tmemset(&fod->rspiubuf, 0, sizeof(fod->rspiubuf));\n\tfod->data_sg = NULL;\n\tfod->data_sg_cnt = 0;\n\tret = nvmet_req_init(&fod->req,\n\t\t\t\t&fod->queue->nvme_cq,\n\t\t\t\t&fod->queue->nvme_sq,\n\t\t\t\t&nvmet_fc_tgt_fcp_ops);\n\tif (!ret) {\n\t\treturn;\n\t}\n\tatomic_inc(&fod->queue->sqtail);\n\tif (fod->total_length) {\n\t\tret = nvmet_fc_alloc_tgt_pgs(fod);\n\t\tif (ret) {\n\t\t\tnvmet_req_complete(&fod->req, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\tfod->req.sg = fod->data_sg;\n\tfod->req.sg_cnt = fod->data_sg_cnt;\n\tfod->offset = 0;\n\tif (fod->io_dir == NVMET_FCP_WRITE) {\n\t\tnvmet_fc_transfer_fcp_data(tgtport, fod, NVMET_FCOP_WRITEDATA);\n\t\treturn;\n\t}\n\tfod->req.execute(&fod->req);\n\treturn;\ntransport_error:\n\tnvmet_fc_abort_op(tgtport, fod);\n}\nint\nnvmet_fc_rcv_fcp_req(struct nvmet_fc_target_port *target_port,\n\t\t\tstruct nvmefc_tgt_fcp_req *fcpreq,\n\t\t\tvoid *cmdiubuf, u32 cmdiubuf_len)\n{\n\tstruct nvmet_fc_tgtport *tgtport = targetport_to_tgtport(target_port);\n\tstruct nvme_fc_cmd_iu *cmdiu = cmdiubuf;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tstruct nvmet_fc_fcp_iod *fod;\n\tstruct nvmet_fc_defer_fcp_req *deferfcp;\n\tunsigned long flags;\n\tif ((cmdiubuf_len != sizeof(*cmdiu)) ||\n\t\t\t(cmdiu->scsi_id != NVME_CMD_SCSI_ID) ||\n\t\t\t(cmdiu->fc_id != NVME_CMD_FC_ID) ||\n\t\t\t(be16_to_cpu(cmdiu->iu_len) != (sizeof(*cmdiu)/4)))\n\t\treturn -EIO;\n\tqueue = nvmet_fc_find_target_queue(tgtport,\n\t\t\t\tbe64_to_cpu(cmdiu->connection_id));\n\tif (!queue)\n\t\treturn -ENOTCONN;\n\tspin_lock_irqsave(&queue->qlock, flags);\n\tfod = nvmet_fc_alloc_fcp_iod(queue);\n\tif (fod) {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\tfcpreq->nvmet_fc_private = fod;\n\t\tfod->fcpreq = fcpreq;\n\t\tmemcpy(&fod->cmdiubuf, cmdiubuf, cmdiubuf_len);\n\t\tnvmet_fc_queue_fcp_req(tgtport, queue, fcpreq);\n\t\treturn 0;\n\t}\n\tif (!tgtport->ops->defer_rcv) {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\tnvmet_fc_tgt_q_put(queue);\n\t\treturn -ENOENT;\n\t}\n\tdeferfcp = list_first_entry_or_null(&queue->avail_defer_list,\n\t\t\tstruct nvmet_fc_defer_fcp_req, req_list);\n\tif (deferfcp) {\n\t\tlist_del(&deferfcp->req_list);\n\t} else {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\tdeferfcp = kmalloc(sizeof(*deferfcp), GFP_KERNEL);\n\t\tif (!deferfcp) {\n\t\t\tnvmet_fc_tgt_q_put(queue);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock_irqsave(&queue->qlock, flags);\n\t}\n\tfcpreq->rspaddr = cmdiubuf;\n\tfcpreq->rsplen  = cmdiubuf_len;\n\tdeferfcp->fcp_req = fcpreq;\n\tlist_add_tail(&deferfcp->req_list, &queue->pending_cmd_list);\n\tspin_unlock_irqrestore(&queue->qlock, flags);\n\treturn -EOVERFLOW;\n}\nEXPORT_SYMBOL_GPL(nvmet_fc_rcv_fcp_req);\nEXPORT_SYMBOL_GPL(nvmet_fc_rcv_fcp_abort);\nstruct nvmet_fc_traddr {\n\tu64\tnn;\n\tu64\tpn;\n};\nstatic int\nnvme_fc_parse_traddr(struct nvmet_fc_traddr *traddr, char *buf, size_t blen)\n{\n\tchar name[2 + NVME_FC_TRADDR_HEXNAMELEN + 1];\n\tsubstring_t wwn = { name, &name[sizeof(name)-1] };\n\tint nnoffset, pnoffset;\n\tif (strnlen(buf, blen) == NVME_FC_TRADDR_MAXLENGTH &&\n\t\t\t!strncmp(buf, \"nn-0x\", NVME_FC_TRADDR_OXNNLEN) &&\n\t\t\t!strncmp(&buf[NVME_FC_TRADDR_MAX_PN_OFFSET],\n\t\t\t\t\"pn-0x\", NVME_FC_TRADDR_OXNNLEN)) {\n\t\tnnoffset = NVME_FC_TRADDR_OXNNLEN;\n\t\tpnoffset = NVME_FC_TRADDR_MAX_PN_OFFSET +\n\t\t\t\t\t\tNVME_FC_TRADDR_OXNNLEN;\n\t} else if ((strnlen(buf, blen) == NVME_FC_TRADDR_MINLENGTH &&\n\t\t\t!strncmp(buf, \"nn-\", NVME_FC_TRADDR_NNLEN) &&\n\t\t\t!strncmp(&buf[NVME_FC_TRADDR_MIN_PN_OFFSET],\n\t\t\t\t\"pn-\", NVME_FC_TRADDR_NNLEN))) {\n\t\tnnoffset = NVME_FC_TRADDR_NNLEN;\n\t\tpnoffset = NVME_FC_TRADDR_MIN_PN_OFFSET + NVME_FC_TRADDR_NNLEN;\n\t} else\n\t\tgoto out_einval;\n\tname[0] = '0';\n\tname[1] = 'x';\n\tname[2 + NVME_FC_TRADDR_HEXNAMELEN] = 0;\n\tmemcpy(&name[2], &buf[nnoffset], NVME_FC_TRADDR_HEXNAMELEN);\n\tif (__nvme_fc_parse_u64(&wwn, &traddr->nn))\n\t\tgoto out_einval;\n\tmemcpy(&name[2], &buf[pnoffset], NVME_FC_TRADDR_HEXNAMELEN);\n\tif (__nvme_fc_parse_u64(&wwn, &traddr->pn))\n\t\tgoto out_einval;\n\treturn 0;\nout_einval:\n\tpr_warn(\"%s: bad traddr string\\n\", __func__);\n\treturn -EINVAL;\n}\nstatic int\nnvmet_fc_add_port(struct nvmet_port *port)\n{\n\tstruct nvmet_fc_tgtport *tgtport;\n\tstruct nvmet_fc_traddr traddr = { 0L, 0L };\n\tunsigned long flags;\n\tint ret;\n\tif ((port->disc_addr.trtype != NVMF_TRTYPE_FC) ||\n\t    (port->disc_addr.adrfam != NVMF_ADDR_FAMILY_FC))\n\t\treturn -EINVAL;\n\tret = nvme_fc_parse_traddr(&traddr, port->disc_addr.traddr,\n\t\t\tsizeof(port->disc_addr.traddr));\n\tif (ret)\n\t\treturn ret;\n\tret = -ENXIO;\n\tspin_lock_irqsave(&nvmet_fc_tgtlock, flags);\n\tlist_for_each_entry(tgtport, &nvmet_fc_target_list, tgt_list) {\n\t\tif ((tgtport->fc_target_port.node_name == traddr.nn) &&\n\t\t    (tgtport->fc_target_port.port_name == traddr.pn)) {\n\t\t\tif (!tgtport->port) {\n\t\t\t\ttgtport->port = port;\n\t\t\t\tport->priv = tgtport;\n\t\t\t\tnvmet_fc_tgtport_get(tgtport);\n\t\t\t\tret = 0;\n\t\t\t} else\n\t\t\t\tret = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&nvmet_fc_tgtlock, flags);\n\treturn ret;\n}\nstatic struct nvmet_fabrics_ops nvmet_fc_tgt_fcp_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.type\t\t\t= NVMF_TRTYPE_FC,\n\t.msdbd\t\t\t= 1,\n\t.add_port\t\t= nvmet_fc_add_port,\n\t.remove_port\t\t= nvmet_fc_remove_port,\n\t.queue_response\t\t= nvmet_fc_fcp_nvme_cmd_done,\n\t.delete_ctrl\t\t= nvmet_fc_delete_ctrl,\n};\nstatic int __init nvmet_fc_init_module(void)\n{\n\treturn nvmet_register_transport(&nvmet_fc_tgt_fcp_ops);\n}\nstatic void __exit nvmet_fc_exit_module(void)\n{\n\tif (!list_empty(&nvmet_fc_target_list))\n\t\tpr_warn(\"%s: targetport list not empty\\n\", __func__);\n\tnvmet_unregister_transport(&nvmet_fc_tgt_fcp_ops);\n\tida_destroy(&nvmet_fc_tgtport_cnt);\n}\nMODULE_LICENSE(\"GPL v2\");\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_3638.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```                const char *name,\n                int af,\n                char *buffer, size_t buflen,\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        assert(name);\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n        if (af != AF_INET && af != AF_INET6) {\n        }\n        r = sd_machine_get_class(name, &class);\n        r = sd_bus_open_system(&bus);\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        r = count_addresses(reply, af, &c);\n        if (r < 0)\n                goto fail;\n        if (c <= 0) {\n        }\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n        if (buflen < ms) {\n        }\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <netdb.h>\n#include <nss.h>\n#include \"sd-bus.h\"\n#include \"sd-login.h\"\n#include \"alloc-util.h\"\n#include \"bus-common-errors.h\"\n#include \"bus-util.h\"\n#include \"hostname-util.h\"\n#include \"in-addr-util.h\"\n#include \"macro.h\"\n#include \"nss-util.h\"\n#include \"string-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\nenum nss_status _nss_mymachines_gethostbyname4_r(\n                const char *name,\n                struct gaih_addrtuple **pat,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp) {\n        struct gaih_addrtuple *r_tuple, *r_tuple_first = NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ int *ifindices = NULL;\n        _cleanup_free_ char *class = NULL;\n        size_t l, ms, idx;\n        unsigned i = 0, c = 0;\n        char *r_name;\n        int n_ifindices, r;\n        assert(name);\n        assert(pat);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n        n_ifindices = sd_machine_get_ifindices(name, &ifindices);\n        if (n_ifindices < 0) {\n                r = n_ifindices;\n                goto fail;\n        }\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n        r = count_addresses(reply, AF_UNSPEC, &c);\n        if (r < 0)\n                goto fail;\n        if (c <= 0) {\n                *errnop = ESRCH;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n        l = strlen(name);\n        ms = ALIGN(l+1) + ALIGN(sizeof(struct gaih_addrtuple)) * c;\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = TRY_AGAIN;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n        r_tuple_first = (struct gaih_addrtuple*) (buffer + idx);\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n                if (!IN_SET(family, AF_INET, AF_INET6)) {\n                        r = -EAFNOSUPPORT;\n                        goto fail;\n                }\n                if (sz != FAMILY_ADDRESS_SIZE(family)) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n                r_tuple = (struct gaih_addrtuple*) (buffer + idx);\n                r_tuple->next = i == c-1 ? NULL : (struct gaih_addrtuple*) ((char*) r_tuple + ALIGN(sizeof(struct gaih_addrtuple)));\n                r_tuple->name = r_name;\n                r_tuple->family = family;\n                r_tuple->scopeid = n_ifindices == 1 ? ifindices[0] : 0;\n                memcpy(r_tuple->addr, a, sz);\n                idx += ALIGN(sizeof(struct gaih_addrtuple));\n                i++;\n        }\n        assert(i == c);\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n        assert(idx == ms);\n        if (*pat)\n                **pat = *r_tuple_first;\n        else\n                *pat = r_tuple_first;\n        if (ttlp)\n                *ttlp = 0;\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n        return NSS_STATUS_SUCCESS;\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_gethostbyname3_r(\n                const char *name,\n                int af,\n                struct hostent *result,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp,\n                char **canonp) {\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        char *r_name, *r_aliases, *r_addr, *r_addr_list;\n        size_t l, idx, ms, alen;\n        int r;\n        assert(name);\n        assert(result);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n        if (af != AF_INET && af != AF_INET6) {\n                r = -EAFNOSUPPORT;\n                goto fail;\n        }\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n        r = count_addresses(reply, af, &c);\n        if (r < 0)\n                goto fail;\n        if (c <= 0) {\n                *errnop = ENOENT;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = NO_RECOVERY;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n        r_aliases = buffer + idx;\n        ((char**) r_aliases)[0] = NULL;\n        idx += sizeof(char*);\n        r_addr = buffer + idx;\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n                if (family != af)\n                        continue;\n                if (sz != alen) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n                memcpy(r_addr + i*ALIGN(alen), a, alen);\n                i++;\n        }\n        assert(i == c);\n        idx += c * ALIGN(alen);\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n        r_addr_list = buffer + idx;\n        for (i = 0; i < c; i++)\n                ((char**) r_addr_list)[i] = r_addr + i*ALIGN(alen);\n        ((char**) r_addr_list)[i] = NULL;\n        idx += (c+1) * sizeof(char*);\n        assert(idx == ms);\n        result->h_name = r_name;\n        result->h_aliases = (char**) r_aliases;\n        result->h_addrtype = af;\n        result->h_length = alen;\n        result->h_addr_list = (char**) r_addr_list;\n        if (ttlp)\n                *ttlp = 0;\n        if (canonp)\n                *canonp = r_name;\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n        return NSS_STATUS_SUCCESS;\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getpwnam_r(\n                const char *name,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t uid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(pwd);\n        p = startswith(name, \"vu-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        if (e - p > HOST_NAME_MAX - 1) \n                goto not_found;\n        r = parse_uid(e + 1, &uid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineUser\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = strlen(name);\n        if (buflen < l+1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memcpy(buffer, name, l+1);\n        pwd->pw_name = buffer;\n        pwd->pw_uid = mapped;\n        pwd->pw_gid = 65534; \n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; \n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getpwuid_r(\n                uid_t uid,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n        if (!uid_is_valid(uid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n        if (uid < 0x10000)\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineUser\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n        if (snprintf(buffer, buflen, \"vu-%s-\" UID_FMT, machine, (uid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        pwd->pw_name = buffer;\n        pwd->pw_uid = uid;\n        pwd->pw_gid = 65534; \n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; \n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(gr);\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        if (e - p > HOST_NAME_MAX - 1)  \n                goto not_found;\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getgrgid_r(\n                gid_t gid,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n        if (!gid_is_valid(gid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n        if (gid < 0x10000)\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineGroup\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n        if (buflen < sizeof(char*) + 1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        if (snprintf(buffer + sizeof(char*), buflen - sizeof(char*), \"vg-%s-\" GID_FMT, machine, (gid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_2266.c",
        "project": "keszybz/systemd",
        "url": "https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```\t\t     gfp_t gfp_flags)\n\tstruct nfs4_ff_layout_segment *fls = NULL;\n\tdprintk(\"--> %s\\n\", __func__);\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn ERR_PTR(-ENOMEM);\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages,\n\t\t\t      lgr->layoutp->len);\n\txdr_set_scratch_page(&stream, scratch);\n\tp = xdr_inline_decode(&stream, 8 + 4);\n\tif (!p)\n\t\tgoto out_err_free;\n\tp = xdr_decode_hyper(p, &stripe_unit);\n\tmirror_array_cnt = be32_to_cpup(p++);\n\tdprintk(\"%s: stripe_unit=%llu mirror_array_cnt=%u\\n\", __func__,\n\t\tstripe_unit, mirror_array_cnt);\n\tif (mirror_array_cnt > NFS4_FLEXFILE_LAYOUT_MAX_MIRROR_CNT ||\n\t    mirror_array_cnt == 0)\n\tfls = kzalloc(struct_size(fls, mirror_array, mirror_array_cnt),\n\t\t\tgfp_flags);\n\tif (!fls)\n\t\tgoto out_err_free;\n\tfls->mirror_array_cnt = mirror_array_cnt;\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/sunrpc/metrics.h>\n#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../nfs4idmap.h\"\n#include \"../internal.h\"\n#include \"../delegation.h\"\n#include \"../nfs4trace.h\"\n#include \"../iostat.h\"\n#include \"../nfs.h\"\n#include \"../nfs42.h\"\n#define NFSDBG_FACILITY         NFSDBG_PNFS_LD\n#define FF_LAYOUT_POLL_RETRY_MAX     (15*HZ)\n#define FF_LAYOUTRETURN_MAXERR 20\nstatic unsigned short io_maxretrans;\nstatic const struct pnfs_commit_ops ff_layout_commit_ops;\nstatic void ff_layout_read_record_layoutstats_done(struct rpc_task *task,\n\t\tstruct nfs_pgio_header *hdr);\nstatic int ff_layout_mirror_prepare_stats(struct pnfs_layout_hdr *lo,\n\t\t\t       struct nfs42_layoutstat_devinfo *devinfo,\n\t\t\t       int dev_limit);\nstatic void ff_layout_encode_ff_layoutupdate(struct xdr_stream *xdr,\n\t\t\t      const struct nfs42_layoutstat_devinfo *devinfo,\n\t\t\t      struct nfs4_ff_layout_mirror *mirror);\nstatic int decode_nfs_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tfh->size = be32_to_cpup(p++);\n\tif (fh->size > NFS_MAXFHSIZE) {\n\t\tprintk(KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\",\n\t\t       fh->size);\n\t\treturn -EOVERFLOW;\n\t}\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(&fh->data, p, fh->size);\n\tdprintk(\"%s: fh len %d\\n\", __func__, fh->size);\n\treturn 0;\n}\nstatic struct pnfs_layout_segment *\nff_layout_alloc_lseg(struct pnfs_layout_hdr *lh,\n\t\t     struct nfs4_layoutget_res *lgr,\n\t\t     gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_segment *ret;\n\tstruct nfs4_ff_layout_segment *fls = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tu64 stripe_unit;\n\tu32 mirror_array_cnt;\n\t__be32 *p;\n\tint i, rc;\n\tdprintk(\"--> %s\\n\", __func__);\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn ERR_PTR(-ENOMEM);\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages,\n\t\t\t      lgr->layoutp->len);\n\txdr_set_scratch_page(&stream, scratch);\n\trc = -EIO;\n\tp = xdr_inline_decode(&stream, 8 + 4);\n\tif (!p)\n\t\tgoto out_err_free;\n\tp = xdr_decode_hyper(p, &stripe_unit);\n\tmirror_array_cnt = be32_to_cpup(p++);\n\tdprintk(\"%s: stripe_unit=%llu mirror_array_cnt=%u\\n\", __func__,\n\t\tstripe_unit, mirror_array_cnt);\n\tif (mirror_array_cnt > NFS4_FLEXFILE_LAYOUT_MAX_MIRROR_CNT ||\n\t    mirror_array_cnt == 0)\n\t\tgoto out_err_free;\n\trc = -ENOMEM;\n\tfls = kzalloc(struct_size(fls, mirror_array, mirror_array_cnt),\n\t\t\tgfp_flags);\n\tif (!fls)\n\t\tgoto out_err_free;\n\tfls->mirror_array_cnt = mirror_array_cnt;\n\tfls->stripe_unit = stripe_unit;\n\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\tstruct nfs4_ff_layout_mirror *mirror;\n\t\tstruct cred *kcred;\n\t\tconst struct cred __rcu *cred;\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t\tu32 ds_count, fh_count, id;\n\t\tint j;\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tds_count = be32_to_cpup(p);\n\t\tif (ds_count != 1)\n\t\t\tgoto out_err_free;\n\t\tfls->mirror_array[i] = ff_layout_alloc_mirror(gfp_flags);\n\t\tif (fls->mirror_array[i] == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\t\tfls->mirror_array[i]->ds_count = ds_count;\n\t\trc = decode_deviceid(&stream, &fls->mirror_array[i]->devid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfls->mirror_array[i]->efficiency = be32_to_cpup(p);\n\t\trc = decode_pnfs_stateid(&stream, &fls->mirror_array[i]->stateid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfh_count = be32_to_cpup(p);\n\t\tfls->mirror_array[i]->fh_versions =\n\t\t\tkcalloc(fh_count, sizeof(struct nfs_fh),\n\t\t\t\tgfp_flags);\n\t\tif (fls->mirror_array[i]->fh_versions == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\t\tfor (j = 0; j < fh_count; j++) {\n\t\t\trc = decode_nfs_fh(&stream,\n\t\t\t\t\t   &fls->mirror_array[i]->fh_versions[j]);\n\t\t\tif (rc)\n\t\t\t\tgoto out_err_free;\n\t\t}\n\t\tfls->mirror_array[i]->fh_versions_cnt = fh_count;\n\t\trc = decode_name(&stream, &id);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\trc = decode_name(&stream, &id);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gfp_flags & __GFP_FS)\n\t\t\tkcred = prepare_kernel_cred(NULL);\n\t\telse {\n\t\t\tunsigned int nofs_flags = memalloc_nofs_save();\n\t\t\tkcred = prepare_kernel_cred(NULL);\n\t\t\tmemalloc_nofs_restore(nofs_flags);\n\t\t}\n\t\trc = -ENOMEM;\n\t\tif (!kcred)\n\t\t\tgoto out_err_free;\n\t\tkcred->fsuid = uid;\n\t\tkcred->fsgid = gid;\n\t\tcred = RCU_INITIALIZER(kcred);\n\t\tif (lgr->range.iomode == IOMODE_READ)\n\t\t\trcu_assign_pointer(fls->mirror_array[i]->ro_cred, cred);\n\t\telse\n\t\t\trcu_assign_pointer(fls->mirror_array[i]->rw_cred, cred);\n\t\tmirror = ff_layout_add_mirror(lh, fls->mirror_array[i]);\n\t\tif (mirror != fls->mirror_array[i]) {\n\t\t\tif (lgr->range.iomode == IOMODE_READ) {\n\t\t\t\tcred = xchg(&mirror->ro_cred, cred);\n\t\t\t\trcu_assign_pointer(fls->mirror_array[i]->ro_cred, cred);\n\t\t\t} else {\n\t\t\t\tcred = xchg(&mirror->rw_cred, cred);\n\t\t\t\trcu_assign_pointer(fls->mirror_array[i]->rw_cred, cred);\n\t\t\t}\n\t\t\tff_layout_free_mirror(fls->mirror_array[i]);\n\t\t\tfls->mirror_array[i] = mirror;\n\t\t}\n\t\tdprintk(\"%s: iomode %s uid %u gid %u\\n\", __func__,\n\t\t\tlgr->range.iomode == IOMODE_READ ? \"READ\" : \"RW\",\n\t\t\tfrom_kuid(&init_user_ns, uid),\n\t\t\tfrom_kgid(&init_user_ns, gid));\n\t}\n\tp = xdr_inline_decode(&stream, 4);\n\tif (!p)\n\t\tgoto out_sort_mirrors;\n\tfls->flags = be32_to_cpup(p);\n\tp = xdr_inline_decode(&stream, 4);\n\tif (!p)\n\t\tgoto out_sort_mirrors;\n\tfor (i=0; i < fls->mirror_array_cnt; i++)\n\t\tfls->mirror_array[i]->report_interval = be32_to_cpup(p);\nout_sort_mirrors:\n\tff_layout_sort_mirrors(fls);\n\tret = &fls->generic_hdr;\n\tdprintk(\"<-- %s (success)\\n\", __func__);\nout_free_page:\n\t__free_page(scratch);\n\treturn ret;\nout_err_free:\n\t_ff_layout_free_lseg(fls);\n\tret = ERR_PTR(rc);\n\tdprintk(\"<-- %s (%d)\\n\", __func__, rc);\n\tgoto out_free_page;\n}\nstatic void\nff_layout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_pnfs_ds *ds;\n\tu32 ds_idx;\nretry:\n\tff_layout_pg_check_layout(pgio, req);\n\tif (!pgio->pg_lseg) {\n\t\tff_layout_pg_get_read(pgio, req, false);\n\t\tif (!pgio->pg_lseg)\n\t\t\tgoto out_nolseg;\n\t}\n\tif (ff_layout_avoid_read_on_rw(pgio->pg_lseg)) {\n\t\tff_layout_pg_get_read(pgio, req, true);\n\t\tif (!pgio->pg_lseg)\n\t\t\tgoto out_nolseg;\n\t}\n\tds = ff_layout_get_ds_for_read(pgio, &ds_idx);\n\tif (!ds) {\n\t\tif (!ff_layout_no_fallback_to_mds(pgio->pg_lseg))\n\t\t\tgoto out_mds;\n\t\tpnfs_generic_pg_cleanup(pgio);\n\t\tssleep(1);\n\t\tgoto retry;\n\t}\n\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, ds_idx);\n\tpgm = &pgio->pg_mirrors[0];\n\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].rsize;\n\tpgio->pg_mirror_idx = ds_idx;\n\tif (NFS_SERVER(pgio->pg_inode)->flags &\n\t\t\t(NFS_MOUNT_SOFT|NFS_MOUNT_SOFTERR))\n\t\tpgio->pg_maxretrans = io_maxretrans;\n\treturn;\nout_nolseg:\n\tif (pgio->pg_error < 0)\n\t\treturn;\nout_mds:\n\ttrace_pnfs_mds_fallback_pg_init_read(pgio->pg_inode,\n\t\t\t0, NFS4_MAX_UINT64, IOMODE_READ,\n\t\t\tNFS_I(pgio->pg_inode)->layout,\n\t\t\tpgio->pg_lseg);\n\tpgio->pg_maxretrans = 0;\n\tnfs_pageio_reset_read_mds(pgio);\n}\nstatic void\nff_layout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs4_pnfs_ds *ds;\n\tu32 i;\nretry:\n\tff_layout_pg_check_layout(pgio, req);\n\tif (!pgio->pg_lseg) {\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   nfs_req_openctx(req),\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   req->wb_bytes,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   false,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\tif (IS_ERR(pgio->pg_lseg)) {\n\t\t\tpgio->pg_error = PTR_ERR(pgio->pg_lseg);\n\t\t\tpgio->pg_lseg = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\tif (pgio->pg_mirror_count != FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg))\n\t\tgoto out_eagain;\n\tfor (i = 0; i < pgio->pg_mirror_count; i++) {\n\t\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, i);\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, mirror, true);\n\t\tif (!ds) {\n\t\t\tif (!ff_layout_no_fallback_to_mds(pgio->pg_lseg))\n\t\t\t\tgoto out_mds;\n\t\t\tpnfs_generic_pg_cleanup(pgio);\n\t\t\tssleep(1);\n\t\t\tgoto retry;\n\t\t}\n\t\tpgm = &pgio->pg_mirrors[i];\n\t\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].wsize;\n\t}\n\tif (NFS_SERVER(pgio->pg_inode)->flags &\n\t\t\t(NFS_MOUNT_SOFT|NFS_MOUNT_SOFTERR))\n\t\tpgio->pg_maxretrans = io_maxretrans;\n\treturn;\nout_eagain:\n\tpnfs_generic_pg_cleanup(pgio);\n\tpgio->pg_error = -EAGAIN;\n\treturn;\nout_mds:\n\ttrace_pnfs_mds_fallback_pg_init_write(pgio->pg_inode,\n\t\t\t0, NFS4_MAX_UINT64, IOMODE_RW,\n\t\t\tNFS_I(pgio->pg_inode)->layout,\n\t\t\tpgio->pg_lseg);\n\tpgio->pg_maxretrans = 0;\n\tnfs_pageio_reset_write_mds(pgio);\n\tpgio->pg_error = -EAGAIN;\n}\nstatic const struct nfs_pageio_ops ff_layout_pg_read_ops = {\n\t.pg_init = ff_layout_pg_init_read,\n\t.pg_test = pnfs_generic_pg_test,\n\t.pg_doio = pnfs_generic_pg_readpages,\n\t.pg_cleanup = pnfs_generic_pg_cleanup,\n};\nstatic const struct nfs_pageio_ops ff_layout_pg_write_ops = {\n\t.pg_init = ff_layout_pg_init_write,\n\t.pg_test = pnfs_generic_pg_test,\n\t.pg_doio = pnfs_generic_pg_writepages,\n\t.pg_get_mirror_count = ff_layout_pg_get_mirror_count_write,\n\t.pg_cleanup = pnfs_generic_pg_cleanup,\n\t.pg_get_mirror = ff_layout_pg_get_mirror_write,\n\t.pg_set_mirror = ff_layout_pg_set_mirror_write,\n};\nstatic void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\t\thdr->completion_ops->reschedule_io(hdr);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\t\ttrace_pnfs_mds_fallback_write_done(hdr->inode,\n\t\t\t\thdr->args.offset, hdr->args.count,\n\t\t\t\tIOMODE_RW, NFS_I(hdr->inode)->layout,\n\t\t\t\thdr->lseg);\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}\nstatic int ff_layout_async_handle_error_v4(struct rpc_task *task,\n\t\t\t\t\t   struct nfs4_state *state,\n\t\t\t\t\t   struct nfs_client *clp,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   u32 idx)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           \n\tcase -EBADHANDLE:       \n\tcase -EISDIR:           \n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_delete_deviceid(devid->ld, devid->nfs_client,\n\t\t\t\t&devid->deviceid);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tfallthrough;\n\tdefault:\n\t\tif (ff_layout_avoid_mds_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\n}\nstatic void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tu32 idx, u64 offset, u64 length,\n\t\t\t\t\tu32 *op_status, int opnum, int error)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tu32 status = *op_status;\n\tint err;\n\tif (status == 0) {\n\t\tswitch (error) {\n\t\tcase -ETIMEDOUT:\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\tcase -EOPNOTSUPP:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ECONNRESET:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ENETUNREACH:\n\t\tcase -EADDRINUSE:\n\t\tcase -ENOBUFS:\n\t\tcase -EPIPE:\n\t\tcase -EPERM:\n\t\t\t*op_status = status = NFS4ERR_NXIO;\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\t\t*op_status = status = NFS4ERR_ACCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tswitch (status) {\n\tcase NFS4ERR_DELAY:\n\tcase NFS4ERR_GRACE:\n\t\tbreak;\n\tcase NFS4ERR_NXIO:\n\t\tff_layout_mark_ds_unreachable(lseg, idx);\n\t\tif (opnum == OP_READ)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tpnfs_error_mark_layout_for_return(lseg->pls_layout->plh_inode,\n\t\t\t\t\t\t  lseg);\n\t}\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}\nstatic int ff_layout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tloff_t end_offs = 0;\n\tint err;\n\tif (task->tk_status < 0) {\n\t\tff_layout_io_track_ds_error(hdr->lseg, hdr->pgio_mirror_idx,\n\t\t\t\t\t    hdr->args.offset, hdr->args.count,\n\t\t\t\t\t    &hdr->res.op_status, OP_WRITE,\n\t\t\t\t\t    task->tk_status);\n\t\ttrace_ff_layout_write_error(hdr);\n\t}\n\terr = ff_layout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t   hdr->ds_clp, hdr->lseg,\n\t\t\t\t\t   hdr->pgio_mirror_idx);\n\ttrace_nfs4_pnfs_write(hdr, err);\n\tclear_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags);\n\tclear_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags);\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\t\tset_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags);\n\t\treturn task->tk_status;\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tset_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\treturn -EAGAIN;\n\t}\n\tif (hdr->res.verf->committed == NFS_FILE_SYNC ||\n\t    hdr->res.verf->committed == NFS_DATA_SYNC)\n\t\tend_offs = hdr->mds_offset + (loff_t)hdr->res.count;\n\tff_layout_set_layoutcommit(hdr->inode, hdr->lseg, end_offs);\n\thdr->fattr.valid = 0;\n\tif (task->tk_status >= 0)\n\t\tnfs_writeback_update_inode(hdr);\n\treturn 0;\n}\nstatic const struct rpc_call_ops ff_layout_read_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v3,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = ff_layout_read_release,\n};\nstatic const struct rpc_call_ops ff_layout_read_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v4,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = ff_layout_read_release,\n};\nstatic const struct rpc_call_ops ff_layout_write_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v3,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = ff_layout_write_release,\n};\nstatic const struct rpc_call_ops ff_layout_write_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v4,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = ff_layout_write_release,\n};\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v3,\n\t.rpc_call_done = ff_layout_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = ff_layout_commit_release,\n};\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v4,\n\t.rpc_call_done = ff_layout_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = ff_layout_commit_release,\n};\nstatic enum pnfs_try_status\nff_layout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tconst struct cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tu32 idx = hdr->pgio_mirror_idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\tdprintk(\"--> %s ino %lu pgbase %u req %zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\tds = nfs4_ff_layout_prepare_ds(lseg, mirror, false);\n\tif (!ds)\n\t\tgoto out_failed;\n\tds_clnt = nfs4_ff_find_or_create_ds_client(mirror, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_failed;\n\tds_cred = ff_layout_get_ds_cred(mirror, &lseg->pls_range, hdr->cred);\n\tif (!ds_cred)\n\t\tgoto out_failed;\n\tvers = nfs4_ff_layout_ds_version(mirror);\n\tdprintk(\"%s USE DS: %s cl_count %d vers %d\\n\", __func__,\n\t\tds->ds_remotestr, refcount_read(&ds->ds_clp->cl_count), vers);\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\trefcount_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\tfh = nfs4_ff_layout_select_ds_fh(mirror);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\tnfs4_ff_layout_select_ds_stateid(mirror, &hdr->args.stateid);\n\thdr->args.offset = offset;\n\thdr->mds_offset = offset;\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_read_call_ops_v3 :\n\t\t\t\t      &ff_layout_read_call_ops_v4,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\tput_cred(ds_cred);\n\treturn PNFS_ATTEMPTED;\nout_failed:\n\tif (ff_layout_avoid_mds_available_ds(lseg))\n\t\treturn PNFS_TRY_AGAIN;\n\ttrace_pnfs_mds_fallback_read_pagelist(hdr->inode,\n\t\t\thdr->args.offset, hdr->args.count,\n\t\t\tIOMODE_READ, NFS_I(hdr->inode)->layout, lseg);\n\treturn PNFS_NOT_ATTEMPTED;\n}\nstatic enum pnfs_try_status\nff_layout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tconst struct cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tint vers;\n\tstruct nfs_fh *fh;\n\tu32 idx = hdr->pgio_mirror_idx;\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\tds = nfs4_ff_layout_prepare_ds(lseg, mirror, true);\n\tif (!ds)\n\t\tgoto out_failed;\n\tds_clnt = nfs4_ff_find_or_create_ds_client(mirror, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_failed;\n\tds_cred = ff_layout_get_ds_cred(mirror, &lseg->pls_range, hdr->cred);\n\tif (!ds_cred)\n\t\tgoto out_failed;\n\tvers = nfs4_ff_layout_ds_version(mirror);\n\tdprintk(\"%s ino %lu sync %d req %zu@%llu DS: %s cl_count %d vers %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, refcount_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\thdr->pgio_done_cb = ff_layout_write_done_cb;\n\trefcount_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_ff_layout_select_ds_fh(mirror);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\tnfs4_ff_layout_select_ds_stateid(mirror, &hdr->args.stateid);\n\thdr->args.offset = offset;\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_write_call_ops_v3 :\n\t\t\t\t      &ff_layout_write_call_ops_v4,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\tput_cred(ds_cred);\n\treturn PNFS_ATTEMPTED;\nout_failed:\n\tif (ff_layout_avoid_mds_available_ds(lseg))\n\t\treturn PNFS_TRY_AGAIN;\n\ttrace_pnfs_mds_fallback_write_pagelist(hdr->inode,\n\t\t\thdr->args.offset, hdr->args.count,\n\t\t\tIOMODE_RW, NFS_I(hdr->inode)->layout, lseg);\n\treturn PNFS_NOT_ATTEMPTED;\n}\nstatic int ff_layout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tconst struct cred *ds_cred;\n\tu32 idx;\n\tint vers, ret;\n\tstruct nfs_fh *fh;\n\tif (!lseg || !(pnfs_is_valid_lseg(lseg) ||\n\t    test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags)))\n\t\tgoto out_err;\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\tds = nfs4_ff_layout_prepare_ds(lseg, mirror, true);\n\tif (!ds)\n\t\tgoto out_err;\n\tds_clnt = nfs4_ff_find_or_create_ds_client(mirror, ds->ds_clp,\n\t\t\t\t\t\t   data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\tds_cred = ff_layout_get_ds_cred(mirror, &lseg->pls_range, data->cred);\n\tif (!ds_cred)\n\t\tgoto out_err;\n\tvers = nfs4_ff_layout_ds_version(mirror);\n\tdprintk(\"%s ino %lu, how %d cl_count %d vers %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, refcount_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\tdata->commit_done_cb = ff_layout_commit_done_cb;\n\tdata->cred = ds_cred;\n\trefcount_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\tret = nfs_initiate_commit(ds_clnt, data, ds->ds_clp->rpc_ops,\n\t\t\t\t   vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4,\n\t\t\t\t   how, RPC_TASK_SOFTCONN);\n\tput_cred(ds_cred);\n\treturn ret;\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}\nstatic const struct nfs4_xdr_opaque_ops layoutreturn_ops = {\n\t.encode = ff_layout_encode_layoutreturn,\n\t.free = ff_layout_free_layoutreturn,\n};\n#ifdef CONFIG_NFS_V4_2\nvoid\nff_layout_send_layouterror(struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct nfs42_layout_error *errors;\n\tLIST_HEAD(head);\n\tif (!nfs_server_capable(lo->plh_inode, NFS_CAP_LAYOUTERROR))\n\t\treturn;\n\tff_layout_fetch_ds_ioerr(lo, &lseg->pls_range, &head, -1);\n\tif (list_empty(&head))\n\t\treturn;\n\terrors = kmalloc_array(NFS42_LAYOUTERROR_MAX,\n\t\t\tsizeof(*errors), GFP_NOFS);\n\tif (errors != NULL) {\n\t\tconst struct nfs4_ff_layout_ds_err *pos;\n\t\tsize_t n = 0;\n\t\tlist_for_each_entry(pos, &head, list) {\n\t\t\terrors[n].offset = pos->offset;\n\t\t\terrors[n].length = pos->length;\n\t\t\tnfs4_stateid_copy(&errors[n].stateid, &pos->stateid);\n\t\t\terrors[n].errors[0].dev_id = pos->deviceid;\n\t\t\terrors[n].errors[0].status = pos->status;\n\t\t\terrors[n].errors[0].opnum = pos->opnum;\n\t\t\tn++;\n\t\t\tif (!list_is_last(&pos->list, &head) &&\n\t\t\t    n < NFS42_LAYOUTERROR_MAX)\n\t\t\t\tcontinue;\n\t\t\tif (nfs42_proc_layouterror(lseg, errors, n) < 0)\n\t\t\t\tbreak;\n\t\t\tn = 0;\n\t\t}\n\t\tkfree(errors);\n\t}\n\tff_layout_free_ds_ioerr(&head);\n}\n#else\n#endif\nstatic void\nff_layout_encode_ff_layoutupdate(struct xdr_stream *xdr,\n\t\t\t      const struct nfs42_layoutstat_devinfo *devinfo,\n\t\t\t      struct nfs4_ff_layout_mirror *mirror)\n{\n\tstruct nfs4_pnfs_ds_addr *da;\n\tstruct nfs4_pnfs_ds *ds = mirror->mirror_ds->ds;\n\tstruct nfs_fh *fh = &mirror->fh_versions[0];\n\t__be32 *p;\n\tda = list_first_entry(&ds->ds_addrs, struct nfs4_pnfs_ds_addr, da_node);\n\tdprintk(\"%s: DS %s: encoding address %s\\n\",\n\t\t__func__, ds->ds_remotestr, da->da_remotestr);\n\tff_layout_encode_netaddr(xdr, da);\n\tp = xdr_reserve_space(xdr, 4 + fh->size);\n\txdr_encode_opaque(p, fh->data, fh->size);\n\tspin_lock(&mirror->lock);\n\tff_layout_encode_io_latency(xdr, &mirror->read_stat.io_stat);\n\tff_layout_encode_io_latency(xdr, &mirror->write_stat.io_stat);\n\tspin_unlock(&mirror->lock);\n\tff_layout_encode_nfstime(xdr, ktime_sub(ktime_get(), mirror->start_time));\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(false);\n}\nstatic const struct nfs4_xdr_opaque_ops layoutstat_ops = {\n\t.encode = ff_layout_encode_layoutstats,\n\t.free\t= ff_layout_free_layoutstats,\n};\nstatic int\nff_layout_mirror_prepare_stats(struct pnfs_layout_hdr *lo,\n\t\t\t       struct nfs42_layoutstat_devinfo *devinfo,\n\t\t\t       int dev_limit)\n{\n\tstruct nfs4_flexfile_layout *ff_layout = FF_LAYOUT_FROM_HDR(lo);\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *dev;\n\tint i = 0;\n\tlist_for_each_entry(mirror, &ff_layout->mirrors, mirrors) {\n\t\tif (i >= dev_limit)\n\t\t\tbreak;\n\t\tif (IS_ERR_OR_NULL(mirror->mirror_ds))\n\t\t\tcontinue;\n\t\tif (!test_and_clear_bit(NFS4_FF_MIRROR_STAT_AVAIL, &mirror->flags))\n\t\t\tcontinue;\n\t\tif (!refcount_inc_not_zero(&mirror->ref))\n\t\t\tcontinue;\n\t\tdev = &mirror->mirror_ds->id_node; \n\t\tmemcpy(&devinfo->dev_id, &dev->deviceid, NFS4_DEVICEID4_SIZE);\n\t\tdevinfo->offset = 0;\n\t\tdevinfo->length = NFS4_MAX_UINT64;\n\t\tspin_lock(&mirror->lock);\n\t\tdevinfo->read_count = mirror->read_stat.io_stat.ops_completed;\n\t\tdevinfo->read_bytes = mirror->read_stat.io_stat.bytes_completed;\n\t\tdevinfo->write_count = mirror->write_stat.io_stat.ops_completed;\n\t\tdevinfo->write_bytes = mirror->write_stat.io_stat.bytes_completed;\n\t\tspin_unlock(&mirror->lock);\n\t\tdevinfo->layout_type = LAYOUT_FLEX_FILES;\n\t\tdevinfo->ld_private.ops = &layoutstat_ops;\n\t\tdevinfo->ld_private.data = mirror;\n\t\tdevinfo++;\n\t\ti++;\n\t}\n\treturn i;\n}\nstatic const struct pnfs_commit_ops ff_layout_commit_ops = {\n\t.setup_ds_info\t\t= ff_layout_setup_ds_info,\n\t.release_ds_info\t= ff_layout_release_ds_info,\n\t.mark_request_commit\t= pnfs_layout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.commit_pagelist\t= ff_layout_commit_pagelist,\n};\nstatic struct pnfs_layoutdriver_type flexfilelayout_type = {\n\t.id\t\t\t= LAYOUT_FLEX_FILES,\n\t.name\t\t\t= \"LAYOUT_FLEX_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.flags\t\t\t= PNFS_LAYOUTGET_ON_OPEN,\n\t.max_layoutget_response\t= 4096, \n\t.set_layoutdriver\t= ff_layout_set_layoutdriver,\n\t.alloc_layout_hdr\t= ff_layout_alloc_layout_hdr,\n\t.free_layout_hdr\t= ff_layout_free_layout_hdr,\n\t.alloc_lseg\t\t= ff_layout_alloc_lseg,\n\t.free_lseg\t\t= ff_layout_free_lseg,\n\t.add_lseg\t\t= ff_layout_add_lseg,\n\t.pg_read_ops\t\t= &ff_layout_pg_read_ops,\n\t.pg_write_ops\t\t= &ff_layout_pg_write_ops,\n\t.get_ds_info\t\t= ff_layout_get_ds_info,\n\t.free_deviceid_node\t= ff_layout_free_deviceid_node,\n\t.read_pagelist\t\t= ff_layout_read_pagelist,\n\t.write_pagelist\t\t= ff_layout_write_pagelist,\n\t.alloc_deviceid_node    = ff_layout_alloc_deviceid_node,\n\t.prepare_layoutreturn   = ff_layout_prepare_layoutreturn,\n\t.sync\t\t\t= pnfs_nfs_generic_sync,\n\t.prepare_layoutstats\t= ff_layout_prepare_layoutstats,\n};\nstatic int __init nfs4flexfilelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&flexfilelayout_type);\n}\nstatic void __exit nfs4flexfilelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&flexfilelayout_type);\n}\nMODULE_ALIAS(\"nfs-layouttype4-4\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"The NFSv4 flexfile layout driver\");\nmodule_param(io_maxretrans, ushort, 0644);\nMODULE_PARM_DESC(io_maxretrans, \"The  number of times the NFSv4.1 client \"\n\t\t\t\"retries an I/O request before returning an error. \");\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_7601.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/ed34695e15aba74f45247f1ee2cf7e09d449f925",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```         char **argv)\n    dirout = argv[2];\n    rootname = argv[3];\n    pixHtmlViewer(dirin, dirout, rootname, thumbwidth, viewwidth);\n              const char  *dirout,\n              const char  *rootname,\n    if (!dirin)\n        return ERROR_INT(\"dirin not defined\", procName, 1);\n    if (!dirout)\n        return ERROR_INT(\"dirout not defined\", procName, 1);\n    if (!rootname)\n        return ERROR_INT(\"rootname not defined\", procName, 1);\n    snprintf(charbuf, sizeof(charbuf), \"mkdir -p %s\", dirout);\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s.html\", dirout, rootname);\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s-links.html\", dirout, rootname);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n * htmlviewer.c\n *\n *    This takes a directory of image files, optionally scales them,\n *    and generates html files to view the scaled images (and thumbnails).\n *\n *    Input:  dirin:  directory of input image files\n *            dirout: directory for output files\n *            rootname: root name for output files\n *            thumbwidth: width of thumb images, in pixels; use 0 for default\n *            viewwidth: max width of view images, in pixels; use 0 for default\n *\n *    Example:\n *         mkdir /tmp/lept/lion-in\n *         mkdir /tmp/lept/lion-out\n *         cp lion-page* /tmp/lept/lion-in\n *         htmlviewer /tmp/lept/lion-in /tmp/lept/lion-out lion 200 600\n *        ==> output:\n *            /tmp/lept/lion-out/lion.html         (main html file)\n *            /tmp/lept/lion-out/lion-links.html   (html file of links)\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\n#ifdef _WIN32\n#include <windows.h>   /* for CreateDirectory() */\n#endif\n\nstatic const l_int32  DEFAULT_THUMB_WIDTH = 120;\nstatic const l_int32  DEFAULT_VIEW_WIDTH = 800;\nstatic const l_int32  MIN_THUMB_WIDTH = 50;\nstatic const l_int32  MIN_VIEW_WIDTH = 300;\n\nstatic l_int32 pixHtmlViewer(const char *dirin, const char *dirout,\n                             const char  *rootname, l_int32 thumbwidth,\n                             l_int32 viewwidth);\nstatic void WriteFormattedPix(char *fname, PIX *pix);\n\n\nint main(int    argc,\n         char **argv)\n{\nchar        *dirin, *dirout, *rootname;\nl_int32      thumbwidth, viewwidth;\nstatic char  mainName[] = \"htmlviewer\";\n\n    if (argc != 6)\n        return ERROR_INT(\n            \" Syntax:  htmlviewer dirin dirout rootname thumbwidth viewwidth\",\n             mainName, 1);\n\n    dirin = argv[1];\n    dirout = argv[2];\n    rootname = argv[3];\n    thumbwidth = atoi(argv[4]);\n    viewwidth = atoi(argv[5]);\n    pixHtmlViewer(dirin, dirout, rootname, thumbwidth, viewwidth);\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *            Generate smaller images for viewing and write html       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   pixHtmlViewer()\n *\n * \\param[in]    dirin      directory of input image files\n * \\param[in]    dirout     directory for output files\n * \\param[in]    rootname   root name for output files\n * \\param[in]    thumbwidth width of thumb images in pixels; use 0 for default\n * \\param[in]    viewwidth  maximum width of view images no up-scaling\n *                          in pixels; use 0 for default\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The thumb and view reduced images are generated,\n *          along with two html files:\n *             <rootname>.html and <rootname>-links.html\n *      (2) The thumb and view files are named\n *             <rootname>_thumb_xxx.jpg\n *             <rootname>_view_xxx.jpg\n *          With this naming scheme, any number of input directories\n *          of images can be processed into views and thumbs\n *          and placed in the same output directory.\n * </pre>\n */\nstatic l_int32\npixHtmlViewer(const char  *dirin,\n              const char  *dirout,\n              const char  *rootname,\n              l_int32      thumbwidth,\n              l_int32      viewwidth)\n{\nchar      *fname, *fullname, *outname;\nchar      *mainname, *linkname, *linknameshort;\nchar      *viewfile, *thumbfile;\nchar      *shtml, *slink;\nchar       charbuf[512];\nchar       htmlstring[] = \"<html>\";\nchar       framestring[] = \"</frameset></html>\";\nl_int32    i, nfiles, index, w, d, nimages, ret;\nl_float32  factor;\nPIX       *pix, *pixthumb, *pixview;\nSARRAY    *safiles, *sathumbs, *saviews, *sahtml, *salink;\n\n    PROCNAME(\"pixHtmlViewer\");\n\n    if (!dirin)\n        return ERROR_INT(\"dirin not defined\", procName, 1);\n    if (!dirout)\n        return ERROR_INT(\"dirout not defined\", procName, 1);\n    if (!rootname)\n        return ERROR_INT(\"rootname not defined\", procName, 1);\n\n    if (thumbwidth == 0)\n        thumbwidth = DEFAULT_THUMB_WIDTH;\n    if (thumbwidth < MIN_THUMB_WIDTH) {\n        L_WARNING(\"thumbwidth too small; using min value\\n\", procName);\n        thumbwidth = MIN_THUMB_WIDTH;\n    }\n    if (viewwidth == 0)\n        viewwidth = DEFAULT_VIEW_WIDTH;\n    if (viewwidth < MIN_VIEW_WIDTH) {\n        L_WARNING(\"viewwidth too small; using min value\\n\", procName);\n        viewwidth = MIN_VIEW_WIDTH;\n    }\n\n        /* Make the output directory if it doesn't already exist */\n#ifndef _WIN32\n    snprintf(charbuf, sizeof(charbuf), \"mkdir -p %s\", dirout);\n    ret = system(charbuf);\n#else\n    ret = CreateDirectory(dirout, NULL) ? 0 : 1;\n#endif  /* !_WIN32 */\n    if (ret) {\n        L_ERROR(\"output directory %s not made\\n\", procName, dirout);\n        return 1;\n    }\n\n        /* Capture the filenames in the input directory */\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        /* Generate output text file names */\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        /* Generate the thumbs and views */\n    sathumbs = sarrayCreate(0);\n    saviews = sarrayCreate(0);\n    nfiles = sarrayGetCount(safiles);\n    index = 0;\n    for (i = 0; i < nfiles; i++) {\n        fname = sarrayGetString(safiles, i, L_NOCOPY);\n        fullname = genPathname(dirin, fname);\n        fprintf(stderr, \"name: %s\\n\", fullname);\n        if ((pix = pixRead(fullname)) == NULL) {\n            fprintf(stderr, \"file %s not a readable image\\n\", fullname);\n            lept_free(fullname);\n            continue;\n        }\n        lept_free(fullname);\n\n            /* Make and store the thumbnail images */\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth / (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        snprintf(charbuf, sizeof(charbuf), \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);\n\n            /* Make and store the view images */\n        factor = (l_float32)viewwidth / (l_float32)w;\n        if (factor >= 1.0)\n            pixview = pixClone(pix);   /* no upscaling */\n        else\n            pixview = pixScale(pix, factor, factor);\n        snprintf(charbuf, sizeof(charbuf), \"%s_view_%03d\", rootname, index);\n        sarrayAddString(saviews, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixview);\n        lept_free(outname);\n        pixDestroy(&pixview);\n        pixDestroy(&pix);\n        index++;\n    }\n\n        /* Generate the main html file */\n    sahtml = sarrayCreate(0);\n    sarrayAddString(sahtml, htmlstring, L_COPY);\n    sprintf(charbuf, \"<frameset cols=\\\"%d, *\\\">\", thumbwidth + 30);\n    sarrayAddString(sahtml, charbuf, L_COPY);\n    sprintf(charbuf, \"<frame name=\\\"thumbs\\\" src=\\\"%s\\\">\", linknameshort);\n    sarrayAddString(sahtml, charbuf, L_COPY);\n    sprintf(charbuf, \"<frame name=\\\"views\\\" src=\\\"%s\\\">\",\n            sarrayGetString(saviews, 0, L_NOCOPY));\n    sarrayAddString(sahtml, charbuf, L_COPY);\n    sarrayAddString(sahtml, framestring, L_COPY);\n    shtml = sarrayToString(sahtml, 1);\n    l_binaryWrite(mainname, \"w\", shtml, strlen(shtml));\n    fprintf(stderr, \"******************************************\\n\"\n                    \"Writing html file: %s\\n\"\n                    \"******************************************\\n\", mainname);\n    lept_free(shtml);\n    lept_free(mainname);\n\n        /* Generate the link html file */\n    nimages = sarrayGetCount(saviews);\n    fprintf(stderr, \"num. images = %d\\n\", nimages);\n    salink = sarrayCreate(0);\n    for (i = 0; i < nimages; i++) {\n        viewfile = sarrayGetString(saviews, i, L_NOCOPY);\n        thumbfile = sarrayGetString(sathumbs, i, L_NOCOPY);\n        sprintf(charbuf, \"<a href=\\\"%s\\\" TARGET=views><img src=\\\"%s\\\"></a>\",\n            viewfile, thumbfile);\n        sarrayAddString(salink, charbuf, L_COPY);\n    }\n    slink = sarrayToString(salink, 1);\n    l_binaryWrite(linkname, \"w\", slink, strlen(slink));\n    lept_free(slink);\n    lept_free(linkname);\n    lept_free(linknameshort);\n    sarrayDestroy(&safiles);\n    sarrayDestroy(&sathumbs);\n    sarrayDestroy(&saviews);\n    sarrayDestroy(&sahtml);\n    sarrayDestroy(&salink);\n    return 0;\n}\n\nstatic void\nWriteFormattedPix(char  *fname,\n                  PIX   *pix)\n{\nl_int32  d;\n\n    d = pixGetDepth(pix);\n    if (d == 1 || pixGetColormap(pix))\n        pixWrite(fname, pix, IFF_PNG);\n    else\n        pixWrite(fname, pix, IFF_JFIF_JPEG);\n    return;\n}\n\n\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_9449.c",
        "project": "danbloomberg/leptonica",
        "url": "https://github.com/DanBloomberg/leptonica/commit/c1079bb8e77cdd426759e466729917ca37a3ed9f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static void dns_stream_stop(DnsStream *s) {\n}\nstatic int dns_stream_update_io(DnsStream *s) {\n}\nstatic int dns_stream_complete(DnsStream *s, int error) {\n}\nstatic int dns_stream_identify(DnsStream *s) {\n        struct msghdr mh = {};\n        assert(s);\n        s->local_salen = sizeof(s->local);\n        r = getsockname(s->fd, &s->local.sa, &s->local_salen);\n        if (r < 0)\n                return -errno;\n        if (s->local.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->local.in6.sin6_scope_id;\n        s->peer_salen = sizeof(s->peer);\n        r = getpeername(s->fd, &s->peer.sa, &s->peer_salen);\n        if (r < 0)\n                return -errno;\n        if (s->peer.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->peer.in6.sin6_scope_id;\n        assert(s->peer.sa.sa_family == s->local.sa.sa_family);\n        assert(IN_SET(s->peer.sa.sa_family, AF_INET, AF_INET6));\n        sl = sizeof(control);\n        if (s->peer.sa.sa_family == AF_INET) {\n                r = getsockopt(s->fd, IPPROTO_IP, IP_PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else if (s->peer.sa.sa_family == AF_INET6) {\n                r = getsockopt(s->fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, &control, &sl);\n        } else\n        mh.msg_control = &control;\n        mh.msg_controllen = sl;\n        CMSG_FOREACH(cmsg, &mh) {\n                if (cmsg->cmsg_level == IPPROTO_IPV6) {\n                                struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi6_ifindex;\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                } else if (cmsg->cmsg_level == IPPROTO_IP) {\n                        assert(s->peer.sa.sa_family == AF_INET);\n                                struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi_ifindex;\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                }\n        if (s->ifindex == LOOPBACK_IFINDEX)\n                s->ifindex = 0;\n        if (s->ifindex <= 0)\n                s->ifindex = manager_find_ifindex(s->manager, s->local.sa.sa_family, s->local.sa.sa_family == AF_INET ? (union in_addr_union*) &s->local.in.sin_addr : (union in_addr_union*)  &s->local.in6.sin6_addr);\n        if (s->protocol == DNS_PROTOCOL_LLMNR && s->ifindex > 0) {\n                uint32_t ifindex = htobe32(s->ifindex);\n                if (s->local.sa.sa_family == AF_INET) {\n                        r = setsockopt(s->fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex));\n                } else if (s->local.sa.sa_family == AF_INET6) {\n        }\n}\nssize_t dns_stream_writev(DnsStream *s, const struct iovec *iov, size_t iovcnt, int flags) {\n}\nstatic int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata) {\n}\nstatic int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); \n        assert(s);\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n        }\n}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <netinet/tcp.h>\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"io-util.h\"\n#include \"missing.h\"\n#include \"resolved-dns-stream.h\"\n#define DNS_STREAM_TIMEOUT_USEC (10 * USEC_PER_SEC)\n#define DNS_STREAMS_MAX 128\nstatic void dns_stream_stop(DnsStream *s) {\n        assert(s);\n        s->io_event_source = sd_event_source_unref(s->io_event_source);\n        s->timeout_event_source = sd_event_source_unref(s->timeout_event_source);\n        s->fd = safe_close(s->fd);\n}\nstatic int dns_stream_update_io(DnsStream *s) {\n        int f = 0;\n        assert(s);\n        if (s->write_packet && s->n_written < sizeof(s->write_size) + s->write_packet->size)\n                f |= EPOLLOUT;\n        else if (!ordered_set_isempty(s->write_queue)) {\n                dns_packet_unref(s->write_packet);\n                s->write_packet = ordered_set_steal_first(s->write_queue);\n                s->write_size = htobe16(s->write_packet->size);\n                s->n_written = 0;\n                f |= EPOLLOUT;\n        }\n        if (!s->read_packet || s->n_read < sizeof(s->read_size) + s->read_packet->size)\n                f |= EPOLLIN;\n#if ENABLE_DNS_OVER_TLS\n        if (s->dnstls_events)\n                f = s->dnstls_events;\n#endif\n        return sd_event_source_set_io_events(s->io_event_source, f);\n}\nstatic int dns_stream_complete(DnsStream *s, int error) {\n        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); \n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}\nstatic int dns_stream_identify(DnsStream *s) {\n        union {\n                struct cmsghdr header; \n                uint8_t buffer[CMSG_SPACE(MAXSIZE(struct in_pktinfo, struct in6_pktinfo))\n                               + EXTRA_CMSG_SPACE ];\n        } control;\n        struct msghdr mh = {};\n        struct cmsghdr *cmsg;\n        socklen_t sl;\n        int r;\n        assert(s);\n        if (s->identified)\n                return 0;\n        s->local_salen = sizeof(s->local);\n        r = getsockname(s->fd, &s->local.sa, &s->local_salen);\n        if (r < 0)\n                return -errno;\n        if (s->local.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->local.in6.sin6_scope_id;\n        s->peer_salen = sizeof(s->peer);\n        r = getpeername(s->fd, &s->peer.sa, &s->peer_salen);\n        if (r < 0)\n                return -errno;\n        if (s->peer.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->peer.in6.sin6_scope_id;\n        assert(s->peer.sa.sa_family == s->local.sa.sa_family);\n        assert(IN_SET(s->peer.sa.sa_family, AF_INET, AF_INET6));\n        sl = sizeof(control);\n        if (s->peer.sa.sa_family == AF_INET) {\n                r = getsockopt(s->fd, IPPROTO_IP, IP_PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else if (s->peer.sa.sa_family == AF_INET6) {\n                r = getsockopt(s->fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else\n                return -EAFNOSUPPORT;\n        mh.msg_control = &control;\n        mh.msg_controllen = sl;\n        CMSG_FOREACH(cmsg, &mh) {\n                if (cmsg->cmsg_level == IPPROTO_IPV6) {\n                        assert(s->peer.sa.sa_family == AF_INET6);\n                        switch (cmsg->cmsg_type) {\n                        case IPV6_PKTINFO: {\n                                struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi6_ifindex;\n                                break;\n                        }\n                        case IPV6_HOPLIMIT:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n                } else if (cmsg->cmsg_level == IPPROTO_IP) {\n                        assert(s->peer.sa.sa_family == AF_INET);\n                        switch (cmsg->cmsg_type) {\n                        case IP_PKTINFO: {\n                                struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi_ifindex;\n                                break;\n                        }\n                        case IP_TTL:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n                }\n        }\n        if (s->ifindex == LOOPBACK_IFINDEX)\n                s->ifindex = 0;\n        if (s->ifindex <= 0)\n                s->ifindex = manager_find_ifindex(s->manager, s->local.sa.sa_family, s->local.sa.sa_family == AF_INET ? (union in_addr_union*) &s->local.in.sin_addr : (union in_addr_union*)  &s->local.in6.sin6_addr);\n        if (s->protocol == DNS_PROTOCOL_LLMNR && s->ifindex > 0) {\n                uint32_t ifindex = htobe32(s->ifindex);\n                if (s->local.sa.sa_family == AF_INET) {\n                        r = setsockopt(s->fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IP_UNICAST_IF: %m\");\n                } else if (s->local.sa.sa_family == AF_INET6) {\n                        r = setsockopt(s->fd, IPPROTO_IPV6, IPV6_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IPV6_UNICAST_IF: %m\");\n                }\n        }\n        s->identified = true;\n        return 0;\n}\nssize_t dns_stream_writev(DnsStream *s, const struct iovec *iov, size_t iovcnt, int flags) {\n        ssize_t m;\n        assert(s);\n        assert(iov);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted && !(flags & DNS_STREAM_WRITE_TLS_DATA)) {\n                ssize_t ss;\n                size_t i;\n                m = 0;\n                for (i = 0; i < iovcnt; i++) {\n                        ss = dnstls_stream_write(s, iov[i].iov_base, iov[i].iov_len);\n                        if (ss < 0)\n                                return ss;\n                        m += ss;\n                        if (ss != (ssize_t) iov[i].iov_len)\n                                continue;\n                }\n        } else\n#endif\n        if (s->tfo_salen > 0) {\n                struct msghdr hdr = {\n                        .msg_iov = (struct iovec*) iov,\n                        .msg_iovlen = iovcnt,\n                        .msg_name = &s->tfo_address.sa,\n                        .msg_namelen = s->tfo_salen\n                };\n                m = sendmsg(s->fd, &hdr, MSG_FASTOPEN);\n                if (m < 0) {\n                        if (errno == EOPNOTSUPP) {\n                                s->tfo_salen = 0;\n                                if (connect(s->fd, &s->tfo_address.sa, s->tfo_salen) < 0)\n                                        return -errno;\n                                return -EAGAIN;\n                        }\n                        if (errno == EINPROGRESS)\n                                return -EAGAIN;\n                        return -errno;\n                } else\n                        s->tfo_salen = 0; \n        } else {\n                m = writev(s->fd, iov, iovcnt);\n                if (m < 0)\n                        return -errno;\n        }\n        return m;\n}\nstatic int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata) {\n        DnsStream *s = userdata;\n        assert(s);\n        return dns_stream_complete(s, ETIMEDOUT);\n}\nstatic int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); \n        int r;\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                r = dnstls_stream_on_io(s, revents);\n                if (r == DNSTLS_STREAM_CLOSED)\n                        return 0;\n                if (r == -EAGAIN)\n                        return dns_stream_update_io(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n                r = dns_stream_update_io(s);\n                if (r < 0)\n                        return r;\n        }\n#endif\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n        }\n        if ((revents & EPOLLOUT) &&\n            s->write_packet &&\n            s->n_written < sizeof(s->write_size) + s->write_packet->size) {\n                struct iovec iov[2];\n                ssize_t ss;\n                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));\n                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);\n                IOVEC_INCREMENT(iov, 2, s->n_written);\n                ss = dns_stream_writev(s, iov, 2, 0);\n                if (ss < 0) {\n                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                return dns_stream_complete(s, -ss);\n                } else\n                        s->n_written += ss;\n                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {\n                        r = dns_stream_update_io(s);\n                        if (r < 0)\n                                return dns_stream_complete(s, -r);\n                }\n        }\n        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&\n            (!s->read_packet ||\n             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {\n                if (s->n_read < sizeof(s->read_size)) {\n                        ssize_t ss;\n                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);\n                        if (ss < 0) {\n                                if (!IN_SET(-ss, EINTR, EAGAIN))\n                                        return dns_stream_complete(s, -ss);\n                        } else if (ss == 0)\n                                return dns_stream_complete(s, ECONNRESET);\n                        else\n                                s->n_read += ss;\n                }\n                if (s->n_read >= sizeof(s->read_size)) {\n                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)\n                                return dns_stream_complete(s, EBADMSG);\n                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {\n                                ssize_t ss;\n                                if (!s->read_packet) {\n                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);\n                                        if (r < 0)\n                                                return dns_stream_complete(s, -r);\n                                        s->read_packet->size = be16toh(s->read_size);\n                                        s->read_packet->ipproto = IPPROTO_TCP;\n                                        s->read_packet->family = s->peer.sa.sa_family;\n                                        s->read_packet->ttl = s->ttl;\n                                        s->read_packet->ifindex = s->ifindex;\n                                        if (s->read_packet->family == AF_INET) {\n                                                s->read_packet->sender.in = s->peer.in.sin_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);\n                                                s->read_packet->destination.in = s->local.in.sin_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);\n                                        } else {\n                                                assert(s->read_packet->family == AF_INET6);\n                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);\n                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;\n                                        }\n                                }\n                                ss = dns_stream_read(s,\n                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),\n                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);\n                                if (ss < 0) {\n                                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                                return dns_stream_complete(s, -ss);\n                                } else if (ss == 0)\n                                        return dns_stream_complete(s, ECONNRESET);\n                                else\n                                        s->n_read += ss;\n                        }\n                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {\n                                if (s->on_packet) {\n                                        r = s->on_packet(s);\n                                        if (r < 0)\n                                                return r;\n                                }\n                                r = dns_stream_update_io(s);\n                                if (r < 0)\n                                        return dns_stream_complete(s, -r);\n                        }\n                }\n        }\n        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&\n            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))\n                return dns_stream_complete(s, 0);\n        return 0;\n}\nint dns_stream_new(\n                Manager *m,\n                DnsStream **ret,\n                DnsProtocol protocol,\n                int fd,\n                const union sockaddr_union *tfo_address) {\n        _cleanup_(dns_stream_unrefp) DnsStream *s = NULL;\n        int r;\n        assert(m);\n        assert(ret);\n        assert(fd >= 0);\n        if (m->n_dns_streams > DNS_STREAMS_MAX)\n                return -EBUSY;\n        s = new(DnsStream, 1);\n        if (!s)\n                return -ENOMEM;\n        *s = (DnsStream) {\n                .n_ref = 1,\n                .fd = -1,\n                .protocol = protocol,\n        };\n        r = ordered_set_ensure_allocated(&s->write_queue, &dns_packet_hash_ops);\n        if (r < 0)\n                return r;\n        r = sd_event_add_io(m->event, &s->io_event_source, fd, EPOLLIN, on_stream_io, s);\n        if (r < 0)\n                return r;\n        (void) sd_event_source_set_description(s->io_event_source, \"dns-stream-io\");\n        r = sd_event_add_time(\n                        m->event,\n                        &s->timeout_event_source,\n                        clock_boottime_or_monotonic(),\n                        now(clock_boottime_or_monotonic()) + DNS_STREAM_TIMEOUT_USEC, 0,\n                        on_stream_timeout, s);\n        if (r < 0)\n                return r;\n        (void) sd_event_source_set_description(s->timeout_event_source, \"dns-stream-timeout\");\n        LIST_PREPEND(streams, m->dns_streams, s);\n        m->n_dns_streams++;\n        s->manager = m;\n        s->fd = fd;\n        if (tfo_address) {\n                s->tfo_address = *tfo_address;\n                s->tfo_salen = tfo_address->sa.sa_family == AF_INET6 ? sizeof(tfo_address->in6) : sizeof(tfo_address->in);\n        }\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_9095.c",
        "project": "systemd/systemd",
        "url": "https://github.com/systemd/systemd/commit/d973d94dec349fb676fdd844f6fe2ada3538f27c",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int usb_console_setup(struct console *co, char *options)\n\tint baud = 9600;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tstruct tty_struct *tty = NULL;\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\tif (baud == 0)\n\t\tbaud = 9600;\n\t\tcflag |= CS7;\n\t\tcflag |= CS8;\n\t\tcflag |= PARODD;\n\t\tcflag |= PARENB;\n\tco->cflag = cflag;\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t}\n\tserial = port->serial;\n\ttty_port_tty_set(&port->port, NULL);\n\tinfo->port = port;\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\t\tif (retval) {\n\t\t}\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t}\n\t}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\tif (baud == 0)\n\t\tbaud = 9600;\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\ttty_port_tty_set(&port->port, NULL);\n\tinfo->port = port;\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t--port->port.count;\n\tport->port.console = 1;\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\tif (count == 0)\n\t\treturn;\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_2568.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\t*out = NULL;\n\t*out_len = 0;\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t}\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t}\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t}\n\t\t\trec_len = rv;\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\t\t\toffs += rv + 2;\n\t\t}\n\t}\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tif (acl == NULL) {\n\t\t\t*out = NULL;\n\t\t}\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\t*out = NULL;\n\t\t}\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t}\n\t\t}\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t}\nsc_oberthur_parse_publicinfo (struct sc_pkcs15_card *p15card,\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii+5<=len; ii+=5)   {\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add public object(file-id:%04X,size:%X)\", file_id, size);\n\t\t\trv = sc_pkcs15emu_oberthur_add_pubkey(p15card, file_id, size);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse public key info\");\n\t\t\trv = sc_pkcs15emu_oberthur_add_cert(p15card, file_id);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse certificate info\");\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 0);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse data info\");\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Public object parse error\");\n\t}\nsc_oberthur_parse_privateinfo (struct sc_pkcs15_card *p15card,\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii+5<=len; ii+=5)   {\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add private object (file-id:%04X, size:%X)\", file_id, size);\n\t\t\trv = sc_pkcs15emu_oberthur_add_prvkey(p15card, file_id, size);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tsc_log(ctx, \"postpone adding of the private keys\");\n\t\t\t\tsc_format_path(\"5011A5A5\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_PRKDF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add PrkDF error\");\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private key info\");\n\t\t\tsc_log(ctx, \"*(buff+ii + 1):%X\", *(buff+ii + 1));\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 1);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tsc_log(ctx, \"postpone adding of the private data\");\n\t\t\t\tsc_format_path(\"5011A6A6\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_DODF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add DODF error\");\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private data info\");\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Private object parse error\");\n\t}\nsc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"public key(file-id:%04X,size:%X)\", file_id, size);\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\nsc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card, unsigned int file_id)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add certificate(file-id:%04X)\", file_id);\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &cinfo.path);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &cert_blob, &cert_len, 1);\nsc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *info_blob = NULL;\n\tsize_t info_len = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add private key(file-id:%04X,size:%04X)\", file_id, size);\n\tmemset(&ccont, 0, sizeof(ccont));\n\trv = sc_oberthur_get_friends (file_id, &ccont);\n\tif (ccont.id_cert)   {\n\t\tstruct sc_pkcs15_object *objs[32];\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_CERT_X509, objs, 32);\n\t}\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\nsc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size, int private)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(ctx, \"Add data(file-id:%04X,size:%i,is-private:%i)\", file_id, size, private);\n\tmemset(&dobj, 0, sizeof(dobj));\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'label'\");\n\tlabel = info_blob + offs + 2;\n\tlabel_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (label_len > sizeof(dobj.label) - 1)\n\t\tlabel_len = sizeof(dobj.label) - 1;\n\tmemcpy(dobj.label, label, label_len);\n\tif (oid_len)\n\t\tsc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tif (private)   {\n\t\tdobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)\n\t\t\t\t? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);\n\t}\n}\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tunsigned char sopin_reference = 0x04;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.tries_left\t\t= tries_left;\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t}\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"../common/compat_strlcpy.h\"\n#include \"pkcs15.h\"\n#include \"log.h\"\n#include \"asn1.h\"\n#include \"internal.h\"\n#ifdef ENABLE_OPENSSL\n#include <openssl/bio.h>\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#endif\n#define OBERTHUR_ATTR_MODIFIABLE\t0x0001\n#define OBERTHUR_ATTR_TRUSTED\t\t0x0002\n#define OBERTHUR_ATTR_LOCAL\t\t0x0004\n#define OBERTHUR_ATTR_ENCRYPT\t\t0x0008\n#define OBERTHUR_ATTR_DECRYPT\t\t0x0010\n#define OBERTHUR_ATTR_SIGN\t\t0x0020\n#define OBERTHUR_ATTR_VERIFY\t\t0x0040\n#define OBERTHUR_ATTR_RSIGN\t\t0x0080\n#define OBERTHUR_ATTR_RVERIFY\t\t0x0100\n#define OBERTHUR_ATTR_WRAP\t\t0x0200\n#define OBERTHUR_ATTR_UNWRAP\t\t0x0400\n#define OBERTHUR_ATTR_DERIVE\t\t0x0800\n#define USAGE_PRV_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT |\\\n\t\t\t SC_PKCS15_PRKEY_USAGE_WRAP | SC_PKCS15_PRKEY_USAGE_UNWRAP)\n#define USAGE_PRV_AUT\t SC_PKCS15_PRKEY_USAGE_SIGN\n#define USAGE_PRV_SIGN\t(SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_NONREPUDIATION)\n#define USAGE_PUB_ENC\t(SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_WRAP)\n#define USAGE_PUB_AUT\t SC_PKCS15_PRKEY_USAGE_VERIFY\n#define USAGE_PUB_SIGN\t(SC_PKCS15_PRKEY_USAGE_VERIFY | SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER)\n#define PIN_DOMAIN_LABEL\t\"SCM\"\nconst unsigned char PinDomainID[3] = {0x53, 0x43, 0x4D};\n#define AWP_PIN_DF\t\t\"3F005011\"\n#define AWP_TOKEN_INFO\t\t\"3F0050111000\"\n#define AWP_PUK_FILE\t\t\"3F0050112000\"\n#define AWP_CONTAINERS_MS\t\"3F0050113000\"\n#define AWP_OBJECTS_LIST_PUB\t\"3F0050114000\"\n#define AWP_OBJECTS_LIST_PRV\t\"3F0050115000\"\n#define AWP_OBJECTS_DF_PUB\t\"3F0050119001\"\n#define AWP_OBJECTS_DF_PRV\t\"3F0050119002\"\n#define AWP_BASE_RSA_PRV\t\"3F00501190023000\"\n#define AWP_BASE_RSA_PUB\t\"3F00501190011000\"\n#define AWP_BASE_CERTIFICATE\t\"3F00501190012000\"\n#define BASE_ID_PUB_RSA   0x10\n#define BASE_ID_CERT\t  0x20\n#define BASE_ID_PRV_RSA   0x30\n#define BASE_ID_PRV_DES   0x40\n#define BASE_ID_PUB_DATA  0x50\n#define BASE_ID_PRV_DATA  0x60\n#define BASE_ID_PUB_DES   0x70\nstatic int sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *, unsigned, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *, unsigned);\nstatic int sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *, unsigned, unsigned, int);\nstatic int sc_oberthur_parse_tokeninfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_containers (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_publicinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_oberthur_parse_privateinfo (struct sc_pkcs15_card *, unsigned char *, size_t, int);\nstatic int sc_awp_parse_df(struct sc_pkcs15_card *, struct sc_pkcs15_df *);\nstatic void sc_awp_clear(struct sc_pkcs15_card *);\nstruct crypto_container {\n\tunsigned  id_pub;\n\tunsigned  id_prv;\n\tunsigned  id_cert;\n};\nstruct container {\n\tchar uuid[37];\n\tstruct crypto_container exchange;\n\tstruct crypto_container sign;\n\tstruct container *next;\n\tstruct container *prev;\n};\nstruct container *Containers = NULL;\nstatic struct {\n\tconst char *name;\n\tconst char *path;\n\tunsigned char *content;\n\tsize_t len;\n\tint (*parser)(struct sc_pkcs15_card *, unsigned char *, size_t, int);\n\tint postpone_allowed;\n} oberthur_infos[] = {\n\t{ \"Token info\",\t\t\tAWP_TOKEN_INFO, \tNULL, 0, sc_oberthur_parse_tokeninfo, \t0},\n\t{ \"Containers MS\",\t\tAWP_CONTAINERS_MS, \tNULL, 0, sc_oberthur_parse_containers, \t0},\n\t{ \"Public objects list\",\tAWP_OBJECTS_LIST_PUB, \tNULL, 0, sc_oberthur_parse_publicinfo, \t0},\n\t{ \"Private objects list\",\tAWP_OBJECTS_LIST_PRV,\tNULL, 0, sc_oberthur_parse_privateinfo, 1},\n\t{ NULL, NULL, NULL, 0, NULL, 0}\n};\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\t*out = NULL;\n\t*out_len = 0;\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trec_len = rv;\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\t\t\toffs += rv + 2;\n\t\t}\n\t\tsz = offs;\n\t}\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\tsc_file_free(file);\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\t*out_len = sz;\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nstatic int\nsc_oberthur_parse_containers (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t offs;\n\tLOG_FUNC_CALLED(ctx);\n\twhile (Containers)   {\n\t\tstruct container *next = Containers->next;\n\t\tfree (Containers);\n\t\tContainers = next;\n\t}\n\tfor (offs=0; offs + 2 + 2+2+2 + 2+2+2 + 2+36 <= len;)  {\n\t\tstruct container *cont;\n\t\tunsigned char *ptr =  buff + offs + 2;\n\t\tsc_log(ctx,\n\t\t       \"parse contaniers offs:%\"SC_FORMAT_LEN_SIZE_T\"u, len:%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       offs, len);\n\t\tif (*(buff + offs) != 'R')\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\tcont = (struct container *)calloc(sizeof(struct container), 1);\n\t\tif (!cont)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tcont->exchange.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->exchange.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\t\tcont->sign.id_pub = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_prv = *ptr * 0x100 + *(ptr + 1);  ptr += 2;\n\t\tcont->sign.id_cert = *ptr * 0x100 + *(ptr + 1); ptr += 2;\n\t\tmemcpy(cont->uuid, ptr + 2, 36);\n\t\tsc_log(ctx, \"UUID: %s; 0x%X, 0x%X, 0x%X\", cont->uuid,\n\t\t\t\tcont->exchange.id_pub, cont->exchange.id_prv, cont->exchange.id_cert);\n\t\tif (!Containers)  {\n\t\t\tContainers = cont;\n\t\t}\n\t\telse   {\n\t\t\tcont->next = Containers;\n\t\t\tContainers->prev = (void *)cont;\n\t\t\tContainers = cont;\n\t\t}\n\t\toffs += *(buff + offs + 1) + 2;\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nstatic int\nsc_oberthur_parse_publicinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii+5<=len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add public object(file-id:%04X,size:%X)\", file_id, size);\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PUB_RSA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_pubkey(p15card, file_id, size);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse public key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_CERT :\n\t\t\trv = sc_pkcs15emu_oberthur_add_cert(p15card, file_id);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse certificate info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PUB_DATA :\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 0);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Public object parse error\");\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nstatic int\nsc_oberthur_parse_privateinfo (struct sc_pkcs15_card *p15card,\n\t\tunsigned char *buff, size_t len, int postpone_allowed)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tsize_t ii;\n\tint rv;\n\tint no_more_private_keys = 0, no_more_private_data = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tfor (ii=0; ii+5<=len; ii+=5)   {\n\t\tunsigned int file_id, size;\n\t\tif(*(buff+ii) != 0xFF)\n\t\t\tcontinue;\n\t\tfile_id = 0x100 * *(buff+ii + 1) + *(buff+ii + 2);\n\t\tsize = 0x100 * *(buff+ii + 3) + *(buff+ii + 4);\n\t\tsc_log(ctx, \"add private object (file-id:%04X, size:%X)\", file_id, size);\n\t\tswitch (*(buff+ii + 1))   {\n\t\tcase BASE_ID_PRV_RSA :\n\t\t\tif (no_more_private_keys)\n\t\t\t\tbreak;\n\t\t\trv = sc_pkcs15emu_oberthur_add_prvkey(p15card, file_id, size);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\t\t\t\tsc_log(ctx, \"postpone adding of the private keys\");\n\t\t\t\tsc_format_path(\"5011A5A5\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_PRKDF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add PrkDF error\");\n\t\t\t\tno_more_private_keys = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private key info\");\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DES :\n\t\t\tbreak;\n\t\tcase BASE_ID_PRV_DATA :\n\t\t\tsc_log(ctx, \"*(buff+ii + 1):%X\", *(buff+ii + 1));\n\t\t\tif (no_more_private_data)\n\t\t\t\tbreak;\n\t\t\trv = sc_pkcs15emu_oberthur_add_data(p15card, file_id, size, 1);\n\t\t\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED && postpone_allowed)   {\n\t\t\t\tstruct sc_path path;\n\t\t\t\tsc_log(ctx, \"postpone adding of the private data\");\n\t\t\t\tsc_format_path(\"5011A6A6\", &path);\n\t\t\t\trv = sc_pkcs15_add_df(p15card, SC_PKCS15_DODF, &path);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Add DODF error\");\n\t\t\t\tno_more_private_data = 1;\n\t\t\t}\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot parse private data info\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Private object parse error\");\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nstatic int\nsc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_pubkey_info key_info;\n\tstruct sc_pkcs15_object key_obj;\n\tchar ch_tmp[0x100];\n\tunsigned char *info_blob;\n\tsize_t len, info_len, offs;\n\tunsigned flags;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"public key(file-id:%04X,size:%X)\", file_id, size);\n\tmemset(&key_info, 0, sizeof(key_info));\n\tmemset(&key_obj, 0, sizeof(key_obj));\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add public key: read oberthur file error\");\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\tkey_info.usage = sc_oberthur_decode_usage(flags);\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkey_obj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tsc_log(ctx, \"Public key key-usage:%04X\", key_info.usage);\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'Label'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(key_obj.label) - 1)\n\t\t\tlen = sizeof(key_obj.label) - 1;\n\t\tmemcpy(key_obj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len || len > sizeof(key_info.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add public key: invalid 'ID' length\");\n\tmemcpy(key_info.id.value, info_blob + offs + 2, len);\n\tkey_info.id.len = len;\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &key_info.path);\n\tkey_info.native = 1;\n\tkey_info.key_reference = file_id & 0xFF;\n\tkey_info.modulus_length = size;\n\trv = sc_pkcs15emu_add_rsa_pubkey(p15card, &key_obj, &key_info);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nstatic int\nsc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card, unsigned int file_id)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_cert_info cinfo;\n\tstruct sc_pkcs15_object cobj;\n\tunsigned char *info_blob, *cert_blob;\n\tsize_t info_len, cert_len, len, offs;\n\tunsigned flags;\n\tint rv;\n\tchar ch_tmp[0x20];\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add certificate(file-id:%04X)\", file_id);\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tmemset(&cobj, 0, sizeof(cobj));\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read oberthur file error\");\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\tif (offs + 2 > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tif (len > sizeof(cobj.label) - 1)\n\t\t\tlen = sizeof(cobj.label) - 1;\n\t\tmemcpy(cobj.label, info_blob + offs + 2, len);\n\t}\n\toffs += 2 + len;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len > sizeof(cinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add certificate: invalid 'ID' length\");\n\tmemcpy(cinfo.id.value, info_blob + offs + 2, len);\n\tcinfo.id.len = len;\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &cinfo.path);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &cert_blob, &cert_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read certificate error\");\n\tcinfo.value.value = cert_blob;\n\tcinfo.value.len = cert_len;\n\trv = sc_oberthur_get_certificate_authority(&cinfo.value, &cinfo.authority);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: get certificate attributes error\");\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tcobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\trv = sc_pkcs15emu_add_x509_cert(p15card, &cobj, &cinfo);\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\nstatic int\nsc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info kinfo;\n\tstruct sc_pkcs15_object kobj;\n\tstruct crypto_container ccont;\n\tunsigned char *info_blob = NULL;\n\tsize_t info_len = 0;\n\tunsigned flags;\n\tsize_t offs, len;\n\tchar ch_tmp[0x100];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"add private key(file-id:%04X,size:%04X)\", file_id, size);\n\tmemset(&kinfo, 0, sizeof(kinfo));\n\tmemset(&kobj, 0, sizeof(kobj));\n\tmemset(&ccont, 0, sizeof(ccont));\n\trv = sc_oberthur_get_friends (file_id, &ccont);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get friends error\");\n\tif (ccont.id_cert)   {\n\t\tstruct sc_pkcs15_object *objs[32];\n\t\tint ii;\n\t\tsc_log(ctx, \"friend certificate %04X\", ccont.id_cert);\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_CERT_X509, objs, 32);\n\t\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: get certificates error\");\n\t\tfor (ii=0; ii<rv; ii++) {\n\t\t\tstruct sc_pkcs15_cert_info *cert = (struct sc_pkcs15_cert_info *)objs[ii]->data;\n\t\t\tstruct sc_path path = cert->path;\n\t\t\tunsigned int id = path.value[path.len - 2] * 0x100 + path.value[path.len - 1];\n\t\t\tif (id == ccont.id_cert)   {\n\t\t\t\tstrlcpy(kobj.label, objs[ii]->label, sizeof(kobj.label));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ii == rv)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, \"Failed to add private key: friend not found\");\n\t}\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add private key: read oberthur file error\");\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'CN'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len && !strlen(kobj.label))   {\n\t\tif (len > sizeof(kobj.label) - 1)\n\t\t\tlen = sizeof(kobj.label) - 1;\n\t\tstrncpy(kobj.label, (char *)(info_blob + offs + 2), len);\n\t}\n\toffs += 2 + len;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: no 'ID'\");\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (!len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private key: zero length ID\");\n\telse if (len > sizeof(kinfo.id.value))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add private key: invalid ID length\");\n\tmemcpy(kinfo.id.value, info_blob + offs + 2, len);\n\tkinfo.id.len = len;\n\toffs += 2 + len;\n\toffs += 16;\n\tif (offs > info_len)\n\t\treturn SC_ERROR_UNKNOWN_DATA_RECEIVED;\n\tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (len)   {\n\t\tkinfo.subject.value = malloc(len);\n\t\tif (!kinfo.subject.value)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Failed to add private key: memory allocation error\");\n\t\tkinfo.subject.len = len;\n\t\tmemcpy(kinfo.subject.value, info_blob + offs + 2, len);\n\t}\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id);\n\tsc_format_path(ch_tmp, &kinfo.path);\n\tsc_log(ctx, \"Private key info path %s\", ch_tmp);\n\tkinfo.modulus_length\t= size;\n\tkinfo.native\t\t= 1;\n\tkinfo.key_reference\t = file_id & 0xFF;\n\tkinfo.usage = sc_oberthur_decode_usage(flags);\n\tkobj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tkobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tkobj.auth_id.len = sizeof(PinDomainID) > sizeof(kobj.auth_id.value)\n\t\t\t? sizeof(kobj.auth_id.value) : sizeof(PinDomainID);\n\tmemcpy(kobj.auth_id.value, PinDomainID, kobj.auth_id.len);\n\tsc_log(ctx, \"Parsed private key(reference:%i,usage:%X,flags:%X)\", kinfo.key_reference, kinfo.usage, kobj.flags);\n\trv = sc_pkcs15emu_add_rsa_prkey(p15card, &kobj, &kinfo);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nstatic int\nsc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\t\tunsigned int file_id, unsigned int size, int private)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_data_info dinfo;\n\tstruct sc_pkcs15_object dobj;\n\tunsigned flags;\n\tunsigned char *info_blob = NULL, *label = NULL, *app = NULL, *oid = NULL;\n\tsize_t info_len, label_len, app_len, oid_len, offs;\n\tchar ch_tmp[0x100];\n\tint rv;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(ctx, \"Add data(file-id:%04X,size:%i,is-private:%i)\", file_id, size, private);\n\tmemset(&dinfo, 0, sizeof(dinfo));\n\tmemset(&dobj, 0, sizeof(dobj));\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id | 0x100);\n\trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Failed to add data: read oberthur file error\");\n\tif (info_len < 2)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'tag'\");\n\tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\toffs = 2;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'label'\");\n\tlabel = info_blob + offs + 2;\n\tlabel_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (label_len > sizeof(dobj.label) - 1)\n\t\tlabel_len = sizeof(dobj.label) - 1;\n\toffs += 2 + *(info_blob + offs + 1);\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'application'\");\n\tapp = info_blob + offs + 2;\n\tapp_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (app_len > sizeof(dinfo.app_label) - 1)\n\t\tapp_len = sizeof(dinfo.app_label) - 1;\n\toffs += 2 + app_len;\n\tif (offs > info_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: no 'OID'\");\n\toid_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n\tif (oid_len)   {\n\t\toid = info_blob + offs + 2;\n\t\tif (*oid != 0x06 || (*(oid + 1) != oid_len - 2))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data: invalid 'OID' format\");\n\t\toid += 2;\n\t\toid_len -= 2;\n\t}\n\tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", private ? AWP_OBJECTS_DF_PRV : AWP_OBJECTS_DF_PUB, file_id);\n\tsc_format_path(ch_tmp, &dinfo.path);\n\tmemcpy(dobj.label, label, label_len);\n\tmemcpy(dinfo.app_label, app, app_len);\n\tif (oid_len)\n\t\tsc_asn1_decode_object_id(oid, oid_len, &dinfo.app_oid);\n\tif (flags & OBERTHUR_ATTR_MODIFIABLE)\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_MODIFIABLE;\n\tif (private)   {\n\t\tdobj.auth_id.len = sizeof(PinDomainID) > sizeof(dobj.auth_id.value)\n\t\t\t\t? sizeof(dobj.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(dobj.auth_id.value, PinDomainID, dobj.auth_id.len);\n\t\tdobj.flags |= SC_PKCS15_CO_FLAG_PRIVATE;\n\t}\n\trv = sc_pkcs15emu_add_data_object(p15card, &dobj, &dinfo);\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_7916.c",
        "project": "opensc/opensc",
        "url": "https://github.com/OpenSC/OpenSC/commit/1db88374bb7706a115d5c3617c6f16115c33bf27",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```                const char *name,\n                int af,\n                char *buffer, size_t buflen,\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        assert(name);\n        assert(buffer);\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n        if (af != AF_INET && af != AF_INET6) {\n        }\n        r = sd_machine_get_class(name, &class);\n        r = sd_bus_open_system(&bus);\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        r = count_addresses(reply, af, &c);\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n        r_aliases = buffer + idx;\n        idx += sizeof(char*);\n        r_addr = buffer + idx;\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                r = sd_bus_message_read(reply, \"i\", &family);\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n                if (family != af)\n                        continue;\n                if (sz != alen) {\n                }\n                memcpy(r_addr + i*ALIGN(alen), a, alen);\n                i++;\n        }\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <netdb.h>\n#include <nss.h>\n#include \"sd-bus.h\"\n#include \"sd-login.h\"\n#include \"alloc-util.h\"\n#include \"bus-common-errors.h\"\n#include \"bus-util.h\"\n#include \"hostname-util.h\"\n#include \"in-addr-util.h\"\n#include \"macro.h\"\n#include \"nss-util.h\"\n#include \"string-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\nenum nss_status _nss_mymachines_gethostbyname4_r(\n                const char *name,\n                struct gaih_addrtuple **pat,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp) {\n        struct gaih_addrtuple *r_tuple, *r_tuple_first = NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ int *ifindices = NULL;\n        _cleanup_free_ char *class = NULL;\n        size_t l, ms, idx;\n        unsigned i = 0, c = 0;\n        char *r_name;\n        int n_ifindices, r;\n        assert(name);\n        assert(pat);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n        n_ifindices = sd_machine_get_ifindices(name, &ifindices);\n        if (n_ifindices < 0) {\n                r = n_ifindices;\n                goto fail;\n        }\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n        r = count_addresses(reply, AF_UNSPEC, &c);\n        if (r < 0)\n                goto fail;\n        if (c <= 0) {\n                *errnop = ESRCH;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n        l = strlen(name);\n        ms = ALIGN(l+1) + ALIGN(sizeof(struct gaih_addrtuple)) * c;\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = TRY_AGAIN;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n        r_tuple_first = (struct gaih_addrtuple*) (buffer + idx);\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n                if (!IN_SET(family, AF_INET, AF_INET6)) {\n                        r = -EAFNOSUPPORT;\n                        goto fail;\n                }\n                if (sz != FAMILY_ADDRESS_SIZE(family)) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n                r_tuple = (struct gaih_addrtuple*) (buffer + idx);\n                r_tuple->next = i == c-1 ? NULL : (struct gaih_addrtuple*) ((char*) r_tuple + ALIGN(sizeof(struct gaih_addrtuple)));\n                r_tuple->name = r_name;\n                r_tuple->family = family;\n                r_tuple->scopeid = n_ifindices == 1 ? ifindices[0] : 0;\n                memcpy(r_tuple->addr, a, sz);\n                idx += ALIGN(sizeof(struct gaih_addrtuple));\n                i++;\n        }\n        assert(i == c);\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n        assert(idx == ms);\n        if (*pat)\n                **pat = *r_tuple_first;\n        else\n                *pat = r_tuple_first;\n        if (ttlp)\n                *ttlp = 0;\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n        return NSS_STATUS_SUCCESS;\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_gethostbyname3_r(\n                const char *name,\n                int af,\n                struct hostent *result,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp,\n                char **canonp) {\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        char *r_name, *r_aliases, *r_addr, *r_addr_list;\n        size_t l, idx, ms, alen;\n        int r;\n        assert(name);\n        assert(result);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n        if (af != AF_INET && af != AF_INET6) {\n                r = -EAFNOSUPPORT;\n                goto fail;\n        }\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n        r = count_addresses(reply, af, &c);\n        if (r < 0)\n                goto fail;\n        if (c <= 0) {\n                *errnop = ENOENT;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = NO_RECOVERY;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n        r_aliases = buffer + idx;\n        ((char**) r_aliases)[0] = NULL;\n        idx += sizeof(char*);\n        r_addr = buffer + idx;\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n                if (family != af)\n                        continue;\n                if (sz != alen) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n                memcpy(r_addr + i*ALIGN(alen), a, alen);\n                i++;\n        }\n        assert(i == c);\n        idx += c * ALIGN(alen);\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n        r_addr_list = buffer + idx;\n        for (i = 0; i < c; i++)\n                ((char**) r_addr_list)[i] = r_addr + i*ALIGN(alen);\n        ((char**) r_addr_list)[i] = NULL;\n        idx += (c+1) * sizeof(char*);\n        assert(idx == ms);\n        result->h_name = r_name;\n        result->h_aliases = (char**) r_aliases;\n        result->h_addrtype = af;\n        result->h_length = alen;\n        result->h_addr_list = (char**) r_addr_list;\n        if (ttlp)\n                *ttlp = 0;\n        if (canonp)\n                *canonp = r_name;\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n        return NSS_STATUS_SUCCESS;\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getpwnam_r(\n                const char *name,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t uid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(pwd);\n        p = startswith(name, \"vu-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        r = parse_uid(e + 1, &uid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineUser\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = strlen(name);\n        if (buflen < l+1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memcpy(buffer, name, l+1);\n        pwd->pw_name = buffer;\n        pwd->pw_uid = mapped;\n        pwd->pw_gid = 65534; \n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; \n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getpwuid_r(\n                uid_t uid,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n        if (!uid_is_valid(uid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n        if (uid < 0x10000)\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineUser\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n        if (snprintf(buffer, buflen, \"vu-%s-\" UID_FMT, machine, (uid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        pwd->pw_name = buffer;\n        pwd->pw_uid = uid;\n        pwd->pw_gid = 65534; \n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; \n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(gr);\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\nenum nss_status _nss_mymachines_getgrgid_r(\n                gid_t gid,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n        if (!gid_is_valid(gid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n        if (gid < 0x10000)\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineGroup\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n        if (buflen < sizeof(char*) + 1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        if (snprintf(buffer + sizeof(char*), buflen - sizeof(char*), \"vg-%s-\" GID_FMT, machine, (gid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_2266.c",
        "project": "keszybz/systemd",
        "url": "https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n    format[MagickPathExtent],\n    keyword[MagickPathExtent],\n    tag[MagickPathExtent],\n    value[MagickPathExtent];\n  double\n    pixel[4],\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n      return((Image *) NULL);\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n    if (c == (int) '#')\n        length=MagickPathExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MagickPathExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n          *p=(char) c;\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        c=ReadBlobByte(image);\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n          p=keyword;\n          do\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n            c=ReadBlobByte(image);\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          *p='\\0';\n              if (LocaleCompare(keyword,\"format\") == 0)\n                  (void) CopyMagickString(format,value,MagickPathExtent);\n                  break;\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                    chromaticity[6],\n                    white_point[2];\n                  count=sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                    &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                    &chromaticity[4],&chromaticity[5],&white_point[0],\n                    &white_point[1]);\n                  if (count == 8)\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                  break;\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              if (strcmp(keyword,target) == 0)\n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                  break;\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if (image->compression != RLECompression)\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n    else\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n        else\n            p=pixels;\n            for (i=0; i < 4; i++)\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                else\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n      if (image->compression == RLECompression)\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n      else\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n      q+=GetPixelChannels(image);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n      break;\n}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\nstatic MagickBooleanType\n  WriteHDRImage(const ImageInfo *,Image *,ExceptionInfo *);\nstatic Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MagickPathExtent],\n    keyword[MagickPathExtent],\n    tag[MagickPathExtent],\n    value[MagickPathExtent];\n  double\n    gamma;\n  Image\n    *image;\n  int\n    c;\n  MagickBooleanType\n    status,\n    value_expected;\n  register Quantum\n    *q;\n  register ssize_t\n    i,\n    x;\n  register unsigned char\n    *p;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n        register char\n          *p;\n        size_t\n          length;\n        length=MagickPathExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MagickPathExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n          {\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MagickPathExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n                  int\n                    count;\n                  count=sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                    &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                    &chromaticity[4],&chromaticity[5],&white_point[0],\n                    &white_point[1]);\n                  if (count == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MagickPathExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\nModuleExport \nModuleExport \nstatic size_t HDRWriteRunlengthPixels(Image *image,unsigned char *pixels)\n{\n#define MinimumRunlength 4\n  register size_t\n    p,\n    q;\n  size_t\n    runlength;\n  ssize_t\n    count,\n    previous_count;\n  unsigned char\n    pixel[2];\n  for (p=0; p < image->columns; )\n  {\n    q=p;\n    runlength=0;\n    previous_count=0;\n    while ((runlength < MinimumRunlength) && (q < image->columns))\n    {\n      q+=runlength;\n      previous_count=(ssize_t) runlength;\n      runlength=1;\n      while ((pixels[q] == pixels[q+runlength]) &&\n             ((q+runlength) < image->columns) && (runlength < 127))\n       runlength++;\n    }\n    if ((previous_count > 1) && (previous_count == (ssize_t) (q-p)))\n      {\n        pixel[0]=(unsigned char) (128+previous_count);\n        pixel[1]=pixels[p];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p=q;\n      }\n    while (p < q)\n    {\n      count=(ssize_t) (q-p);\n      if (count > 128)\n        count=128;\n      pixel[0]=(unsigned char) count;\n      if (WriteBlob(image,sizeof(*pixel),pixel) < 1)\n        break;\n      if (WriteBlob(image,(size_t) count*sizeof(*pixel),&pixels[p]) < 1)\n        break;\n      p+=count;\n    }\n    if (runlength >= MinimumRunlength)\n      {\n        pixel[0]=(unsigned char) (128+runlength);\n        pixel[1]=pixels[q];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p+=runlength;\n      }\n  }\n  return(p);\n}\nstatic MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n  const char\n    *property;\n  MagickBooleanType\n    status;\n  register const Quantum\n    *p;\n  register ssize_t\n    i,\n    x;\n  size_t\n    length;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    pixel[4],\n    *pixels;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  (void) ResetMagickMemory(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n        image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_1919.c",
        "project": "imagemagick/imagemagick",
        "url": "https://github.com/ImageMagick/ImageMagick/commit/14e606db148d6ebcaae20f1e1d6d71903ca4a556",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```Sprintf(char *fmt, ...)\n    int len = 0;\n    int p = 0;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n\t    if (*f == '%') {\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\t    len += (p > 0) ? p : 10;\n\t\t    len += (p > 0) ? p : 15;\n\t\t    len += 1;\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    len += 10;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t    else if (*f == '%') {\n\t\tlen++;\n\t    }\n\t    if (IS_ALPHA(*f)) {\n\t    }\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <stdio.h>\n#include <stdlib.h>\n#include <gc.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef __EMX__\t\t\t\n#include <strings.h>\n#endif\n#include \"Str.h\"\n#include \"myctype.h\"\n#define INITIAL_STR_SIZE 32\n#ifdef STR_DEBUG\n#define STR_LENGTH_CHECK(x) if (((x)->ptr==0&&(x)->length!=0)||(strlen((x)->ptr)!=(x)->length))abort();\n#else\t\t\t\t\n#define STR_LENGTH_CHECK(x)\n#endif\t\t\t\t\nvoid\nStrgrow(Str x)\n{\n    char *old = x->ptr;\n    int newlen;\n    newlen = x->area_size * 6 / 5;\n    if (newlen == x->area_size)\n\tnewlen += 2;\n    x->ptr = GC_MALLOC_ATOMIC(newlen);\n    x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n#define SP_NORMAL 0\n#define SP_PREC   1\n#define SP_PREC2  2\nStr\nSprintf(char *fmt, ...)\n{\n    int len = 0;\n    int status = SP_NORMAL;\n    int p = 0;\n    char *f;\n    Str s;\n    va_list ap;\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n      redo:\n\tswitch (status) {\n\tcase SP_NORMAL:\n\t    if (*f == '%') {\n\t\tstatus = SP_PREC;\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\tcase SP_PREC:\n\t    if (IS_ALPHA(*f)) {\n\t\tdouble vd;\n\t\tint vi;\n\t\tchar *vs;\n\t\tvoid *vp;\n\t\tswitch (*f) {\n\t\tcase 'l':\n\t\tcase 'h':\n\t\tcase 'L':\n\t\tcase 'w':\n\t\t    continue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\tcase 'u':\n\t\t    vi = va_arg(ap, int);\n\t\t    len += (p > 0) ? p : 10;\n\t\t    break;\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'e':\n\t\tcase 'G':\n\t\tcase 'E':\n\t\t    vd = va_arg(ap, double);\n\t\t    len += (p > 0) ? p : 15;\n\t\t    break;\n\t\tcase 'c':\n\t\t    len += 1;\n\t\t    vi = va_arg(ap, int);\n\t\t    break;\n\t\tcase 's':\n\t\t    vs = va_arg(ap, char *);\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    break;\n\t\tcase 'p':\n\t\t    vp = va_arg(ap, void *);\n\t\t    len += 10;\n\t\t    break;\n\t\tcase 'n':\n\t\t    vp = va_arg(ap, void *);\n\t\t    break;\n\t\t}\n\t\tstatus = SP_NORMAL;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t\tstatus = SP_PREC2;\n\t    else if (*f == '%') {\n\t\tstatus = SP_NORMAL;\n\t\tlen++;\n\t    }\n\t    break;\n\tcase SP_PREC2:\n\t    if (IS_ALPHA(*f)) {\n\t\tstatus = SP_PREC;\n\t\tgoto redo;\n\t    }\n\t    break;\n\t}\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n    va_end(ap);\n    s->length = strlen(s->ptr);\n    if (s->length > len * 2) {\n\tfprintf(stderr, \"Sprintf: string too long\\n\");\n\texit(1);\n    }\n    return s;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_1446.c",
        "project": "tats/w3m",
        "url": "https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static struct request *__get_request(struct request_list *rl, unsigned int op,\n\t\tstruct bio *bio, blk_mq_req_flags_t flags, gfp_t gfp_mask)\n\tstruct request_queue *q = rl->q;\n\tstruct elevator_type *et = q->elevator->type;\n\tstruct io_context *ioc = rq_ioc(bio);\n\tconst bool is_sync = op_is_sync(op);\n\tlockdep_assert_held(q->queue_lock);\n\tif (unlikely(blk_queue_dying(q)))\n\t\treturn ERR_PTR(-ENODEV);\n\tmay_queue = elv_may_queue(q, op);\n\tif (may_queue == ELV_MQUEUE_NO)\n\t\tgoto rq_starved;\n\tif (rl->count[is_sync]+1 >= queue_congestion_on_threshold(q)) {\n\t\tif (rl->count[is_sync]+1 >= q->nr_requests) {\n\t\t\tif (!blk_rl_full(rl, is_sync)) {\n\t\t\t\tioc_set_batching(q, ioc);\n\t\t\t\tblk_set_rl_full(rl, is_sync);\n\t\t\t} else {\n\t\t\t\tif (may_queue != ELV_MQUEUE_MUST\n\t\t\t\t\t\t&& !ioc_batching(q, ioc)) {\n\t\t\t}\n\t\t}\n\t\tblk_set_congested(rl, is_sync);\n\t}\n\tif (rl->count[is_sync] >= (3 * q->nr_requests / 2))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!op_is_flush(op) && !blk_queue_bypass(q)) {\n\t\tq->nr_rqs_elvpriv++;\n\t\tif (et->icq_cache && ioc)\n\t\t\ticq = ioc_lookup_icq(ioc, q);\n\t}\n\tif (blk_queue_io_stat(q))\n\t\trq_flags |= RQF_IO_STAT;\n\tspin_unlock_irq(q->queue_lock);\n\trq = mempool_alloc(rl->rq_pool, gfp_mask);\n\tif (!rq)\n\t\tgoto fail_alloc;\n\tblk_rq_init(q, rq);\n\tblk_rq_set_rl(rq, rl);\nstatic struct request *get_request(struct request_queue *q, unsigned int op,\n\t\tstruct bio *bio, blk_mq_req_flags_t flags, gfp_t gfp)\n\tconst bool is_sync = op_is_sync(op);\n\tlockdep_assert_held(q->queue_lock);\n\tWARN_ON_ONCE(q->mq_ops);\n\trl = blk_get_rl(q, bio);\t\n\trq = __get_request(rl, op, bio, flags, gfp);\n\tif (!IS_ERR(rq))\n\t\treturn rq;\n\tif (op & REQ_NOWAIT) {\n\t}\n\tif ((flags & BLK_MQ_REQ_NOWAIT) || unlikely(blk_queue_dying(q))) {\n\t}\n\ttrace_block_sleeprq(q, bio, op);\n\tspin_unlock_irq(q->queue_lock);\n\tioc_set_batching(q, current->io_context);\n\tspin_lock_irq(q->queue_lock);\nstatic blk_qc_t blk_queue_bio(struct request_queue *q, struct bio *bio)\n\tblk_queue_bounce(q, &bio);\n\tblk_queue_split(q, &bio);\n\tif (!bio_integrity_prep(bio))\n\t\treturn BLK_QC_T_NONE;\n\tif (op_is_flush(bio->bi_opf)) {\n\t\tspin_lock_irq(q->queue_lock);\n\t}\n\tif (!blk_queue_nomerges(q)) {\n\t\tif (blk_attempt_plug_merge(q, bio, &request_count, NULL))\n\t\t\treturn BLK_QC_T_NONE;\n\t} else\n\t\trequest_count = blk_plug_queued_count(q);\n\tspin_lock_irq(q->queue_lock);\n\tswitch (elv_merge(q, &req, bio)) {\n\t\tif (!bio_attempt_back_merge(q, req, bio))\n\t\t\tbreak;\n\t\tif (!bio_attempt_front_merge(q, req, bio))\n\t\t\tbreak;\n\trq_qos_throttle(q, bio, q->queue_lock);\n\tblk_queue_enter_live(q);\n\treq = get_request(q, bio->bi_opf, bio, 0, GFP_NOIO);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/fault-inject.h>\n#include <linux/list_sort.h>\n#include <linux/delay.h>\n#include <linux/ratelimit.h>\n#include <linux/pm_runtime.h>\n#include <linux/blk-cgroup.h>\n#include <linux/debugfs.h>\n#include <linux/bpf.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/block.h>\n#include \"blk.h\"\n#include \"blk-mq.h\"\n#include \"blk-mq-sched.h\"\n#include \"blk-rq-qos.h\"\n#ifdef CONFIG_DEBUG_FS\nstruct dentry *blk_debugfs_root;\n#endif\nEXPORT_TRACEPOINT_SYMBOL_GPL(block_rq_remap);\nEXPORT_TRACEPOINT_SYMBOL_GPL(block_bio_complete);\nEXPORT_TRACEPOINT_SYMBOL_GPL(block_split);\nEXPORT_TRACEPOINT_SYMBOL_GPL(block_unplug);\nstruct kmem_cache *request_cachep;\nstruct kmem_cache *blk_requestq_cachep;\nstatic struct workqueue_struct *kblockd_workqueue;\nEXPORT_SYMBOL(blk_queue_flag_clear);\nEXPORT_SYMBOL_GPL(blk_queue_flag_test_and_clear);\nEXPORT_SYMBOL(blk_rq_init);\nstatic const struct {\n\tint\t\terrno;\n\tconst char\t*name;\n} blk_errors[] = {\n\t[BLK_STS_OK]\t\t= { 0,\t\t\"\" },\n\t[BLK_STS_NOTSUPP]\t= { -EOPNOTSUPP, \"operation not supported\" },\n\t[BLK_STS_TIMEOUT]\t= { -ETIMEDOUT,\t\"timeout\" },\n\t[BLK_STS_NOSPC]\t\t= { -ENOSPC,\t\"critical space allocation\" },\n\t[BLK_STS_TRANSPORT]\t= { -ENOLINK,\t\"recoverable transport\" },\n\t[BLK_STS_TARGET]\t= { -EREMOTEIO,\t\"critical target\" },\n\t[BLK_STS_NEXUS]\t\t= { -EBADE,\t\"critical nexus\" },\n\t[BLK_STS_MEDIUM]\t= { -ENODATA,\t\"critical medium\" },\n\t[BLK_STS_PROTECTION]\t= { -EILSEQ,\t\"protection\" },\n\t[BLK_STS_RESOURCE]\t= { -ENOMEM,\t\"kernel resource\" },\n\t[BLK_STS_DEV_RESOURCE]\t= { -EBUSY,\t\"device resource\" },\n\t[BLK_STS_AGAIN]\t\t= { -EAGAIN,\t\"nonblocking retry\" },\n\t[BLK_STS_DM_REQUEUE]\t= { -EREMCHG, \"dm internal retry\" },\n\t[BLK_STS_IOERR]\t\t= { -EIO,\t\"I/O\" },\n};\nEXPORT_SYMBOL_GPL(errno_to_blk_status);\nEXPORT_SYMBOL_GPL(blk_status_to_errno);\nEXPORT_SYMBOL(blk_dump_rq_flags);\nEXPORT_SYMBOL(blk_delay_queue);\nEXPORT_SYMBOL(blk_start_queue_async);\nEXPORT_SYMBOL(blk_start_queue);\nEXPORT_SYMBOL(blk_stop_queue);\nEXPORT_SYMBOL(blk_sync_queue);\nEXPORT_SYMBOL_GPL(blk_set_preempt_only);\nEXPORT_SYMBOL_GPL(blk_clear_preempt_only);\nEXPORT_SYMBOL_GPL(__blk_run_queue_uncond);\nEXPORT_SYMBOL(__blk_run_queue);\nEXPORT_SYMBOL(blk_run_queue_async);\nEXPORT_SYMBOL(blk_run_queue);\nEXPORT_SYMBOL(blk_put_queue);\n\t__releases(q->queue_lock)\n\t__acquires(q->queue_lock)\n{\n\tint i;\n\tlockdep_assert_held(q->queue_lock);\n\tWARN_ON_ONCE(q->mq_ops);\n\twhile (true) {\n\t\tbool drain = false;\n\t\tif (q->elevator)\n\t\t\telv_drain_elevator(q);\n\t\tblkcg_drain_queue(q);\n\t\tif (!list_empty(&q->queue_head) && q->request_fn)\n\t\t\t__blk_run_queue(q);\n\t\tdrain |= q->nr_rqs_elvpriv;\n\t\tdrain |= q->request_fn_active;\n\t\tif (drain_all) {\n\t\t\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, NULL);\n\t\t\tdrain |= !list_empty(&q->queue_head);\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tdrain |= q->nr_rqs[i];\n\t\t\t\tdrain |= q->in_flight[i];\n\t\t\t\tif (fq)\n\t\t\t\t    drain |= !list_empty(&fq->flush_queue[i]);\n\t\t\t}\n\t\t}\n\t\tif (!drain)\n\t\t\tbreak;\n\t\tspin_unlock_irq(q->queue_lock);\n\t\tmsleep(10);\n\t\tspin_lock_irq(q->queue_lock);\n\t}\n\tif (q->request_fn) {\n\t\tstruct request_list *rl;\n\t\tblk_queue_for_each_rl(rl, q)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(rl->wait); i++)\n\t\t\t\twake_up_all(&rl->wait[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(blk_queue_bypass_start);\nEXPORT_SYMBOL_GPL(blk_queue_bypass_end);\nEXPORT_SYMBOL_GPL(blk_set_queue_dying);\nvoid blk_cleanup_queue(struct request_queue *q)\n{\n\tspinlock_t *lock = q->queue_lock;\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tspin_lock_irq(lock);\n\tq->bypass_depth++;\n\tqueue_flag_set(QUEUE_FLAG_BYPASS, q);\n\tqueue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tqueue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tqueue_flag_set(QUEUE_FLAG_DYING, q);\n\tspin_unlock_irq(lock);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\tspin_lock_irq(lock);\n\tqueue_flag_set(QUEUE_FLAG_DEAD, q);\n\tspin_unlock_irq(lock);\n\tif (q->mq_ops && blk_queue_init_done(q))\n\t\tblk_mq_quiesce_queue(q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tWARN_ON_ONCE(q->kobj.state_in_sysfs);\n\tif (q->elevator) {\n\t\tioc_clear_queue(q);\n\t\televator_exit(q, q->elevator);\n\t\tq->elevator = NULL;\n\t}\n\tblkcg_exit_queue(q);\n\tbdi_put(q->backing_dev_info);\n\tif (q->mq_ops)\n\t\tblk_mq_free_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tspin_lock_irq(lock);\n\tif (q->queue_lock != &q->__queue_lock)\n\t\tq->queue_lock = &q->__queue_lock;\n\tspin_unlock_irq(lock);\n\tblk_put_queue(q);\n}\nEXPORT_SYMBOL(blk_cleanup_queue);\nint blk_init_rl(struct request_list *rl, struct request_queue *q,\n\t\tgfp_t gfp_mask)\n{\n\tif (unlikely(rl->rq_pool) || q->mq_ops)\n\t\treturn 0;\n\trl->q = q;\n\trl->count[BLK_RW_SYNC] = rl->count[BLK_RW_ASYNC] = 0;\n\trl->starved[BLK_RW_SYNC] = rl->starved[BLK_RW_ASYNC] = 0;\n\tinit_waitqueue_head(&rl->wait[BLK_RW_SYNC]);\n\tinit_waitqueue_head(&rl->wait[BLK_RW_ASYNC]);\n\tif (q->cmd_size) {\n\t\trl->rq_pool = mempool_create_node(BLKDEV_MIN_RQ,\n\t\t\t\talloc_request_size, free_request_size,\n\t\t\t\tq, gfp_mask, q->node);\n\t} else {\n\t\trl->rq_pool = mempool_create_node(BLKDEV_MIN_RQ,\n\t\t\t\talloc_request_simple, free_request_simple,\n\t\t\t\tq, gfp_mask, q->node);\n\t}\n\tif (!rl->rq_pool)\n\t\treturn -ENOMEM;\n\tif (rl != &q->root_rl)\n\t\tWARN_ON_ONCE(!blk_get_queue(q));\n\treturn 0;\n}\nEXPORT_SYMBOL(blk_alloc_queue);\nint blk_queue_enter(struct request_queue *q, blk_mq_req_flags_t flags)\n{\n\tconst bool preempt = flags & BLK_MQ_REQ_PREEMPT;\n\twhile (true) {\n\t\tbool success = false;\n\t\trcu_read_lock();\n\t\tif (percpu_ref_tryget_live(&q->q_usage_counter)) {\n\t\t\tif (preempt || !blk_queue_preempt_only(q)) {\n\t\t\t\tsuccess = true;\n\t\t\t} else {\n\t\t\t\tpercpu_ref_put(&q->q_usage_counter);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (success)\n\t\t\treturn 0;\n\t\tif (flags & BLK_MQ_REQ_NOWAIT)\n\t\t\treturn -EBUSY;\n\t\tsmp_rmb();\n\t\twait_event(q->mq_freeze_wq,\n\t\t\t   (atomic_read(&q->mq_freeze_depth) == 0 &&\n\t\t\t    (preempt || !blk_queue_preempt_only(q))) ||\n\t\t\t   blk_queue_dying(q));\n\t\tif (blk_queue_dying(q))\n\t\t\treturn -ENODEV;\n\t}\n}\nstruct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id,\n\t\t\t\t\t   spinlock_t *lock)\n{\n\tstruct request_queue *q;\n\tint ret;\n\tq = kmem_cache_alloc_node(blk_requestq_cachep,\n\t\t\t\tgfp_mask | __GFP_ZERO, node_id);\n\tif (!q)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&q->queue_head);\n\tq->last_merge = NULL;\n\tq->end_sector = 0;\n\tq->boundary_rq = NULL;\n\tq->id = ida_simple_get(&blk_queue_ida, 0, 0, gfp_mask);\n\tif (q->id < 0)\n\t\tgoto fail_q;\n\tret = bioset_init(&q->bio_split, BIO_POOL_SIZE, 0, BIOSET_NEED_BVECS);\n\tif (ret)\n\t\tgoto fail_id;\n\tq->backing_dev_info = bdi_alloc_node(gfp_mask, node_id);\n\tif (!q->backing_dev_info)\n\t\tgoto fail_split;\n\tq->stats = blk_alloc_queue_stats();\n\tif (!q->stats)\n\t\tgoto fail_stats;\n\tq->backing_dev_info->ra_pages =\n\t\t\t(VM_MAX_READAHEAD * 1024) / PAGE_SIZE;\n\tq->backing_dev_info->capabilities = BDI_CAP_CGROUP_WRITEBACK;\n\tq->backing_dev_info->name = \"block\";\n\tq->node = node_id;\n\ttimer_setup(&q->backing_dev_info->laptop_mode_wb_timer,\n\t\t    laptop_mode_timer_fn, 0);\n\ttimer_setup(&q->timeout, blk_rq_timed_out_timer, 0);\n\tINIT_WORK(&q->timeout_work, NULL);\n\tINIT_LIST_HEAD(&q->queue_head);\n\tINIT_LIST_HEAD(&q->timeout_list);\n\tINIT_LIST_HEAD(&q->icq_list);\n#ifdef CONFIG_BLK_CGROUP\n\tINIT_LIST_HEAD(&q->blkg_list);\n#endif\n\tINIT_DELAYED_WORK(&q->delay_work, blk_delay_work);\n\tkobject_init(&q->kobj, &blk_queue_ktype);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\tmutex_init(&q->blk_trace_mutex);\n#endif\n\tmutex_init(&q->sysfs_lock);\n\tspin_lock_init(&q->__queue_lock);\n\tif (!q->mq_ops)\n\t\tq->queue_lock = lock ? : &q->__queue_lock;\n\tq->bypass_depth = 1;\n\tqueue_flag_set_unlocked(QUEUE_FLAG_BYPASS, q);\n\tinit_waitqueue_head(&q->mq_freeze_wq);\n\tif (percpu_ref_init(&q->q_usage_counter,\n\t\t\t\tblk_queue_usage_counter_release,\n\t\t\t\tPERCPU_REF_INIT_ATOMIC, GFP_KERNEL))\n\t\tgoto fail_bdi;\n\tif (blkcg_init_queue(q))\n\t\tgoto fail_ref;\n\treturn q;\nfail_ref:\n\tpercpu_ref_exit(&q->q_usage_counter);\nfail_bdi:\n\tblk_free_queue_stats(q->stats);\nfail_stats:\n\tbdi_put(q->backing_dev_info);\nfail_split:\n\tbioset_exit(&q->bio_split);\nfail_id:\n\tida_simple_remove(&blk_queue_ida, q->id);\nfail_q:\n\tkmem_cache_free(blk_requestq_cachep, q);\n\treturn NULL;\n}\nEXPORT_SYMBOL(blk_alloc_queue_node);\nEXPORT_SYMBOL(blk_init_queue);\nEXPORT_SYMBOL(blk_init_queue_node);\nstatic blk_qc_t blk_queue_bio(struct request_queue *q, struct bio *bio);\nint blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(blk_init_allocated_queue);\nbool blk_get_queue(struct request_queue *q)\n{\n\tif (likely(!blk_queue_dying(q))) {\n\t\t__blk_get_queue(q);\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(blk_get_queue);\nint blk_update_nr_requests(struct request_queue *q, unsigned int nr)\n{\n\tstruct request_list *rl;\n\tint on_thresh, off_thresh;\n\tWARN_ON_ONCE(q->mq_ops);\n\tspin_lock_irq(q->queue_lock);\n\tq->nr_requests = nr;\n\tblk_queue_congestion_threshold(q);\n\ton_thresh = queue_congestion_on_threshold(q);\n\toff_thresh = queue_congestion_off_threshold(q);\n\tblk_queue_for_each_rl(rl, q) {\n\t\tif (rl->count[BLK_RW_SYNC] >= on_thresh)\n\t\t\tblk_set_congested(rl, BLK_RW_SYNC);\n\t\telse if (rl->count[BLK_RW_SYNC] < off_thresh)\n\t\t\tblk_clear_congested(rl, BLK_RW_SYNC);\n\t\tif (rl->count[BLK_RW_ASYNC] >= on_thresh)\n\t\t\tblk_set_congested(rl, BLK_RW_ASYNC);\n\t\telse if (rl->count[BLK_RW_ASYNC] < off_thresh)\n\t\t\tblk_clear_congested(rl, BLK_RW_ASYNC);\n\t\tif (rl->count[BLK_RW_SYNC] >= q->nr_requests) {\n\t\t\tblk_set_rl_full(rl, BLK_RW_SYNC);\n\t\t} else {\n\t\t\tblk_clear_rl_full(rl, BLK_RW_SYNC);\n\t\t\twake_up(&rl->wait[BLK_RW_SYNC]);\n\t\t}\n\t\tif (rl->count[BLK_RW_ASYNC] >= q->nr_requests) {\n\t\t\tblk_set_rl_full(rl, BLK_RW_ASYNC);\n\t\t} else {\n\t\t\tblk_clear_rl_full(rl, BLK_RW_ASYNC);\n\t\t\twake_up(&rl->wait[BLK_RW_ASYNC]);\n\t\t}\n\t}\n\tspin_unlock_irq(q->queue_lock);\n\treturn 0;\n}\nstatic struct request *__get_request(struct request_list *rl, unsigned int op,\n\t\tstruct bio *bio, blk_mq_req_flags_t flags, gfp_t gfp_mask)\n{\n\tstruct request_queue *q = rl->q;\n\tstruct request *rq;\n\tstruct elevator_type *et = q->elevator->type;\n\tstruct io_context *ioc = rq_ioc(bio);\n\tstruct io_cq *icq = NULL;\n\tconst bool is_sync = op_is_sync(op);\n\tint may_queue;\n\treq_flags_t rq_flags = RQF_ALLOCED;\n\tlockdep_assert_held(q->queue_lock);\n\tif (unlikely(blk_queue_dying(q)))\n\t\treturn ERR_PTR(-ENODEV);\n\tmay_queue = elv_may_queue(q, op);\n\tif (may_queue == ELV_MQUEUE_NO)\n\t\tgoto rq_starved;\n\tif (rl->count[is_sync]+1 >= queue_congestion_on_threshold(q)) {\n\t\tif (rl->count[is_sync]+1 >= q->nr_requests) {\n\t\t\tif (!blk_rl_full(rl, is_sync)) {\n\t\t\t\tioc_set_batching(q, ioc);\n\t\t\t\tblk_set_rl_full(rl, is_sync);\n\t\t\t} else {\n\t\t\t\tif (may_queue != ELV_MQUEUE_MUST\n\t\t\t\t\t\t&& !ioc_batching(q, ioc)) {\n\t\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tblk_set_congested(rl, is_sync);\n\t}\n\tif (rl->count[is_sync] >= (3 * q->nr_requests / 2))\n\t\treturn ERR_PTR(-ENOMEM);\n\tq->nr_rqs[is_sync]++;\n\trl->count[is_sync]++;\n\trl->starved[is_sync] = 0;\n\tif (!op_is_flush(op) && !blk_queue_bypass(q)) {\n\t\trq_flags |= RQF_ELVPRIV;\n\t\tq->nr_rqs_elvpriv++;\n\t\tif (et->icq_cache && ioc)\n\t\t\ticq = ioc_lookup_icq(ioc, q);\n\t}\n\tif (blk_queue_io_stat(q))\n\t\trq_flags |= RQF_IO_STAT;\n\tspin_unlock_irq(q->queue_lock);\n\trq = mempool_alloc(rl->rq_pool, gfp_mask);\n\tif (!rq)\n\t\tgoto fail_alloc;\n\tblk_rq_init(q, rq);\n\tblk_rq_set_rl(rq, rl);\n\trq->cmd_flags = op;\n\trq->rq_flags = rq_flags;\n\tif (flags & BLK_MQ_REQ_PREEMPT)\n\t\trq->rq_flags |= RQF_PREEMPT;\n\tif (rq_flags & RQF_ELVPRIV) {\n\t\tif (unlikely(et->icq_cache && !icq)) {\n\t\t\tif (ioc)\n\t\t\t\ticq = ioc_create_icq(ioc, q, gfp_mask);\n\t\t\tif (!icq)\n\t\t\t\tgoto fail_elvpriv;\n\t\t}\n\t\trq->elv.icq = icq;\n\t\tif (unlikely(elv_set_request(q, rq, bio, gfp_mask)))\n\t\t\tgoto fail_elvpriv;\n\t\tif (icq)\n\t\t\tget_io_context(icq->ioc);\n\t}\nout:\n\tif (ioc_batching(q, ioc))\n\t\tioc->nr_batch_requests--;\n\ttrace_block_getrq(q, bio, op);\n\treturn rq;\nfail_elvpriv:\n\tprintk_ratelimited(KERN_WARNING \"%s: dev %s: request aux data allocation failed, iosched may be disturbed\\n\",\n\t\t\t   __func__, dev_name(q->backing_dev_info->dev));\n\trq->rq_flags &= ~RQF_ELVPRIV;\n\trq->elv.icq = NULL;\n\tspin_lock_irq(q->queue_lock);\n\tq->nr_rqs_elvpriv--;\n\tspin_unlock_irq(q->queue_lock);\n\tgoto out;\nfail_alloc:\n\tspin_lock_irq(q->queue_lock);\n\tfreed_request(rl, is_sync, rq_flags);\nrq_starved:\n\tif (unlikely(rl->count[is_sync] == 0))\n\t\trl->starved[is_sync] = 1;\n\treturn ERR_PTR(-ENOMEM);\n}\nstatic struct request *get_request(struct request_queue *q, unsigned int op,\n\t\tstruct bio *bio, blk_mq_req_flags_t flags, gfp_t gfp)\n{\n\tconst bool is_sync = op_is_sync(op);\n\tDEFINE_WAIT(wait);\n\tstruct request_list *rl;\n\tstruct request *rq;\n\tlockdep_assert_held(q->queue_lock);\n\tWARN_ON_ONCE(q->mq_ops);\n\trl = blk_get_rl(q, bio);\t\nretry:\n\trq = __get_request(rl, op, bio, flags, gfp);\n\tif (!IS_ERR(rq))\n\t\treturn rq;\n\tif (op & REQ_NOWAIT) {\n\t\tblk_put_rl(rl);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tif ((flags & BLK_MQ_REQ_NOWAIT) || unlikely(blk_queue_dying(q))) {\n\t\tblk_put_rl(rl);\n\t\treturn rq;\n\t}\n\tprepare_to_wait_exclusive(&rl->wait[is_sync], &wait,\n\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\ttrace_block_sleeprq(q, bio, op);\n\tspin_unlock_irq(q->queue_lock);\n\tio_schedule();\n\tioc_set_batching(q, current->io_context);\n\tspin_lock_irq(q->queue_lock);\n\tfinish_wait(&rl->wait[is_sync], &wait);\n\tgoto retry;\n}\nEXPORT_SYMBOL(blk_get_request);\nEXPORT_SYMBOL(blk_requeue_request);\nEXPORT_SYMBOL_GPL(part_round_stats);\n#ifdef CONFIG_PM\nstatic void blk_pm_put_request(struct request *rq)\n{\n\tif (rq->q->dev && !(rq->rq_flags & RQF_PM) && !--rq->q->nr_pending)\n\t\tpm_runtime_mark_last_busy(rq->q->dev);\n}\n#else\n#endif\nEXPORT_SYMBOL_GPL(__blk_put_request);\nEXPORT_SYMBOL(blk_put_request);\nbool blk_attempt_plug_merge(struct request_queue *q, struct bio *bio,\n\t\t\t    unsigned int *request_count,\n\t\t\t    struct request **same_queue_rq)\n{\n\tstruct blk_plug *plug;\n\tstruct request *rq;\n\tstruct list_head *plug_list;\n\tplug = current->plug;\n\tif (!plug)\n\t\treturn false;\n\t*request_count = 0;\n\tif (q->mq_ops)\n\t\tplug_list = &plug->mq_list;\n\telse\n\t\tplug_list = &plug->list;\n\tlist_for_each_entry_reverse(rq, plug_list, queuelist) {\n\t\tbool merged = false;\n\t\tif (rq->q == q) {\n\t\t\t(*request_count)++;\n\t\t\tif (same_queue_rq)\n\t\t\t\t*same_queue_rq = rq;\n\t\t}\n\t\tif (rq->q != q || !blk_rq_merge_ok(rq, bio))\n\t\t\tcontinue;\n\t\tswitch (blk_try_merge(rq, bio)) {\n\t\tcase ELEVATOR_BACK_MERGE:\n\t\t\tmerged = bio_attempt_back_merge(q, rq, bio);\n\t\t\tbreak;\n\t\tcase ELEVATOR_FRONT_MERGE:\n\t\t\tmerged = bio_attempt_front_merge(q, rq, bio);\n\t\t\tbreak;\n\t\tcase ELEVATOR_DISCARD_MERGE:\n\t\t\tmerged = bio_attempt_discard_merge(q, rq, bio);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (merged)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(blk_init_request_from_bio);\nstatic blk_qc_t blk_queue_bio(struct request_queue *q, struct bio *bio)\n{\n\tstruct blk_plug *plug;\n\tint where = ELEVATOR_INSERT_SORT;\n\tstruct request *req, *free;\n\tunsigned int request_count = 0;\n\tblk_queue_bounce(q, &bio);\n\tblk_queue_split(q, &bio);\n\tif (!bio_integrity_prep(bio))\n\t\treturn BLK_QC_T_NONE;\n\tif (op_is_flush(bio->bi_opf)) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\twhere = ELEVATOR_INSERT_FLUSH;\n\t\tgoto get_rq;\n\t}\n\tif (!blk_queue_nomerges(q)) {\n\t\tif (blk_attempt_plug_merge(q, bio, &request_count, NULL))\n\t\t\treturn BLK_QC_T_NONE;\n\t} else\n\t\trequest_count = blk_plug_queued_count(q);\n\tspin_lock_irq(q->queue_lock);\n\tswitch (elv_merge(q, &req, bio)) {\n\tcase ELEVATOR_BACK_MERGE:\n\t\tif (!bio_attempt_back_merge(q, req, bio))\n\t\t\tbreak;\n\t\telv_bio_merged(q, req, bio);\n\t\tfree = attempt_back_merge(q, req);\n\t\tif (free)\n\t\t\t__blk_put_request(q, free);\n\t\telse\n\t\t\telv_merged_request(q, req, ELEVATOR_BACK_MERGE);\n\t\tgoto out_unlock;\n\tcase ELEVATOR_FRONT_MERGE:\n\t\tif (!bio_attempt_front_merge(q, req, bio))\n\t\t\tbreak;\n\t\telv_bio_merged(q, req, bio);\n\t\tfree = attempt_front_merge(q, req);\n\t\tif (free)\n\t\t\t__blk_put_request(q, free);\n\t\telse\n\t\t\telv_merged_request(q, req, ELEVATOR_FRONT_MERGE);\n\t\tgoto out_unlock;\n\tdefault:\n\t\tbreak;\n\t}\nget_rq:\n\trq_qos_throttle(q, bio, q->queue_lock);\n\tblk_queue_enter_live(q);\n\treq = get_request(q, bio->bi_opf, bio, 0, GFP_NOIO);\n\tif (IS_ERR(req)) {\n\t\tblk_queue_exit(q);\n\t\trq_qos_cleanup(q, bio);\n\t\tif (PTR_ERR(req) == -ENOMEM)\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\telse\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\tbio_endio(bio);\n\t\tgoto out_unlock;\n\t}\n\trq_qos_track(q, req, bio);\n\tblk_init_request_from_bio(req, bio);\n\tif (test_bit(QUEUE_FLAG_SAME_COMP, &q->queue_flags))\n\t\treq->cpu = raw_smp_processor_id();\n\tplug = current->plug;\n\tif (plug) {\n\t\tif (!request_count || list_empty(&plug->list))\n\t\t\ttrace_block_plug(q);\n\t\telse {\n\t\t\tstruct request *last = list_entry_rq(plug->list.prev);\n\t\t\tif (request_count >= BLK_MAX_REQUEST_COUNT ||\n\t\t\t    blk_rq_bytes(last) >= BLK_PLUG_FLUSH_SIZE) {\n\t\t\t\tblk_flush_plug_list(plug, false);\n\t\t\t\ttrace_block_plug(q);\n\t\t\t}\n\t\t}\n\t\tlist_add_tail(&req->queuelist, &plug->list);\n\t\tblk_account_io_start(req, true);\n\t} else {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tadd_acct_request(q, req, where);\n\t\t__blk_run_queue(q);\nout_unlock:\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn BLK_QC_T_NONE;\n}\n#ifdef CONFIG_FAIL_MAKE_REQUEST\nstatic DECLARE_FAULT_ATTR(fail_make_request);\nstatic int __init setup_fail_make_request(char *str)\n{\n\treturn setup_fault_attr(&fail_make_request, str);\n}\n__setup(\"fail_make_request=\", setup_fail_make_request);\nstatic bool should_fail_request(struct hd_struct *part, unsigned int bytes)\n{\n\treturn part->make_it_fail && should_fail(&fail_make_request, bytes);\n}\nstatic int __init fail_make_request_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_make_request\",\n\t\t\t\t\t\tNULL, &fail_make_request);\n\treturn PTR_ERR_OR_ZERO(dir);\n}\nlate_initcall(fail_make_request_debugfs);\n#else \n#endif \nstatic noinline int should_fail_bio(struct bio *bio)\n{\n\tif (should_fail_request(&bio->bi_disk->part0, bio->bi_iter.bi_size))\n\t\treturn -EIO;\n\treturn 0;\n}\nstatic noinline_for_stack bool\ngeneric_make_request_checks(struct bio *bio)\n{\n\tstruct request_queue *q;\n\tint nr_sectors = bio_sectors(bio);\n\tblk_status_t status = BLK_STS_IOERR;\n\tchar b[BDEVNAME_SIZE];\n\tmight_sleep();\n\tq = bio->bi_disk->queue;\n\tif (unlikely(!q)) {\n\t\tprintk(KERN_ERR\n\t\t       \"generic_make_request: Trying to access \"\n\t\t\t\"nonexistent block-device %s (%Lu)\\n\",\n\t\t\tbio_devname(bio, b), (long long)bio->bi_iter.bi_sector);\n\t\tgoto end_io;\n\t}\n\tif ((bio->bi_opf & REQ_NOWAIT) && !queue_is_rq_based(q))\n\t\tgoto not_supported;\n\tif (should_fail_bio(bio))\n\t\tgoto end_io;\n\tif (bio->bi_partno) {\n\t\tif (unlikely(blk_partition_remap(bio)))\n\t\t\tgoto end_io;\n\t} else {\n\t\tif (unlikely(bio_check_ro(bio, &bio->bi_disk->part0)))\n\t\t\tgoto end_io;\n\t\tif (unlikely(bio_check_eod(bio, get_capacity(bio->bi_disk))))\n\t\t\tgoto end_io;\n\t}\n\tif (op_is_flush(bio->bi_opf) &&\n\t    !test_bit(QUEUE_FLAG_WC, &q->queue_flags)) {\n\t\tbio->bi_opf &= ~(REQ_PREFLUSH | REQ_FUA);\n\t\tif (!nr_sectors) {\n\t\t\tstatus = BLK_STS_OK;\n\t\t\tgoto end_io;\n\t\t}\n\t}\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_DISCARD:\n\t\tif (!blk_queue_discard(q))\n\t\t\tgoto not_supported;\n\t\tbreak;\n\tcase REQ_OP_SECURE_ERASE:\n\t\tif (!blk_queue_secure_erase(q))\n\t\t\tgoto not_supported;\n\t\tbreak;\n\tcase REQ_OP_WRITE_SAME:\n\t\tif (!q->limits.max_write_same_sectors)\n\t\t\tgoto not_supported;\n\t\tbreak;\n\tcase REQ_OP_ZONE_REPORT:\n\tcase REQ_OP_ZONE_RESET:\n\t\tif (!blk_queue_is_zoned(q))\n\t\t\tgoto not_supported;\n\t\tbreak;\n\tcase REQ_OP_WRITE_ZEROES:\n\t\tif (!q->limits.max_write_zeroes_sectors)\n\t\t\tgoto not_supported;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tcreate_io_context(GFP_ATOMIC, q->node);\n\tif (!blkcg_bio_issue_check(q, bio))\n\t\treturn false;\n\tif (!bio_flagged(bio, BIO_TRACE_COMPLETION)) {\n\t\ttrace_block_bio_queue(q, bio);\n\t\tbio_set_flag(bio, BIO_TRACE_COMPLETION);\n\t}\n\treturn true;\nnot_supported:\n\tstatus = BLK_STS_NOTSUPP;\nend_io:\n\tbio->bi_status = status;\n\tbio_endio(bio);\n\treturn false;\n}\nblk_qc_t generic_make_request(struct bio *bio)\n{\n\tstruct bio_list bio_list_on_stack[2];\n\tblk_mq_req_flags_t flags = 0;\n\tstruct request_queue *q = bio->bi_disk->queue;\n\tblk_qc_t ret = BLK_QC_T_NONE;\n\tif (bio->bi_opf & REQ_NOWAIT)\n\t\tflags = BLK_MQ_REQ_NOWAIT;\n\tif (bio_flagged(bio, BIO_QUEUE_ENTERED))\n\t\tblk_queue_enter_live(q);\n\telse if (blk_queue_enter(q, flags) < 0) {\n\t\tif (!blk_queue_dying(q) && (bio->bi_opf & REQ_NOWAIT))\n\t\t\tbio_wouldblock_error(bio);\n\t\telse\n\t\t\tbio_io_error(bio);\n\t\treturn ret;\n\t}\n\tif (!generic_make_request_checks(bio))\n\t\tgoto out;\n\tif (current->bio_list) {\n\t\tbio_list_add(&current->bio_list[0], bio);\n\t\tgoto out;\n\t}\n\tBUG_ON(bio->bi_next);\n\tbio_list_init(&bio_list_on_stack[0]);\n\tcurrent->bio_list = bio_list_on_stack;\n\tdo {\n\t\tbool enter_succeeded = true;\n\t\tif (unlikely(q != bio->bi_disk->queue)) {\n\t\t\tif (q)\n\t\t\t\tblk_queue_exit(q);\n\t\t\tq = bio->bi_disk->queue;\n\t\t\tflags = 0;\n\t\t\tif (bio->bi_opf & REQ_NOWAIT)\n\t\t\t\tflags = BLK_MQ_REQ_NOWAIT;\n\t\t\tif (blk_queue_enter(q, flags) < 0) {\n\t\t\t\tenter_succeeded = false;\n\t\t\t\tq = NULL;\n\t\t\t}\n\t\t}\n\t\tif (enter_succeeded) {\n\t\t\tstruct bio_list lower, same;\n\t\t\tbio_list_on_stack[1] = bio_list_on_stack[0];\n\t\t\tbio_list_init(&bio_list_on_stack[0]);\n\t\t\tret = q->make_request_fn(q, bio);\n\t\t\tbio_list_init(&lower);\n\t\t\tbio_list_init(&same);\n\t\t\twhile ((bio = bio_list_pop(&bio_list_on_stack[0])) != NULL)\n\t\t\t\tif (q == bio->bi_disk->queue)\n\t\t\t\t\tbio_list_add(&same, bio);\n\t\t\t\telse\n\t\t\t\t\tbio_list_add(&lower, bio);\n\t\t\tbio_list_merge(&bio_list_on_stack[0], &lower);\n\t\t\tbio_list_merge(&bio_list_on_stack[0], &same);\n\t\t\tbio_list_merge(&bio_list_on_stack[0], &bio_list_on_stack[1]);\n\t\t} else {\n\t\t\tif (unlikely(!blk_queue_dying(q) &&\n\t\t\t\t\t(bio->bi_opf & REQ_NOWAIT)))\n\t\t\t\tbio_wouldblock_error(bio);\n\t\t\telse\n\t\t\t\tbio_io_error(bio);\n\t\t}\n\t\tbio = bio_list_pop(&bio_list_on_stack[0]);\n\t} while (bio);\n\tcurrent->bio_list = NULL; \nout:\n\tif (q)\n\t\tblk_queue_exit(q);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_make_request);\nEXPORT_SYMBOL_GPL(direct_make_request);\nEXPORT_SYMBOL(submit_bio);\nEXPORT_SYMBOL_GPL(blk_poll);\nblk_status_t blk_insert_cloned_request(struct request_queue *q, struct request *rq)\n{\n\tunsigned long flags;\n\tint where = ELEVATOR_INSERT_BACK;\n\tif (blk_cloned_rq_check_limits(q, rq))\n\t\treturn BLK_STS_IOERR;\n\tif (rq->rq_disk &&\n\t    should_fail_request(&rq->rq_disk->part0, blk_rq_bytes(rq)))\n\t\treturn BLK_STS_IOERR;\n\tif (q->mq_ops) {\n\t\tif (blk_queue_io_stat(q))\n\t\t\tblk_account_io_start(rq, true);\n\t\treturn blk_mq_request_issue_directly(rq);\n\t}\n\tspin_lock_irqsave(q->queue_lock, flags);\n\tif (unlikely(blk_queue_dying(q))) {\n\t\tspin_unlock_irqrestore(q->queue_lock, flags);\n\t\treturn BLK_STS_IOERR;\n\t}\n\tBUG_ON(blk_queued_rq(rq));\n\tif (op_is_flush(rq->cmd_flags))\n\t\twhere = ELEVATOR_INSERT_FLUSH;\n\tadd_acct_request(q, rq, where);\n\tif (where == ELEVATOR_INSERT_FLUSH)\n\t\t__blk_run_queue(q);\n\tspin_unlock_irqrestore(q->queue_lock, flags);\n\treturn BLK_STS_OK;\n}\nEXPORT_SYMBOL_GPL(blk_insert_cloned_request);\nEXPORT_SYMBOL_GPL(blk_rq_err_bytes);\n#ifdef CONFIG_PM\nstatic bool blk_pm_allow_request(struct request *rq)\n{\n\tswitch (rq->q->rpm_status) {\n\tcase RPM_RESUMING:\n\tcase RPM_SUSPENDING:\n\t\treturn rq->rq_flags & RQF_PM;\n\tcase RPM_SUSPENDED:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n#else\n#endif\nstatic struct request *elv_next_request(struct request_queue *q)\n{\n\tstruct request *rq;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, NULL);\n\tWARN_ON_ONCE(q->mq_ops);\n\twhile (1) {\n\t\tlist_for_each_entry(rq, &q->queue_head, queuelist) {\n\t\t\tif (blk_pm_allow_request(rq))\n\t\t\t\treturn rq;\n\t\t\tif (rq->rq_flags & RQF_SOFTBARRIER)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (fq->flush_pending_idx != fq->flush_running_idx &&\n\t\t\t\t!queue_flush_queueable(q)) {\n\t\t\tfq->flush_queue_delayed = 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (unlikely(blk_queue_bypass(q)) ||\n\t\t    !q->elevator->type->ops.sq.elevator_dispatch_fn(q, 0))\n\t\t\treturn NULL;\n\t}\n}\nstruct request *blk_peek_request(struct request_queue *q)\n{\n\tstruct request *rq;\n\tint ret;\n\tlockdep_assert_held(q->queue_lock);\n\tWARN_ON_ONCE(q->mq_ops);\n\twhile ((rq = elv_next_request(q)) != NULL) {\n\t\tif (!(rq->rq_flags & RQF_STARTED)) {\n\t\t\tif (rq->rq_flags & RQF_SORTED)\n\t\t\t\telv_activate_rq(q, rq);\n\t\t\trq->rq_flags |= RQF_STARTED;\n\t\t\ttrace_block_rq_issue(q, rq);\n\t\t}\n\t\tif (!q->boundary_rq || q->boundary_rq == rq) {\n\t\t\tq->end_sector = rq_end_sector(rq);\n\t\t\tq->boundary_rq = NULL;\n\t\t}\n\t\tif (rq->rq_flags & RQF_DONTPREP)\n\t\t\tbreak;\n\t\tif (q->dma_drain_size && blk_rq_bytes(rq)) {\n\t\t\trq->nr_phys_segments++;\n\t\t}\n\t\tif (!q->prep_rq_fn)\n\t\t\tbreak;\n\t\tret = q->prep_rq_fn(q, rq);\n\t\tif (ret == BLKPREP_OK) {\n\t\t\tbreak;\n\t\t} else if (ret == BLKPREP_DEFER) {\n\t\t\tif (q->dma_drain_size && blk_rq_bytes(rq) &&\n\t\t\t    !(rq->rq_flags & RQF_DONTPREP)) {\n\t\t\t\t--rq->nr_phys_segments;\n\t\t\t}\n\t\t\trq = NULL;\n\t\t\tbreak;\n\t\t} else if (ret == BLKPREP_KILL || ret == BLKPREP_INVALID) {\n\t\t\trq->rq_flags |= RQF_QUIET;\n\t\t\tblk_start_request(rq);\n\t\t\t__blk_end_request_all(rq, ret == BLKPREP_INVALID ?\n\t\t\t\t\tBLK_STS_TARGET : BLK_STS_IOERR);\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: bad return=%d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rq;\n}\nEXPORT_SYMBOL(blk_peek_request);\nEXPORT_SYMBOL(blk_start_request);\nEXPORT_SYMBOL(blk_fetch_request);\nEXPORT_SYMBOL_GPL(blk_steal_bios);\nbool blk_update_request(struct request *req, blk_status_t error,\n\t\tunsigned int nr_bytes)\n{\n\tint total_bytes;\n\ttrace_block_rq_complete(req, blk_status_to_errno(error), nr_bytes);\n\tif (!req->bio)\n\t\treturn false;\n\tif (unlikely(error && !blk_rq_is_passthrough(req) &&\n\t\t     !(req->rq_flags & RQF_QUIET)))\n\t\tprint_req_error(req, error);\n\tblk_account_io_completion(req, nr_bytes);\n\ttotal_bytes = 0;\n\twhile (req->bio) {\n\t\tstruct bio *bio = req->bio;\n\t\tunsigned bio_bytes = min(bio->bi_iter.bi_size, nr_bytes);\n\t\tif (bio_bytes == bio->bi_iter.bi_size)\n\t\t\treq->bio = bio->bi_next;\n\t\tbio_clear_flag(bio, BIO_TRACE_COMPLETION);\n\t\treq_bio_endio(req, bio, bio_bytes, error);\n\t\ttotal_bytes += bio_bytes;\n\t\tnr_bytes -= bio_bytes;\n\t\tif (!nr_bytes)\n\t\t\tbreak;\n\t}\n\tif (!req->bio) {\n\t\treq->__data_len = 0;\n\t\treturn false;\n\t}\n\treq->__data_len -= total_bytes;\n\tif (!blk_rq_is_passthrough(req))\n\t\treq->__sector += total_bytes >> 9;\n\tif (req->rq_flags & RQF_MIXED_MERGE) {\n\t\treq->cmd_flags &= ~REQ_FAILFAST_MASK;\n\t\treq->cmd_flags |= req->bio->bi_opf & REQ_FAILFAST_MASK;\n\t}\n\tif (!(req->rq_flags & RQF_SPECIAL_PAYLOAD)) {\n\t\tif (blk_rq_bytes(req) < blk_rq_cur_bytes(req)) {\n\t\t\tblk_dump_rq_flags(req, \"request botched\");\n\t\t\treq->__data_len = blk_rq_cur_bytes(req);\n\t\t}\n\t\tblk_recalc_rq_segments(req);\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(blk_update_request);\nEXPORT_SYMBOL_GPL(blk_unprep_request);\nEXPORT_SYMBOL(blk_finish_request);\nEXPORT_SYMBOL(blk_end_request);\nEXPORT_SYMBOL(blk_end_request_all);\nEXPORT_SYMBOL(__blk_end_request);\nEXPORT_SYMBOL(__blk_end_request_all);\nEXPORT_SYMBOL(__blk_end_request_cur);\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE\nvoid rq_flush_dcache_pages(struct request *rq)\n{\n\tstruct req_iterator iter;\n\tstruct bio_vec bvec;\n\trq_for_each_segment(bvec, rq, iter)\n\t\tflush_dcache_page(bvec.bv_page);\n}\nEXPORT_SYMBOL_GPL(rq_flush_dcache_pages);\n#endif\nEXPORT_SYMBOL_GPL(blk_lld_busy);\nEXPORT_SYMBOL_GPL(blk_rq_unprep_clone);\nEXPORT_SYMBOL_GPL(blk_rq_prep_clone);\nEXPORT_SYMBOL(kblockd_schedule_work);\nEXPORT_SYMBOL(kblockd_schedule_work_on);\nEXPORT_SYMBOL(kblockd_mod_delayed_work_on);\nEXPORT_SYMBOL(blk_start_plug);\n\t__releases(q->queue_lock)\n{\n\tlockdep_assert_held(q->queue_lock);\n\ttrace_block_unplug(q, depth, !from_schedule);\n\tif (from_schedule)\n\t\tblk_run_queue_async(q);\n\telse\n\t\t__blk_run_queue(q);\n\tspin_unlock_irq(q->queue_lock);\n}\nEXPORT_SYMBOL(blk_check_plugged);\nvoid blk_flush_plug_list(struct blk_plug *plug, bool from_schedule)\n{\n\tstruct request_queue *q;\n\tstruct request *rq;\n\tLIST_HEAD(list);\n\tunsigned int depth;\n\tflush_plug_callbacks(plug, from_schedule);\n\tif (!list_empty(&plug->mq_list))\n\t\tblk_mq_flush_plug_list(plug, from_schedule);\n\tif (list_empty(&plug->list))\n\t\treturn;\n\tlist_splice_init(&plug->list, &list);\n\tlist_sort(NULL, &list, plug_rq_cmp);\n\tq = NULL;\n\tdepth = 0;\n\twhile (!list_empty(&list)) {\n\t\trq = list_entry_rq(list.next);\n\t\tlist_del_init(&rq->queuelist);\n\t\tBUG_ON(!rq->q);\n\t\tif (rq->q != q) {\n\t\t\tif (q)\n\t\t\t\tqueue_unplugged(q, depth, from_schedule);\n\t\t\tq = rq->q;\n\t\t\tdepth = 0;\n\t\t\tspin_lock_irq(q->queue_lock);\n\t\t}\n\t\tif (unlikely(blk_queue_dying(q))) {\n\t\t\t__blk_end_request_all(rq, BLK_STS_IOERR);\n\t\t\tcontinue;\n\t\t}\n\t\tif (op_is_flush(rq->cmd_flags))\n\t\t\t__elv_add_request(q, rq, ELEVATOR_INSERT_FLUSH);\n\t\telse\n\t\t\t__elv_add_request(q, rq, ELEVATOR_INSERT_SORT_MERGE);\n\t\tdepth++;\n\t}\n\tif (q)\n\t\tqueue_unplugged(q, depth, from_schedule);\n}\nEXPORT_SYMBOL(blk_finish_plug);\n#ifdef CONFIG_PM\nvoid blk_pm_runtime_init(struct request_queue *q, struct device *dev)\n{\n\tif (q->mq_ops)\n\t\treturn;\n\tq->dev = dev;\n\tq->rpm_status = RPM_ACTIVE;\n\tpm_runtime_set_autosuspend_delay(q->dev, -1);\n\tpm_runtime_use_autosuspend(q->dev);\n}\nEXPORT_SYMBOL(blk_pm_runtime_init);\nint blk_pre_runtime_suspend(struct request_queue *q)\n{\n\tint ret = 0;\n\tif (!q->dev)\n\t\treturn ret;\n\tspin_lock_irq(q->queue_lock);\n\tif (q->nr_pending) {\n\t\tret = -EBUSY;\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t} else {\n\t\tq->rpm_status = RPM_SUSPENDING;\n\t}\n\tspin_unlock_irq(q->queue_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_pre_runtime_suspend);\nvoid blk_post_runtime_suspend(struct request_queue *q, int err)\n{\n\tif (!q->dev)\n\t\treturn;\n\tspin_lock_irq(q->queue_lock);\n\tif (!err) {\n\t\tq->rpm_status = RPM_SUSPENDED;\n\t} else {\n\t\tq->rpm_status = RPM_ACTIVE;\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t}\n\tspin_unlock_irq(q->queue_lock);\n}\nEXPORT_SYMBOL(blk_post_runtime_suspend);\nvoid blk_pre_runtime_resume(struct request_queue *q)\n{\n\tif (!q->dev)\n\t\treturn;\n\tspin_lock_irq(q->queue_lock);\n\tq->rpm_status = RPM_RESUMING;\n\tspin_unlock_irq(q->queue_lock);\n}\nEXPORT_SYMBOL(blk_pre_runtime_resume);\nvoid blk_post_runtime_resume(struct request_queue *q, int err)\n{\n\tif (!q->dev)\n\t\treturn;\n\tspin_lock_irq(q->queue_lock);\n\tif (!err) {\n\t\tq->rpm_status = RPM_ACTIVE;\n\t\t__blk_run_queue(q);\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t\tpm_request_autosuspend(q->dev);\n\t} else {\n\t\tq->rpm_status = RPM_SUSPENDED;\n\t}\n\tspin_unlock_irq(q->queue_lock);\n}\nEXPORT_SYMBOL(blk_post_runtime_resume);\nvoid blk_set_runtime_active(struct request_queue *q)\n{\n\tspin_lock_irq(q->queue_lock);\n\tq->rpm_status = RPM_ACTIVE;\n\tpm_runtime_mark_last_busy(q->dev);\n\tpm_request_autosuspend(q->dev);\n\tspin_unlock_irq(q->queue_lock);\n}\nEXPORT_SYMBOL(blk_set_runtime_active);\n#endif\nint __init blk_dev_init(void)\n{\n\tBUILD_BUG_ON(REQ_OP_LAST >= (1 << REQ_OP_BITS));\n\tBUILD_BUG_ON(REQ_OP_BITS + REQ_FLAG_BITS > 8 *\n\t\t\tFIELD_SIZEOF(struct request, cmd_flags));\n\tBUILD_BUG_ON(REQ_OP_BITS + REQ_FLAG_BITS > 8 *\n\t\t\tFIELD_SIZEOF(struct bio, bi_opf));\n\tkblockd_workqueue = alloc_workqueue(\"kblockd\",\n\t\t\t\t\t    WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);\n\tif (!kblockd_workqueue)\n\t\tpanic(\"Failed to create kblockd\\n\");\n\trequest_cachep = kmem_cache_create(\"blkdev_requests\",\n\t\t\tsizeof(struct request), 0, SLAB_PANIC, NULL);\n\tblk_requestq_cachep = kmem_cache_create(\"request_queue\",\n\t\t\tsizeof(struct request_queue), 0, SLAB_PANIC, NULL);\n#ifdef CONFIG_DEBUG_FS\n\tblk_debugfs_root = debugfs_create_dir(\"block\", NULL);\n#endif\n\treturn 0;\n}\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_3644.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)\n\tchar file_dirname[MAXPATHLEN];\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\tpath_cleaned_len = strlen(path_cleaned);\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t}\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\t}\n\tzval *zval_files = NULL;\n\tzval *zval_file = NULL;\n\tif (!self) {\n\t}\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t}\n\tif (pathto_len < 1) {\n\t}\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t}\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) {\n\t\t\t\t}\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t} else {\n\t\tif (filecount == -1) {\n\t\t}\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file))) {\n\t\t\t}\n\t\t}\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/pcre/php_pcre.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_zip.h\"\nstatic PHP_NAMED_FUNCTION(zif_zip_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_close);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close);\n#ifdef HAVE_GLOB\n#ifndef PHP_WIN32\n#include <glob.h>\n#else\n#include \"win32/glob.h\"\n#endif\n#endif\nstatic int le_zip_dir;\n#define le_zip_dir_name \"Zip Directory\"\nstatic int le_zip_entry;\n#define le_zip_entry_name \"Zip Entry\"\n#define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \\\n\tif (zip_stat_index(za, index, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n#define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \\\n\tif (path_len < 1) { \\\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\"); \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tif (zip_stat(za, path, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n#define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \\\n\tif (comment_len == 0) { \\\n\t\t \\\n\t\tif (zip_set_file_comment(za, index, NULL, 0) < 0) { \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t} else if (zip_set_file_comment(za, index, comment, comment_len) < 0) { \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tRETURN_TRUE;\n# define add_ascii_assoc_string add_assoc_string\n# define add_ascii_assoc_long add_assoc_long\n# define CWD_STATE_ALLOC(l) emalloc(l)\n# define CWD_STATE_FREE(s)  efree(s)\nstatic int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\tzend_string *file_basename;\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\t\tfile_basename =\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0);\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tzend_string_release(file_basename);\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tzend_string_release(file_basename);\n\t\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 1;\n\t}\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, ZSTR_VAL(file_basename));\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\tn = 0;\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\ndone:\n\tefree(fullpath);\n\tzend_string_release(file_basename);\n\tefree(file_dirname_fullpath);\n\tCWD_STATE_FREE(new_state.cwd);\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\nstatic int php_zip_parse_options(zval *options, zend_long *remove_all_path, char **remove_path, size_t *remove_path_len, char **add_path, size_t *add_path_len) \n{\n\tzval *option;\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_all_path\", sizeof(\"remove_all_path\") - 1)) != NULL) {\n\t\t*remove_all_path = zval_get_long(option);\n\t}\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_path\", sizeof(\"remove_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path string is too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_P(option);\n\t\t*remove_path = Z_STRVAL_P(option);\n\t}\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"add_path\", sizeof(\"add_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_P(option);\n\t\t*add_path = Z_STRVAL_P(option);\n\t}\n\treturn 1;\n}\n#define REGISTER_ZIP_CLASS_CONST_LONG(const_name, value) \\\n\t    zend_declare_class_constant_long(zip_class_entry, const_name, sizeof(const_name)-1, (zend_long)value);\n#define ZIP_FROM_OBJECT(intern, object) \\\n\t{ \\\n\t\tze_zip_object *obj = Z_ZIP_P(object); \\\n\t\tintern = obj->za; \\\n\t\tif (!intern) { \\\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid or uninitialized Zip object\"); \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t}\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t}\n#ifdef HAVE_GLOB \n#ifndef GLOB_ONLYDIR\n#define GLOB_ONLYDIR (1<<30)\n#define GLOB_EMULATE_ONLYDIR\n#define GLOB_FLAGMASK (~GLOB_ONLYDIR)\n#else\n#define GLOB_FLAGMASK (~0)\n#endif\n#ifndef GLOB_BRACE\n# define GLOB_BRACE 0\n#endif\n#ifndef GLOB_MARK\n# define GLOB_MARK 0\n#endif\n#ifndef GLOB_NOSORT\n# define GLOB_NOSORT 0\n#endif\n#ifndef GLOB_NOCHECK\n# define GLOB_NOCHECK 0\n#endif\n#ifndef GLOB_NOESCAPE\n# define GLOB_NOESCAPE 0\n#endif\n#ifndef GLOB_ERR\n# define GLOB_ERR 0\n#endif\n#define GLOB_AVAILABLE_FLAGS (0 | GLOB_BRACE | GLOB_MARK | GLOB_NOSORT | GLOB_NOCHECK | GLOB_NOESCAPE | GLOB_ERR | GLOB_ONLYDIR)\n#endif \nint php_zip_glob(char *pattern, int pattern_len, zend_long flags, zval *return_value) \n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tzend_stat_t s;\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip);\n\t}\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  \n}\nint php_zip_pcre(zend_string *regexp, char *path, int path_len, zval *return_value) \n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tzend_string **namelist;\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\tif (files_cnt > 0) {\n\t\tpcre *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\t\tarray_init(return_value);\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tzend_stat_t s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = ZSTR_LEN(namelist[i]);\n\t\t\tif ((namelist_len == 1 && ZSTR_VAL(namelist[i])[0] == '.') ||\n\t\t\t\t(namelist_len == 2 && ZSTR_VAL(namelist[i])[0] == '.' && ZSTR_VAL(namelist[i])[1] == '.')) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, ZSTR_VAL(namelist[i]));\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmatches = pcre_exec(re, NULL, ZSTR_VAL(namelist[i]), ZSTR_LEN(namelist[i]), 0, 0, ovector, 3);\n\t\t\tif (matches < 0) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd_next_index_string(return_value, fullpath);\n\t\t\tzend_string_release(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_open, 0, 0, 2)\n\tZEND_ARG_INFO(0, zip_dp)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_ent)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, len)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_name, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressedsize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_filesize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressionmethod, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\nstatic const zend_function_entry zip_functions[] = {\n\tZEND_RAW_FENTRY(\"zip_open\", zif_zip_open, arginfo_zip_open, 0)\n\tZEND_RAW_FENTRY(\"zip_close\", zif_zip_close, arginfo_zip_close, 0)\n\tZEND_RAW_FENTRY(\"zip_read\", zif_zip_read, arginfo_zip_read, 0)\n\tPHP_FE(zip_entry_open,\t\targinfo_zip_entry_open)\n\tPHP_FE(zip_entry_close,\t\targinfo_zip_entry_close)\n\tPHP_FE(zip_entry_read,\t\targinfo_zip_entry_read)\n\tPHP_FE(zip_entry_filesize,\targinfo_zip_entry_filesize)\n\tPHP_FE(zip_entry_name,\t\targinfo_zip_entry_name)\n\tPHP_FE(zip_entry_compressedsize,\t\targinfo_zip_entry_compressedsize)\n\tPHP_FE(zip_entry_compressionmethod,\t\targinfo_zip_entry_compressionmethod)\n#ifdef  PHP_FE_END\n\tPHP_FE_END\n#else\n\t{NULL,NULL,NULL}\n#endif\n};\nstatic zend_class_entry *zip_class_entry;\nstatic zend_object_handlers zip_object_handlers;\nstatic HashTable zip_prop_handlers;\ntypedef int (*zip_read_int_t)(struct zip *za);\ntypedef char *(*zip_read_const_char_t)(struct zip *za, int *len);\ntypedef char *(*zip_read_const_char_from_ze_t)(ze_zip_object *obj);\ntypedef struct _zip_prop_handler {\n\tzip_read_int_t read_int_func;\n\tzip_read_const_char_t read_const_char_func;\n\tzip_read_const_char_from_ze_t read_const_char_from_obj_func;\n\tint type;\n} zip_prop_handler;\nstatic PHP_MINIT_FUNCTION(zip);\nstatic PHP_MSHUTDOWN_FUNCTION(zip);\nstatic PHP_MINFO_FUNCTION(zip);\nzend_module_entry zip_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"zip\",\n\tzip_functions,\n\tPHP_MINIT(zip),\n\tPHP_MSHUTDOWN(zip),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(zip),\n\tPHP_ZIP_VERSION,\n\tSTANDARD_MODULE_PROPERTIES\n};\n#ifdef COMPILE_DL_ZIP\nZEND_GET_MODULE(zip)\n#endif\nstatic PHP_NAMED_FUNCTION(zif_zip_open)\n{\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tzend_string *filename;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\tif(!expand_filepath(ZSTR_VAL(filename), resolved_path)) {\n\t\tRETURN_FALSE;\n\t}\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_files(rsrc_int->za);\n\tRETURN_RES(zend_register_resource(rsrc_int, le_zip_dir));\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_close)\n{\n\tzval * zip;\n\tzip_rsrc *z_rsrc = NULL;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tzend_list_close(Z_RES_P(zip));\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_read)\n{\n\tzval *zip_dp;\n\tzip_read_rsrc *zr_rsrc;\n\tint ret;\n\tzip_rsrc *rsrc_int;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_dp) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((rsrc_int = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip_dp), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (rsrc_int && rsrc_int->za) {\n\t\tif (rsrc_int->index_current >= rsrc_int->num_files) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzr_rsrc = emalloc(sizeof(zip_read_rsrc));\n\t\tret = zip_stat_index(rsrc_int->za, rsrc_int->index_current, 0, &zr_rsrc->sb);\n\t\tif (ret != 0) {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzr_rsrc->zf = zip_fopen_index(rsrc_int->za, rsrc_int->index_current, 0);\n\t\tif (zr_rsrc->zf) {\n\t\t\trsrc_int->index_current++;\n\t\t\tRETURN_RES(zend_register_resource(zr_rsrc, le_zip_entry));\n\t\t} else {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open)\n{\n\tzval * zip;\n\tzval * zip_entry;\n\tchar *mode = NULL;\n\tsize_t mode_len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzip_rsrc *z_rsrc;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rr|s\", &zip, &zip_entry, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zr_rsrc->zf != NULL) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close)\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(SUCCESS == zend_list_close(Z_RES_P(zip_entry)));\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\nstatic void php_zip_entry_get_info(INTERNAL_FUNCTION_PARAMETERS, int opt) \n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (!zr_rsrc->zf) {\n\t\tRETURN_FALSE;\n\t}\n\tswitch (opt) {\n\t\tcase 0:\n\t\t\tRETURN_STRING((char *)zr_rsrc->sb.name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_size));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.size));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (zr_rsrc->sb.comp_method) {\n\t\t\t\tcase 0:\n\t\t\t\t\tRETURN_STRING(\"stored\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tRETURN_STRING(\"shrunk\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\t\tRETURN_STRING(\"reduced\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tRETURN_STRING(\"imploded\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tRETURN_STRING(\"tokenized\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tRETURN_STRING(\"deflated\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tRETURN_STRING(\"deflatedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tRETURN_STRING(\"implodedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_method));\n\t\t\tbreak;\n\t}\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\nstatic ZIPARCHIVE_METHOD(open)\n{\n\tstruct zip *intern;\n\tint err = 0;\n\tzend_long flags = 0;\n\tchar *resolved_path;\n\tzend_string *filename;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj = NULL;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (self) {\n\t\tze_obj = Z_ZIP_P(self);\n\t}\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\tif (!(resolved_path = expand_filepath(ZSTR_VAL(filename), NULL))) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ze_obj->za) {\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\t\tefree(resolved_path);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tefree(resolved_path);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\tze_obj->filename = resolved_path;\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\nstatic void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tsize_t  add_path_len, remove_path_len = 0, path_len = 0;\n\tzend_long remove_all_path = 0;\n\tzend_long flags = 0;\n\tzval *options = NULL;\n\tint found;\n\tzend_string *pattern;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|la\",\n\t\t\t\t\t&pattern, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sa\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (remove_path && remove_path_len > 1) {\n\t\tsize_t real_len = strlen(remove_path);\n\t\tif ((real_len > 1) && ((remove_path[real_len - 1] == '/') || (remove_path[real_len - 1] == '\\\\'))) {\n\t\t\tremove_path[real_len - 1] = '\\0';\n\t\t}\n\t}\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_P(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %pd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_ptr_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_P(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_string *buffer;\n\tchar *name;\n\tsize_t name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sS\",\n\t\t\t&name, &name_len, &buffer) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = Z_ZIP_P(self);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(ZSTR_LEN(buffer) + 1);\n\tmemcpy(ze_obj->buffers[pos], ZSTR_VAL(buffer), ZSTR_LEN(buffer) + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], ZSTR_LEN(buffer), 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) == -1) {\n\t\tzip_source_free(zs);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETURN_TRUE;\n\t}\n}\n#ifdef ZIP_OPSYS_DEFAULT\nstatic ZIPARCHIVE_METHOD(setExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0, opsys, attr;\n\tzip_int64_t idx;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll|l\",\n\t\t\t&name, &name_len, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_set_external_attributes(intern, idx, (zip_flags_t)flags,\n\t\t\t(zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\nstatic ZIPARCHIVE_METHOD(setExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags=0, opsys, attr;\n\tstruct zip_stat sb;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lll|l\",\n\t\t\t&index, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_set_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, (zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\nstatic ZIPARCHIVE_METHOD(getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_ptr_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_ptr_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\nstatic ZIPARCHIVE_METHOD(getExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tzend_long index, flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tstruct zip_stat sb;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lz/z/|l\",\n\t\t\t&index, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_get_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n#endif \nstatic ZIPARCHIVE_METHOD(extractTo)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzval *zval_files = NULL;\n\tzval *zval_file = NULL;\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tsize_t pathto_len;\n\tint ret, i;\n\tint nelems;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t\treturn;\n\t}\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\t\tif (!ret) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) {\n\t\t\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_LONG:\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid argument, expect string or array of strings\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tint filecount = zip_get_num_files(intern);\n\t\tif (filecount == -1) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal archive\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tchar *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\tRETURN_TRUE;\n}\nstatic void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setpassword, 0, 0, 1)\n\tZEND_ARG_INFO(0, password)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO(arginfo_ziparchive__void, 0)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addemptydir, 0, 0, 1)\n\tZEND_ARG_INFO(0, dirname)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addglob, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, flags)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addpattern, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfile, 0, 0, 1)\n\tZEND_ARG_INFO(0, filepath)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfromstring, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, content)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statname, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setarchivecomment, 0, 0, 1)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentname, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renameindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renamename, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangeindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangename, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_extractto, 0, 0, 1)\n\tZEND_ARG_INFO(0, pathto)\n\tZEND_ARG_INFO(0, files)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromname, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getarchivecomment, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getstream, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\nZEND_END_ARG_INFO()\n#ifdef ZIP_OPSYS_DEFAULT\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n#endif \nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\nstatic const zend_function_entry zip_class_functions[] = {\n\tZIPARCHIVE_ME(open,\t\t\t\t\targinfo_ziparchive_open, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setPassword,\t\t\targinfo_ziparchive_setpassword, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(close,\t\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStatusString,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addEmptyDir,\t\t\targinfo_ziparchive_addemptydir, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFromString,\t\targinfo_ziparchive_addfromstring, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFile,\t\t\t\targinfo_ziparchive_addfile, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addGlob,\t\t\t\targinfo_ziparchive_addglob, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addPattern,\t\t\targinfo_ziparchive_addpattern, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameIndex,\t\t\targinfo_ziparchive_renameindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameName,\t\t\targinfo_ziparchive_renamename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setArchiveComment,\targinfo_ziparchive_setarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getArchiveComment,\targinfo_ziparchive_getarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentIndex,\t\targinfo_ziparchive_setcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentName,\t\targinfo_ziparchive_setcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentIndex,\t\targinfo_ziparchive_getcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentName,\t\targinfo_ziparchive_getcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteIndex,\t\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statName,\t\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(locateName,\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getNameIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeArchive,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeAll,\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeIndex,\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(extractTo,\t\t\targinfo_ziparchive_extractto, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromName,\t\t\targinfo_ziparchive_getfromname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromIndex,\t\t\targinfo_ziparchive_getfromindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStream,\t\t\targinfo_ziparchive_getstream, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesName,\targinfo_ziparchive_setextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesIndex,\targinfo_ziparchive_setextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesName,\targinfo_ziparchive_getextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesIndex,\targinfo_ziparchive_getextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionName,\t\targinfo_ziparchive_setcompname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionIndex,\t\targinfo_ziparchive_setcompindex, ZEND_ACC_PUBLIC)\n\t{NULL, NULL, NULL}\n};\nstatic PHP_MINIT_FUNCTION(zip)\n{\n\tzend_class_entry ce;\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.offset = XtOffsetOf(ze_zip_object, zo);\n\tzip_object_handlers.free_obj = php_zip_object_free_storage;\n\tzip_object_handlers.clone_obj = NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce);\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, php_zip_free_prop_handler, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t\n#ifdef ZIP_OPSYS_DEFAULT\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DOS\",\t\t\t\tZIP_OPSYS_DOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_AMIGA\",\t\t\tZIP_OPSYS_AMIGA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OPENVMS\",\t\t\tZIP_OPSYS_OPENVMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_UNIX\",\t\t\t\tZIP_OPSYS_UNIX);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VM_CMS\",\t\t\tZIP_OPSYS_VM_CMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ATARI_ST\",\t\t\tZIP_OPSYS_ATARI_ST);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_2\",\t\t\t\tZIP_OPSYS_OS_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MACINTOSH\",\t\tZIP_OPSYS_MACINTOSH);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_SYSTEM\",\t\t\tZIP_OPSYS_Z_SYSTEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_CPM\",\t\t\tZIP_OPSYS_CPM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_WINDOWS_NTFS\",\t\tZIP_OPSYS_WINDOWS_NTFS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MVS\",\t\t\t\tZIP_OPSYS_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VSE\",\t\t\t\tZIP_OPSYS_VSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ACORN_RISC\",\t\tZIP_OPSYS_ACORN_RISC);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VFAT\",\t\t\t\tZIP_OPSYS_VFAT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ALTERNATE_MVS\",\tZIP_OPSYS_ALTERNATE_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_BEOS\",\t\t\t\tZIP_OPSYS_BEOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_TANDEM\",\t\t\tZIP_OPSYS_TANDEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_400\",\t\t\tZIP_OPSYS_OS_400);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_X\",\t\t\t\tZIP_OPSYS_OS_X);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DEFAULT\", ZIP_OPSYS_DEFAULT);\n#endif \n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper);\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\treturn SUCCESS;\n}\n",
        "cwe": "CWE-190",
        "file_name": "safe_respovul_idx_1251.c",
        "project": "php/php-src",
        "url": "https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\tr_return_val_if_fail (bf, -1);\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t}\n\tif (from > to) {\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t} else {\n\t}\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\twhile (needle < to && needle < UT64_MAX - 4) {\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t}\n\t\t\tneedle += rc;\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t} else {\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t}\n\t\ttmp[i++] = '\\0';\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\nstatic void get_strings_range(RBinFile *bf, RList *list, int min, int raw, ut64 from, ut64 to, RBinSection *section) {\n\tr_return_if_fail (bf && bf->buf);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tif (!raw && (!plugin || !plugin->info)) {\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\tif (min < 0) {\n\t}\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\t\tif (cb && cb->cfgGet) {\n\t\t\tif (!cfg_debug) {\n\t\t\t\tif (!to || to > r_buf_size (bf->buf)) {\n\t\t\t\t\tto = r_buf_size (bf->buf);\n\t\t\t\t}\n\t\t\t\tif (!to) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (raw != 2) {\n\t\tut64 size = to - from;\n\t}\n\tif (!enc) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t} else if (!strcmp (enc, \"latin1\")) {\n\t\ttype = R_STRING_TYPE_ASCII;\n\t} else if (!strcmp (enc, \"utf8\")) {\n\t\ttype = R_STRING_TYPE_UTF8;\n\t} else if (!strcmp (enc, \"utf16le\")) {\n\t\ttype = R_STRING_TYPE_WIDE;\n\t} else if (!strcmp (enc, \"utf32le\")) {\n\t\ttype = R_STRING_TYPE_WIDE32;\n\t} else { // TODO utf16be, utf32be\n\tstring_scan_range (list, bf, min, from, to, type, raw, section);\n}\nR_IPI RList *r_bin_file_get_strings(RBinFile *bf, int min, int dump, int raw) {\n\tr_return_val_if_fail (bf, NULL);\n\tRList *ret = dump? NULL: r_list_newf (r_bin_string_free);\n\tif (!raw && bf && bf->o && bf->o->sections && !r_list_empty (bf->o->sections)) {\n\t\tRBinObject *o = bf->o;\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (__isDataSection (bf, section)) {\n\t\t\t\tget_strings_range (bf, ret, min, raw, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size, section);\n\t\t\t}\n\t} else {\n\t\tget_strings_range (bf, ret, min, raw, 0, bf->size, NULL);\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <r_bin.h>\n#include <r_hash.h>\n#include \"i/private.h\"\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n#define R_STRING_MAX_UNI_BLOCKS 4\nstatic void print_string(RBinFile *bf, RBinString *string, int raw, PJ *pj) {\n\tr_return_if_fail (bf && string);\n\tint mode = bf->strmode;\n\tRBin *bin = bf->rbin;\n\tif (!bin) {\n\t\treturn;\n\t}\n\tRIO *io = bin->iob.io;\n\tif (!io) {\n\t\treturn;\n\t}\n\tRBinSection *s = r_bin_get_section_at (bf->o, string->paddr, false);\n\tif (s) {\n\t\tstring->vaddr = s->vaddr + (string->paddr - s->paddr);\n\t}\n\tconst char *section_name = s ? s->name : \"\";\n\tconst char *type_string = r_bin_string_type (string->type);\n\tut64 vaddr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);\n\tut64 addr = vaddr;\n\t// If raw string dump mode, use printf to dump directly to stdout.\n\t//  PrintfCallback temp = io->cb_printf;\n\tswitch (mode) {\n\tcase R_MODE_JSON:\n\t\t{\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"vaddr\", vaddr);\n\t\t\t\tpj_kn (pj, \"paddr\", string->paddr);\n\t\t\t\tpj_kn (pj, \"ordinal\", string->ordinal);\n\t\t\t\tpj_kn (pj, \"size\", string->size);\n\t\t\t\tpj_kn (pj, \"length\", string->length);\n\t\t\t\tpj_ks (pj, \"section\", section_name);\n\t\t\t\tpj_ks (pj, \"type\", type_string);\n\t\t\t\tpj_ks (pj, \"string\", string->string);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_MODE_SIMPLEST:\n\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\tbreak;\n\tcase R_MODE_SIMPLE:\n\t\tif (raw == 2) {\n\t\t\tio->cb_printf (\"0x%08\"PFMT64x\" %s\\n\", addr, string->string);\n\t\t} else {\n\t\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\t}\n\t\tbreak;\n\tcase R_MODE_RADARE: {\n\t\tchar *f_name = strdup (string->string);\n\t\tr_name_filter (f_name, -1);\n\t\tif (bin->prefix) {\n\t\t\tio->cb_printf (\"f %s.str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tbin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t} else {\n\t\t\tio->cb_printf (\"f str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t}\n\t\tfree (f_name);\n\t\tbreak;\n\t\t}\n\tcase R_MODE_PRINT:\n\t\tio->cb_printf (\"%03u 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %3u %3u \"\n\t\t\t       \"(%s) %5s %s\\n\",\n\t\t\tstring->ordinal, string->paddr, vaddr,\n\t\t\tstring->length, string->size,\n\t\t\tsection_name, type_string, string->string);\n\t\tbreak;\n\t}\n}\nstatic int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to && needle < UT64_MAX - 4) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tneedle += rc;\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttmp[i++] = '\\0';\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}\nstatic void get_strings_range(RBinFile *bf, RList *list, int min, int raw, ut64 from, ut64 to, RBinSection *section) {\n\tr_return_if_fail (bf && bf->buf);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tif (!raw && (!plugin || !plugin->info)) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\t{\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tRCoreBind *cb = &io->coreb;\n\t\tif (cb && cb->cfgGet) {\n\t\t\tconst bool cfg_debug = cb->cfgGet (cb->core, \"cfg.debug\");\n\t\t\tif (!cfg_debug) {\n\t\t\t\tif (!to || to > r_buf_size (bf->buf)) {\n\t\t\t\t\tto = r_buf_size (bf->buf);\n\t\t\t\t}\n\t\t\t\tif (!to) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (raw != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (bf->rbin->maxstrbuf && size && size > bf->rbin->maxstrbuf) {\n\t\t\tif (bf->rbin->verbose) {\n\t\t\t\tR_LOG_WARN (\"bin_strings buffer is too big (0x%08\" PFMT64x \"). Use -zzz or set bin.maxstrbuf (RABIN2_MAXSTRBUF) in r2 (rabin2)\", size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tint type;\n\tconst char *enc = bf->rbin->strenc;\n\tif (!enc) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t} else if (!strcmp (enc, \"latin1\")) {\n\t\ttype = R_STRING_TYPE_ASCII;\n\t} else if (!strcmp (enc, \"utf8\")) {\n\t\ttype = R_STRING_TYPE_UTF8;\n\t} else if (!strcmp (enc, \"utf16le\")) {\n\t\ttype = R_STRING_TYPE_WIDE;\n\t} else if (!strcmp (enc, \"utf32le\")) {\n\t\ttype = R_STRING_TYPE_WIDE32;\n\t} else { // TODO utf16be, utf32be\n\t\teprintf (\"ERROR: encoding %s not supported\\n\", enc);\n\t\treturn;\n\t}\n\tstring_scan_range (list, bf, min, from, to, type, raw, section);\n}\nR_IPI \nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {\n\tr_return_val_if_fail (bin && bf && data, false);\n\tut64 offset = data->offset;\n\tut64 sz = data->size;\n\tRBinPlugin *plugin = get_plugin_from_buffer (bin, bf, NULL, data->buf);\n\tbf->buf = r_buf_ref (data->buf);\n\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\tif (!o) {\n\t\treturn false;\n\t}\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tR_FREE (o->info->file);\n\tR_FREE (o->info->arch);\n\tR_FREE (o->info->machine);\n\tR_FREE (o->info->type);\n\to->info->file = strdup (bf->file);\n\tif (data->metadata) {\n\t\tif (data->metadata->arch) {\n\t\t\to->info->arch = strdup (data->metadata->arch);\n\t\t}\n\t\tif (data->metadata->machine) {\n\t\t\to->info->machine = strdup (data->metadata->machine);\n\t\t}\n\t\tif (data->metadata->type) {\n\t\t\to->info->type = strdup (data->metadata->type);\n\t\t}\n\t\to->info->bits = data->metadata->bits;\n\t}\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\nR_IPI \nR_API \nR_IPI \nR_API \nR_API \nR_API \nR_API \nR_API \nR_API \nR_IPI \nR_API \nR_API \nR_API \nR_API \nR_IPI RBinFile *r_bin_file_xtr_load_buffer(RBin *bin, RBinXtrPlugin *xtr, const char *filename, RBuffer *buf, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {\n\tr_return_val_if_fail (bin && xtr && buf, NULL);\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_new (bin, filename, r_buf_size (buf), rawstr, fd, xtr->name, bin->sdb, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (bin->binfiles, bf);\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tr_list_free (bf->xtr_data);\n\tbf->xtr_data = NULL;\n\tif (xtr->extractall_from_buffer) {\n\t\tbf->xtr_data = xtr->extractall_from_buffer (bin, buf);\n\t} else if (xtr->extractall_from_bytes) {\n\t\tut64 sz = 0;\n\t\tconst ut8 *bytes = r_buf_data (buf, &sz);\n\t\teprintf (\"TODO: Implement extractall_from_buffer in '%s' xtr.bin plugin\\n\", xtr->name);\n\t\tbf->xtr_data = xtr->extractall_from_bytes (bin, bytes, sz);\n\t}\n\tif (bf->xtr_data) {\n\t\tRListIter *iter;\n\t\tRBinXtrData *x;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (bf->xtr_data, iter, x) {\n\t\t\tx->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\tx->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t}\n\tbf->loadaddr = loadaddr;\n\treturn bf;\n}\nR_IPI \nR_API \nR_IPI RList *r_bin_file_get_strings(RBinFile *bf, int min, int dump, int raw) {\n\tr_return_val_if_fail (bf, NULL);\n\tRListIter *iter;\n\tRBinSection *section;\n\tRList *ret = dump? NULL: r_list_newf (r_bin_string_free);\n\tif (!raw && bf && bf->o && bf->o->sections && !r_list_empty (bf->o->sections)) {\n\t\tRBinObject *o = bf->o;\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (__isDataSection (bf, section)) {\n\t\t\t\tget_strings_range (bf, ret, min, raw, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size, section);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tconst int bits = (bf->o && bf->o->info) ? bf->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n\t\t\t\t// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tif (section->size > bf->size) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut8 *sbuf = malloc (section->size);\n\t\t\t\tif (!sbuf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, section->paddr + cfstr_offs, sbuf, section->size);\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 *buf = sbuf;\n\t\t\t\t\tp = buf + i;\n\t\t\t\t\tif ((i + ((bits == 64)? 8: 4)) >= section->size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64) ? r_read_le64 (p) : r_read_le32 (p);\n\t\t\t\t\tRBinString *s = __stringAt (bf, ret, cstr_vaddr);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\t\t\t\tif (bs) {\n\t\t\t\t\t\t\tbs->type = s->type;\n\t\t\t\t\t\t\tbs->length = s->length;\n\t\t\t\t\t\t\tbs->size = s->size;\n\t\t\t\t\t\t\tbs->ordinal = s->ordinal;\n\t\t\t\t\t\t\tbs->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\tbs->paddr = cfstr_vaddr; // XXX should be paddr instead\n\t\t\t\t\t\t\tbs->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\tr_list_append (ret, bs);\n\t\t\t\t\t\t\tht_up_insert (o->strings_db, bs->vaddr, bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (sbuf);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tget_strings_range (bf, ret, min, raw, 0, bf->size, NULL);\n\t}\n\treturn ret;\n}\nR_API \nR_API \nR_API RList *r_bin_file_compute_hashes(RBin *bin, ut64 limit) {\n\tr_return_val_if_fail (bin && bin->cur && bin->cur->o, NULL);\n\tut64 buf_len = 0, r = 0;\n\tRBinFile *bf = bin->cur;\n\tRBinObject *o = bf->o;\n\tRIODesc *iod = r_io_desc_get (bin->iob.io, bf->fd);\n\tif (!iod) {\n\t\treturn NULL;\n\t}\n\tbuf_len = r_io_desc_size (iod);\n\t// By SLURP_LIMIT normally cannot compute ...\n\tif (buf_len > limit) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Warning: r_bin_file_hash: file exceeds bin.hashlimit\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\tconst size_t blocksize = 64000;\n\tut8 *buf = malloc (blocksize);\n\tif (!buf) {\n\t\teprintf (\"Cannot allocate computation buffer\\n\");\n\t\treturn NULL;\n\t}\n\tchar hash[128];\n\tRHash *ctx = r_hash_new (false, R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256);\n\twhile (r + blocksize < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tint b = r_io_desc_read (iod, buf, blocksize);\n\t\t(void)r_hash_do_md5 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha1 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha256 (ctx, buf, blocksize);\n\t\tr += b;\n\t}\n\tif (r < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tconst size_t rem_len = buf_len-r;\n\t\tint b = r_io_desc_read (iod, buf, rem_len);\n\t\tif (b < 1) {\n\t\t\teprintf (\"r_io_desc_read: error\\n\");\n\t\t} else {\n\t\t\t(void)r_hash_do_md5 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha1 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha256 (ctx, buf, b);\n\t\t}\n\t}\n\tr_hash_do_end (ctx, R_HASH_MD5);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_MD5, hash);\n\tRList *file_hashes = r_list_newf ((RListFree) r_bin_file_hash_free);\n\tRBinFileHash *md5h = R_NEW0 (RBinFileHash);\n\tif (md5h) {\n\t\tmd5h->type = strdup (\"md5\");\n\t\tmd5h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, md5h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA1);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA1, hash);\n\tRBinFileHash *sha1h = R_NEW0 (RBinFileHash);\n\tif (sha1h) {\n\t\tsha1h->type = strdup (\"sha1\");\n\t\tsha1h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha1h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA256);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA256, hash);\n\tRBinFileHash *sha256h = R_NEW0 (RBinFileHash);\n\tif (sha256h) {\n\t\tsha256h->type = strdup (\"sha256\");\n\t\tsha256h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha256h);\n\t}\n\tif (o->plugin && o->plugin->hashes) {\n\t\tRList *plugin_hashes = o->plugin->hashes (bf);\n\t\tr_list_join (file_hashes, plugin_hashes);\n\t\tfree (plugin_hashes);\n\t}\n\t// TODO: add here more rows\n\tfree (buf);\n\tr_hash_free (ctx);\n\treturn file_hashes;\n}\nR_API \nR_IPI \nR_IPI \nR_API \nR_API \nR_API \nR_API \nR_API \nR_API \n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_8105.c",
        "project": "radareorg/radare2",
        "url": "https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\terr = device_register(&bus->dev);\n\tmutex_init(&bus->mdio_lock);\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\t\tudelay(bus->reset_delay_us);\n\t}\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t}\n\t}\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\n\tphydev = get_phy_device(bus, addr, false);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_mdio.h>\n#include <linux/of_gpio.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <asm/irq.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/mdio.h>\n#include \"mdio-boardinfo.h\"\nEXPORT_SYMBOL(mdiobus_unregister_device);\nEXPORT_SYMBOL(mdiobus_get_phy);\nEXPORT_SYMBOL(mdiobus_is_registered_device);\nEXPORT_SYMBOL(mdiobus_alloc_size);\nEXPORT_SYMBOL_GPL(devm_mdiobus_free);\nstatic struct class mdio_bus_class = {\n\t.name\t\t= \"mdio_bus\",\n\t.dev_release\t= mdiobus_release,\n};\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)\n{\n\treturn dev->of_node == mdio_bus_np;\n}\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\n{\n\tstruct device *d;\n\tif (!mdio_bus_np)\n\t\treturn NULL;\n\td = class_find_device(&mdio_bus_class, NULL,  mdio_bus_np,\n\t\t\t      of_mdio_bus_match);\n\treturn d ? to_mii_bus(d) : NULL;\n}\nEXPORT_SYMBOL(of_mdio_find_bus);\nstatic void of_mdiobus_link_mdiodev(struct mii_bus *bus,\n\t\t\t\t    struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *child;\n\tif (dev->of_node || !bus->dev.of_node)\n\t\treturn;\n\tfor_each_available_child_of_node(bus->dev.of_node, child) {\n\t\tint addr;\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0)\n\t\t\tcontinue;\n\t\tif (addr == mdiodev->addr) {\n\t\t\tdev->of_node = child;\n\t\t\tdev->fwnode = of_fwnode_handle(child);\n\t\t\treturn;\n\t\t}\n\t}\n}\n#else \nstatic inline void of_mdiobus_link_mdiodev(struct mii_bus *mdio,\n\t\t\t\t\t   struct mdio_device *mdiodev)\n{\n}\n#endif\nint __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tint i, err;\n\tstruct gpio_desc *gpiod;\n\tif (NULL == bus || NULL == bus->name ||\n\t    NULL == bus->read || NULL == bus->write)\n\t\treturn -EINVAL;\n\tBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\n\t       bus->state != MDIOBUS_UNREGISTERED);\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\treturn -EINVAL;\n\t}\n\tmutex_init(&bus->mdio_lock);\n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\tbus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn PTR_ERR(gpiod);\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tudelay(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t}\n\tif (bus->reset)\n\t\tbus->reset(bus);\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & (1 << i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\t\t\tphydev = mdiobus_scan(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\n\t\t\t\terr = PTR_ERR(phydev);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\tbus->state = MDIOBUS_REGISTERED;\n\tpr_info(\"%s: probed\\n\", bus->name);\n\treturn 0;\nerror:\n\twhile (--i >= 0) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\tdevice_del(&bus->dev);\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_register);\nEXPORT_SYMBOL(mdiobus_unregister);\nEXPORT_SYMBOL(mdiobus_free);\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\n{\n\tstruct phy_device *phydev;\n\tint err;\n\tphydev = get_phy_device(bus, addr, false);\n\tif (IS_ERR(phydev))\n\t\treturn phydev;\n\tof_mdiobus_link_mdiodev(bus, &phydev->mdio);\n\terr = phy_device_register(phydev);\n\tif (err) {\n\t\tphy_device_free(phydev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\treturn phydev;\n}\nEXPORT_SYMBOL(mdiobus_scan);\nEXPORT_SYMBOL(__mdiobus_read);\nEXPORT_SYMBOL(__mdiobus_write);\nEXPORT_SYMBOL(mdiobus_read_nested);\nEXPORT_SYMBOL(mdiobus_read);\nEXPORT_SYMBOL(mdiobus_write_nested);\nEXPORT_SYMBOL(mdiobus_write);\nstruct bus_type mdio_bus_type = {\n\t.name\t\t= \"mdio_bus\",\n\t.match\t\t= mdio_bus_match,\n\t.uevent\t\t= mdio_uevent,\n};\nEXPORT_SYMBOL(mdio_bus_type);\nint __init mdio_bus_init(void)\n{\n\tint ret;\n\tret = class_register(&mdio_bus_class);\n\tif (!ret) {\n\t\tret = bus_register(&mdio_bus_type);\n\t\tif (ret)\n\t\t\tclass_unregister(&mdio_bus_class);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mdio_bus_init);\n#if IS_ENABLED(CONFIG_PHYLIB)\nvoid mdio_bus_exit(void)\n{\n\tclass_unregister(&mdio_bus_class);\n\tbus_unregister(&mdio_bus_type);\n}\nEXPORT_SYMBOL_GPL(mdio_bus_exit);\n#else\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MDIO bus/device layer\");\n#endif\n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_3592.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\troot->red = 1;\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tif (!tree->root) {\n\t}\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n}\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tint dir = 1, last;\n\t_set_link (q, tree->root, 1);\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0 && !found) {\n\t\t\tfound = q;\n\t\t}\n\t\tdir = (bool)(dir > 0);\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <r_util.h>\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\nR_API \nR_API \nR_API \nR_API \nR_API \nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\treturn node;\n}\n#define IS_RED(n) ((n) && (n)->red == 1)\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\troot->red = 1;\n\tsave->red = 0;\n\treturn save;\n}\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (!tree->root) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (!tree->root) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[1]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\t_set_link (q, tree->root, 1);\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0 && !found) {\n\t\t\tfound = q;\n\t\t}\n\t\tdir = (bool)(dir > 0);\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid *ret = NULL;\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\nR_API \nR_API \nR_API \nR_API \nR_API \n",
        "cwe": "CWE-416",
        "file_name": "safe_respovul_idx_7879.c",
        "project": "radareorg/radare2",
        "url": "https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int myeid_loadkey(sc_card_t *card, unsigned mode, u8* value, int value_len)\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (value_len == 0 || value == NULL)\n\t\treturn 0;\n\tif (mode == LOAD_KEY_MODULUS && value_len == 256 && !priv->cap_chaining)\n\t\tmode = 0x88;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode);\n\t\tapdu.cla     = 0x00;\n\t\tapdu.data    = value;\n\t\tapdu.datalen = 128;\n\t\tapdu.lc\t     = 128;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tvalue_len -= 128;\nstatic int myeid_generate_store_key(struct sc_card *card,\n\tstruct sc_cardctl_myeid_gen_store_key_info *data)\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t\tLOG_TEST_RET(card->ctx, r, \"GENERATE_KEY returned error\");\n\telse\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t\tif((r=myeid_loadkey(card, LOAD_KEY_PRIME_P,\n\t\t\t\tdata->primep, data->primep_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PRIME_Q,\n\t\t\t\tdata->primeq, data->primeq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DP1,\n\t\t\t\tdata->dp1, data->dp1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DQ1,\n\t\t\t\tdata->dq1, data->dq1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_INVQ,\n\t\t\t\tdata->invq, data->invq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_MODULUS,\n\t\t\t\tdata->mod, data->key_len_bits)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PUBLIC_EXPONENT,\n\t\t\t\tdata->pubexp, data->pubexp_len)) >= 0)\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_EC_PRIVATE, data->d,\n\t\t\t\t\tdata->d_len)) >= 0 &&\n\t\t\t\t(r = myeid_loadkey(card, LOAD_KEY_EC_PUBLIC, data->ecpublic_point,\n\t\t\t\t\tdata->ecpublic_point_len)) >= 0)\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_AES ||\n\t\t\tdata->key_type == SC_CARDCTL_MYEID_KEY_DES) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_SYMMETRIC, data->d,\n\t\t\t\t\tdata->d_len)) >= 0)\n\t\t}\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#include \"types.h\"\n#define LOAD_KEY_MODULUS\t\t0x0080\n#define LOAD_KEY_PUBLIC_EXPONENT\t0x0081\n#define LOAD_KEY_PRIME_P\t\t0x0083\n#define LOAD_KEY_PRIME_Q\t\t0x0084\n#define LOAD_KEY_DP1\t\t\t0x0085\n#define LOAD_KEY_DQ1\t\t\t0x0086\n#define LOAD_KEY_INVQ\t\t\t0x0087\n#define LOAD_KEY_EC_PUBLIC\t\t0x1086\n#define LOAD_KEY_EC_PRIVATE\t\t0x1087\n#define LOAD_KEY_SYMMETRIC\t\t0x20a0\n#define MYEID_CARD_NAME_MAX_LEN\t\t100\n#define MYEID_CARD_CAP_RSA\t\t0x01\n#define MYEID_CARD_CAP_3DES\t\t0x02\n#define MYEID_CARD_CAP_AES\t\t0x04\n#define MYEID_CARD_CAP_ECC\t\t0x08\n#define MYEID_CARD_CAP_GRIDPIN\t\t0x10\n#define MYEID_CARD_CAP_PIV_EMU\t\t0x20\n#define MYEID_MAX_APDU_DATA_LEN\t\t0xFF\n#define MYEID_MAX_RSA_KEY_LEN\t\t4096\n#define MYEID_MAX_EXT_APDU_BUFFER_SIZE\t(MYEID_MAX_RSA_KEY_LEN/8+16)\nstatic const char *myeid_card_name = \"MyEID\";\nstatic const char *oseid_card_name = \"OsEID\";\nstatic char card_name_buf[MYEID_CARD_NAME_MAX_LEN];\nstatic struct sc_card_operations myeid_ops;\nstatic struct sc_card_driver myeid_drv = {\n\t\"MyEID cards with PKCS#15 applet\",\n\t\"myeid\",\n\t&myeid_ops,\n\tNULL,\n\t0,\n\tNULL\n};\ntypedef struct myeid_private_data {\n\tint card_state;\n\tunsigned short change_counter;\n\tunsigned char cap_chaining;\n\tconst struct sc_security_env* sec_env;\n\tint disable_hw_pkcs1_padding;\n\tuint8_t sym_crypt_buffer[16];\n\tuint8_t sym_plain_buffer[16];\n\tuint8_t sym_crypt_buffer_len;\n\tuint8_t sym_plain_buffer_len;\n\tunsigned int algorithm, algorithm_flags;\n} myeid_private_data_t;\ntypedef struct myeid_card_caps {\n\tunsigned char card_caps_ver;\n\tunsigned short card_supported_features;\n\tunsigned short max_rsa_key_length;\n\tunsigned short max_des_key_length;\n\tunsigned short max_aes_key_length;\n\tunsigned short max_ecc_key_length;\n} myeid_card_caps_t;\nstatic struct myeid_supported_ec_curves {\n\tchar *curve_name;\n\tstruct sc_object_id curve_oid;\n\tsize_t size;\n} ec_curves[] = {\n\t{\"secp192r1\", {{1, 2, 840, 10045, 3, 1, 1, -1}},192},\n\t{\"secp256r1\", {{1, 2, 840, 10045, 3, 1, 7, -1}},256},\n\t{\"secp384r1\", {{1, 3, 132, 0, 34, -1}},\t\t384},\n\t{\"secp521r1\", {{1, 3, 132, 0, 35, -1}},\t\t521},\n\t{NULL, {{-1}}, 0},\n};\nstatic int myeid_get_info(struct sc_card *card, u8 *rbuf, size_t buflen);\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps);\nstatic int\nmyeid_select_aid(struct sc_card *card, struct sc_aid *aid, unsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid->len;\n\tapdu.data = aid->value;\n\tapdu.datalen = aid->len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\tif (*out_len > 0) {\n\t\tif (*out_len < apdu.resplen)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID - response buffer too small.\");\n\t\tif (out == NULL)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot select AID - invalid arguments.\");\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\t*out_len = apdu.resplen;\n\t}\n\treturn SC_SUCCESS;\n}\nstatic int myeid_init(struct sc_card *card)\n{\n\tunsigned long flags = 0, ext_flags = 0;\n\tmyeid_private_data_t *priv;\n\tu8 appletInfo[20];\n\tsize_t appletInfoLen;\n\tmyeid_card_caps_t card_caps;\n\tsize_t resp_len = 0;\n\tstatic struct sc_aid myeid_aid = { \"\\xA0\\x00\\x00\\x00\\x63\\x50\\x4B\\x43\\x53\\x2D\\x31\\x35\", 0x0C };\n\tint rv = 0;\n\tvoid *old_drv_data = card->drv_data;\n\tLOG_FUNC_CALLED(card->ctx);\n\tswitch (card->type) {\n\tcase SC_CARD_TYPE_MYEID_OSEID:\n\t\tcard->name = oseid_card_name;\n\t\tbreak;\n\tcase SC_CARD_TYPE_MYEID_GENERIC:\n\t\tcard->name = myeid_card_name;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\tpriv = calloc(1, sizeof(myeid_private_data_t));\n\tif (!priv)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\trv = myeid_load_options (card->ctx, priv);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Unable to read options from opensc.conf\");\n\tpriv->card_state = SC_FILE_STATUS_CREATION;\n\tcard->drv_data = priv;\n\trv = myeid_select_aid(card, &myeid_aid, NULL, &resp_len);\n\tLOG_TEST_GOTO_ERR(card->ctx, rv, \"Failed to select MyEID applet.\");\n\tappletInfoLen = 20;\n\tif (0 > myeid_get_info(card, appletInfo, appletInfoLen))\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_CARD, \"Failed to get MyEID applet information.\");\n\tpriv->change_counter = appletInfo[19] | appletInfo[18] << 8;\n\tmemset(&card_caps, 0, sizeof(myeid_card_caps_t));\n\tcard_caps.max_ecc_key_length = 256;\n\tcard_caps.max_rsa_key_length = 2048;\n\tif (card->version.fw_major >= 40) {\n\t    if (myeid_get_card_caps(card, &card_caps) != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Failed to get card capabilities. Using default max ECC key length 256.\");\n\t    }\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\tif (priv->disable_hw_pkcs1_padding == 0)\n\t\tflags |= SC_ALGORITHM_RSA_PAD_PKCS1;\n\tflags |= SC_ALGORITHM_RSA_HASH_NONE;\n\t_sc_card_add_rsa_alg(card,  512, flags, 0);\n\t_sc_card_add_rsa_alg(card,  768, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0);\n\t_sc_card_add_rsa_alg(card, 1536, flags, 0);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0);\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_RSA) {\n\t\tif (card_caps.max_rsa_key_length >= 3072)\n\t\t\t_sc_card_add_rsa_alg(card, 3072, flags, 0);\n\t\tif (card_caps.max_rsa_key_length >= 4096)\n\t\t\t_sc_card_add_rsa_alg(card, 4096, flags, 0);\n\t}\n\tif (card->version.fw_major >= 35) {\n\t\tint i;\n\t\tflags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\tflags |= SC_ALGORITHM_ECDSA_HASH_NONE;\n\t\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;\n\t\tfor (i=0; ec_curves[i].curve_name != NULL; i++) {\n\t\t\tif (card_caps.max_ecc_key_length >= ec_curves[i].size)\n\t\t\t\t_sc_card_add_ec_alg(card, ec_curves[i].size, flags, ext_flags, &ec_curves[i].curve_oid);\n\t\t}\n\t}\n\tflags = 0;\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_3DES) {\n\t\tif (card_caps.max_des_key_length >= 64)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_DES, 64, flags);\n\t\tif (card_caps.max_des_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 128, flags);\n\t\tif (card_caps.max_des_key_length >= 192)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_3DES, 192, flags);\n\t}\n\tif (card_caps.card_supported_features & MYEID_CARD_CAP_AES) {\n\t\tif (card_caps.max_aes_key_length >= 128)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 128, flags);\n\t\tif (card_caps.max_aes_key_length >= 256)\n\t\t\t_sc_card_add_symmetric_alg(card, SC_ALGORITHM_AES, 256, flags);\n\t}\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\tif ((card->version.fw_major == 40 && card->version.fw_minor >= 10 )\n\t\t|| card->version.fw_major >= 41)\n\t\tcard->caps |= SC_CARD_CAP_WRAP_KEY | SC_CARD_CAP_UNWRAP_KEY\n\t\t\t   | SC_CARD_CAP_ONCARD_SESSION_OBJECTS;\n\tif (card->version.fw_major >= 45)\n\t\tpriv->cap_chaining = 1;\n\tif (card->version.fw_major >= 40)\n\t\tcard->max_recv_size = 256;\n\telse\n\t\tcard->max_recv_size = 255;\n\tcard->max_send_size = 255;\n\trv = SC_SUCCESS;\nerr:\n\tif (rv < 0) {\n\t\tfree(priv);\n\t\tcard->drv_data = old_drv_data;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, rv);\n}\nstatic const struct sc_card_operations *iso_ops = NULL;\nstatic int myeid_process_fci(struct sc_card *card, struct sc_file *file,\n\t\tconst u8 *buf, size_t buflen)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsize_t taglen = 0;\n\tconst u8 *tag = NULL;\n\tint r;\n\tLOG_FUNC_CALLED(card->ctx);\n\tr = iso_ops->process_fci(card, file, buf, buflen);\n\tif (r < 0)\n\t LOG_FUNC_RETURN(card->ctx, r);\n\tif(file->type == SC_FILE_EF_UNKNOWN)\n\t{\n\t\ttag = sc_asn1_find_tag(NULL, buf, buflen, 0x82, &taglen);\n\t\tif (tag != NULL && taglen > 0 && *tag == 17)\n\t\t{\n\t\t\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\t\t}\n\t}\n\tif(file->sec_attr_len >= 3)\n\t{\n\t\tsc_log(card->ctx, \"id (%X) sec_attr (%X %X %X)\", file->id,\n\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\tpriv->card_state = file->status;\n\tswitch (file->status) {\n\t\tcase SC_FILE_STATUS_CREATION:\n\t\t\tfile->acl_inactive = 1;\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_CREATION\", file->id);\n\t\t\tbreak;\n\t\tcase SC_FILE_STATUS_ACTIVATED:\n\t\t\tsc_log(card->ctx, \"File id (%X) status SC_FILE_STATUS_ACTIVATED\", file->id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx, \"File id (%X) unusual status (0x%X)\", file->id, file->status);\n\t}\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\nstatic int encode_file_structure(sc_card_t *card, const sc_file_t *file,\n\t\tu8 *buf, size_t *outlen)\n{\n\tconst sc_acl_entry_t *read, *update, *delete, *generate;\n\tsize_t i;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (!buf || !outlen || *outlen < 45)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\tmemset(buf, 0x0, *outlen);\n\tbuf[0] = 0x62;\n\tbuf[1] = 0x17;\n\tbuf[2] = (SC_FILE_TYPE_WORKING_EF == file->type ? 0x80 : 0x81);\n\tbuf[3] = 0x02;\n\tbuf[4] = (file->size >> 8) & 0xFF;\n\tbuf[5] = file->size & 0xFF;\n\tbuf[6] = 0x82;\n\tbuf[7] = 0x01;\n\tbuf[8] = 0x01;\n\tbuf[9]  = 0x83;\n\tbuf[10] = 0x02;\n\tbuf[11] = (file->id >> 8) & 0xFF;\n\tbuf[12] = file->id & 0xFF;\n\tbuf[13] = 0x86;\n\tbuf[14] = 0x03;\n\tbuf[15] = 0xFF;\n\tbuf[16] = 0xFF;\n\tbuf[17] = 0xFF;\n\tif (file->sec_attr_len == 3 && file->sec_attr)   {\n\t\tbuf[15] = file->sec_attr[0];\n\t\tbuf[16] = file->sec_attr[1];\n\t\tbuf[17] = file->sec_attr[2];\n\t\tsc_log(card->ctx, \"id (%X), sec_attr %X %X %X\", file->id,\n\t\t\t\tfile->sec_attr[0],file->sec_attr[1],file->sec_attr[2]);\n\t}\n\telse   {\n\t\tdelete = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\t\tsc_log(card->ctx, \"id (%X), type (%X)\", file->id, file->type);\n\t\tswitch (file->type) {\n\t\tcase SC_FILE_TYPE_WORKING_EF:\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | 0x0F;\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\t\tread = sc_file_get_acl_entry(file, SC_AC_OP_CRYPTO);\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\t\tgenerate = sc_file_get_acl_entry(file, SC_AC_OP_GENERATE);\n\t\t\tbuf[15] = (acl_to_byte(read) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete)<< 4) | acl_to_byte(generate);\n\t\t\tbreak;\n\t\tcase SC_FILE_TYPE_DF:\n\t\t\tupdate = sc_file_get_acl_entry(file, SC_AC_OP_CREATE);\n\t\t\tbuf[15] = (acl_to_byte(update) << 4) | acl_to_byte(update);\n\t\t\tbuf[16] = (acl_to_byte(delete) << 4) | 0x0F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[18] = 0x85;\n\tbuf[19] = 0x02;\n\tif (file->prop_attr_len == 2 && file->prop_attr != NULL)\n\t    memcpy(&buf[20], file->prop_attr, 2);\n\telse\n\t{\n\t\tbuf[20] = 0x00;\n\t\tbuf[21] = 0x00;\n\t}\n\tbuf[22] = 0x8A;\n\tbuf[23] = 0x01;\n\tbuf[24] = 0x0; \n\tswitch (file->type)\n\t{\n\tcase SC_FILE_TYPE_WORKING_EF:\n\t\tbreak;\n\tcase SC_FILE_TYPE_INTERNAL_EF:\n\t\tbuf[8] = file->ef_structure; \n\t\tbreak;\n\tcase SC_FILE_TYPE_DF:\n\t\tbuf[8] = 0x38;\n\t\tif(file->namelen > 0 && file->namelen <= 16)\n\t\t{\n\t\t\tbuf[25] = 0x84;\n\t\t\tbuf[26] = (u8)file->namelen;\n\t\t\tfor(i=0;i < file->namelen;i++)\n\t\t\t\tbuf[i + 27] = file->name[i];\n\t\t\tbuf[1] = 27 + file->namelen;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsc_log(card->ctx, \"Unknown file type\\n\");\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\t*outlen = buf[1]+2;\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n#define IS_SYMETRIC_CRYPT(x) ((x) == SC_SEC_OPERATION_ENCRYPT_SYM || (x) == SC_SEC_OPERATION_DECRYPT_SYM)\nstatic int myeid_set_security_env_rsa(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\tsize_t i;\n\tsc_path_t *target_file;\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\\n\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_UNWRAP:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_WRAP:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_ENCRYPT_SYM:\n\t\tapdu.p1 = 0x81;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECRYPT_SYM:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB8;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 2;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\tif (IS_SYMETRIC_CRYPT(env->operation)) {\n\t\t*p++ = 0x83;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT && env->operation != SC_SEC_OPERATION_UNWRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_WRAP &&\n\t\t\tenv->operation != SC_SEC_OPERATION_ENCRYPT_SYM &&\n\t\t\tenv->operation != SC_SEC_OPERATION_DECRYPT_SYM) {\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t    if (env->params[i].param_type == SC_SEC_ENV_PARAM_TARGET_FILE) {\n\t\t\ttarget_file = (sc_path_t*) env->params[i].value;\n\t\t\tif (env->params[i].value_len < sizeof(sc_path_t) || target_file->len != 2) {\n\t\t\t\tsc_log(card->ctx, \"wrong length of target file reference.\\n\");\n\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t}\n\t\t\t*p++ = 0x83;\n\t\t\t*p++ = 2;\n\t\t\tmemcpy(p, target_file->value, 2);\n\t\t\tp+= 2;\n\t\t\tbreak;\n\t    }\n\tr = 0;\n\tif (env->operation == SC_SEC_OPERATION_UNWRAP || env->operation == SC_SEC_OPERATION_WRAP ||\n\t\t\tIS_SYMETRIC_CRYPT(env->operation)) {\n\t\tfor (i = 0; i < SC_SEC_ENV_MAX_PARAMS; i++)\n\t\t\tif (env->params[i].param_type == SC_SEC_ENV_PARAM_IV) {\n\t\t\t\tr = 1;\n\t\t\t\t*p++ = 0x87;\n\t\t\t\t*p++ = (unsigned char) env->params[i].value_len;\n\t\t\t\tif (p + env->params[i].value_len >= sbuf + SC_MAX_APDU_BUFFER_SIZE) {\n\t\t\t\t\tsc_log(card->ctx, \"IV too long.\\n\");\n\t\t\t\t\treturn SC_ERROR_WRONG_LENGTH;\n\t\t\t\t}\n\t\t\t\tmemcpy(p, env->params[i].value, env->params[i].value_len);\n\t\t\t\tp+=(unsigned char) env->params[i].value_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (IS_SYMETRIC_CRYPT(env->operation) && env->algorithm == SC_ALGORITHM_AES &&\n\t\t\tenv->algorithm_flags == SC_ALGORITHM_AES_ECB && r == 0) {\n\t\t*p++ = 0x87;\n\t\t*p++ = 16;\n\t\tmemset(p, 0, 16);\n\t\tp += 16;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_set_security_env_ec(sc_card_t *card, const sc_security_env_t *env,\n\t\tint se_num)\n{\n\tsc_apdu_t apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *p;\n\tint r;\n\tassert(card != NULL && env != NULL);\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (env->flags & SC_SEC_ENV_KEY_REF_SYMMETRIC)\n\t{\n\t\tsc_log(card->ctx, \"symmetric keyref not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tif (se_num > 0)\n\t{\n\t\tsc_log(card->ctx, \"restore security environment not supported.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);\n\tswitch (env->operation)\n\t{\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\tsc_log(card->ctx, \"Decipher operation is not supported with EC keys.\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xB6;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DERIVE:\n\t\tapdu.p1 = 0x41;\n\t\tapdu.p2 = 0xA4;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tapdu.le = 0;\n\tp = sbuf;\n\tif (env->flags & SC_SEC_ENV_ALG_REF_PRESENT)\n\t{\n\t\t*p++ = 0x80;\t\n\t\t*p++ = 0x01;\n\t\t*p++ = env->algorithm_ref & 0xFF;\n\t}\n\tif (env->flags & SC_SEC_ENV_FILE_REF_PRESENT)\n\t{\n\t\t*p++ = 0x81;\n\t\t*p++ = 0x02;\n\t\tmemcpy(p, env->file_ref.value, 2);\n\t\tp += 2;\n\t}\n\tif (env->flags & SC_SEC_ENV_KEY_REF_PRESENT)\n\t{\n\t\t*p++ = 0x84;\n\t\t*p++ = 1;\n\t\t*p++ = 0;\n\t}\n\tr = p - sbuf;\n\tapdu.lc = r;\n\tapdu.datalen = r;\n\tapdu.data = sbuf;\n\tapdu.resplen = 0;\n\tif (apdu.datalen != 0)\n\t{\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: APDU transmit failed\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (r)\n\t\t{\n\t\t\tsc_log(card->ctx,\n\t\t\t\t\"%s: Card returned error\", sc_strerror(r));\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tmyeid_private_data_t* priv;\n\tLOG_FUNC_CALLED(ctx);\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\tpriv->sec_env = env;\n\tpriv->algorithm_flags = env->algorithm_flags;\n\tpriv->algorithm = env->algorithm;\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT)\n\t{\n\t\tsc_security_env_t tmp;\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\t\tif (tmp.algorithm == SC_ALGORITHM_RSA)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t    tmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\t\t\ttmp.algorithm_ref = 0x02;\n\t\t\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\t\t\ttmp.algorithm_ref |= 0x10;\n\t\t\t}\n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_EC)\n\t\t{\n\t\t\ttmp.algorithm_ref = 0x04;\n\t\t\ttmp.algorithm_flags = 0;\n\t\t\treturn myeid_set_security_env_ec(card, &tmp, se_num);\n\t\t}\n\t\telse if (tmp.algorithm == SC_ALGORITHM_AES)\n\t\t{\n\t\t\tif (tmp.operation == SC_SEC_OPERATION_UNWRAP || tmp.operation == SC_SEC_OPERATION_WRAP)\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x0A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp.algorithm_ref = 0x00;\n\t\t\t}\n\t\t\tif ((tmp.algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) == SC_ALGORITHM_AES_CBC_PAD)\n\t\t\t\ttmp.algorithm_ref |= 0x80;\t\t\n\t\t\tif (IS_SYMETRIC_CRYPT(env->operation))\n\t\t\t\ttmp.algorithm_ref &= ~0x80; \n\t\t\treturn myeid_set_security_env_rsa(card, &tmp, se_num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsc_log(ctx, \"Unsupported algorithm.\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\treturn myeid_set_security_env_rsa(card, env, se_num);\n}\nstatic int\nmyeid_convert_ec_signature(struct sc_context *ctx, size_t s_len, unsigned char *data, size_t datalen)\n{\n\tunsigned char *buf;\n\tsize_t buflen;\n\tint r;\n\tsize_t len_size = 1;\n\tsize_t sig_len = 0;\n\tassert(data && datalen && datalen > 3);\n\tif (*data != 0x30)\n\t\treturn SC_ERROR_INVALID_DATA;\n\tif ((*(data + 1) & 0x80) == 0x80)\n\t\tlen_size += *(data + 1) & 0x7F;\n\tif (len_size == 1)\n\t    sig_len = *(data + 1);\n\telse if (len_size == 2)\n\t    sig_len = *(data + 2);\n\telse if (len_size == 3)\n\t{\n\t    sig_len = *(data + 2) | (*data + 3) << 8;\n\t}\n\telse\n\t    return SC_ERROR_INVALID_DATA;\n\tif (*(data + 1 + len_size) != 0x02)\t\t\n\tif (sig_len != (datalen - len_size - 1))\t\n\t    return SC_ERROR_INVALID_DATA;\n\tbuflen = (s_len + 7)/8*2;\n\tif (buflen > datalen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\tbuf = calloc(1, buflen);\n\tif (!buf)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tr = sc_asn1_sig_value_sequence_to_rs(ctx, data, datalen, buf, buflen);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\tsc_log(ctx, \"Failed to convert Sig-Value to the raw RS format\");\n\t\treturn r;\n\t}\n\tmemmove(data, buf, buflen);\n\tfree(buf);\n\treturn buflen;\n}\nstatic int\nmyeid_compute_raw_2048_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tstruct sc_context *ctx;\n\tstruct myeid_private_data *priv;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tsc_security_env_t env;\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tpriv = (myeid_private_data_t *) card->drv_data;\n\tmemcpy(&env, priv->sec_env, sizeof(sc_security_env_t));\n\tenv.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_FILE_REF_PRESENT;\n\tenv.flags |= SC_SEC_ENV_KEY_REF_PRESENT;\n\tenv.operation = SC_SEC_OPERATION_DECIPHER;\n\tmyeid_set_security_env_rsa(card, &env, 0);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 0;\t\n\tsbuf[0] = 0x81;\n\tmemcpy(sbuf + 1, data, datalen / 2);\n\tapdu.lc = datalen / 2 + 1;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = datalen;\n\t\tsbuf[0] = 0x82;\n\t\tmemcpy(sbuf + 1, data + datalen / 2, datalen / 2);\n\t\tapdu.lc = datalen / 2 + 1;\n\t\tapdu.datalen = apdu.lc;\n\t\tapdu.data = sbuf;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {\n\t\t\tint len = apdu.resplen > outlen ? outlen : apdu.resplen;\n\t\t\tmemcpy(out, apdu.resp, len);\n\t\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\nstatic int\nmyeid_compute_signature(struct sc_card *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tstruct myeid_private_data* priv;\n\tint r;\n\tsize_t field_length = 0;\n\tsize_t pad_chars = 0;\n\tassert(card != NULL && data != NULL && out != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tpriv = (myeid_private_data_t*) card->drv_data;\n\tsc_log(ctx, \"key type %i, key length %i\", priv->sec_env->algorithm, priv->sec_env->algorithm_ref);\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC ) {\n\t    field_length = priv->sec_env->algorithm_ref;\n\t\tif (datalen < (field_length + 7) / 8 ) {\n\t\t\tpad_chars = ((field_length + 7) / 8) - datalen;\n\t\t\tmemset(sbuf, 0, pad_chars);\n\t\t}\n\t}\n\tif ((datalen + pad_chars) > sizeof(sbuf))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_RSA && datalen == 256 && !priv->cap_chaining)\n\t\treturn myeid_compute_raw_2048_signature(card, data, datalen, out, outlen);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x9E, 0x9A);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = 256;\n\tmemcpy(sbuf + pad_chars, data, datalen);\n\tapdu.lc = datalen + pad_chars;\n\tapdu.datalen = datalen + pad_chars;\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, r, \"compute_signature failed\");\n\tif (priv->sec_env->algorithm == SC_ALGORITHM_EC) {\n\t\tr = myeid_convert_ec_signature(ctx, priv->sec_env->algorithm_ref, apdu.resp, apdu.resplen);\n\t\tLOG_TEST_RET(ctx, r, \"compute_signature convert signature failed\");\n\t\tapdu.resplen = r;\n\t}\n\tif (apdu.resplen > outlen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\tmemcpy(out, apdu.resp, apdu.resplen);\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\nint myeid_ecdh_derive(struct sc_card *card, const u8* pubkey, size_t pubkey_len, u8* out, size_t outlen)\n{\n\tstruct sc_apdu apdu;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint r;\n\tsize_t ext_len_bytes;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x86, 0x00, 0x00);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tsbuf[0] = 0x7C;\n\text_len_bytes = 0;\n\tif (pubkey_len > 127)\n\t{\n\t\tsbuf[1] = 0x81;\n\t\tsbuf[2] = (u8) (pubkey_len + 3);\n\t\tsbuf[3] = 0x85;\n\t\tsbuf[4] = 0x81;\n\t\tsbuf[5] = (u8) (pubkey_len);\n\t\text_len_bytes = 2;\n\t}\n\telse\n\t{\n\t\tsbuf[1] = pubkey_len + 2;\n\t\tsbuf[2] = 0x85;\n\t\tsbuf[3] = pubkey_len;\n\t}\n\tmemcpy(&sbuf[4 + ext_len_bytes], pubkey, pubkey_len);\n\tapdu.lc = pubkey_len + 4 + ext_len_bytes;\n\tapdu.le = pubkey_len / 2;\n\tapdu.datalen = apdu.lc;\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed.\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"ECDH operation failed - GENERAL AUTHENTICATE returned error.\");\n\tif (outlen < apdu.resplen)\n\t{\n\t\tr = SC_ERROR_BUFFER_TOO_SMALL;\n\t\tLOG_TEST_RET(card->ctx, r, \"Buffer too small to hold shared secret.\");\n\t}\n\tmemcpy(out, rbuf, apdu.resplen);\n\tLOG_FUNC_RETURN(card->ctx, apdu.resplen);\n}\nstatic int myeid_transmit_decipher_pi_split(struct sc_card *card, struct sc_apdu *apdu, u8 *sbuf)\n{\n\tsize_t crgram_len = apdu->lc - 1;\n\tsize_t crgram_half = crgram_len / 2;\n\tsize_t resplen = apdu->resplen;\n\tunsigned char *resp = apdu->resp;\n\tint r;\n\tLOG_FUNC_CALLED(card->ctx);\n\tapdu->cse = SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[0];\n\tapdu->datalen = apdu->lc = crgram_half + 1;\n\tapdu->resp = 0;\n\tapdu->resplen = 0;\n\tapdu->le = 0;\n\tsbuf[0] = 0x81;\t\t\t\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif (apdu->sw1 != 0x90 || apdu->sw2 != 0x00)\n\t\treturn 0;\n\tapdu->cse = resplen ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT;\n\tapdu->data = &sbuf[crgram_half];\n\tapdu->datalen = apdu->lc = crgram_len - crgram_half + 1;\n\tapdu->resp = resp;\n\tapdu->resplen = resplen;\n\tapdu->le = resplen ? MIN(card->max_recv_size, crgram_len) : 0;\n\tsbuf[crgram_half] = 0x82;\t\n\tr = sc_transmit_apdu(card, apdu);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_transmit_decipher(struct sc_card *card, u8 p1, u8 p2,\n\t\tconst u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tmyeid_private_data_t *priv = card->drv_data;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_format_apdu(card, &apdu, p1 ? SC_APDU_CASE_4_SHORT : SC_APDU_CASE_3_SHORT, 0x2A, p1, p2);\n\tif (p2 == 0x86) {\n\t\tif (crgram_len+1 > sizeof(sbuf))\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t\tsbuf[0] = 0; \n\t\tmemcpy(sbuf + 1, crgram, crgram_len);\n\t\tapdu.data = sbuf;\n\t\tapdu.datalen = apdu.lc = crgram_len + 1;\n\t} else {\n\t\tapdu.data = crgram;\n\t\tapdu.datalen = apdu.lc = crgram_len;\n\t}\n\tif (p1 != 0x00) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = MIN(card->max_recv_size, crgram_len);\n\t}\n\tif (p2 == 0x86 && crgram_len == 256 && priv && !priv->cap_chaining) {\n\t\tr = myeid_transmit_decipher_pi_split(card, &apdu, sbuf);\n\t} else {\n\t\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"DECIPHER returned error\");\n\tif (out && outlen) {\n\t\toutlen = MIN(apdu.resplen, outlen);\n\t\tmemcpy(out, apdu.resp, outlen);\n\t} else {\n\t\toutlen = 0;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, outlen);\n}\nstatic int myeid_unwrap_key(struct sc_card *card, const u8 *crgram, size_t crgram_len)\n{\n\tmyeid_private_data_t* priv;\n\tu8 p2 = 0x86; \n\tint r;\n\tif (card == NULL || crgram == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tpriv = card->drv_data;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (crgram_len > MYEID_MAX_RSA_KEY_LEN / 8)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\tif (priv && priv->sec_env)\n\t{\n\t\tif (priv->sec_env->algorithm == SC_ALGORITHM_AES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_3DES ||\n\t\t\tpriv->sec_env->algorithm == SC_ALGORITHM_DES)\n\t\t\t\tp2 = 0x84;\n\t}\n\tif (p2 == 0x84 && crgram_len > MYEID_MAX_APDU_DATA_LEN)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_WRONG_LENGTH, \"Unwrapping symmetric data longer that 255 bytes is not supported\\n\");\n\tr = myeid_transmit_decipher(card, 0x00, p2, crgram, crgram_len, 0, 0);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_loadkey(sc_card_t *card, unsigned mode, u8* value, int value_len)\n{\n\tmyeid_private_data_t *priv = (myeid_private_data_t *) card->drv_data;\n\tsc_apdu_t apdu;\n\tu8 sbuf[MYEID_MAX_EXT_APDU_BUFFER_SIZE];\n\tint r;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (value_len == 0 || value == NULL)\n\t\treturn 0;\n\tif (mode == LOAD_KEY_MODULUS && value_len == 256 && !priv->cap_chaining)\n\t{\n\t\tmode = 0x88;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode);\n\t\tapdu.cla     = 0x00;\n\t\tapdu.data    = value;\n\t\tapdu.datalen = 128;\n\t\tapdu.lc\t     = 128;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"LOAD KEY returned error\");\n\t\tmode = 0x89;\n\t\tvalue += 128;\n\t\tvalue_len -= 128;\n\t}\n\telse if ((mode & 0xff00) == 0 && mode != LOAD_KEY_PUBLIC_EXPONENT &&\n\t\t value[0] != 0x00)\n\t{\n\t\tsbuf[0] = 0x0;\n\t\tmemcpy(&sbuf[1], value, value_len);\n\t\tvalue = sbuf;\n\t\tvalue_len ++;\n\t}\n\tmemset(&apdu, 0, sizeof(apdu));\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDA, 0x01, mode & 0xFF);\n\tapdu.flags   = SC_APDU_FLAGS_CHAINING;\n\tapdu.cla     = 0x00;\n\tapdu.data    = value;\n\tapdu.datalen = value_len;\n\tapdu.lc\t     = value_len;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_generate_store_key(struct sc_card *card,\n\tstruct sc_cardctl_myeid_gen_store_key_info *data)\n{\n\tstruct\tsc_apdu apdu;\n\tu8\tsbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tint\tr=0,len;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (data->op_type == OP_TYPE_GENERATE)\n\t{\n\t\tlen = 0;\n\t\tmemset(&apdu, 0, sizeof(apdu));\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t    sbuf[len++] = 0x30;\n\t\t    sbuf[len++] = 0x05;\n\t\t    sbuf[len++] = 0x81;\n\t\t    sbuf[len++] = data->pubexp_len;\n\t\t    memcpy(sbuf + len, data->pubexp, data->pubexp_len);\n\t\t    len += data->pubexp_len;\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n\t\t\tapdu.data    = sbuf;\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x46, 0x00, 0x00);\n\t\t\tapdu.data    = NULL;\n\t\t\tapdu.resp\t = sbuf;\n\t\t\tapdu.resplen = 0x00;\n\t\t\tapdu.le\t\t = 0x00;\n\t\t}\n\t\tapdu.cla     = 0x00;\n\t\tapdu.datalen = len;\n\t\tapdu.lc\t     = len;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(card->ctx, r, \"GENERATE_KEY returned error\");\n\t}\n\telse\n\t{\n\t\tif(data->key_type == SC_CARDCTL_MYEID_KEY_RSA)\n\t\t{\n\t\t\tif((r=myeid_loadkey(card, LOAD_KEY_PRIME_P,\n\t\t\t\tdata->primep, data->primep_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PRIME_Q,\n\t\t\t\tdata->primeq, data->primeq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DP1,\n\t\t\t\tdata->dp1, data->dp1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_DQ1,\n\t\t\t\tdata->dq1, data->dq1_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_INVQ,\n\t\t\t\tdata->invq, data->invq_len)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_MODULUS,\n\t\t\t\tdata->mod, data->key_len_bits)) >= 0 &&\n\t\t\t(r=myeid_loadkey(card, LOAD_KEY_PUBLIC_EXPONENT,\n\t\t\t\tdata->pubexp, data->pubexp_len)) >= 0)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_EC) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_EC_PRIVATE, data->d,\n\t\t\t\t\tdata->d_len)) >= 0 &&\n\t\t\t\t(r = myeid_loadkey(card, LOAD_KEY_EC_PUBLIC, data->ecpublic_point,\n\t\t\t\t\tdata->ecpublic_point_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\telse if(data->key_type == SC_CARDCTL_MYEID_KEY_AES ||\n\t\t\tdata->key_type == SC_CARDCTL_MYEID_KEY_DES) {\n\t\t\tif((r = myeid_loadkey(card, LOAD_KEY_SYMMETRIC, data->d,\n\t\t\t\t\tdata->d_len)) >= 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int myeid_get_card_caps(struct sc_card *card, myeid_card_caps_t* card_caps)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0xAA);\n\tapdu.resp    = rbuf;\n\tapdu.resplen = sizeof(myeid_card_caps_t);\n\tapdu.le      = sizeof(myeid_card_caps_t);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r,  \"APDU transmit failed\");\n\tif (apdu.sw1 != 0x90 || apdu.sw2 != 0x00)\n\t\treturn SC_ERROR_INTERNAL;\n\tif (apdu.resplen < 11) {\n\t\tsc_log(card->ctx, \"Unexpected response to GET DATA (MyEIC card capabilities)\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tcard_caps->card_caps_ver = rbuf[0];\n\tcard_caps->card_supported_features = (unsigned short) rbuf[1] << 8 | rbuf[2];\n\tcard_caps->max_rsa_key_length = (unsigned short) rbuf[3] << 8 | rbuf[4];\n\tcard_caps->max_des_key_length = (unsigned short) rbuf[5] << 8 | rbuf[6];\n\tcard_caps->max_aes_key_length = (unsigned short) rbuf[7] << 8 | rbuf[8];\n\tcard_caps->max_ecc_key_length = (unsigned short) rbuf[9] << 8 | rbuf[10];\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int\nmyeid_enc_dec_sym(struct sc_card *card, const u8 *data, size_t datalen,\n\t\tu8 *out, size_t *outlen, int decipher)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 *sdata;\n\tint r, padding = 0, cbc = 0;\n\tsize_t block_size;\n\tsize_t len, rest_len;\n\tsize_t return_len = 0;\n\tsize_t max_apdu_datalen;\n\tsize_t apdu_datalen;\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\tmyeid_private_data_t *priv;\n\tpriv = (myeid_private_data_t *)card->drv_data;\n\tmax_apdu_datalen = sc_get_max_send_size(card);\n\tif (max_apdu_datalen > sc_get_max_recv_size(card))\n\t\tmax_apdu_datalen = sc_get_max_recv_size(card);\n\tif (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)\n\t\tmax_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;\n\tsc_log(ctx, \"algorithm %d algorithm_flags %x\", priv->algorithm, priv->algorithm_flags);\n\tif (outlen == NULL) {\n\t\tsc_log(ctx, \"%s (symmetric key) initialized\", decipher ? \"C_DecryptInit\" : \"C_EncryptInit\");\n\t\tpriv->sym_crypt_buffer_len = 0;\n\t\tpriv->sym_plain_buffer_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\tswitch (priv->algorithm) {\n\tcase SC_ALGORITHM_AES:\n\t\tblock_size = 16;\n\t\tif (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 0;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {\n\t\t\tpadding = 0;\n\t\t\tcbc = 1;\n\t\t} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {\n\t\t\tpadding = 1;\n\t\t\tcbc = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\tif (cbc)\n\t\tmax_apdu_datalen -= max_apdu_datalen % block_size;\n\telse\n\t\tmax_apdu_datalen = block_size;\n\trest_len = priv->sym_crypt_buffer_len;\n\tif (data == NULL) {\n\t\tif (datalen != 0)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tif (decipher) {\n\t\t\tif (priv->sym_plain_buffer_len != block_size)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\tif (rest_len)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\treturn_len = block_size;\n\t\t\tif (padding) {\n\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (*(--sdata) != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\tif (out == NULL) {\n\t\t\t\t*outlen = return_len;\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\t}\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\t*outlen = return_len;\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\tif (padding) {\n\t\t\t\tuint8_t pad_byte = block_size - rest_len;\n\t\t\t\tsc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);\n\t\t\t\tsdata = priv->sym_crypt_buffer + rest_len;\n\t\t\t\tmemset(sdata, pad_byte, pad_byte);\n\t\t\t\trest_len = block_size;\n\t\t\t} else if (rest_len) {\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\t\t}\n\t\t}\n\t}\n\tlen = datalen + rest_len;\n\tsc_log(ctx, \"datalen=%zu rest_len=%zu len=%zu outlen=%zu\", datalen, rest_len, len, *outlen);\n\tlen -= (len % block_size);\n\t*outlen = len;\n\tif (out == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tif (*outlen < len)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\twhile (len >= block_size) {\n\t\tif (!decipher)\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);\n\t\telse\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);\n\t\tapdu.cla = 0;\n\t\tif (len > max_apdu_datalen)\n\t\t\tapdu_datalen = max_apdu_datalen;\n\t\telse\n\t\t\tapdu_datalen = len;\n\t\tif (cbc)\n\t\t\tapdu.cla = 0x10;\n\t\tlen -= apdu_datalen;\n\t\tsdata = sbuf;\n\t\tapdu.le = apdu_datalen;\n\t\tapdu.lc = apdu_datalen;\n\t\tapdu.datalen = apdu_datalen;\n\t\tapdu.data = sbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.resp = rbuf;\n\t\tif (rest_len) {\n\t\t\tmemcpy(sbuf, priv->sym_crypt_buffer, rest_len);\n\t\t\tsdata += rest_len;\n\t\t\tapdu_datalen -= rest_len;\n\t\t\tpriv->sym_crypt_buffer_len = 0;\n\t\t\trest_len = 0;\n\t\t}\n\t\tif (data) {\n\t\t\tmemcpy(sdata, data, apdu_datalen);\n\t\t\tdata += apdu_datalen;\n\t\t\tdatalen -= apdu_datalen;\n\t\t}\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, r, \"decrypt_sym/encrypt_sym failed\");\n\t\tif (apdu.resplen != apdu.datalen)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t\tout += apdu.resplen;\n\t\treturn_len += apdu.resplen;\n\t}\n\tif (decipher) {\n\t\tuint8_t tmp_buf[16];\n\t\tif (return_len >= block_size) {\n\t\t\tmemcpy(tmp_buf, out - block_size, block_size);\n\t\t\tif (priv->sym_plain_buffer_len) {\n\t\t\t\tsc_log(ctx, \"inserting block from previous decrypt\");\n\t\t\t\tmemmove(out - return_len + block_size, out - return_len, return_len - block_size);\n\t\t\t\tmemcpy(out - return_len, priv->sym_plain_buffer, block_size);\n\t\t\t} else\n\t\t\t\treturn_len -= block_size;\n\t\t\tmemcpy(priv->sym_plain_buffer, tmp_buf, block_size);\n\t\t\tpriv->sym_plain_buffer_len = block_size;\n\t\t} else\n\t\t\tpriv->sym_plain_buffer_len = 0;\n\t}\n\tpriv->sym_crypt_buffer_len = datalen;\n\tsc_log(ctx, \"rest data len = %zu\", datalen);\n\tif (data)\n\t\tmemcpy(priv->sym_crypt_buffer, data, datalen);\n\tsc_log(ctx, \"return data len = %zu\", return_len);\n\t*outlen = return_len;\n\treturn SC_SUCCESS;\n}\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\tif (iso_ops == NULL)\n\t\tiso_ops = iso_drv->ops;\n\tmyeid_ops\t\t\t= *iso_drv->ops;\n\tmyeid_ops.match_card\t\t= myeid_match_card;\n\tmyeid_ops.init\t\t\t= myeid_init;\n\tmyeid_ops.finish\t\t= myeid_finish;\n\tmyeid_ops.read_record\t\t= NULL;\n\tmyeid_ops.write_record\t\t= NULL;\n\tmyeid_ops.append_record\t\t= NULL;\n\tmyeid_ops.update_record\t\t= NULL;\n\tmyeid_ops.select_file\t\t= myeid_select_file;\n\tmyeid_ops.get_response\t\t= iso_ops->get_response;\n\tmyeid_ops.logout\t\t= myeid_logout;\n\tmyeid_ops.create_file\t\t= myeid_create_file;\n\tmyeid_ops.delete_file\t\t= myeid_delete_file;\n\tmyeid_ops.list_files\t\t= myeid_list_files;\n\tmyeid_ops.set_security_env\t= myeid_set_security_env;\n\tmyeid_ops.compute_signature\t= myeid_compute_signature;\n\tmyeid_ops.decipher\t\t= myeid_decipher;\n\tmyeid_ops.process_fci\t\t= myeid_process_fci;\n\tmyeid_ops.card_ctl\t\t= myeid_card_ctl;\n\tmyeid_ops.pin_cmd\t\t= myeid_pin_cmd;\n\tmyeid_ops.wrap\t\t\t= myeid_wrap_key;\n\tmyeid_ops.unwrap\t\t= myeid_unwrap_key;\n\tmyeid_ops.encrypt_sym\t\t= myeid_encrypt_sym;\n\tmyeid_ops.decrypt_sym\t\t= myeid_decrypt_sym;\n\treturn &myeid_drv;\n}\n",
        "cwe": "CWE-125",
        "file_name": "safe_respovul_idx_12801.c",
        "project": "opensc/opensc",
        "url": "https://github.com/OpenSC/OpenSC/commit/f1993dc4e0b33050b8f72a3558ee88b24c4063b2",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int32_t parse_len(const char *line)\n\tchar num[PKT_LEN_SIZE + 1];\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t}\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\treturn len;\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n\tlen = parse_len(line);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"common.h\"\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include <ctype.h>\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\treturn 0;\n}\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\treturn 0;\n}\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\treturn 0;\n}\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\tline += 4;\n\tlen -= 4;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\tline++;\n\tlen--;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\tline++;\n\tlen--;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\t*out = (git_pkt *) pkt;\n\treturn 0;\n}\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\tline++;\n\tlen--;\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_OK;\n\tline += 3; \n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\tGIT_UNUSED(len);\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\treturn len;\n}\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1  +\n\t\t git_buf_len(&str) + 1 ;\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\treturn 0;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_1711.c",
        "project": "libgit2/libgit2",
        "url": "https://github.com/libgit2/libgit2/commit/66e3774d279672ee51c3b54545a79d20d1ada834",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static int vop_copy_dp_entry(struct vop_vdev *vdev,\n\t\t\t     struct mic_device_desc *argp, __u8 *type,\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tvqconfig = mic_vq_config(argp);\n\tfor (i = 0; i < argp->num_vq; i++) {\n\t}\n\tfor (i = sizeof(struct mic_bootparam);\n\t\ti < MIC_DP_SIZE - mic_total_desc_size(argp);\n\t\ti += mic_total_desc_size(devp)) {\n\t\tdevp = vpdev->hw_ops->get_dp(vpdev) + i;\n\t\tif (devp->type == 0 || devp->type == -1) {\n\t\t}\n\targp->type = 0;\n\tmemcpy(devp, argp, mic_desc_size(argp));\nstatic int vop_virtio_add_device(struct vop_vdev *vdev,\n\t\t\t\t struct mic_device_desc *argp)\n\tstruct vop_info *vi = vdev->vi;\n\tstruct vop_device *vpdev = vi->vpdev;\n\tstruct mic_device_desc *dd = NULL;\n\tu8 type = 0;\n\tbootparam = vpdev->hw_ops->get_dp(vpdev);\n\tinit_waitqueue_head(&vdev->waitq);\n\tINIT_LIST_HEAD(&vdev->list);\n\tvdev->vpdev = vpdev;\n\tret = vop_copy_dp_entry(vdev, argp, &type, &dd);\nstatic long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n\t\t}\n\t\tif (memcmp(&dd, dd_config, sizeof(dd))) {\n\t\t}\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_virtio_add_device(vdev, dd_config);\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/dma-mapping.h>\n#include <linux/mic_common.h>\n#include \"../common/mic_dev.h\"\n#include <linux/mic_ioctl.h>\n#include \"vop_main.h\"\nstatic inline struct device *vop_dev(struct vop_vdev *vdev)\n{\n\treturn vdev->vpdev->dev.parent;\n}\nstatic inline int vop_vdev_inited(struct vop_vdev *vdev)\n{\n\tif (!vdev)\n\t\treturn -EINVAL;\n\tif (!vdev->dd || !vdev->dd->type) {\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, -EINVAL);\n\t\treturn -EINVAL;\n\t}\n\tif (vdev->dd->type == -1) {\n\t\tdev_dbg(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, -ENODEV);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\nstatic int vop_virtio_config_change(struct vop_vdev *vdev, void *argp)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wake);\n\tint ret = 0, retry, i;\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tstruct vop_info *vi = dev_get_drvdata(&vpdev->dev);\n\tstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\n\ts8 db = bootparam->h2c_config_db;\n\tmutex_lock(&vi->vop_mutex);\n\tfor (i = 0; i < vdev->dd->num_vq; i++)\n\t\tmutex_lock_nested(&vdev->vvr[i].vr_mutex, i + 1);\n\tif (db == -1 || vdev->dd->type == -1) {\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\tmemcpy(mic_vq_configspace(vdev->dd), argp, vdev->dd->config_len);\n\tvdev->dc->config_change = MIC_VIRTIO_PARAM_CONFIG_CHANGED;\n\tvpdev->hw_ops->send_intr(vpdev, db);\n\tfor (retry = 100; retry--;) {\n\t\tret = wait_event_timeout(wake, vdev->dc->guest_ack,\n\t\t\t\t\t msecs_to_jiffies(100));\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdev_dbg(vop_dev(vdev),\n\t\t\"%s %d retry: %d\\n\", __func__, __LINE__, retry);\n\tvdev->dc->config_change = 0;\n\tvdev->dc->guest_ack = 0;\nexit:\n\tfor (i = 0; i < vdev->dd->num_vq; i++)\n\t\tmutex_unlock(&vdev->vvr[i].vr_mutex);\n\tmutex_unlock(&vi->vop_mutex);\n\treturn ret;\n}\nstatic int vop_copy_dp_entry(struct vop_vdev *vdev,\n\t\t\t     struct mic_device_desc *argp, __u8 *type,\n\t\t\t     struct mic_device_desc **devpage)\n{\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tstruct mic_device_desc *devp;\n\tstruct mic_vqconfig *vqconfig;\n\tint ret = 0, i;\n\tbool slot_found = false;\n\tvqconfig = mic_vq_config(argp);\n\tfor (i = 0; i < argp->num_vq; i++) {\n\t\tif (le16_to_cpu(vqconfig[i].num) > MIC_MAX_VRING_ENTRIES) {\n\t\t\tret =  -EINVAL;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tfor (i = sizeof(struct mic_bootparam);\n\t\ti < MIC_DP_SIZE - mic_total_desc_size(argp);\n\t\ti += mic_total_desc_size(devp)) {\n\t\tdevp = vpdev->hw_ops->get_dp(vpdev) + i;\n\t\tif (devp->type == 0 || devp->type == -1) {\n\t\t\tslot_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!slot_found) {\n\t\tret =  -EINVAL;\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\t\tgoto exit;\n\t}\n\t*type = argp->type;\n\targp->type = 0;\n\tmemcpy(devp, argp, mic_desc_size(argp));\n\t*devpage = devp;\nexit:\n\treturn ret;\n}\nstatic void vop_init_device_ctrl(struct vop_vdev *vdev,\n\t\t\t\t struct mic_device_desc *devpage)\n{\n\tstruct mic_device_ctrl *dc;\n\tdc = (void *)devpage + mic_aligned_desc_size(devpage);\n\tdc->config_change = 0;\n\tdc->guest_ack = 0;\n\tdc->vdev_reset = 0;\n\tdc->host_ack = 0;\n\tdc->used_address_updated = 0;\n\tdc->c2h_vdev_db = -1;\n\tdc->h2c_vdev_db = -1;\n\tvdev->dc = dc;\n}\nstatic int vop_virtio_add_device(struct vop_vdev *vdev,\n\t\t\t\t struct mic_device_desc *argp)\n{\n\tstruct vop_info *vi = vdev->vi;\n\tstruct vop_device *vpdev = vi->vpdev;\n\tstruct mic_device_desc *dd = NULL;\n\tstruct mic_vqconfig *vqconfig;\n\tint vr_size, i, j, ret;\n\tu8 type = 0;\n\ts8 db = -1;\n\tchar irqname[16];\n\tstruct mic_bootparam *bootparam;\n\tu16 num;\n\tdma_addr_t vr_addr;\n\tbootparam = vpdev->hw_ops->get_dp(vpdev);\n\tinit_waitqueue_head(&vdev->waitq);\n\tINIT_LIST_HEAD(&vdev->list);\n\tvdev->vpdev = vpdev;\n\tret = vop_copy_dp_entry(vdev, argp, &type, &dd);\n\tif (ret) {\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\t\tkfree(vdev);\n\t\treturn ret;\n\t}\n\tvop_init_device_ctrl(vdev, dd);\n\tvdev->dd = dd;\n\tvdev->virtio_id = type;\n\tvqconfig = mic_vq_config(dd);\n\tINIT_WORK(&vdev->virtio_bh_work, vop_bh_handler);\n\tfor (i = 0; i < dd->num_vq; i++) {\n\t\tstruct vop_vringh *vvr = &vdev->vvr[i];\n\t\tstruct mic_vring *vr = &vdev->vvr[i].vring;\n\t\tnum = le16_to_cpu(vqconfig[i].num);\n\t\tmutex_init(&vvr->vr_mutex);\n\t\tvr_size = PAGE_ALIGN(vring_size(num, MIC_VIRTIO_RING_ALIGN) +\n\t\t\tsizeof(struct _mic_vring_info));\n\t\tvr->va = (void *)\n\t\t\t__get_free_pages(GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t\t get_order(vr_size));\n\t\tif (!vr->va) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tvr->len = vr_size;\n\t\tvr->info = vr->va + vring_size(num, MIC_VIRTIO_RING_ALIGN);\n\t\tvr->info->magic = cpu_to_le32(MIC_MAGIC + vdev->virtio_id + i);\n\t\tvr_addr = dma_map_single(&vpdev->dev, vr->va, vr_size,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(&vpdev->dev, vr_addr)) {\n\t\t\tfree_pages((unsigned long)vr->va, get_order(vr_size));\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tvqconfig[i].address = cpu_to_le64(vr_addr);\n\t\tvring_init(&vr->vr, num, vr->va, MIC_VIRTIO_RING_ALIGN);\n\t\tret = vringh_init_kern(&vvr->vrh,\n\t\t\t\t       *(u32 *)mic_vq_features(vdev->dd),\n\t\t\t\t       num, false, vr->vr.desc, vr->vr.avail,\n\t\t\t\t       vr->vr.used);\n\t\tif (ret) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tvringh_kiov_init(&vvr->riov, NULL, 0);\n\t\tvringh_kiov_init(&vvr->wiov, NULL, 0);\n\t\tvvr->head = USHRT_MAX;\n\t\tvvr->vdev = vdev;\n\t\tvvr->vrh.notify = _vop_notify;\n\t\tdev_dbg(&vpdev->dev,\n\t\t\t\"%s %d index %d va %p info %p vr_size 0x%x\\n\",\n\t\t\t__func__, __LINE__, i, vr->va, vr->info, vr_size);\n\t\tvvr->buf = (void *)__get_free_pages(GFP_KERNEL,\n\t\t\t\t\tget_order(VOP_INT_DMA_BUF_SIZE));\n\t\tvvr->buf_da = dma_map_single(&vpdev->dev,\n\t\t\t\t\t  vvr->buf, VOP_INT_DMA_BUF_SIZE,\n\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\t}\n\tsnprintf(irqname, sizeof(irqname), \"vop%dvirtio%d\", vpdev->index,\n\t\t vdev->virtio_id);\n\tvdev->virtio_db = vpdev->hw_ops->next_db(vpdev);\n\tvdev->virtio_cookie = vpdev->hw_ops->request_irq(vpdev,\n\t\t\t_vop_virtio_intr_handler, irqname, vdev,\n\t\t\tvdev->virtio_db);\n\tif (IS_ERR(vdev->virtio_cookie)) {\n\t\tret = PTR_ERR(vdev->virtio_cookie);\n\t\tdev_dbg(&vpdev->dev, \"request irq failed\\n\");\n\t\tgoto err;\n\t}\n\tvdev->dc->c2h_vdev_db = vdev->virtio_db;\n\tsmp_wmb();\n\tdd->type = type;\n\targp->type = type;\n\tif (bootparam) {\n\t\tdb = bootparam->h2c_config_db;\n\t\tif (db != -1)\n\t\t\tvpdev->hw_ops->send_intr(vpdev, db);\n\t}\n\tdev_dbg(&vpdev->dev, \"Added virtio id %d db %d\\n\", dd->type, db);\n\treturn 0;\nerr:\n\tvqconfig = mic_vq_config(dd);\n\tfor (j = 0; j < i; j++) {\n\t\tstruct vop_vringh *vvr = &vdev->vvr[j];\n\t\tdma_unmap_single(&vpdev->dev, le64_to_cpu(vqconfig[j].address),\n\t\t\t\t vvr->vring.len, DMA_BIDIRECTIONAL);\n\t\tfree_pages((unsigned long)vvr->vring.va,\n\t\t\t   get_order(vvr->vring.len));\n\t}\n\treturn ret;\n}\nstatic void vop_virtio_del_device(struct vop_vdev *vdev)\n{\n\tstruct vop_info *vi = vdev->vi;\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tint i;\n\tstruct mic_vqconfig *vqconfig;\n\tstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\n\tif (!bootparam)\n\t\tgoto skip_hot_remove;\n\tvop_dev_remove(vi, vdev->dc, vpdev);\nskip_hot_remove:\n\tvpdev->hw_ops->free_irq(vpdev, vdev->virtio_cookie, vdev);\n\tflush_work(&vdev->virtio_bh_work);\n\tvqconfig = mic_vq_config(vdev->dd);\n\tfor (i = 0; i < vdev->dd->num_vq; i++) {\n\t\tstruct vop_vringh *vvr = &vdev->vvr[i];\n\t\tdma_unmap_single(&vpdev->dev,\n\t\t\t\t vvr->buf_da, VOP_INT_DMA_BUF_SIZE,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tfree_pages((unsigned long)vvr->buf,\n\t\t\t   get_order(VOP_INT_DMA_BUF_SIZE));\n\t\tvringh_kiov_cleanup(&vvr->riov);\n\t\tvringh_kiov_cleanup(&vvr->wiov);\n\t\tdma_unmap_single(&vpdev->dev, le64_to_cpu(vqconfig[i].address),\n\t\t\t\t vvr->vring.len, DMA_BIDIRECTIONAL);\n\t\tfree_pages((unsigned long)vvr->vring.va,\n\t\t\t   get_order(vvr->vring.len));\n\t}\n\tsmp_wmb();\n\tvdev->dd->type = -1;\n}\n#define VOP_USE_DMA true\nstatic int vop_virtio_copy_to_user(struct vop_vdev *vdev, void __user *ubuf,\n\t\t\t\t   size_t len, u64 daddr, size_t dlen,\n\t\t\t\t   int vr_idx)\n{\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tvoid __iomem *dbuf = vpdev->hw_ops->ioremap(vpdev, daddr, len);\n\tstruct vop_vringh *vvr = &vdev->vvr[vr_idx];\n\tstruct vop_info *vi = dev_get_drvdata(&vpdev->dev);\n\tsize_t dma_alignment = 1 << vi->dma_ch->device->copy_align;\n\tbool x200 = is_dma_copy_aligned(vi->dma_ch->device, 1, 1, 1);\n\tsize_t dma_offset, partlen;\n\tint err;\n\tif (!VOP_USE_DMA) {\n\t\tif (copy_to_user(ubuf, (void __force *)dbuf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, err);\n\t\t\tgoto err;\n\t\t}\n\t\tvdev->in_bytes += len;\n\t\terr = 0;\n\t\tgoto err;\n\t}\n\tdma_offset = daddr - round_down(daddr, dma_alignment);\n\tdaddr -= dma_offset;\n\tlen += dma_offset;\n\tif (x200)\n\t\tdaddr += vpdev->aper->pa;\n\twhile (len) {\n\t\tpartlen = min_t(size_t, len, VOP_INT_DMA_BUF_SIZE);\n\t\terr = vop_sync_dma(vdev, vvr->buf_da, daddr,\n\t\t\t\t   ALIGN(partlen, dma_alignment));\n\t\tif (err) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, err);\n\t\t\tgoto err;\n\t\t}\n\t\tif (copy_to_user(ubuf, vvr->buf + dma_offset,\n\t\t\t\t partlen - dma_offset)) {\n\t\t\terr = -EFAULT;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, err);\n\t\t\tgoto err;\n\t\t}\n\t\tdaddr += partlen;\n\t\tubuf += partlen;\n\t\tdbuf += partlen;\n\t\tvdev->in_bytes_dma += partlen;\n\t\tvdev->in_bytes += partlen;\n\t\tlen -= partlen;\n\t\tdma_offset = 0;\n\t}\n\terr = 0;\nerr:\n\tvpdev->hw_ops->iounmap(vpdev, dbuf);\n\tdev_dbg(vop_dev(vdev),\n\t\t\"%s: ubuf %p dbuf %p len 0x%lx vr_idx 0x%x\\n\",\n\t\t__func__, ubuf, dbuf, len, vr_idx);\n\treturn err;\n}\nstatic int vop_virtio_copy_from_user(struct vop_vdev *vdev, void __user *ubuf,\n\t\t\t\t     size_t len, u64 daddr, size_t dlen,\n\t\t\t\t     int vr_idx)\n{\n\tstruct vop_device *vpdev = vdev->vpdev;\n\tvoid __iomem *dbuf = vpdev->hw_ops->ioremap(vpdev, daddr, len);\n\tstruct vop_vringh *vvr = &vdev->vvr[vr_idx];\n\tstruct vop_info *vi = dev_get_drvdata(&vdev->vpdev->dev);\n\tsize_t dma_alignment = 1 << vi->dma_ch->device->copy_align;\n\tbool x200 = is_dma_copy_aligned(vi->dma_ch->device, 1, 1, 1);\n\tsize_t partlen;\n\tbool dma = VOP_USE_DMA;\n\tint err = 0;\n\tif (daddr & (dma_alignment - 1)) {\n\t\tvdev->tx_dst_unaligned += len;\n\t\tdma = false;\n\t} else if (ALIGN(len, dma_alignment) > dlen) {\n\t\tvdev->tx_len_unaligned += len;\n\t\tdma = false;\n\t}\n\tif (!dma)\n\t\tgoto memcpy;\n\tif (x200)\n\t\tdaddr += vpdev->aper->pa;\n\twhile (len) {\n\t\tpartlen = min_t(size_t, len, VOP_INT_DMA_BUF_SIZE);\n\t\tif (copy_from_user(vvr->buf, ubuf, partlen)) {\n\t\t\terr = -EFAULT;\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, err);\n\t\t\tgoto err;\n\t\t}\n\t\terr = vop_sync_dma(vdev, daddr, vvr->buf_da,\n\t\t\t\t   ALIGN(partlen, dma_alignment));\n\t\tif (err) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, err);\n\t\t\tgoto err;\n\t\t}\n\t\tdaddr += partlen;\n\t\tubuf += partlen;\n\t\tdbuf += partlen;\n\t\tvdev->out_bytes_dma += partlen;\n\t\tvdev->out_bytes += partlen;\n\t\tlen -= partlen;\n\t}\nmemcpy:\n\tif (copy_from_user((void __force *)dbuf, ubuf, len)) {\n\t\terr = -EFAULT;\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, err);\n\t\tgoto err;\n\t}\n\tvdev->out_bytes += len;\n\terr = 0;\nerr:\n\tvpdev->hw_ops->iounmap(vpdev, dbuf);\n\tdev_dbg(vop_dev(vdev),\n\t\t\"%s: ubuf %p dbuf %p len 0x%lx vr_idx 0x%x\\n\",\n\t\t__func__, ubuf, dbuf, len, vr_idx);\n\treturn err;\n}\n#define MIC_VRINGH_READ true\nstatic inline u32 vop_vringh_iov_consumed(struct vringh_kiov *iov)\n{\n\tint i;\n\tu32 total = iov->consumed;\n\tfor (i = 0; i < iov->i; i++)\n\t\ttotal += iov->iov[i].iov_len;\n\treturn total;\n}\nstatic int vop_vringh_copy(struct vop_vdev *vdev, struct vringh_kiov *iov,\n\t\t\t   void __user *ubuf, size_t len, bool read, int vr_idx,\n\t\t\t   size_t *out_len)\n{\n\tint ret = 0;\n\tsize_t partlen, tot_len = 0;\n\twhile (len && iov->i < iov->used) {\n\t\tstruct kvec *kiov = &iov->iov[iov->i];\n\t\tpartlen = min(kiov->iov_len, len);\n\t\tif (read)\n\t\t\tret = vop_virtio_copy_to_user(vdev, ubuf, partlen,\n\t\t\t\t\t\t      (u64)kiov->iov_base,\n\t\t\t\t\t\t      kiov->iov_len,\n\t\t\t\t\t\t      vr_idx);\n\t\telse\n\t\t\tret = vop_virtio_copy_from_user(vdev, ubuf, partlen,\n\t\t\t\t\t\t\t(u64)kiov->iov_base,\n\t\t\t\t\t\t\tkiov->iov_len,\n\t\t\t\t\t\t\tvr_idx);\n\t\tif (ret) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= partlen;\n\t\tubuf += partlen;\n\t\ttot_len += partlen;\n\t\tiov->consumed += partlen;\n\t\tkiov->iov_len -= partlen;\n\t\tkiov->iov_base += partlen;\n\t\tif (!kiov->iov_len) {\n\t\t\tkiov->iov_len = iov->consumed;\n\t\t\tkiov->iov_base -= iov->consumed;\n\t\t\tiov->consumed = 0;\n\t\t\tiov->i++;\n\t\t}\n\t}\n\t*out_len = tot_len;\n\treturn ret;\n}\nstatic int _vop_virtio_copy(struct vop_vdev *vdev, struct mic_copy_desc *copy)\n{\n\tint ret = 0;\n\tu32 iovcnt = copy->iovcnt;\n\tstruct iovec iov;\n\tstruct iovec __user *u_iov = copy->iov;\n\tvoid __user *ubuf = NULL;\n\tstruct vop_vringh *vvr = &vdev->vvr[copy->vr_idx];\n\tstruct vringh_kiov *riov = &vvr->riov;\n\tstruct vringh_kiov *wiov = &vvr->wiov;\n\tstruct vringh *vrh = &vvr->vrh;\n\tu16 *head = &vvr->head;\n\tstruct mic_vring *vr = &vvr->vring;\n\tsize_t len = 0, out_len;\n\tcopy->out_len = 0;\n\tif (riov->i == riov->used && wiov->i == wiov->used) {\n\t\tret = vringh_getdesc_kern(vrh, riov, wiov,\n\t\t\t\t\t  head, GFP_KERNEL);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\twhile (iovcnt) {\n\t\tif (!len) {\n\t\t\tret = copy_from_user(&iov, u_iov, sizeof(*u_iov));\n\t\t\tif (ret) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t\t__func__, __LINE__, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = iov.iov_len;\n\t\t\tubuf = iov.iov_base;\n\t\t}\n\t\tret = vop_vringh_copy(vdev, riov, ubuf, len,\n\t\t\t\t      MIC_VRINGH_READ, copy->vr_idx, &out_len);\n\t\tif (ret) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= out_len;\n\t\tubuf += out_len;\n\t\tcopy->out_len += out_len;\n\t\tret = vop_vringh_copy(vdev, wiov, ubuf, len,\n\t\t\t\t      !MIC_VRINGH_READ, copy->vr_idx, &out_len);\n\t\tif (ret) {\n\t\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t\t__func__, __LINE__, ret);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= out_len;\n\t\tubuf += out_len;\n\t\tcopy->out_len += out_len;\n\t\tif (!len) {\n\t\t\tiovcnt--;\n\t\t\tu_iov++;\n\t\t}\n\t\tif (riov->i == riov->used && wiov->i == wiov->used)\n\t\t\tbreak;\n\t}\n\tif (*head != USHRT_MAX && copy->out_len && copy->update_used) {\n\t\tu32 total = 0;\n\t\ttotal += vop_vringh_iov_consumed(riov);\n\t\ttotal += vop_vringh_iov_consumed(wiov);\n\t\tvringh_complete_kern(vrh, *head, total);\n\t\t*head = USHRT_MAX;\n\t\tif (vringh_need_notify_kern(vrh) > 0)\n\t\t\tvringh_notify(vrh);\n\t\tvringh_kiov_cleanup(riov);\n\t\tvringh_kiov_cleanup(wiov);\n\t\tvr->info->avail_idx = vrh->last_avail_idx;\n\t}\n\treturn ret;\n}\nstatic inline int vop_verify_copy_args(struct vop_vdev *vdev,\n\t\t\t\t       struct mic_copy_desc *copy)\n{\n\tif (!vdev || copy->vr_idx >= vdev->dd->num_vq)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nstatic int vop_virtio_copy_desc(struct vop_vdev *vdev,\n\t\t\t\tstruct mic_copy_desc *copy)\n{\n\tint err;\n\tstruct vop_vringh *vvr;\n\terr = vop_verify_copy_args(vdev, copy);\n\tif (err)\n\t\treturn err;\n\tvvr = &vdev->vvr[copy->vr_idx];\n\tmutex_lock(&vvr->vr_mutex);\n\tif (!vop_vdevup(vdev)) {\n\t\terr = -ENODEV;\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, err);\n\t\tgoto err;\n\t}\n\terr = _vop_virtio_copy(vdev, copy);\n\tif (err) {\n\t\tdev_err(vop_dev(vdev), \"%s %d err %d\\n\",\n\t\t\t__func__, __LINE__, err);\n\t}\nerr:\n\tmutex_unlock(&vvr->vr_mutex);\n\treturn err;\n}\nstatic long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\tswitch (cmd) {\n\tcase MIC_VIRTIO_ADD_DEVICE:\n\t{\n\t\tstruct mic_device_desc dd, *dd_config;\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\t\treturn -EINVAL;\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_ret;\n\t\t}\n\t\tif (memcmp(&dd, dd_config, sizeof(dd))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_ret;\n\t\t}\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tmutex_lock(&vi->vop_mutex);\n\t\tret = vop_virtio_add_device(vdev, dd_config);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t\tlist_add_tail(&vdev->list, &vi->vdev_list);\nunlock_ret:\n\t\tmutex_unlock(&vi->vop_mutex);\n\t\tmutex_unlock(&vdev->vdev_mutex);\nfree_ret:\n\t\tkfree(dd_config);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_COPY_DESC:\n\t{\n\t\tstruct mic_copy_desc copy;\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_from_user(&copy, argp, sizeof(copy))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto _unlock_ret;\n\t\t}\n\t\tret = vop_virtio_copy_desc(vdev, &copy);\n\t\tif (ret < 0)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_to_user(\n\t\t\t&((struct mic_copy_desc __user *)argp)->out_len,\n\t\t\t&copy.out_len, sizeof(copy.out_len)))\n\t\t\tret = -EFAULT;\n_unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_CONFIG_CHANGE:\n\t{\n\t\tvoid *buf;\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto __unlock_ret;\n\t\tbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __unlock_ret;\n\t\t}\n\t\tif (copy_from_user(buf, argp, vdev->dd->config_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tret = vop_virtio_config_change(vdev, buf);\ndone:\n\t\tkfree(buf);\n__unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t};\n\treturn 0;\n}\nstatic const struct file_operations vop_fops = {\n\t.open = vop_open,\n\t.release = vop_release,\n\t.unlocked_ioctl = vop_ioctl,\n\t.poll = vop_poll,\n\t.mmap = vop_mmap,\n\t.owner = THIS_MODULE,\n};\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1152.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/9bf292bfca94694a721449e3fd752493856710f6",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```MOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in) {\n}\nstatic MOBI_INLINE uint64_t mobi_buffer_fill64(MOBIBuffer *buf) {\n}\nstatic MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        if (!(t1 & 0x80)) {\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n        }\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        int is_decompressed = symbol_length >> 15;\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n}\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <string.h>\n#include \"compression.h\"\n#include \"buffer.h\"\n#include \"mobi.h\"\n#include \"debug.h\"\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in) {\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf_in = mobi_buffer_init_null((unsigned char *) in, len_in);\n    if (buf_in == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIBuffer *buf_out = mobi_buffer_init_null(out, *len_out);\n    if (buf_out == NULL) {\n        mobi_buffer_free_null(buf_in);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    while (ret == MOBI_SUCCESS && buf_in->offset < buf_in->maxlen) {\n        uint8_t byte = mobi_buffer_get8(buf_in);\n        if (byte >= 0xc0) {\n            mobi_buffer_add8(buf_out, ' ');\n            mobi_buffer_add8(buf_out, byte ^ 0x80);\n        }\n        else if (byte >= 0x80) {\n            uint8_t next = mobi_buffer_get8(buf_in);\n            uint16_t distance = ((((byte << 8) | ((uint8_t)next)) >> 3) & 0x7ff);\n            uint8_t length = (next & 0x7) + 3;\n            while (length--) {\n                mobi_buffer_move(buf_out, -distance, 1);\n            }\n        }\n        else if (byte >= 0x09) {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        else if (byte >= 0x01) {\n            mobi_buffer_copy(buf_out, buf_in, byte);\n        }\n        else {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        if (buf_in->error || buf_out->error) {\n            ret = MOBI_BUFFER_END;\n        }\n    }\n    *len_out = buf_out->offset;\n    mobi_buffer_free_null(buf_out);\n    mobi_buffer_free_null(buf_in);\n    return ret;\n}\nstatic MOBI_INLINE uint64_t mobi_buffer_fill64(MOBIBuffer *buf) {\n    uint64_t val = 0;\n    uint8_t i = 8;\n    size_t bytesleft = buf->maxlen - buf->offset;\n    unsigned char *ptr = buf->data + buf->offset;\n    while (i-- && bytesleft--) {\n        val |= (uint64_t) *ptr++ << (i * 8);\n    }\n    buf->offset += 4;\n    return val;\n}\nstatic MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        if (!(t1 & 0x80)) {\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        int is_decompressed = symbol_length >> 15;\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\nFile number 2:\n/** @file compression.h\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#ifndef libmobi_compression_h\n#define libmobi_compression_h\n\n#include \"config.h\"\n#include \"mobi.h\"\n\n#ifndef MOBI_INLINE\n#define MOBI_INLINE /**< Syntax for compiler inline keyword from config.h */\n#endif\n\n/* FIXME: what is the reasonable value? */\n#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */\n\n\n/**\n @brief Parsed data from HUFF and CDIC records needed to unpack huffman compressed text\n */\ntypedef struct {\n    size_t index_count; /**< Total number of indices in all CDIC records, stored in each CDIC record header */\n    size_t index_read; /**< Number of indices parsed, used by parser */\n    size_t code_length; /**< Code length value stored in CDIC record header */\n    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */\n    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */\n    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */\n    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */\n    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */\n} MOBIHuffCdic;\n\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in);\nMOBI_RET mobi_decompress_huffman(unsigned char *out, const unsigned char *in, size_t *len_out, size_t len_in, const MOBIHuffCdic *huffcdic);\n\n#endif\n\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_6603.c",
        "project": "bfabiszewski/libmobi",
        "url": "https://github.com/bfabiszewski/libmobi/commit/bec783e6212439a335ba6e8df7ab8ed610ca9a21",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n\tstruct hiddev_list *list = file->private_data;\n\tstruct hiddev *hiddev = list->hiddev;\n\thid = hiddev->hid;\n\t\tif (copy_from_user(&finfo, user_arg, sizeof(finfo))) {\n\t\t}\n\t\trinfo.report_type = finfo.report_type;\n\t\trinfo.report_id = finfo.report_id;\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\t\tif (finfo.field_index >= report->maxfield)\n\t\t\tbreak;\n\t\tfield = report->field[finfo.field_index];\n\t\tmemset(&finfo, 0, sizeof(finfo));\n\t\tfinfo.report_type = rinfo.report_type;\n\t\tfinfo.report_id = rinfo.report_id;\n\t\tfinfo.field_index = field->report_count - 1;\n\t\tfinfo.maxusage = field->maxusage;\n\t\tfinfo.flags = field->flags;\n\t\tfinfo.physical = field->physical;\n\t\tfinfo.logical = field->logical;\n\t\tfinfo.application = field->application;\n\t\tfinfo.logical_minimum = field->logical_minimum;\n\t\tfinfo.logical_maximum = field->logical_maximum;\n\t\tfinfo.physical_minimum = field->physical_minimum;\n\t\tfinfo.physical_maximum = field->physical_maximum;\n\t\tfinfo.unit_exponent = field->unit_exponent;\n\t\tfinfo.unit = field->unit;\n\t\tr = copy_to_user(user_arg, &finfo, sizeof(finfo)) ?\n\t\t\t-EFAULT : 0;\n```",
        "output": "No",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/compat.h>\n#include <linux/vmalloc.h>\n#include \"usbhid.h\"\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define HIDDEV_MINOR_BASE\t0\n#define HIDDEV_MINORS\t\t256\n#else\n#define HIDDEV_MINOR_BASE\t96\n#define HIDDEV_MINORS\t\t16\n#endif\n#define HIDDEV_BUFFER_SIZE\t2048\nstruct hiddev {\n\tint exist;\n\tint open;\n\tstruct mutex existancelock;\n\twait_queue_head_t wait;\n\tstruct hid_device *hid;\n\tstruct list_head list;\n\tspinlock_t list_lock;\n};\nstruct hiddev_list {\n\tstruct hiddev_usage_ref buffer[HIDDEV_BUFFER_SIZE];\n\tint head;\n\tint tail;\n\tunsigned flags;\n\tstruct fasync_struct *fasync;\n\tstruct hiddev *hiddev;\n\tstruct list_head node;\n\tstruct mutex thread_lock;\n};\nstatic struct hid_report *\nhiddev_lookup_report(struct hid_device *hid, struct hiddev_report_info *rinfo)\n{\n\tunsigned int flags = rinfo->report_id & ~HID_REPORT_ID_MASK;\n\tunsigned int rid = rinfo->report_id & HID_REPORT_ID_MASK;\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_report *report;\n\tstruct list_head *list;\n\tif (rinfo->report_type < HID_REPORT_TYPE_MIN ||\n\t    rinfo->report_type > HID_REPORT_TYPE_MAX)\n\t\treturn NULL;\n\treport_enum = hid->report_enum +\n\t\t(rinfo->report_type - HID_REPORT_TYPE_MIN);\n\tswitch (flags) {\n\tcase 0: \n\t\tbreak;\n\tcase HID_REPORT_ID_FIRST:\n\t\tif (list_empty(&report_enum->report_list))\n\t\t\treturn NULL;\n\t\tlist = report_enum->report_list.next;\n\t\treport = list_entry(list, struct hid_report, list);\n\t\trinfo->report_id = report->id;\n\t\tbreak;\n\tcase HID_REPORT_ID_NEXT:\n\t\treport = report_enum->report_id_hash[rid];\n\t\tif (!report)\n\t\t\treturn NULL;\n\t\tlist = report->list.next;\n\t\tif (list == &report_enum->report_list)\n\t\t\treturn NULL;\n\t\treport = list_entry(list, struct hid_report, list);\n\t\trinfo->report_id = report->id;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn report_enum->report_id_hash[rinfo->report_id];\n}\nstatic int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = usbhid_open(hiddev->hid);\n\t\t\tif (res < 0) {\n\t\t\t\tres = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\tmutex_lock(&hiddev->existancelock);\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = usbhid_get_power(hid);\n\t\t\tif (res < 0) {\n\t\t\t\tres = -EIO;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tusbhid_open(hid);\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}\nstatic ssize_t hiddev_write(struct file * file, const char __user * buffer, size_t count, loff_t *ppos)\n{\n\treturn -EINVAL;\n}\nstatic ssize_t hiddev_read(struct file * file, char __user * buffer, size_t count, loff_t *ppos)\n{\n\tDEFINE_WAIT(wait);\n\tstruct hiddev_list *list = file->private_data;\n\tint event_size;\n\tint retval;\n\tevent_size = ((list->flags & HIDDEV_FLAG_UREF) != 0) ?\n\t\tsizeof(struct hiddev_usage_ref) : sizeof(struct hiddev_event);\n\tif (count < event_size)\n\t\treturn 0;\n\tretval = mutex_lock_interruptible(&list->thread_lock);\n\tif (retval)\n\t\treturn -ERESTARTSYS;\n\twhile (retval == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tprepare_to_wait(&list->hiddev->wait, &wait, TASK_INTERRUPTIBLE);\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hiddev->exist) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\tschedule();\n\t\t\t\tif (mutex_lock_interruptible(&list->thread_lock)) {\n\t\t\t\t\tfinish_wait(&list->hiddev->wait, &wait);\n\t\t\t\t\treturn -EINTR;\n\t\t\t\t}\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tfinish_wait(&list->hiddev->wait, &wait);\n\t\t}\n\t\tif (retval) {\n\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\treturn retval;\n\t\t}\n\t\twhile (list->head != list->tail &&\n\t\t       retval + event_size <= count) {\n\t\t\tif ((list->flags & HIDDEV_FLAG_UREF) == 0) {\n\t\t\t\tif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE) {\n\t\t\t\t\tstruct hiddev_event event;\n\t\t\t\t\tevent.hid = list->buffer[list->tail].usage_code;\n\t\t\t\t\tevent.value = list->buffer[list->tail].value;\n\t\t\t\t\tif (copy_to_user(buffer + retval, &event, sizeof(struct hiddev_event))) {\n\t\t\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tretval += sizeof(struct hiddev_event);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE ||\n\t\t\t\t    (list->flags & HIDDEV_FLAG_REPORT) != 0) {\n\t\t\t\t\tif (copy_to_user(buffer + retval, list->buffer + list->tail, sizeof(struct hiddev_usage_ref))) {\n\t\t\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tretval += sizeof(struct hiddev_usage_ref);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);\n\t\t}\n\t}\n\tmutex_unlock(&list->thread_lock);\n\treturn retval;\n}\nstatic noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\t\tgoto goodreturn;\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\t\t\tfield = report->field[uref->field_index];\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\tgoto inval;\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}\nstatic noinline int hiddev_ioctl_string(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tint idx, len;\n\tchar *buf;\n\tif (get_user(idx, (int __user *)user_arg))\n\t\treturn -EFAULT;\n\tif ((buf = kmalloc(HID_STRING_SIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tif ((len = usb_string(dev, idx, buf, HID_STRING_SIZE-1)) < 0) {\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\tif (copy_to_user(user_arg+sizeof(int), buf, len+1)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tkfree(buf);\n\treturn len;\n}\nstatic long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hiddev_list *list = file->private_data;\n\tstruct hiddev *hiddev = list->hiddev;\n\tstruct hid_device *hid;\n\tstruct hiddev_collection_info cinfo;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_field_info finfo;\n\tstruct hiddev_devinfo dinfo;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tvoid __user *user_arg = (void __user *)arg;\n\tint i, r = -EINVAL;\n\tmutex_lock(&hiddev->existancelock);\n\tif (!hiddev->exist) {\n\t\tr = -ENODEV;\n\t\tgoto ret_unlock;\n\t}\n\thid = hiddev->hid;\n\tswitch (cmd) {\n\tcase HIDIOCGVERSION:\n\t\tr = put_user(HID_VERSION, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\tcase HIDIOCAPPLICATION:\n\t\tif (arg >= hid->maxapplication)\n\t\t\tbreak;\n\t\tfor (i = 0; i < hid->maxcollection; i++)\n\t\t\tif (hid->collection[i].type ==\n\t\t\t    HID_COLLECTION_APPLICATION && arg-- == 0)\n\t\t\t\tbreak;\n\t\tif (i < hid->maxcollection)\n\t\t\tr = hid->collection[i].usage;\n\t\tbreak;\n\tcase HIDIOCGDEVINFO:\n\t\t{\n\t\t\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\t\t\tstruct usbhid_device *usbhid = hid->driver_data;\n\t\t\tmemset(&dinfo, 0, sizeof(dinfo));\n\t\t\tdinfo.bustype = BUS_USB;\n\t\t\tdinfo.busnum = dev->bus->busnum;\n\t\t\tdinfo.devnum = dev->devnum;\n\t\t\tdinfo.ifnum = usbhid->ifnum;\n\t\t\tdinfo.vendor = le16_to_cpu(dev->descriptor.idVendor);\n\t\t\tdinfo.product = le16_to_cpu(dev->descriptor.idProduct);\n\t\t\tdinfo.version = le16_to_cpu(dev->descriptor.bcdDevice);\n\t\t\tdinfo.num_applications = hid->maxapplication;\n\t\t\tr = copy_to_user(user_arg, &dinfo, sizeof(dinfo)) ?\n\t\t\t\t-EFAULT : 0;\n\t\t\tbreak;\n\t\t}\n\tcase HIDIOCGFLAG:\n\t\tr = put_user(list->flags, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\tcase HIDIOCSFLAG:\n\t\t{\n\t\t\tint newflags;\n\t\t\tif (get_user(newflags, (int __user *)arg)) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((newflags & ~HIDDEV_FLAGS) != 0 ||\n\t\t\t    ((newflags & HIDDEV_FLAG_REPORT) != 0 &&\n\t\t\t     (newflags & HIDDEV_FLAG_UREF) == 0))\n\t\t\t\tbreak;\n\t\t\tlist->flags = newflags;\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\tcase HIDIOCGSTRING:\n\t\tr = hiddev_ioctl_string(hiddev, cmd, user_arg);\n\t\tbreak;\n\tcase HIDIOCINITREPORT:\n\t\tusbhid_init_reports(hid);\n\t\tr = 0;\n\t\tbreak;\n\tcase HIDIOCGREPORT:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (rinfo.report_type == HID_REPORT_TYPE_OUTPUT)\n\t\t\tbreak;\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\t\thid_hw_request(hid, report, HID_REQ_GET_REPORT);\n\t\thid_hw_wait(hid);\n\t\tr = 0;\n\t\tbreak;\n\tcase HIDIOCSREPORT:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (rinfo.report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tbreak;\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\t\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\t\thid_hw_wait(hid);\n\t\tr = 0;\n\t\tbreak;\n\tcase HIDIOCGREPORTINFO:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\t\trinfo.num_fields = report->maxfield;\n\t\tr = copy_to_user(user_arg, &rinfo, sizeof(rinfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\tcase HIDIOCGFIELDINFO:\n\t\tif (copy_from_user(&finfo, user_arg, sizeof(finfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trinfo.report_type = finfo.report_type;\n\t\trinfo.report_id = finfo.report_id;\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\t\tif (finfo.field_index >= report->maxfield)\n\t\t\tbreak;\n\t\tfield = report->field[finfo.field_index];\n\t\tmemset(&finfo, 0, sizeof(finfo));\n\t\tfinfo.report_type = rinfo.report_type;\n\t\tfinfo.report_id = rinfo.report_id;\n\t\tfinfo.field_index = field->report_count - 1;\n\t\tfinfo.maxusage = field->maxusage;\n\t\tfinfo.flags = field->flags;\n\t\tfinfo.physical = field->physical;\n\t\tfinfo.logical = field->logical;\n\t\tfinfo.application = field->application;\n\t\tfinfo.logical_minimum = field->logical_minimum;\n\t\tfinfo.logical_maximum = field->logical_maximum;\n\t\tfinfo.physical_minimum = field->physical_minimum;\n\t\tfinfo.physical_maximum = field->physical_maximum;\n\t\tfinfo.unit_exponent = field->unit_exponent;\n\t\tfinfo.unit = field->unit;\n\t\tr = copy_to_user(user_arg, &finfo, sizeof(finfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\tcase HIDIOCGUCODE:\n\tcase HIDIOCGUSAGE:\n\tcase HIDIOCSUSAGE:\n\tcase HIDIOCGUSAGES:\n\tcase HIDIOCSUSAGES:\n\tcase HIDIOCGCOLLECTIONINDEX:\n\t\tr = hiddev_ioctl_usage(hiddev, cmd, user_arg);\n\t\tbreak;\n\tcase HIDIOCGCOLLECTIONINFO:\n\t\tif (copy_from_user(&cinfo, user_arg, sizeof(cinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (cinfo.index >= hid->maxcollection)\n\t\t\tbreak;\n\t\tcinfo.type = hid->collection[cinfo.index].type;\n\t\tcinfo.usage = hid->collection[cinfo.index].usage;\n\t\tcinfo.level = hid->collection[cinfo.index].level;\n\t\tr = copy_to_user(user_arg, &cinfo, sizeof(cinfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\tdefault:\n\t\tif (_IOC_TYPE(cmd) != 'H' || _IOC_DIR(cmd) != _IOC_READ)\n\t\t\tbreak;\n\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGNAME(0))) {\n\t\t\tint len = strlen(hid->name) + 1;\n\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\t len = _IOC_SIZE(cmd);\n\t\t\tr = copy_to_user(user_arg, hid->name, len) ?\n\t\t\t\t-EFAULT : len;\n\t\t\tbreak;\n\t\t}\n\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGPHYS(0))) {\n\t\t\tint len = strlen(hid->phys) + 1;\n\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\tlen = _IOC_SIZE(cmd);\n\t\t\tr = copy_to_user(user_arg, hid->phys, len) ?\n\t\t\t\t-EFAULT : len;\n\t\t\tbreak;\n\t\t}\n\t}\nret_unlock:\n\tmutex_unlock(&hiddev->existancelock);\n\treturn r;\n}\n#ifdef CONFIG_COMPAT\nstatic long hiddev_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn hiddev_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\nstatic const struct file_operations hiddev_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\thiddev_read,\n\t.write =\thiddev_write,\n\t.poll =\t\thiddev_poll,\n\t.open =\t\thiddev_open,\n\t.release =\thiddev_release,\n\t.unlocked_ioctl =\thiddev_ioctl,\n\t.fasync =\thiddev_fasync,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= hiddev_compat_ioctl,\n#endif\n\t.llseek\t\t= noop_llseek,\n};\nstatic struct usb_class_driver hiddev_class = {\n\t.name =\t\t\"hiddev%d\",\n\t.devnode =\thiddev_devnode,\n\t.fops =\t\t&hiddev_fops,\n\t.minor_base =\tHIDDEV_MINOR_BASE,\n};\nstatic struct usb_class_driver hiddev_class;\n",
        "cwe": "CWE-119",
        "file_name": "safe_respovul_idx_1154.c",
        "project": "torvalds/linux",
        "url": "https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```static bool can_read_data(struct io *io, void *user_data)\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tbytes_read = read(chan->fd, chan->buf, chan->mtu);\n\tif (bytes_read < 0)\n\t\treturn false;\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT received: %zd\",\n\t\t\t\tchan, bytes_read);\n\tutil_hexdump('>', chan->buf, bytes_read,\n\t\t\t\tatt->debug_callback, att->debug_data);\n\tif (bytes_read < ATT_MIN_PDU_LEN)\n\t\treturn true;\n\tpdu = chan->buf;\n\topcode = pdu[0];\n\tbt_att_ref(att);\n\tswitch (get_op_type(opcode)) {\n\t\tchan->in_req = true;\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT PDU received: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\thandle_notify(chan, pdu, bytes_read);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/timeout.h\"\n#include \"lib/bluetooth.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/uuid.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/crypto.h\"\n#define ATT_MIN_PDU_LEN\t\t\t1  \n#define ATT_OP_CMD_MASK\t\t\t0x40\n#define ATT_OP_SIGNED_MASK\t\t0x80\n#define ATT_TIMEOUT_INTERVAL\t\t30000  \n#define BT_ATT_SIGNATURE_LEN\t\t12\nstruct att_send_op;\nstruct bt_att_chan {\n\tstruct bt_att *att;\n\tint fd;\n\tstruct io *io;\n\tuint8_t type;\n\tint sec_level;\t\t\t\n\tstruct queue *queue;\t\t\n\tstruct att_send_op *pending_req;\n\tstruct att_send_op *pending_ind;\n\tbool writer_active;\n\tbool in_req;\t\t\t\n\tuint8_t *buf;\n\tuint16_t mtu;\n};\nstruct bt_att {\n\tint ref_count;\n\tbool close_on_unref;\n\tstruct queue *chans;\n\tuint8_t enc_size;\n\tuint16_t mtu;\t\t\t\n\tstruct queue *notify_list;\t\n\tstruct queue *disconn_list;\t\n\tunsigned int next_send_id;\t\n\tunsigned int next_reg_id;\t\n\tstruct queue *req_queue;\t\n\tstruct queue *ind_queue;\t\n\tstruct queue *write_queue;\t\n\tbt_att_timeout_func_t timeout_callback;\n\tbt_att_destroy_func_t timeout_destroy;\n\tvoid *timeout_data;\n\tbt_att_debug_func_t debug_callback;\n\tbt_att_destroy_func_t debug_destroy;\n\tvoid *debug_data;\n\tstruct bt_crypto *crypto;\n\tstruct sign_info *local_sign;\n\tstruct sign_info *remote_sign;\n};\nstruct sign_info {\n\tuint8_t key[16];\n\tbt_att_counter_func_t counter;\n\tvoid *user_data;\n};\nenum att_op_type {\n\tATT_OP_TYPE_REQ,\n\tATT_OP_TYPE_RSP,\n\tATT_OP_TYPE_CMD,\n\tATT_OP_TYPE_IND,\n\tATT_OP_TYPE_NFY,\n\tATT_OP_TYPE_CONF,\n\tATT_OP_TYPE_UNKNOWN,\n};\nstatic const struct {\n\tuint8_t opcode;\n\tenum att_op_type type;\n} att_opcode_type_table[] = {\n\t{ BT_ATT_OP_ERROR_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_MTU_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_INFO_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BLOB_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_MULT_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_RSP,\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_WRITE_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_CMD,\t\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_SIGNED_WRITE_CMD,\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_PREP_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_EXEC_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_HANDLE_NFY,\t\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_NFY_MULT,\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_IND,\t\t\tATT_OP_TYPE_IND },\n\t{ BT_ATT_OP_HANDLE_CONF,\t\tATT_OP_TYPE_CONF },\n\t{ }\n};\nstatic const struct {\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n} att_req_rsp_mapping_table[] = {\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tBT_ATT_OP_MTU_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tBT_ATT_OP_FIND_INFO_RSP},\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tBT_ATT_OP_FIND_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tBT_ATT_OP_READ_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tBT_ATT_OP_READ_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tBT_ATT_OP_READ_BLOB_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tBT_ATT_OP_READ_MULT_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tBT_ATT_OP_READ_BY_GRP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tBT_ATT_OP_WRITE_RSP },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tBT_ATT_OP_PREP_WRITE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tBT_ATT_OP_EXEC_WRITE_RSP },\n\t{ }\n};\nstruct att_send_op {\n\tunsigned int id;\n\tunsigned int timeout_id;\n\tenum att_op_type type;\n\tuint8_t opcode;\n\tvoid *pdu;\n\tuint16_t len;\n\tbt_att_response_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\nstatic void destroy_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\tif (op->timeout_id)\n\t\ttimeout_remove(op->timeout_id);\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\tfree(op->pdu);\n\tfree(op);\n}\nstatic void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}\nstruct att_notify {\n\tunsigned int id;\n\tuint16_t opcode;\n\tbt_att_notify_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\nstruct att_disconn {\n\tunsigned int id;\n\tbool removed;\n\tbt_att_disconnect_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\nstatic struct att_send_op *create_att_send_op(struct bt_att *att,\n\t\t\t\t\t\tuint8_t opcode,\n\t\t\t\t\t\tconst void *pdu,\n\t\t\t\t\t\tuint16_t length,\n\t\t\t\t\t\tbt_att_response_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tenum att_op_type type;\n\tif (length && !pdu)\n\t\treturn NULL;\n\ttype = get_op_type(opcode);\n\tif (type == ATT_OP_TYPE_UNKNOWN)\n\t\treturn NULL;\n\tif (callback && type != ATT_OP_TYPE_REQ && type != ATT_OP_TYPE_IND)\n\t\treturn NULL;\n\tif (!callback && (type == ATT_OP_TYPE_REQ || type == ATT_OP_TYPE_IND))\n\t\treturn NULL;\n\top = new0(struct att_send_op, 1);\n\top->type = type;\n\top->opcode = opcode;\n\top->callback = callback;\n\top->destroy = destroy;\n\top->user_data = user_data;\n\tif (!encode_pdu(att, op, pdu, length)) {\n\t\tfree(op);\n\t\treturn NULL;\n\t}\n\treturn op;\n}\nstatic void disc_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\tif (op->callback)\n\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0, op->user_data);\n\tdestroy_att_send_op(op);\n}\nstruct timeout_data {\n\tstruct bt_att_chan *chan;\n\tunsigned int id;\n};\nstatic bool can_write_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct att_send_op *op;\n\tstruct timeout_data *timeout;\n\top = pick_next_send_op(chan);\n\tif (!op)\n\t\treturn false;\n\tif (!bt_att_chan_write(chan, op->opcode, op->pdu, op->len)) {\n\t\tif (op->callback)\n\t\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0,\n\t\t\t\t\t\t\top->user_data);\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tchan->pending_req = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tchan->pending_ind = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_RSP:\n\t\tchan->in_req = false;\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_CONF:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tdefault:\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\ttimeout = new0(struct timeout_data, 1);\n\ttimeout->chan = chan;\n\ttimeout->id = op->id;\n\top->timeout_id = timeout_add(ATT_TIMEOUT_INTERVAL, timeout_cb,\n\t\t\t\t\t\t\t\ttimeout, free);\n\treturn true;\n}\nstatic void wakeup_chan_writer(void *data, void *user_data)\n{\n\tstruct bt_att_chan *chan = data;\n\tstruct bt_att *att = chan->att;\n\tif (chan->writer_active)\n\t\treturn;\n\tif (queue_isempty(chan->queue) && queue_isempty(att->write_queue)) {\n\t\tif ((chan->pending_req || queue_isempty(att->req_queue)) &&\n\t\t\t(chan->pending_ind || queue_isempty(att->ind_queue)))\n\t\t\treturn;\n\t}\n\tif (!io_set_write_handler(chan->io, can_write_data, chan,\n\t\t\t\t\t\t\twrite_watch_destroy))\n\t\treturn;\n\tchan->writer_active = true;\n}\nstatic void wakeup_writer(struct bt_att *att)\n{\n\tqueue_foreach(att->chans, wakeup_chan_writer, NULL);\n}\nstatic void bt_att_chan_free(void *data)\n{\n\tstruct bt_att_chan *chan = data;\n\tif (chan->pending_req)\n\t\tdestroy_att_send_op(chan->pending_req);\n\tif (chan->pending_ind)\n\t\tdestroy_att_send_op(chan->pending_ind);\n\tqueue_destroy(chan->queue, destroy_att_send_op);\n\tio_destroy(chan->io);\n\tfree(chan->buf);\n\tfree(chan);\n}\nstatic bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}\nstatic void handle_rsp(struct bt_att_chan *chan, uint8_t opcode, uint8_t *pdu,\n\t\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = chan->pending_req;\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n\tuint8_t *rsp_pdu = NULL;\n\tuint16_t rsp_pdu_len = 0;\n\tif (!op) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received unexpected ATT \"\n\t\t\t\t\t\"response\", chan);\n\t\tio_shutdown(chan->io);\n\t\treturn;\n\t}\n\tif (opcode == BT_ATT_OP_ERROR_RSP) {\n\t\tif (handle_error_rsp(chan, pdu, pdu_len, &req_opcode)) {\n\t\t\twakeup_chan_writer(chan, NULL);\n\t\t\treturn;\n\t\t}\n\t} else if (!(req_opcode = get_req_opcode(opcode)))\n\t\tgoto fail;\n\tif (req_opcode != op->opcode)\n\t\tgoto fail;\n\trsp_opcode = opcode;\n\tif (pdu_len > 0) {\n\t\trsp_pdu = pdu;\n\t\trsp_pdu_len = pdu_len;\n\t}\n\tgoto done;\nfail:\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\"(chan %p) Failed to handle response PDU; opcode: \"\n\t\t\t\"0x%02x\", chan, opcode);\n\trsp_opcode = BT_ATT_OP_ERROR_RSP;\ndone:\n\tif (op->callback)\n\t\top->callback(rsp_opcode, rsp_pdu, rsp_pdu_len, op->user_data);\n\tdestroy_att_send_op(op);\n\tchan->pending_req = NULL;\n\twakeup_chan_writer(chan, NULL);\n}\nstruct notify_data {\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t pdu_len;\n\tbool handler_found;\n};\nstatic void handle_notify(struct bt_att_chan *chan, uint8_t *pdu,\n\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tconst struct queue_entry *entry;\n\tbool found;\n\tuint8_t opcode = pdu[0];\n\tbt_att_ref(att);\n\tfound = false;\n\tentry = queue_get_entries(att->notify_list);\n\twhile (entry) {\n\t\tstruct att_notify *notify = entry->data;\n\t\tentry = entry->next;\n\t\tif (!opcode_match(notify->opcode, opcode))\n\t\t\tcontinue;\n\t\tif ((opcode & ATT_OP_SIGNED_MASK) && att->crypto) {\n\t\t\tif (!handle_signed(att, pdu, pdu_len))\n\t\t\t\treturn;\n\t\t\tpdu_len -= BT_ATT_SIGNATURE_LEN;\n\t\t}\n\t\tif (bt_att_get_link_type(att) == BT_ATT_BREDR) {\n\t\t\tswitch (opcode) {\n\t\t\tcase BT_ATT_OP_MTU_REQ:\n\t\t\t\tgoto not_supported;\n\t\t\t}\n\t\t}\n\t\tfound = true;\n\t\tif (notify->callback)\n\t\t\tnotify->callback(chan, opcode, pdu + 1, pdu_len - 1,\n\t\t\t\t\t\t\tnotify->user_data);\n\t\tif (queue_isempty(att->notify_list))\n\t\t\tbreak;\n\t}\nnot_supported:\n\tif (!found && get_op_type(opcode) != ATT_OP_TYPE_CMD)\n\t\trespond_not_supported(att, opcode);\n\tbt_att_unref(att);\n}\nstatic bool can_read_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t bytes_read;\n\tbytes_read = read(chan->fd, chan->buf, chan->mtu);\n\tif (bytes_read < 0)\n\t\treturn false;\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT received: %zd\",\n\t\t\t\tchan, bytes_read);\n\tutil_hexdump('>', chan->buf, bytes_read,\n\t\t\t\tatt->debug_callback, att->debug_data);\n\tif (bytes_read < ATT_MIN_PDU_LEN)\n\t\treturn true;\n\tpdu = chan->buf;\n\topcode = pdu[0];\n\tbt_att_ref(att);\n\tswitch (get_op_type(opcode)) {\n\tcase ATT_OP_TYPE_RSP:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT response received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_rsp(chan, opcode, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CONF:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT confirmation received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_conf(chan, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_REQ:\n\t\tif (chan->in_req) {\n\t\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received request while \"\n\t\t\t\t\t\"another is pending: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\t\tio_shutdown(chan->io);\n\t\t\tbt_att_unref(chan->att);\n\t\t\treturn false;\n\t\t}\n\t\tchan->in_req = true;\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_IND:\n\tdefault:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT PDU received: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\thandle_notify(chan, pdu, bytes_read);\n\t\tbreak;\n\t}\n\tbt_att_unref(att);\n\treturn true;\n}\nstatic void bt_att_free(struct bt_att *att)\n{\n\tbt_crypto_unref(att->crypto);\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\tqueue_destroy(att->chans, bt_att_chan_free);\n\tfree(att);\n}\nstruct bt_att *bt_att_ref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn NULL;\n\t__sync_fetch_and_add(&att->ref_count, 1);\n\treturn att;\n}\nvoid bt_att_unref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn;\n\tif (__sync_sub_and_fetch(&att->ref_count, 1))\n\t\treturn;\n\tbt_att_unregister_all(att);\n\tbt_att_cancel_all(att);\n\tbt_att_free(att);\n}\nunsigned int bt_att_send(struct bt_att *att, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\tbt_att_response_func_t callback, void *user_data,\n\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tbool result;\n\tif (!att || queue_isempty(att->chans))\n\t\treturn 0;\n\top = create_att_send_op(att, opcode, pdu, length, callback, user_data,\n\t\t\t\t\t\t\t\tdestroy);\n\tif (!op)\n\t\treturn 0;\n\tif (att->next_send_id < 1)\n\t\tatt->next_send_id = 1;\n\top->id = att->next_send_id++;\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tresult = queue_push_tail(att->req_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tresult = queue_push_tail(att->ind_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_RSP:\n\tcase ATT_OP_TYPE_CONF:\n\tdefault:\n\t\tresult = queue_push_tail(att->write_queue, op);\n\t\tbreak;\n\t}\n\tif (!result) {\n\t\tfree(op->pdu);\n\t\tfree(op);\n\t\treturn 0;\n\t}\n\twakeup_writer(att);\n\treturn op->id;\n}\nbool bt_att_chan_cancel(struct bt_att_chan *chan, unsigned int id)\n{\n\tstruct att_send_op *op;\n\tif (chan->pending_req && chan->pending_req->id == id) {\n\t\tcancel_att_send_op(chan->pending_req);\n\t\treturn true;\n\t}\n\tif (chan->pending_ind && chan->pending_ind->id == id) {\n\t\tcancel_att_send_op(chan->pending_ind);\n\t\treturn true;\n\t}\n\top = queue_remove_if(chan->queue, match_op_id, UINT_TO_PTR(id));\n\tif (!op)\n\t\treturn false;\n\tdestroy_att_send_op(op);\n\twakeup_chan_writer(chan, NULL);\n\treturn true;\n}\nbool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\tif (!att || !id)\n\t\treturn false;\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\tif (!op)\n\t\treturn false;\ndone:\n\tdestroy_att_send_op(op);\n\twakeup_writer(att);\n\treturn true;\n}\nbool bt_att_cancel_all(struct bt_att *att)\n{\n\tconst struct queue_entry *entry;\n\tif (!att)\n\t\treturn false;\n\tqueue_remove_all(att->req_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, destroy_att_send_op);\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\t\tif (chan->pending_req)\n\t\t\tcancel_att_send_op(chan->pending_req);\n\t\tif (chan->pending_ind)\n\t\t\tcancel_att_send_op(chan->pending_ind);\n\t}\n\treturn true;\n}\nbool bt_att_unregister_all(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn false;\n\tqueue_remove_all(att->notify_list, NULL, NULL, destroy_att_notify);\n\tqueue_remove_all(att->disconn_list, NULL, NULL, destroy_att_disconn);\n\treturn true;\n}\n",
        "cwe": "CWE-415",
        "file_name": "vul_respovul_idx_5045.c",
        "project": "bluez/bluez",
        "url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```    YR_EXTERNAL_VARIABLE* external,\n  uint8_t obj_type = 0;\n      obj_type = OBJECT_TYPE_INTEGER;\n      obj_type = OBJECT_TYPE_FLOAT;\n      obj_type = OBJECT_TYPE_STRING;\n      obj_type,\n      external->identifier,\n      NULL,\n      &obj);\n  if (result == ERROR_SUCCESS)\n        yr_object_set_string(\n            external->value.s, strlen(external->value.s), obj, NULL);\n    *object = obj;\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include <yara/modules.h>\n#define MODULE_NAME tests\nbegin_declarations;\n  begin_struct(\"constants\");\n    declare_integer(\"one\");\n    declare_integer(\"two\");\n    declare_string(\"foo\");\n    declare_string(\"empty\");\n  end_struct(\"constants\");\n  begin_struct(\"undefined\");\n    declare_integer(\"i\");\n    declare_float(\"f\");\n  end_struct(\"undefined\");\n  declare_integer_array(\"integer_array\");\n  declare_string_array(\"string_array\");\n  declare_integer_dictionary(\"integer_dict\");\n  declare_string_dictionary(\"string_dict\");\n  begin_struct_array(\"struct_array\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_array(\"struct_array\");\n  begin_struct_dictionary(\"struct_dict\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_dictionary(\"struct_dict\");\n  declare_function(\"match\", \"rs\", \"i\", match);\n  declare_function(\"isum\", \"ii\", \"i\", isum_2);\n  declare_function(\"isum\", \"iii\", \"i\", isum_3);\n  declare_function(\"fsum\", \"ff\", \"f\", fsum_2);\n  declare_function(\"fsum\", \"fff\", \"f\", fsum_3);\n  declare_function(\"length\", \"s\", \"i\", length);\n  declare_function(\"empty\", \"\", \"s\", empty);\n  declare_function(\"foobar\", \"i\", \"s\", foobar);\nend_declarations;\nint module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n  set_integer(1, module_object, \"struct_array[1].i\");\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n  return ERROR_SUCCESS;\n}\nFile number 2:\n#include <assert.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#if _WIN32 || __CYGWIN__\n#define PRIu64 \"I64d\"\n#else\n#include <inttypes.h>\n#endif\n#include <yara/mem.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/exec.h>\n#include <yara/utils.h>\nint yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int i;\n  size_t object_size = 0;\n  assert(parent != NULL || object != NULL);\n  switch (type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      object_size = sizeof(YR_OBJECT_STRUCTURE);\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_size = sizeof(YR_OBJECT_ARRAY);\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_size = sizeof(YR_OBJECT_DICTIONARY);\n      break;\n    case OBJECT_TYPE_INTEGER:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_FLOAT:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_STRING:\n      object_size = sizeof(YR_OBJECT);\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_size = sizeof(YR_OBJECT_FUNCTION);\n      break;\n    default:\n      assert(FALSE);\n  }\n  obj = (YR_OBJECT*) yr_malloc(object_size);\n  if (obj == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n  obj->type = type;\n  obj->identifier = yr_strdup(identifier);\n  obj->parent = parent;\n  obj->data = NULL;\n  switch(type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      obj->value.i = UNDEFINED;\n      break;\n    case OBJECT_TYPE_FLOAT:\n      obj->value.d = NAN;\n      break;\n    case OBJECT_TYPE_STRING:\n      obj->value.ss = NULL;\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      object_as_structure(obj)->members = NULL;\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_as_array(obj)->items = NULL;\n      object_as_array(obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_as_dictionary(obj)->items = NULL;\n      object_as_dictionary(obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_as_function(obj)->return_obj = NULL;\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n      {\n        object_as_function(obj)->prototypes[i].arguments_fmt = NULL;\n        object_as_function(obj)->prototypes[i].code = NULL;\n      }\n      break;\n  }\n  if (obj->identifier == NULL)\n  {\n    yr_free(obj);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n  if (parent != NULL)\n  {\n    assert(parent->type == OBJECT_TYPE_STRUCTURE ||\n           parent->type == OBJECT_TYPE_ARRAY ||\n           parent->type == OBJECT_TYPE_DICTIONARY ||\n           parent->type == OBJECT_TYPE_FUNCTION);\n    switch(parent->type)\n    {\n      case OBJECT_TYPE_STRUCTURE:\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(parent, obj),\n            {\n              yr_free((void*) obj->identifier);\n              yr_free(obj);\n            });\n        break;\n      case OBJECT_TYPE_ARRAY:\n        object_as_array(parent)->prototype_item = obj;\n        break;\n      case OBJECT_TYPE_DICTIONARY:\n        object_as_dictionary(parent)->prototype_item = obj;\n        break;\n      case OBJECT_TYPE_FUNCTION:\n        object_as_function(parent)->return_obj = obj;\n        break;\n    }\n  }\n  if (object != NULL)\n    *object = obj;\n  return ERROR_SUCCESS;\n}\nint yr_object_function_create(\n    const char* identifier,\n    const char* arguments_fmt,\n    const char* return_fmt,\n    YR_MODULE_FUNC code,\n    YR_OBJECT* parent,\n    YR_OBJECT** function)\n{\n  YR_OBJECT* return_obj;\n  YR_OBJECT* o = NULL;\n  YR_OBJECT_FUNCTION* f = NULL;\n  int8_t return_type;\n  int i;\n  switch (*return_fmt)\n  {\n    case 'i':\n      return_type = OBJECT_TYPE_INTEGER;\n      break;\n    case 's':\n      return_type = OBJECT_TYPE_STRING;\n      break;\n    case 'f':\n      return_type = OBJECT_TYPE_FLOAT;\n      break;\n    default:\n      return ERROR_INVALID_FORMAT;\n  }\n  if (parent != NULL)\n  {\n    // The parent of a function must be a structure.\n    assert(parent->type == OBJECT_TYPE_STRUCTURE);\n    // Try to find if the structure already has a function\n    // with that name. In that case this is a function overload.\n    f = object_as_function(yr_object_lookup_field(parent, identifier));\n    // Overloaded functions must have the same return type.\n    if (f != NULL && return_type != f->return_obj->type)\n      return ERROR_WRONG_RETURN_TYPE;\n  }\n  if (f == NULL) // Function doesn't exist yet\n  {\n    FAIL_ON_ERROR(\n        yr_object_create(\n            OBJECT_TYPE_FUNCTION,\n            identifier,\n            parent,\n            &o));\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_create(\n            return_type,\n            \"result\",\n            o,\n            &return_obj),\n        yr_object_destroy(o));\n    f = object_as_function(o);\n  }\n  for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n  {\n    if (f->prototypes[i].arguments_fmt == NULL)\n    {\n      f->prototypes[i].arguments_fmt = arguments_fmt;\n      f->prototypes[i].code = code;\n      break;\n    }\n  }\n  if (function != NULL)\n    *function = (YR_OBJECT*) f;\n  return ERROR_SUCCESS;\n}\nint yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int result;\n  uint8_t obj_type = 0;\n  switch(external->type)\n  {\n    case EXTERNAL_VARIABLE_TYPE_INTEGER:\n    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n      obj_type = OBJECT_TYPE_INTEGER;\n      break;\n    case EXTERNAL_VARIABLE_TYPE_FLOAT:\n      obj_type = OBJECT_TYPE_FLOAT;\n      break;\n    case EXTERNAL_VARIABLE_TYPE_STRING:\n    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n      obj_type = OBJECT_TYPE_STRING;\n      break;\n    default:\n      assert(FALSE);\n  }\n  result = yr_object_create(\n      obj_type,\n      external->identifier,\n      NULL,\n      &obj);\n  if (result == ERROR_SUCCESS)\n  {\n    switch(external->type)\n    {\n      case EXTERNAL_VARIABLE_TYPE_INTEGER:\n      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n        yr_object_set_integer(external->value.i, obj, NULL);\n        break;\n      case EXTERNAL_VARIABLE_TYPE_FLOAT:\n        yr_object_set_float(external->value.f, obj, NULL);\n        break;\n      case EXTERNAL_VARIABLE_TYPE_STRING:\n      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n        yr_object_set_string(\n            external->value.s, strlen(external->value.s), obj, NULL);\n        break;\n    }\n    *object = obj;\n  }\n  return result;\n}\nvoid yr_object_destroy(\n    YR_OBJECT* object)\n{\n  YR_STRUCTURE_MEMBER* member;\n  YR_STRUCTURE_MEMBER* next_member;\n  YR_ARRAY_ITEMS* array_items;\n  YR_DICTIONARY_ITEMS* dict_items;\n  int i;\n  if (object == NULL)\n    return;\n  switch(object->type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      member = object_as_structure(object)->members;\n      while (member != NULL)\n      {\n        next_member = member->next;\n        yr_object_destroy(member->object);\n        yr_free(member);\n        member = next_member;\n      }\n      break;\n    case OBJECT_TYPE_STRING:\n      if (object->value.ss != NULL)\n        yr_free(object->value.ss);\n      break;\n    case OBJECT_TYPE_ARRAY:\n      if (object_as_array(object)->prototype_item != NULL)\n        yr_object_destroy(object_as_array(object)->prototype_item);\n      array_items = object_as_array(object)->items;\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n          if (array_items->objects[i] != NULL)\n            yr_object_destroy(array_items->objects[i]);\n      }\n      yr_free(array_items);\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      if (object_as_dictionary(object)->prototype_item != NULL)\n        yr_object_destroy(object_as_dictionary(object)->prototype_item);\n      dict_items = object_as_dictionary(object)->items;\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          if (dict_items->objects[i].key != NULL)\n            yr_free(dict_items->objects[i].key);\n          if (dict_items->objects[i].obj != NULL)\n            yr_object_destroy(dict_items->objects[i].obj);\n        }\n      }\n      yr_free(dict_items);\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      yr_object_destroy(object_as_function(object)->return_obj);\n      break;\n  }\n  yr_free((void*) object->identifier);\n  yr_free(object);\n}\nYR_OBJECT* _yr_object_lookup(\n    YR_OBJECT* object,\n    int flags,\n    const char* pattern,\n    va_list args)\n{\n  YR_OBJECT* obj = object;\n  const char* p = pattern;\n  const char* key = NULL;\n  char str[256];\n  int i;\n  int index = -1;\n  while (obj != NULL)\n  {\n    i = 0;\n    while(*p != '\\0' && *p != '.' && *p != '[' && i < sizeof(str) - 1)\n    {\n      str[i++] = *p++;\n    }\n    str[i] = '\\0';\n    if (obj->type != OBJECT_TYPE_STRUCTURE)\n      return NULL;\n    obj = yr_object_lookup_field(obj, str);\n    if (obj == NULL)\n      return NULL;\n    if (*p == '[')\n    {\n      p++;\n      if (*p == '%')\n      {\n        p++;\n        switch(*p++)\n        {\n          case 'i':\n            index = va_arg(args, int);\n            break;\n          case 's':\n            key = va_arg(args, const char*);\n            break;\n          default:\n            return NULL;\n        }\n      }\n      else if (*p >= '0' && *p <= '9')\n      {\n        index = (int) strtol(p, (char**) &p, 10);\n      }\n      else if (*p == '\"')\n      {\n        i = 0;\n        p++;              // skip the opening quotation mark\n        while (*p != '\"' && *p != '\\0' && i < sizeof(str))\n          str[i++] = *p++;\n        str[i] = '\\0';\n        p++;              // skip the closing quotation mark\n        key = str;\n      }\n      else\n      {\n        return NULL;\n      }\n      assert(*p == ']');\n      p++;\n      assert(*p == '.' || *p == '\\0');\n      switch(obj->type)\n      {\n        case OBJECT_TYPE_ARRAY:\n          assert(index != -1);\n          obj = yr_object_array_get_item(obj, flags, index);\n          break;\n        case OBJECT_TYPE_DICTIONARY:\n          assert(key != NULL);\n          obj = yr_object_dict_get_item(obj, flags, key);\n          break;\n      }\n    }\n    if (*p == '\\0')\n      break;\n    p++;\n  }\n  return obj;\n}\nint yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      copy->value.i = object->value.i;\n      break;\n    case OBJECT_TYPE_FLOAT:\n      copy->value.d = object->value.d;\n      break;\n    case OBJECT_TYPE_STRING:\n      if (object->value.ss != NULL)\n        copy->value.ss = sized_string_dup(object->value.ss);\n      else\n        copy->value.ss = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      FAIL_ON_ERROR_WITH_CLEANUP(\n          yr_object_copy(\n              object_as_function(object)->return_obj,\n              &object_as_function(copy)->return_obj),\n          yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        object_as_function(copy)->prototypes[i] = \\\n            object_as_function(object)->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = object_as_structure(object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      FAIL_ON_ERROR_WITH_CLEANUP(\n          yr_object_copy(object_as_array(object)->prototype_item, &o),\n          yr_object_destroy(copy));\n      object_as_array(copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      FAIL_ON_ERROR_WITH_CLEANUP(\n          yr_object_copy(object_as_dictionary(object)->prototype_item, &o),\n          yr_object_destroy(copy));\n      object_as_dictionary(copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}\nint yr_object_dict_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    const char* key)\n{\n  YR_OBJECT_DICTIONARY* dict;\n  int i;\n  int count;\n  assert(object->type == OBJECT_TYPE_DICTIONARY);\n  dict = object_as_dictionary(object);\n  if (dict->items == NULL)\n  {\n    count = 64;\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_malloc(\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(dict->items->objects, 0, count * sizeof(dict->items->objects[0]));\n    dict->items->free = count;\n    dict->items->used = 0;\n  }\n  else if (dict->items->free == 0)\n  {\n    count = dict->items->used * 2;\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_realloc(\n        dict->items,\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = dict->items->used; i < count; i++)\n    {\n      dict->items->objects[i].key = NULL;\n      dict->items->objects[i].obj = NULL;\n    }\n    dict->items->free = dict->items->used;\n  }\n  item->parent = object;\n  dict->items->objects[dict->items->used].key = yr_strdup(key);\n  dict->items->objects[dict->items->used].obj = item;\n  dict->items->used++;\n  dict->items->free--;\n  return ERROR_SUCCESS;\n}\nYR_API void yr_object_print_data(\n    YR_OBJECT* object,\n    int indent,\n    int print_identifier)\n{\n  YR_DICTIONARY_ITEMS* dict_items;\n  YR_ARRAY_ITEMS* array_items;\n  YR_STRUCTURE_MEMBER* member;\n  char indent_spaces[32];\n  int i;\n  indent = yr_min(indent, sizeof(indent_spaces) - 1);\n  memset(indent_spaces, '\\t', indent);\n  indent_spaces[indent] = '\\0';\n  if (print_identifier && object->type != OBJECT_TYPE_FUNCTION)\n    printf(\"%s%s\", indent_spaces, object->identifier);\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      if (object->value.i != UNDEFINED)\n        printf(\" = %\" PRIu64, object->value.i);\n      else\n        printf(\" = UNDEFINED\");\n      break;\n    case OBJECT_TYPE_STRING:\n      if (object->value.ss != NULL)\n      {\n        size_t l;\n        printf(\" = \\\"\");\n        for (l = 0; l < object->value.ss->length; l++)\n        {\n          char c = object->value.ss->c_string[l];\n          if (isprint((unsigned char) c))\n            printf(\"%c\", c);\n          else\n            printf(\"\\\\x%02x\", (unsigned char) c);\n        }\n        printf(\"\\\"\");\n      }\n      else\n      {\n        printf(\" = UNDEFINED\");\n      }\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      member = object_as_structure(object)->members;\n      while (member != NULL)\n      {\n        if (member->object->type != OBJECT_TYPE_FUNCTION)\n        {\n          printf(\"\\n\");\n          yr_object_print_data(member->object, indent + 1, 1);\n        }\n        member = member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      array_items = object_as_array(object)->items;\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n        {\n          if (array_items->objects[i] != NULL)\n          {\n            printf(\"\\n%s\\t[%d]\", indent_spaces, i);\n            yr_object_print_data(array_items->objects[i], indent + 1, 0);\n          }\n        }\n      }\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      dict_items = object_as_dictionary(object)->items;\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          printf(\"\\n%s\\t%s\", indent_spaces, dict_items->objects[i].key);\n          yr_object_print_data(dict_items->objects[i].obj, indent + 1, 0);\n        }\n      }\n      break;\n  }\n}\nFile number 3:\n#include <yara.h>\n#include \"blob.h\"\n#include \"util.h\"\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <fileapi.h>\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\nstatic void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n}\nstatic void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 0o10 == 8 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 0o100 == 64 }\", NULL);\n  assert_true_rule(\n      \"rule test { condition: 0o755 == 493 }\", NULL);\n}\nstatic void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n}\nstatic void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\\\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32  [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32  [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n}\nstatic void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}\nstatic void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n  assert_regexp_syntax_error(\"\\\\xxy\");\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n}\nstatic void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) == tests.foobar(1) \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) != tests.foobar(2) \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}\n#if defined(HASH_MODULE)\nstatic void test_hash_module()\n{\n  uint8_t blob[] = {0x61, 0x62, 0x63, 0x64, 0x65};\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.sha1(0, filesize) == \\\n            \\\"03de6c570bfe24bfc328ccd7ca46b76eadaf4334\\\" \\\n            and \\\n          hash.sha1(1, filesize) == \\\n            \\\"a302d65ae4d9e768a1538d53605f203fd8e2d6e2\\\" \\\n            and \\\n          hash.sha256(0, filesize) == \\\n            \\\"36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\\\" \\\n            and \\\n          hash.sha256(1, filesize) == \\\n            \\\"aaaaf2863e043b9df604158ad5c16ff1adaf3fd7e9fcea5dcb322b6762b3b59a\\\" \\\n      }\",\n      blob);\n  // Test hash caching mechanism\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n      }\",\n      blob);\n}\n#endif\nvoid test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n  return;\n}\n",
        "cwe": "CWE-119",
        "file_name": "vul_respovul_idx_2146.c",
        "project": "virustotal/yara",
        "url": "https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f",
        "predicted": ""
    },
    {
        "instruction": "You are a security code vulnerability analyzer. Your task is to carefully analyze the provided code snippet. Note that the provided code snippet might not be complete, but it has all the important context.\nYour output must be EXACTLY ONE WORD:\n\nIf you detect any potential security vulnerability in the specified code segment, return: VULNERABLE\nIf the code segment appears to be secure and free from obvious vulnerabilities, return: BENIGN\n\nIMPORTANT GUIDELINES:\n\nConsider common vulnerability types such as:\n\n- Buffer overflows\n- Improper input validation\n- Integer Overflow\n- Memory corruption potential\n- Double free\n- Use after free\n\nYour response must be either 'VULNERABLE' or 'BENIGN' - no additional explanation\n\nOutput format:\nOne word: VULNERABLE or BENIGN\n",
        "input": "### Source Code:\n```IncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n    tmp = str;\n    stmt = strdup_safe(str);\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n```",
        "output": "Yes",
        "dataset": "ReposVul",
        "code": "File number 1:\n#include \"xkbcomp-priv.h\"\n#include \"ast-build.h\"\n#include \"include.h\"\n#define EXPR_CREATE(type_, name_, op_, value_type_) \\\n    ExprDef *name_ = ExprCreate(op_, value_type_, sizeof(type_)); \\\n    if (!name_) \\\n        return NULL;\nExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}\nstatic void\nFreeInclude(IncludeStmt *incl);\nIncludeStmt *\nIncludeCreate(struct xkb_context *ctx, char *str, enum merge_mode merge)\n{\n    IncludeStmt *incl, *first;\n    char *file, *map, *stmt, *tmp, *extra_data;\n    char nextop;\n    incl = first = NULL;\n    file = map = NULL;\n    tmp = str;\n    stmt = strdup_safe(str);\n    while (tmp && *tmp)\n    {\n        if (!ParseIncludeMap(&tmp, &file, &map, &nextop, &extra_data))\n            goto err;\n        if (isempty(file)) {\n            free(file);\n            free(map);\n            free(extra_data);\n            continue;\n        }\n        if (first == NULL) {\n            first = incl = malloc(sizeof(*first));\n        } else {\n            incl->next_incl = malloc(sizeof(*first));\n            incl = incl->next_incl;\n        }\n        if (!incl)\n            break;\n        incl->common.type = STMT_INCLUDE;\n        incl->common.next = NULL;\n        incl->merge = merge;\n        incl->stmt = NULL;\n        incl->file = file;\n        incl->map = map;\n        incl->modifier = extra_data;\n        incl->next_incl = NULL;\n        if (nextop == '|')\n            merge = MERGE_AUGMENT;\n        else\n            merge = MERGE_OVERRIDE;\n    }\n    if (first)\n        first->stmt = stmt;\n    else\n        free(stmt);\n    return first;\nerr:\n    log_err(ctx, \"Illegal include statement \\\"%s\\\"; Ignored\\n\", stmt);\n    FreeInclude(first);\n    free(stmt);\n    return NULL;\n}\nstatic void\nFreeExpr(ExprDef *expr)\n{\n    if (!expr)\n        return;\n    switch (expr->expr.op) {\n    case EXPR_ACTION_LIST:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n    case EXPR_NOT:\n    case EXPR_INVERT:\n        FreeStmt((ParseCommon *) expr->unary.child);\n        break;\n    case EXPR_DIVIDE:\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_ASSIGN:\n        FreeStmt((ParseCommon *) expr->binary.left);\n        FreeStmt((ParseCommon *) expr->binary.right);\n        break;\n    case EXPR_ACTION_DECL:\n        FreeStmt((ParseCommon *) expr->action.args);\n        break;\n    case EXPR_ARRAY_REF:\n        FreeStmt((ParseCommon *) expr->array_ref.entry);\n        break;\n    case EXPR_KEYSYM_LIST:\n        darray_free(expr->keysym_list.syms);\n        darray_free(expr->keysym_list.symsMapIndex);\n        darray_free(expr->keysym_list.symsNumEntries);\n        break;\n    default:\n        break;\n    }\n}\nstatic void\nFreeInclude(IncludeStmt *incl)\n{\n    IncludeStmt *next;\n    while (incl)\n    {\n        next = incl->next_incl;\n        free(incl->file);\n        free(incl->map);\n        free(incl->modifier);\n        free(incl->stmt);\n        free(incl);\n        incl = next;\n    }\n}\nvoid\nFreeStmt(ParseCommon *stmt)\n{\n    ParseCommon *next;\n    while (stmt)\n    {\n        next = stmt->next;\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            FreeInclude((IncludeStmt *) stmt);\n            stmt = NULL;\n            break;\n        case STMT_EXPR:\n            FreeExpr((ExprDef *) stmt);\n            break;\n        case STMT_VAR:\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->name);\n            FreeStmt((ParseCommon *) ((VarDef *) stmt)->value);\n            break;\n        case STMT_TYPE:\n            FreeStmt((ParseCommon *) ((KeyTypeDef *) stmt)->body);\n            break;\n        case STMT_INTERP:\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->match);\n            FreeStmt((ParseCommon *) ((InterpDef *) stmt)->def);\n            break;\n        case STMT_VMOD:\n            FreeStmt((ParseCommon *) ((VModDef *) stmt)->value);\n            break;\n        case STMT_SYMBOLS:\n            FreeStmt((ParseCommon *) ((SymbolsDef *) stmt)->symbols);\n            break;\n        case STMT_MODMAP:\n            FreeStmt((ParseCommon *) ((ModMapDef *) stmt)->keys);\n            break;\n        case STMT_GROUP_COMPAT:\n            FreeStmt((ParseCommon *) ((GroupCompatDef *) stmt)->def);\n            break;\n        case STMT_LED_MAP:\n            FreeStmt((ParseCommon *) ((LedMapDef *) stmt)->body);\n            break;\n        case STMT_LED_NAME:\n            FreeStmt((ParseCommon *) ((LedNameDef *) stmt)->name);\n            break;\n        default:\n            break;\n        }\n        free(stmt);\n        stmt = next;\n    }\n}\nstatic const char *xkb_file_type_strings[_FILE_TYPE_NUM_ENTRIES] = {\n    [FILE_TYPE_KEYCODES] = \"xkb_keycodes\",\n    [FILE_TYPE_TYPES] = \"xkb_types\",\n    [FILE_TYPE_COMPAT] = \"xkb_compatibility\",\n    [FILE_TYPE_SYMBOLS] = \"xkb_symbols\",\n    [FILE_TYPE_GEOMETRY] = \"xkb_geometry\",\n    [FILE_TYPE_KEYMAP] = \"xkb_keymap\",\n    [FILE_TYPE_RULES] = \"rules\",\n};\nstatic const char *stmt_type_strings[_STMT_NUM_VALUES] = {\n    [STMT_UNKNOWN] = \"unknown statement\",\n    [STMT_INCLUDE] = \"include statement\",\n    [STMT_KEYCODE] = \"key name definition\",\n    [STMT_ALIAS] = \"key alias definition\",\n    [STMT_EXPR] = \"expression\",\n    [STMT_VAR] = \"variable definition\",\n    [STMT_TYPE] = \"key type definition\",\n    [STMT_INTERP] = \"symbol interpretation definition\",\n    [STMT_VMOD] = \"virtual modifiers definition\",\n    [STMT_SYMBOLS] = \"key symbols definition\",\n    [STMT_MODMAP] = \"modifier map declaration\",\n    [STMT_GROUP_COMPAT] = \"group declaration\",\n    [STMT_LED_MAP] = \"indicator map declaration\",\n    [STMT_LED_NAME] = \"indicator name declaration\",\n};\nstatic const char *expr_op_type_strings[_EXPR_NUM_VALUES] = {\n    [EXPR_VALUE] = \"literal\",\n    [EXPR_IDENT] = \"identifier\",\n    [EXPR_ACTION_DECL] = \"action declaration\",\n    [EXPR_FIELD_REF] = \"field reference\",\n    [EXPR_ARRAY_REF] = \"array reference\",\n    [EXPR_KEYSYM_LIST] = \"list of keysyms\",\n    [EXPR_ACTION_LIST] = \"list of actions\",\n    [EXPR_ADD] = \"addition\",\n    [EXPR_SUBTRACT] = \"subtraction\",\n    [EXPR_MULTIPLY] = \"multiplication\",\n    [EXPR_DIVIDE] = \"division\",\n    [EXPR_ASSIGN] = \"assignment\",\n    [EXPR_NOT] = \"logical negation\",\n    [EXPR_NEGATE] = \"arithmetic negation\",\n    [EXPR_INVERT] = \"bitwise inversion\",\n    [EXPR_UNARY_PLUS] = \"unary plus\",\n};\nstatic const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n    [EXPR_TYPE_UNKNOWN] = \"unknown\",\n    [EXPR_TYPE_BOOLEAN] = \"boolean\",\n    [EXPR_TYPE_INT] = \"int\",\n    [EXPR_TYPE_FLOAT] = \"float\",\n    [EXPR_TYPE_STRING] = \"string\",\n    [EXPR_TYPE_ACTION] = \"action\",\n    [EXPR_TYPE_KEYNAME] = \"keyname\",\n    [EXPR_TYPE_SYMBOLS] = \"symbols\",\n};\n",
        "cwe": "CWE-416",
        "file_name": "vul_respovul_idx_3037.c",
        "project": "xkbcommon/libxkbcommon",
        "url": "https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb",
        "predicted": ""
    }
]